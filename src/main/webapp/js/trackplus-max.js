/* #exclude ifGenji */
/**
 * FiltersFeature is a grid {@link Ext.grid.feature.Feature feature} that allows for a slightly more
 * robust representation of filtering than what is provided by the default store.
 *
 * Filtering is adjusted by the user using the grid's column header menu (this menu can be
 * disabled through configuration). Through this menu users can configure, enable, and
 * disable filters for each column.
 *
 * #Features#
 *
 * ##Filtering implementations:##
 *
 * Default filtering for Strings, Numeric Ranges, Date Ranges, Lists (which can be backed by a
 * {@link Ext.data.Store}), and Boolean. Additional custom filter types and menus are easily
 * created by extending {@link Ext.ux.grid.filter.Filter}.
 *
 * ##Graphical Indicators:##
 *
 * Columns that are filtered have {@link #filterCls a configurable css class} applied to the column headers.
 *
 * ##Automatic Reconfiguration:##
 *
 * Filters automatically reconfigure when the grid 'reconfigure' event fires.
 *
 * ##Stateful:##
 *
 * Filter information will be persisted across page loads by specifying a `stateId`
 * in the Grid configuration.
 *
 * The filter collection binds to the {@link Ext.grid.Panel#beforestaterestore beforestaterestore}
 * and {@link Ext.grid.Panel#beforestatesave beforestatesave} events in order to be stateful.
 *
 * ##GridPanel Changes:##
 *
 * - A `filters` property is added to the GridPanel using this feature.
 * - A `filterupdate` event is added to the GridPanel and is fired upon onStateChange completion.
 *
 * ##Server side code examples:##
 *
 * - [PHP](http://www.vinylfox.com/extjs/grid-filter-php-backend-code.php) - (Thanks VinylFox)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=77326#post77326) - (Thanks Zyclops)
 * - [Ruby on Rails](http://extjs.com/forum/showthread.php?p=176596#post176596) - (Thanks Rotomaul)
 *
 * #Example usage:#
 *
 *     var store = Ext.create('Ext.data.Store', {
 *         pageSize: 15
 *         ...
 *     });
 *
 *     var filtersCfg = {
 *         ftype: 'filters',
 *         autoReload: false, //don't reload automatically
 *         local: true, //only filter locally
 *         // filters may be configured through the plugin,
 *         // or in the column definition within the headers configuration
 *         filters: [{
 *             type: 'numeric',
 *             dataIndex: 'id'
 *         }, {
 *             type: 'string',
 *             dataIndex: 'name'
 *         }, {
 *             type: 'numeric',
 *             dataIndex: 'price'
 *         }, {
 *             type: 'date',
 *             dataIndex: 'dateAdded'
 *         }, {
 *             type: 'list',
 *             dataIndex: 'size',
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large'],
 *             phpMode: true
 *         }, {
 *             type: 'boolean',
 *             dataIndex: 'visible'
 *         }]
 *     };
 *
 *     var grid = Ext.create('Ext.grid.Panel', {
 *          store: store,
 *          columns: ...,
 *          features: [filtersCfg],
 *          height: 400,
 *          width: 700,
 *          bbar: Ext.create('Ext.PagingToolbar', {
 *              store: store
 *          })
 *     });
 *
 *     // a filters property is added to the GridPanel
 *     grid.filters
 */
/* #end */
Ext.define('Ext.ux.grid.FiltersFeature', {
    extend: 'Ext.grid.feature.Feature',
    alias: 'feature.filters',
    uses: [
        'Ext.ux.grid.menu.ListMenu',
        'Ext.ux.grid.menu.RangeMenu',
        'Ext.ux.grid.filter.BooleanFilter',
        'Ext.ux.grid.filter.DateFilter',
        'Ext.ux.grid.filter.DateTimeFilter',
        'Ext.ux.grid.filter.ListFilter',
        'Ext.ux.grid.filter.NumericFilter',
        'Ext.ux.grid.filter.StringFilter'
    ],
    /**
     * @cfg {Boolean} autoReload
     * Defaults to true, reloading the datasource when a filter change happens.
     * Set this to false to prevent the datastore from being reloaded if there
     * are changes to the filters.  See `{@link #updateBuffer}`.
     */
    autoReload : true,
    /**
     * @cfg {Boolean} encode
     * Specify true for {@link #buildQuery} to use Ext.util.JSON.encode to
     * encode the filter query parameter sent with a remote request.
     * Defaults to false.
     */
    /**
     * @cfg {Array} filters
     * An Array of filters config objects. Refer to each filter type class for
     * configuration details specific to each filter type. Filters for Strings,
     * Numeric Ranges, Date Ranges, Lists, and Boolean are the standard filters
     * available.
     */
    /**
     * @cfg {String} filterCls
     * The css class to be applied to column headers with active filters.
     * Defaults to `'ux-filterd-column'`
     */
    filterCls : 'ux-filtered-column',
    /**
     * @cfg {Boolean} local
     * <tt>true</tt> to use Ext.data.Store filter functions (local filtering)
     * instead of the default (<tt>false</tt>) server side filtering.
     */
    local : false,
    /**
     * @cfg {String} menuFilterText
     * defaults to `'Filters'`.
     */
    menuFilterText : 'Filters',
    /**
     * @cfg {String} paramPrefix
     * The url parameter prefix for the filters.
     * Defaults to `'filter'`.
     */
    paramPrefix : 'filter',
    /**
     * @cfg {Boolean} showMenu
     * Defaults to true, including a filter submenu in the default header menu.
     */
    showMenu : true,
    /**
     * @cfg {String} stateId
     * Name of the value to be used to store state information.
     */
    stateId : undefined,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to defer store updates since the last filter change.
     */
    updateBuffer : 500,
    // doesn't handle grid body events
    hasFeatureEvent: false,
    /** @private */
    constructor : function (config) {
        var me = this;
        me.callParent(arguments);
        me.deferredUpdate = Ext.create('Ext.util.DelayedTask', me.reload, me);
        // Init filters
        me.filters = me.createFiltersCollection();
        me.filterConfigs = config.filters;
    },
    init: function(grid) {
        var me = this,
            view = me.view,
            headerCt = view.headerCt;
        me.bindStore(view.getStore(), true);
        // Listen for header menu being created
        headerCt.on('menucreate', me.onMenuCreate, me);
        view.on('refresh', me.onRefresh, me);
        grid.on({
            scope: me,
            beforestaterestore: me.applyState,
            beforestatesave: me.saveState,
            beforedestroy: me.destroy
        });
        // Add event and filters shortcut on grid panel
        grid.filters = me;
        //grid.addEvents('filterupdate');
        me.createFilters();
    },
    createFiltersCollection: function () {
        return Ext.create('Ext.util.MixedCollection', false, function (o) {
            return o ? o.dataIndex : null;
        });
    },
    /**
     * @private Create the Filter objects for the current configuration, destroying any existing ones first.
     */
    createFilters: function() {
        var me = this,
            hadFilters = me.filters.getCount(),
            grid = me.getGridPanel(),
            filters = me.createFiltersCollection(),
            model = grid.store.model,
            fields = model.prototype.fields,
            field,
            filter,
            state;
        if (hadFilters) {
            state = {};
            me.saveState(null, state);
        }
        function add (dataIndex, config, filterable) {
            if (dataIndex && (filterable || config)) {
                field = fields.get(dataIndex);
                filter = {
                    dataIndex: dataIndex,
                    type: (field && field.type && field.type.type) || 'auto'
                };
                if (Ext.isObject(config)) {
                    Ext.apply(filter, config);
                }
                filters.replace(filter);
            }
        }
        // We start with filters from our config
        Ext.Array.each(me.filterConfigs, function (filterConfig) {
            add(filterConfig.dataIndex, filterConfig);
        });
        // Then we merge on filters from the columns in the grid. The columns' filters take precedence.
        Ext.Array.each(grid.columnManager.getColumns(), function (column) {
            if (column.filterable === false) {
                filters.removeAtKey(column.dataIndex);
            } else {
                add(column.dataIndex, column.filter, column.filterable);
            }
        });
        me.removeAll();
        if (filters.items) {
            me.initializeFilters(filters.items);
        }
        if (hadFilters) {
            me.applyState(null, state);
        }
    },
    /**
     * @private
     */
    initializeFilters: function(filters) {
        var me = this,
            filtersLength = filters.length,
            i, filter, FilterClass;
        for (i = 0; i < filtersLength; i++) {
            filter = filters[i];
            if (filter) {
                FilterClass = me.getFilterClass(filter.type);
                filter = filter.menu ? filter : new FilterClass(Ext.apply({
                    grid: me.grid
                }, filter));
                me.filters.add(filter);
                Ext.util.Observable.capture(filter, me.onStateChange, me);
            }
        }
    },
    /**
     * @private Handle creation of the grid's header menu. Initializes the filters and listens
     * for the menu being shown.
     */
    onMenuCreate: function(headerCt, menu) {
        var me = this;
        // If the menu is ever destroyed, the filters need recreating because
        // the filters' menu structures will be destroyed.
        if (me.filtersNeedReCreating) {
            me.createFilters();
            me.filtersNeedReCreating = false;
        }
        menu.on({
            beforeshow: me.onMenuBeforeShow,
            destroy: me.onMenuDestroy,
            scope: me
        });
    },
    // The filters at first have to be created at init time so that state can be restored if the grid subsequently
    // fires a beforestaterestore event.
    // However after that, they may need recreating if the column menu is ever destroyed (due to column movement) because
    // that tears down the whole filter item and submenu structure.
    onMenuDestroy: function() {
        this.filtersNeedReCreating = true;
    },
    /**
     * @private Handle showing of the grid's header menu. Sets up the filter item and menu
     * appropriate for the target column.
     */
    onMenuBeforeShow: function(menu) {
        var me = this,
            menuItem, filter;
        if (me.showMenu) {
            menuItem = me.menuItem;
            if (!menuItem || menuItem.isDestroyed) {
                me.createMenuItem(menu);
                menuItem = me.menuItem;
            }
            filter = me.getMenuFilter();
            if (filter) {
                menuItem.setMenu(filter.menu, false);
                menuItem.setChecked(filter.active);
                // disable the menu if filter.disabled explicitly set to true
                menuItem.setDisabled(filter.disabled === true);
            }
            menuItem.setVisible(!!filter);
            me.sep.setVisible(!!filter);
        }
    },
    createMenuItem: function(menu) {
        var me = this;
        me.sep  = menu.add('-');
        me.menuItem = menu.add({
            checked: false,
            itemId: 'filters',
            text: me.menuFilterText,
            listeners: {
                scope: me,
                checkchange: me.onCheckChange,
                beforecheckchange: me.onBeforeCheck
            }
        });
    },
    getGridPanel: function() {
        // This reference is injected in TableView.initFeatures
        return this.grid;
    },
    /**
     * @private
     * Handler for the grid's beforestaterestore event (fires before the state of the
     * grid is restored).
     * @param {Object} grid The grid object
     * @param {Object} state The hash of state values returned from the StateProvider.
     */
    applyState : function (grid, state) {
        var me = this,
            key, filter;
        me.applyingState = true;
        me.clearFilters();
        if (state.filters) {
            for (key in state.filters) {
                if (state.filters.hasOwnProperty(key)) {
                    filter = me.filters.get(key);
                    if (filter) {
                        filter.setValue(state.filters[key]);
                        filter.setActive(true);
                    }
                }
            }
        }
        me.deferredUpdate.cancel();
        if (me.local) {
            me.reload();
        }
        delete me.applyingState;
        delete state.filters;
    },
    /**
     * Saves the state of all active filters
     * @param {Object} grid
     * @param {Object} state
     * @return {Boolean}
     */
    saveState : function (grid, state) {
        var filters = {};
        this.filters.each(function (filter) {
            if (filter.active) {
                filters[filter.dataIndex] = filter.getValue();
            }
        });
        return (state.filters = filters);
    },
    /**
     * @private
     * Handler called by the grid 'beforedestroy' event
     */
    destroy : function () {
        var me = this;
        Ext.destroyMembers(me, 'menuItem', 'sep');
        me.removeAll();
        me.clearListeners();
    },
    /**
     * Remove all filters, permanently destroying them.
     */
    removeAll : function () {
        if(this.filters){
            Ext.destroy.apply(Ext, this.filters.items);
            // remove all items from the collection
            this.filters.clear();
        }
    },
    /**
     * Changes the data store bound to this view and refreshes it.
     * @param {Ext.data.Store} store The store to bind to this view
     */
    bindStore : function(store) {
        var me = this;
        // Unbind from the old Store
        if (me.store && me.storeListeners) {
            me.store.un(me.storeListeners);
        }
        // Set up correct listeners
        if (store) {
            me.storeListeners = {
                scope: me
            };
            if (me.local) {
                me.storeListeners.load = me.onLoad;
            } else {
                me.storeListeners['before' + (store.buffered ? 'prefetch' : 'load')] = me.onBeforeLoad;
            }
            store.on(me.storeListeners);
        } else {
            delete me.storeListeners;
        }
        me.store = store;
    },
    /**
     * @private
     * Get the filter menu from the filters MixedCollection based on the clicked header
     */
    getMenuFilter : function () {
        var header = this.view.headerCt.getMenu().activeHeader;
        return header ? this.filters.get(header.dataIndex) : null;
    },
    /** @private */
    onCheckChange : function (item, value) {
        this.getMenuFilter().setActive(value);
    },
    /** @private */
    onBeforeCheck : function (check, value) {
        return !value || this.getMenuFilter().isActivatable();
    },
    /**
     * @private
     * Handler for all events on filters.
     * @param {String} event Event name
     * @param {Object} filter Standard signature of the event before the event is fired
     */
    onStateChange : function (event, filter) {
        if (event !== 'serialize') {
            var me = this,
                grid = me.getGridPanel();
            if (filter == me.getMenuFilter()) {
                me.menuItem.setChecked(filter.active, false);
            }
            if ((me.autoReload || me.local) && !me.applyingState) {
                me.deferredUpdate.delay(me.updateBuffer);
            }
            me.updateColumnHeadings();
            if (!me.applyingState) {
                grid.saveState();
            }
            grid.fireEvent('filterupdate', me, filter);
        }
    },
    /**
     * @private
     * Handler for store's beforeload event when configured for remote filtering
     * @param {Object} store
     * @param {Object} options
     */
    onBeforeLoad : function (store, options) {
        var params;
        options.params = options.params || {};
        this.cleanParams(options.params);
        params = this.buildQuery(this.getFilterData());
        // Memory proxy
        if (store.getProxy().isSynchronous && this.hasActiveFilter()) {
            options.filters = [new Ext.util.Filter({
                filterFn: this.getRecordFilter()
            })];
        }
        Ext.apply(options.params, params);
    },
    /**
     * @private
     * Handler for store's load event when configured for local filtering
     * @param {Object} store
     */
    onLoad : function (store) {
        if (this.filters.length) {
            store.filterBy(this.getRecordFilter());
        }
    },
    /**
     * @private
     * Handler called when the grid's view is refreshed
     */
    onRefresh : function () {
        this.updateColumnHeadings();
    },
    /**
     * Update the styles for the header row based on the active filters
     */
    updateColumnHeadings : function () {
        var me = this,
            headerCt = me.view.headerCt;
        if (headerCt) {
            headerCt.items.each(function(header) {
                var filter = me.getFilter(header.dataIndex);
                header[filter && filter.active ? 'addCls' : 'removeCls'](me.filterCls);
            });
        }
    },
    /** @private */
    reload : function () {
        var me = this,
            store = me.view.getStore();
        if (me.local) {
            store.clearFilter(true);
            store.filterBy(me.getRecordFilter());
            store.sort();
        } else {
            me.deferredUpdate.cancel();
            if (store.buffered) {
                store.data.clear();
            }
            store.loadPage(1);
        }
    },
    /**
     * Method factory that generates a record validator for the filters active at the time
     * of invokation.
     * @private
     */
    getRecordFilter : function () {
        var f = [], len, i,
            lockingPartner = this.lockingPartner;
        this.filters.each(function (filter) {
            if (filter.active) {
                f.push(filter);
            }
        });
        // Be sure to check the active filters on a locking partner as well.
        if (lockingPartner) {
            lockingPartner.filters.each(function (filter) {
                if (filter.active) {
                    f.push(filter);
                }
            });
        }
        len = f.length;
        return function (record) {
            for (i = 0; i < len; i++) {
                if (!f[i].validateRecord(record)) {
                    return false;
                }
            }
            return true;
        };
    },
    hasActiveFilter: function(){
        var result = false;
        this.filters.each(function (filter) {
            if (filter.active) {
                result = true;
                return false;
            }
        });
        return result;
    },
    /**
     * Adds a filter to the collection and observes it for state change.
     * @param {Object/Ext.ux.grid.filter.Filter} config A filter configuration or a filter object.
     * @return {Ext.ux.grid.filter.Filter} The existing or newly created filter object.
     */
    addFilter : function (config) {
        var me = this,
            columns = me.getGridPanel().columnManager.getColumns(),
            i, columnsLength, column, filtersLength, filter;
        for (i = 0, columnsLength = columns.length; i < columnsLength; i++) {
            column = columns[i];
            if (column.dataIndex === config.dataIndex) {
                column.filter = config;
            }
        }
        if (me.view.headerCt.menu) {
            me.createFilters();
        } else {
            // Call getMenu() to ensure the menu is created, and so, also are the filters. We cannot call
            // createFilters() withouth having a menu because it will cause in a recursion to applyState()
            // that ends up to clear all the filter values. This is likely to happen when we reorder a column
            // and then add a new filter before the menu is recreated.
            me.view.headerCt.getMenu();
        }
        for (i = 0, filtersLength = me.filters.items.length; i < filtersLength; i++) {
            filter = me.filters.items[i];
            if (filter.dataIndex === config.dataIndex) {
                return filter;
            }
        }
    },
    /**
     * Adds filters to the collection.
     * @param {Array} filters An Array of filter configuration objects.
     */
    addFilters : function (filters) {
        if (filters) {
            var me = this,
                i, filtersLength;
            for (i = 0, filtersLength = filters.length; i < filtersLength; i++) {
                me.addFilter(filters[i]);
            }
        }
    },
    /**
     * Returns a filter for the given dataIndex, if one exists.
     * @param {String} dataIndex The dataIndex of the desired filter object.
     * @return {Ext.ux.grid.filter.Filter}
     */
    getFilter : function (dataIndex) {
        return this.filters.get(dataIndex);
    },
    /**
     * Turns all filters off. This does not clear the configuration information
     * (see {@link #removeAll}).
     */
    clearFilters : function () {
        this.filters.each(function (filter) {
            filter.setActive(false);
        });
    },
    getFilterItems: function () {
        var me = this;
        // If there's a locked grid then we must get the filter items for each grid.
        if (me.lockingPartner) {
            return me.filters.items.concat(me.lockingPartner.filters.items);
        }
        return me.filters.items;
    },
    /**
     * Returns an Array of the currently active filters.
     * @return {Array} filters Array of the currently active filters.
     */
    getFilterData : function () {
        var items = this.getFilterItems(),
            filters = [],
            n, nlen, item, d, i, len;
        for (n = 0, nlen = items.length; n < nlen; n++) {
            item = items[n];
            if (item.active) {
                d = [].concat(item.serialize());
                for (i = 0, len = d.length; i < len; i++) {
                    filters.push({
                        field: item.dataIndex,
                        data: d[i]
                    });
                }
            }
        }
        return filters;
    },
    /**
     * Function to take the active filters data and build it into a query.
     * The format of the query depends on the {@link #encode} configuration:
     *
     *   - `false` (Default) :
     *     Flatten into query string of the form (assuming <code>{@link #paramPrefix}='filters'</code>:
     *
     *         filters[0][field]="someDataIndex"&
     *         filters[0][data][comparison]="someValue1"&
     *         filters[0][data][type]="someValue2"&
     *         filters[0][data][value]="someValue3"&
     *
     *
     *   - `true` :
     *     JSON encode the filter data
     *
     *         {filters:[{"field":"someDataIndex","comparison":"someValue1","type":"someValue2","value":"someValue3"}]}
     *
     * Override this method to customize the format of the filter query for remote requests.
     *
     * @param {Array} filters A collection of objects representing active filters and their configuration.
     * Each element will take the form of {field: dataIndex, data: filterConf}. dataIndex is not assured
     * to be unique as any one filter may be a composite of more basic filters for the same dataIndex.
     *
     * @return {Object} Query keys and values
     */
    buildQuery : function (filters) {
        var p = {}, i, f, root, dataPrefix, key, tmp,
            len = filters.length;
        if (!this.encode){
            for (i = 0; i < len; i++) {
                f = filters[i];
                root = [this.paramPrefix, '[', i, ']'].join('');
                p[root + '[field]'] = f.field;
                dataPrefix = root + '[data]';
                for (key in f.data) {
                    p[[dataPrefix, '[', key, ']'].join('')] = f.data[key];
                }
            }
        } else {
            tmp = [];
            for (i = 0; i < len; i++) {
                f = filters[i];
                tmp.push(Ext.apply(
                    {},
                    {field: f.field},
                    f.data
                ));
            }
            // only build if there is active filter
            if (tmp.length > 0){
                p[this.paramPrefix] = Ext.JSON.encode(tmp);
            }
        }
        return p;
    },
    /**
     * Removes filter related query parameters from the provided object.
     * @param {Object} p Query parameters that may contain filter related fields.
     */
    cleanParams : function (p) {
        // if encoding just delete the property
        if (this.encode) {
            delete p[this.paramPrefix];
        // otherwise scrub the object of filter data
        } else {
            var regex, key;
            regex = new RegExp('^' + this.paramPrefix + '\[[0-9]+\]');
            for (key in p) {
                if (regex.test(key)) {
                    delete p[key];
                }
            }
        }
    },
    /**
     * Function for locating filter classes, overwrite this with your favorite
     * loader to provide dynamic filter loading.
     * @param {String} type The type of filter to load ('Filter' is automatically
     * appended to the passed type; eg, 'string' becomes 'StringFilter').
     * @return {Function} The Ext.ux.grid.filter.Class
     */
    getFilterClass : function (type) {
        // map the supported Ext.data.Field type values into a supported filter
        switch(type) {
            case 'auto':
              type = 'string';
              break;
            case 'int':
            case 'float':
              type = 'numeric';
              break;
            case 'bool':
              type = 'boolean';
              break;
        }
        return Ext.ClassManager.getByAlias('gridfilter.' + type);
    }
});

/**
 * This is a supporting class for {@link Ext.ux.grid.filter.ListFilter}.
 * Although not listed as configuration options for this class, this class
 * also accepts all configuration options from {@link Ext.ux.grid.filter.ListFilter}.
 */
Ext.define('Ext.ux.grid.menu.ListMenu', {
    extend: 'Ext.menu.Menu',
    /**
     * @cfg {String} idField
     * Defaults to 'id'.
     */
    idField :  'id',
    /**
     * @cfg {String} labelField
     * Defaults to 'text'.
     */
    labelField :  'text',
    /**
     * @cfg {String} paramPrefix
     * Defaults to 'Loading...'.
     */
    loadingText : 'Loading...',
    /**
     * @cfg {Boolean} loadOnShow
     * Defaults to true.
     */
    loadOnShow : true,
    /**
     * @cfg {Boolean} single
     * Specify true to group all items in this list into a single-select
     * radio button group. Defaults to false.
     */
    single : false,
    plain: true,
    constructor: function (cfg) {
        var me = this,
            gridStore;
        me.selected = [];
        me.addEvents(
            /**
             * @event checkchange
             * Fires when there is a change in checked items from this list
             * @param {Object} item Ext.menu.CheckItem
             * @param {Object} checked The checked value that was set
             */
            'checkchange'
        );
        me.callParent(arguments);
        gridStore = me.grid.store;
        if (me.store) {
            me.add({
                text: me.loadingText,
                iconCls: 'loading-indicator'
            });
            me.store.on('load', me.onLoad, me);
        // A ListMenu which is completely unconfigured acquires its store from the unique values of its field in the store.
        // If there are no records in the grid store, then we know it's async and we need to listen for its 'load' event.
        } else if (gridStore.data.length) {
            me.createMenuStore();
        } else {
            gridStore.on('load', me.createMenuStore, me, {single: true});
        }
    },
    destroy : function () {
        var me = this,
            store = me.store;
        if (store) {
            if (me.autoStore) {
                store.destroyStore();
            } else {
                store.un('unload', me.onLoad, me);
            }
        }
        me.callParent();
    },
    /**
     * Lists will initially show a 'loading' item while the data is retrieved from the store.
     * In some cases the loaded data will result in a list that goes off the screen to the
     * right (as placement calculations were done with the loading item). This adapter will
     * allow show to be called with no arguments to show with the previous arguments and
     * thus recalculate the width and potentially hang the menu from the left.
     */
    show : function () {
        var me = this;
        if (me.loadOnShow && !me.loaded && !me.store.loading) {
            me.store.load();
        }
        me.callParent();
    },
    /** @private */
    onLoad: function (store, records) {
        var me = this,
            gid, itemValue, i, len,
            listeners = {
                checkchange: me.checkChange,
                scope: me
            };
        Ext.suspendLayouts();
        me.removeAll(true);
        gid = me.single ? Ext.id() : null;
        for (i = 0, len = records.length; i < len; i++) {
            itemValue = records[i].get(me.idField);
            me.add(Ext.create('Ext.menu.CheckItem', {
                text: records[i].get(me.labelField),
                group: gid,
                checked: Ext.Array.contains(me.selected, itemValue),
                hideOnClick: false,
                value: itemValue,
                listeners: listeners
            }));
        }
        me.loaded = true;
        Ext.resumeLayouts(true);
        me.fireEvent('load', me, records);
    },
    createMenuStore: function () {
        var me = this,
            options = [],
            i, len, value;
        me.options = me.grid.store.collect(me.dataIndex, false, true);
        for (i = 0, len = me.options.length; i < len; i++) {
            value = me.options[i];
            switch (Ext.type(value)) {
                case 'array': 
                    options.push(value);
                    break;
                case 'object':
                    options.push([value[me.idField], value[me.labelField]]);
                    break;
                default:
                    if (value != null) {
                        options.push([value, value]);
                    }
            }
        }
        me.store = Ext.create('Ext.data.ArrayStore', {
            fields: [me.idField, me.labelField],
            data:   options,
            listeners: {
                load: me.onLoad,
                scope:  me
            }
        });
        me.loaded = true;
        me.autoStore = true;
    },
    /**
     * Get the selected items.
     * @return {Array} selected
     */
    getSelected : function () {
        return this.selected;
    },
    /** @private */
    setSelected : function (value) {
        value = this.selected = [].concat(value);
        if (this.loaded) {
            this.items.each(function(item){
                item.setChecked(false, true);
                for (var i = 0, len = value.length; i < len; i++) {
                    if (item.value == value[i]) {
                        item.setChecked(true, true);
                    }
                }
            });
        }
    },
    /**
     * Handler for the 'checkchange' event from an check item in this menu
     * @param {Object} item Ext.menu.CheckItem
     * @param {Object} checked The checked value that was set
     */
    checkChange : function (item, checked) {
        var value = [];
        this.items.each(function(item){
            if (item.checked) {
                value.push(item.value);
            }
        });
        this.selected = value;
        this.fireEvent('checkchange', item, checked);
    }
});

/**
 * Custom implementation of {@link Ext.menu.Menu} that has preconfigured items for entering numeric
 * range comparison values: less-than, greater-than, and equal-to. This is used internally
 * by {@link Ext.ux.grid.filter.NumericFilter} to create its menu.
 */
Ext.define('Ext.ux.grid.menu.RangeMenu', {
    extend: 'Ext.menu.Menu',
    /**
     * @cfg {String} fieldCls
     * The Class to use to construct each field item within this menu
     * Defaults to:<pre>
     * fieldCls : Ext.form.field.Number
     * </pre>
     */
    fieldCls : 'Ext.form.field.Number',
    /**
     * @cfg {Object} fieldCfg
     * The default configuration options for any field item unless superseded
     * by the <code>{@link #fields}</code> configuration.
     * Defaults to:<pre>
     * fieldCfg : {}
     * </pre>
     * Example usage:
     * <pre><code>
fieldCfg : {
    width: 150,
},
     * </code></pre>
     */
    /**
     * @cfg {Object} fields
     * The field items may be configured individually
     * Defaults to <tt>undefined</tt>.
     * Example usage:
     * <pre><code>
fields : {
    gt: { // override fieldCfg options
        width: 200,
        fieldCls: Ext.ux.form.CustomNumberField // to override default {@link #fieldCls}
    }
},
     * </code></pre>
     */
    /**
     * @cfg {Object} itemIconCls
     * The itemIconCls to be applied to each comparator field item.
     * Defaults to:<pre>
itemIconCls : {
    gt : 'ux-rangemenu-gt',
    lt : 'ux-rangemenu-lt',
    eq : 'ux-rangemenu-eq'
}
     * </pre>
     */
    itemIconCls : {
        gt : 'ux-rangemenu-gt',
        lt : 'ux-rangemenu-lt',
        eq : 'ux-rangemenu-eq'
    },
    /**
     * @cfg {Object} fieldLabels
     * Accessible label text for each comparator field item. Can be overridden by localization
     * files. Defaults to:<pre>
fieldLabels : {
     gt: 'Greater Than',
     lt: 'Less Than',
     eq: 'Equal To'
}</pre>
     */
    fieldLabels: {
        gt: 'Greater Than',
        lt: 'Less Than',
        eq: 'Equal To'
    },
    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     * Defaults to:<pre>
menuItemCfgs : {
    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125
}
     * </pre>
     */
    menuItemCfgs : {
        emptyText: 'Enter Number...',
        selectOnFocus: false,
        width: 155
    },
    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu.  Items are added to the menu
     * according to their position within this array. Defaults to:<pre>
     * menuItems : ['lt','gt','-','eq']
     * </pre>
     */
    menuItems : ['lt', 'gt', '-', 'eq'],
    plain: true,
    constructor : function (config) {
        var me = this,
            fields, fieldCfg, i, len, item, cfg, Cls;
        me.callParent(arguments);
        fields = me.fields = me.fields || {};
        fieldCfg = me.fieldCfg = me.fieldCfg || {};
        me.addEvents(
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {Ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
        me.updateTask = Ext.create('Ext.util.DelayedTask', me.fireUpdate, me);
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                // defaults
                cfg = {
                    itemId: 'range-' + item,
                    enableKeyEvents: true,
                    hideEmptyLabel: false,
                    labelCls: 'ux-rangemenu-icon ' + me.itemIconCls[item],
                    labelSeparator: '',
                    labelWidth: 29,
                    listeners: {
                        scope: me,
                        change: me.onInputChange,
                        keyup: me.onInputKeyUp,
                        el: {
                            click: this.stopFn
                        }
                    },
                    activate: Ext.emptyFn,
                    deactivate: Ext.emptyFn
                };
                Ext.apply(
                    cfg,
                    // custom configs
                    Ext.applyIf(fields[item] || {}, fieldCfg[item]),
                    // configurable defaults
                    me.menuItemCfgs
                );
                Cls = cfg.fieldCls || me.fieldCls;
                item = fields[item] = Ext.create(Cls, cfg);
            }
            me.add(item);
        }
    },
    stopFn: function(e) {
        e.stopPropagation();
    },
    /**
     * @private
     * called by this.updateTask
     */
    fireUpdate : function () {
        this.fireEvent('update', this);
    },
    /**
     * Get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var result = {},
            fields = this.fields, 
            key, field;
        for (key in fields) {
            if (fields.hasOwnProperty(key)) {
                field = fields[key];
                if (field.isValid() && field.getValue() !== null) {
                    result[key] = field.getValue();
                }
            }
        }
        return result;
    },
    /**
     * Set the value of this menu and fires the 'update' event.
     * @param {Object} data The data to assign to this menu
     */	
    setValue : function (data) {
        var me = this,
            fields = me.fields,
            key,
            field;
        for (key in fields) {
            if (fields.hasOwnProperty(key)) {
                // Prevent field's change event from tiggering a Store filter. The final upate event will do that
                field =fields[key];
                field.suspendEvents();
                field.setValue(key in data ? data[key] : '');
                field.resumeEvents();
            }
        }
        // Trigger the filering of the Store
        me.fireEvent('update', me);
    },
    /**  
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp: function(field, e) {
        if (e.getKey() === e.RETURN && field.isValid()) {
            e.stopEvent();
            this.hide();
        }
    },
    /**
     * @private
     * Handler method called when the user changes the value of one of the input
     * items in this menu.
     */
    onInputChange: function(field) {
        var me = this,
            fields = me.fields,
            eq = fields.eq,
            gt = fields.gt,
            lt = fields.lt;
        if (field == eq) {
            if (gt) {
                gt.setValue(null);
            }
            if (lt) {
                lt.setValue(null);
            }
        }
        else {
            eq.setValue(null);
        }
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

/**
 * Abstract base class for filter implementations.
 */
Ext.define('Ext.ux.grid.filter.Filter', {
    extend: 'Ext.util.Observable',
    /**
     * @cfg {Boolean} active
     * Indicates the initial status of the filter (defaults to false).
     */
    active : false,
    /**
     * @property {Boolean} active
     * True if this filter is active.  Use setActive() to alter after configuration.
     */
    /**
     * @cfg {String} dataIndex
     * The {@link Ext.data.Store} dataIndex of the field this filter represents.
     * The dataIndex does not actually have to exist in the store.
     */
    dataIndex : null,
    /**
     * @property {Ext.menu.Menu} menu
     * The filter configuration menu that will be installed into the filter submenu of a column menu.
     */
    menu : null,
    /**
     * @cfg {Number} updateBuffer
     * Number of milliseconds to wait after user interaction to fire an update. Only supported
     * by filters: 'list', 'numeric', and 'string'.
     */
    updateBuffer : 500,
    constructor : function (config) {
        Ext.apply(this, config);
        this.addEvents(
            /**
             * @event activate
             * Fires when an inactive filter becomes active
             * @param {Ext.ux.grid.filter.Filter} this
             */
            'activate',
            /**
             * @event deactivate
             * Fires when an active filter becomes inactive
             * @param {Ext.ux.grid.filter.Filter} this
             */
            'deactivate',
            /**
             * @event serialize
             * Fires after the serialization process. Use this to attach additional parameters to serialization
             * data before it is encoded and sent to the server.
             * @param {Array/Object} data A map or collection of maps representing the current filter configuration.
             * @param {Ext.ux.grid.filter.Filter} filter The filter being serialized.
             */
            'serialize',
            /**
             * @event update
             * Fires when a filter configuration has changed
             * @param {Ext.ux.grid.filter.Filter} this The filter object.
             */
            'update'
        );
        Ext.ux.grid.filter.Filter.superclass.constructor.call(this);
        this.menu = this.createMenu(config);
        this.init(config);
        if(config && config.value){
            this.setValue(config.value);
            this.setActive(config.active !== false, true);
            delete config.value;
        }
    },
    /**
     * Destroys this filter by purging any event listeners, and removing any menus.
     */
    destroy : function(){
        if (this.menu){
            this.menu.destroy();
        }
        this.clearListeners();
    },
    /**
     * Template method to be implemented by all subclasses that is to
     * initialize the filter and install required menu items.
     * Defaults to Ext.emptyFn.
     */
    init : Ext.emptyFn,
    /**
     * @private
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        config.plain = true;
        return Ext.create('Ext.menu.Menu', config);
    },
    /**
     * Template method to be implemented by all subclasses that is to
     * get and return the value of the filter.
     * @return {Object} The 'serialized' form of this filter
     * @template
     */
    getValue : Ext.emptyFn,
    /**
     * Template method to be implemented by all subclasses that is to
     * set the value of the filter and fire the 'update' event.
     * @param {Object} data The value to set the filter
     * @template
     */
    setValue : Ext.emptyFn,
    /**
     * Template method to be implemented by all subclasses that is to
     * return true if the filter has enough configuration information to be activated.
     * Defaults to always returning true.
     * @return {Boolean}
     */
    isActivatable : function(){
        return true;
    },
    /**
     * Template method to be implemented by all subclasses that is to
     * get and return serialized filter data for transmission to the server.
     */
    getSerialArgs : Ext.emptyFn,
    /**
     * Template method to be implemented by all subclasses that is to
     * validates the provided Ext.data.Record against the filters configuration.
     * Defaults to always returning true.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function(){
        return true;
    },
    /**
     * Returns the serialized filter data for transmission to the server
     * and fires the 'serialize' event.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    serialize : function(){
        var args = this.getSerialArgs();
        this.fireEvent('serialize', args, this);
        return args;
    },
    /** @private */
    fireUpdate : function(){
        if (this.active) {
            this.fireEvent('update', this);
        }
        this.setActive(this.isActivatable());
    },
    /**
     * Sets the status of the filter and fires the appropriate events.
     * @param {Boolean} active        The new filter state.
     * @param {Boolean} suppressEvent True to prevent events from being fired.
     */
    setActive : function(active, suppressEvent){
        if(this.active != active){
            this.active = active;
            if (suppressEvent !== true) {
                this.fireEvent(active ? 'activate' : 'deactivate', this);
            }
        }
    }
});

/**
 * Boolean filters use unique radio group IDs (so you can have more than one!)
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('Ext.ux.grid.GridFilters', {
    ...
    filters: [{
        // required configs
        type: 'boolean',
        dataIndex: 'visible'
        // optional configs
        defaultValue: null, // leave unselected (false selected by default)
        yesText: 'Yes',     // default
        noText: 'No'        // default
    }]
});
 * </code></pre>
 */
Ext.define('Ext.ux.grid.filter.BooleanFilter', {
    extend: 'Ext.ux.grid.filter.Filter',
    alias: 'gridfilter.boolean',
	/**
	 * @cfg {Boolean} defaultValue
	 * Set this to null if you do not want either option to be checked by default. Defaults to false.
	 */
	defaultValue : false,
	/**
	 * @cfg {String} yesText
	 * Defaults to 'Yes'.
	 */
	yesText : 'Yes',
	/**
	 * @cfg {String} noText
	 * Defaults to 'No'.
	 */
	noText : 'No',
    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        var gId = Ext.id();
		this.options = [
			Ext.create('Ext.menu.CheckItem', {text: this.yesText, group: gId, checked: this.defaultValue === true}),
			Ext.create('Ext.menu.CheckItem', {text: this.noText, group: gId, checked: this.defaultValue === false})];
		this.menu.add(this.options[0], this.options[1]);
		for(var i=0; i<this.options.length; i++){
			this.options[i].on('click', this.fireUpdate, this);
			this.options[i].on('checkchange', this.fireUpdate, this);
		}
	},
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
		return this.options[0].checked;
	},
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
	setValue : function (value) {
		this.options[value ? 0 : 1].setChecked(true);
	},
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
		var args = {type: 'boolean', value: this.getValue()};
		return args;
	},
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
		return record.get(this.dataIndex) == this.getValue();
	}
});

/**
 * Filter by a configurable Ext.picker.DatePicker menu
 *
 * Example Usage:
 *
 *     var filters = Ext.create('Ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             // required configs
 *             type: 'date',
 *             dataIndex: 'dateAdded',
 *      
 *             // optional configs
 *             dateFormat: 'm/d/Y',  // default
 *             beforeText: 'Before', // default
 *             afterText: 'After',   // default
 *             onText: 'On',         // default
 *             pickerOpts: {
 *                 // any DatePicker configs
 *             },
 *      
 *             active: true // default is false
 *         }]
 *     });
 */
Ext.define('Ext.ux.grid.filter.DateFilter', {
    extend: 'Ext.ux.grid.filter.Filter',
    alias: 'gridfilter.date',
    uses: ['Ext.picker.Date', 'Ext.menu.Menu'],
    /**
     * @cfg {String} afterText
     * Defaults to 'After'.
     */
    afterText : 'After',
    /**
     * @cfg {String} beforeText
     * Defaults to 'Before'.
     */
    beforeText : 'Before',
    /**
     * @cfg {Object} compareMap
     * Map for assigning the comparison values used in serialization.
     */
    compareMap : {
        before: 'lt',
        after:  'gt',
        on:     'eq'
    },
    /**
     * @cfg {String} dateFormat
     * The date format to return when using getValue.
     * Defaults to 'm/d/Y'.
     */
    dateFormat : 'm/d/Y',
    /**
     * @cfg {Date} maxDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Date} minDate
     * Allowable date as passed to the Ext.DatePicker
     * Defaults to undefined.
     */
    /**
     * @cfg {Array} menuItems
     * The items to be shown in this menu
     * Defaults to:<pre>
     * menuItems : ['before', 'after', '-', 'on'],
     * </pre>
     */
    menuItems : ['before', 'after', '-', 'on'],
    /**
     * @cfg {Object} menuItemCfgs
     * Default configuration options for each menu item
     */
    menuItemCfgs : {
        selectOnFocus: true,
        width: 125
    },
    /**
     * @cfg {String} onText
     * Defaults to 'On'.
     */
    onText : 'On',
    /**
     * @cfg {Object} pickerOpts
     * Configuration options for the date picker associated with each field.
     */
    pickerOpts : {},
    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        var me = this,
            pickerCfg, i, len, item, cfg;
        pickerCfg = Ext.apply(me.pickerOpts, {
            xtype: 'datepicker',
            minDate: me.minDate,
            maxDate: me.maxDate,
            format:  me.dateFormat,
            listeners: {
                scope: me,
                select: me.onMenuSelect
            }
        });
        me.fields = {};
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                cfg = {
                    itemId: 'range-' + item,
                    text: me[item + 'Text'],
                    menu: Ext.create('Ext.menu.Menu', {
                        plain: true,
                        items: [
                            Ext.apply(pickerCfg, {
                                itemId: item
                            })
                        ]
                    }),
                    listeners: {
                        scope: me,
                        checkchange: me.onCheckChange
                    }
                };
                item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
            }
            //me.add(item);
            me.menu.add(item);
        }
        me.values = {};
    },
    onCheckChange : function (item, checked) {
        var me = this,
            picker = item.menu.items.first(),
            itemId = picker.itemId,
            values = me.values;
        if (checked) {
            values[itemId] = picker.getValue();
        } else {
            delete values[itemId]
        }
        me.setActive(me.isActivatable());
        me.fireEvent('update', me);
    },
    /**
     * @private
     * Handler method called when there is a keyup event on an input
     * item of this menu.
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k === e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide();
        }
    },
    /**
     * Handler for when the DatePicker for a field fires the 'select' event
     * @param {Ext.picker.Date} picker
     * @param {Object} date
     */
    onMenuSelect : function (picker, date) {
        var fields = this.fields,
            field = this.fields[picker.itemId];
        field.setChecked(true);
        if (field === fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field === fields.after && this.getFieldValue('before') < date) {
                fields.before.setChecked(false, true);
            } else if (field === fields.before && this.getFieldValue('after') > date) {
                fields.after.setChecked(false, true);
            }
        }
        // keep track of the picker value separately because the menu gets destroyed
        // when columns order changes.  We return this value from getValue() instead
        // of picker.getValue()
        this.values[picker.itemId] = date;
        this.fireEvent('update', this);
        picker.up('menu').hide();
    },
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        var key, result = {};
        for (key in this.fields) {
            if (this.fields[key].checked) {
                result[key] = this.getFieldValue(key);
            }
        }
        return result;
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     * @param {Boolean} preserve true to preserve the checked status
     * of the other fields.  Defaults to false, unchecking the
     * other fields
     */
    setValue : function (value, preserve) {
        var key;
        for (key in this.fields) {
            if(value[key]){
                this.getPicker(key).setValue(value[key]);
                this.fields[key].setChecked(true);
            } else if (!preserve) {
                this.fields[key].setChecked(false);
            }
        }
        this.fireEvent('update', this);
    },
    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var key;
        for (key in this.fields) {
            if (this.fields[key].checked) {
                return true;
            }
        }
        return false;
    },
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var args = [];
        for (var key in this.fields) {
            if(this.fields[key].checked){
                args.push({
                    type: 'date',
                    comparison: this.compareMap[key],
                    value: Ext.Date.format(this.getFieldValue(key), this.dateFormat)
                });
            }
        }
        return args;
    },
    /**
     * Get and return the date menu picker value
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Date} Gets the current selected value of the date field
     */
    getFieldValue : function(item){
        return this.values[item];
    },
    /**
     * Gets the menu picker associated with the passed field
     * @param {String} item The field identifier ('before', 'after', 'on')
     * @return {Object} The menu picker
     */
    getPicker : function(item){
        return this.fields[item].menu.items.first();
    },
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var key,
            pickerValue,
            val = record.get(this.dataIndex),
            clearTime = Ext.Date.clearTime;
        if(!Ext.isDate(val)){
            return false;
        }
        val = clearTime(val, true).getTime();
        for (key in this.fields) {
            if (this.fields[key].checked) {
                pickerValue = clearTime(this.getFieldValue(key), true).getTime();
                if (key === 'before' && pickerValue <= val) {
                    return false;
                }
                if (key === 'after' && pickerValue >= val) {
                    return false;
                }
                if (key === 'on' && pickerValue != val) {
                    return false;
                }
            }
        }
        return true;
    }
});

/* #exclude ifGenji */
/**
 * Filter by a configurable Ext.picker.DatePicker menu
 *
 * This filter allows for the following configurations:
 *
 * - Any of the normal configs will be passed through to either component.
 * - There can be a docked config.
 * - The timepicker can be on the right or left (datepicker, too, of course).
 * - Choose which component will initiate the filtering, i.e., the event can be
 *   configured to be bound to either the datepicker or the timepicker, or if
 *   there is a docked config it be automatically have the handler bound to it.
 *
 * Although not shown here, this class accepts all configuration options
 * for {@link Ext.picker.Date} and {@link Ext.picker.Time}.
 *
 * In the case that a custom dockedItems config is passed in, the
 * class will handle binding the default listener to it so the
 * developer need not worry about having to do it.
 *
 * The default dockedItems position and the toolbar's
 * button text can be passed a config for convenience, i.e.,:
 *
 *     dock: {
 *        buttonText: 'Click to Filter',
 *        dock: 'left'
 *     }
 *
 * Or, pass in a full dockedItems config:
 *
 *     dock: {
 *        dockedItems: {
 *            xtype: 'toolbar',
 *            dock: 'bottom',
 *            ...
 *        }
 *     }
 *
 * Or, give a value of `true` to accept dock defaults:
 *
 *     dock: true
 *
 * But, it must be one or the other.
 *
 * Example Usage:
 *
 *     var filters = Ext.create('Ext.ux.grid.FiltersFeature', {
 *         ...
 *         filters: [{
 *             // required configs
 *             type: 'datetime',
 *             dataIndex: 'date',
 *
 *             // optional configs
 *             positionDatepickerFirst: false,
 *             //selectDateToFilter: false, // this is overridden b/c of the presence of the dock cfg object
 *
 *             date: {
 *                 format: 'm/d/Y',
 *             },
 *
 *             time: {
 *                 format: 'H:i:s A',
 *                 increment: 1
 *             },
 *
 *             dock: {
 *                 buttonText: 'Click to Filter',
 *                 dock: 'left'
 *
 *                 // allows for custom dockedItems cfg
 *                 //dockedItems: {}
 *             }
 *         }]
 *     });
 *
 * In the above example, note that the filter is being passed a {@link #date} config object,
 * a {@link #time} config object and a {@link #dock} config. These are all optional.
 *
 * As for positioning, the datepicker will be on the right, the timepicker on the left
 * and the docked items will be docked on the left. In addition, since there's a {@link #dock}
 * config, clicking the button in the dock will trigger the filtering.
 */
/* #end */
Ext.define('Ext.ux.grid.filter.DateTimeFilter', {
    extend: 'Ext.ux.grid.filter.DateFilter',
    alias: 'gridfilter.datetime',
    /**
     * @private
     */
    dateDefaults: {
        xtype: 'datepicker',
        format: 'm/d/Y'
    },
    /**
     * @private
     */
    timeDefaults: {
        xtype: 'timepicker',
        width: 100,
        height: 200,
        format: 'g:i A'
    },
    /**
     * @private
     */
    dockDefaults: {
        dock: 'top',
        buttonText: 'Filter'
    },
    /**
     * @cfg {Object} date
     * A {@link Ext.picker.Date} can be configured here.
     * Uses {@link #dateDefaults} by default.
     */
    /**
     * @cfg {Object} time
     * A {@link Ext.picker.Time} can be configured here.
     * Uses {@link #timeDefaults} by default.
     */
    /**
     * @cfg {Boolean/Object} dock
     * A {@link Ext.panel.AbstractPanel#cfg-dockedItems} can be configured here.
     * A `true` value will use the {@link #dockDefaults} default configuration.
     * If present, the button in the docked items will initiate the filtering.
     */
    /**
     * @cfg {Boolean} [selectDateToFilter=true]
     * By default, the datepicker has the default event listener bound to it.
     * Setting to `false` will bind it to the timepicker.
     *
     * The config will be ignored if there is a `dock` config.
     */
    selectDateToFilter: true,
    /**
     * @cfg {Boolean} [positionDatepickerFirst=true]
     * Positions the datepicker within its container.
     * A `true` value will place it on the left in the container.
     * Set to `false` if the timepicker should be placed on the left.
     * Defaults to `true`.
     */
    positionDatepickerFirst: true,
    reTime: /\s(am|pm)/i,
    /**
     * Replaces the selected value of the timepicker with the default 00:00:00.
     * @private
     * @param {Object} date
     * @param {Ext.picker.Time} timepicker
     * @return Date object
     */
    addTimeSelection: function (date, timepicker) {
        var me = this,
            selection = timepicker.getSelectionModel().getSelection(),
            time, len, fn, val,
            i = 0,
            arr = [],
            timeFns = ['setHours', 'setMinutes', 'setSeconds', 'setMilliseconds'];
        if (selection.length) {
            time = selection[0].get('disp');
            // Loop through all of the splits and add the time values.
            arr = time.replace(me.reTime, '').split(':');
            for (len = arr.length; i < len; i++) {
                fn = timeFns[i];
                val = arr[i];
                if (val) {
                    date[fn](parseInt(val, 10));
                }
            }
        }
        return date;
    },
    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init: function (config) {
        var me = this,
            dateCfg = Ext.applyIf(me.date || {}, me.dateDefaults),
            timeCfg = Ext.applyIf(me.time || {}, me.timeDefaults),
            dockCfg = me.dock, // should not default to empty object
            defaultListeners = {
                click: {
                    scope: me,
                    click: me.onMenuSelect
                },
                select: {
                    scope: me,
                    select: me.onMenuSelect
                }
            },
            pickerCtnCfg, i, len, item, cfg,
            items = [dateCfg, timeCfg],
            // we need to know the datepicker's position in the items array
            // for when the itemId name is bound to it before adding to the menu
            datepickerPosition = 0;
        if (!me.positionDatepickerFirst) {
            items = items.reverse();
            datepickerPosition = 1;
        }
        pickerCtnCfg = Ext.apply(me.pickerOpts, {
            xtype: !dockCfg ? 'container' : 'panel',
            layout: 'hbox',
            items: items
        });
        // If there's no dock config then bind the default listener to the desired picker.
        if (!dockCfg) {
            if (me.selectDateToFilter) {
                dateCfg.listeners = defaultListeners.select;
            } else {
                timeCfg.listeners = defaultListeners.select;
            }
        } else if (dockCfg) {
            me.selectDateToFilter = null;
            if (dockCfg.dockedItems) {
                pickerCtnCfg.dockedItems = dockCfg.dockedItems;
                // TODO: allow config that will tell which item to bind the listener to
                // right now, it's using the first item
                pickerCtnCfg.dockedItems.items[dockCfg.bindToItem || 0].listeners = defaultListeners.click;
            } else {
                // dockCfg can be `true` if button text and dock position defaults are wanted
                if (Ext.isBoolean(dockCfg)) {
                    dockCfg = {};
                }
                dockCfg = Ext.applyIf(dockCfg, me.dockDefaults);
                pickerCtnCfg.dockedItems = {
                    xtype: 'toolbar',
                    dock: dockCfg.dock,
                    items: [{
                        xtype: 'button',
                        text: dockCfg.buttonText,
                        flex: 1,
                        listeners: defaultListeners.click
                    }]   
                };
            }
        }
        me.fields = {};
        for (i = 0, len = me.menuItems.length; i < len; i++) {
            item = me.menuItems[i];
            if (item !== '-') {
                pickerCtnCfg.items[datepickerPosition].itemId = item;
                cfg = {
                    itemId: item,
                    text: me[item + 'Text'],
                    menu: Ext.create('Ext.menu.Menu', {
                        items: pickerCtnCfg
                    }),
                    listeners: {
                        scope: me,
                        checkchange: me.onCheckChange
                    }
                };
                item = me.fields[item] = Ext.create('Ext.menu.CheckItem', cfg);
            }
            me.menu.add(item);
        }
        me.values = {};
    },
    /**
     * @private
     */
    onCheckChange: function (item, checked) {
        var me = this,
            menu = item.menu,
            timepicker = menu.down('timepicker'),
            datepicker = menu.down('datepicker'),
            itemId = datepicker.itemId,
            values = me.values;
        if (checked) {
            values[itemId] = me.addTimeSelection(datepicker.value, timepicker);
        } else {
            delete values[itemId];
        }
        me.setActive(me.isActivatable());
        me.fireEvent('update', me);
    },
    /** 
     * Handler for when the DatePicker for a field fires the 'select' event
     * @param {Ext.picker.Date} picker
     * @param {Object} date
     */
    onMenuSelect: function (picker, date) {
        // NOTE: we need to redefine the picker.
        var me = this,
            menu = me.menu,
            fields = me.fields,
            field;
        if (me.dock) {
            // If there is a dock config then the button will trigger the menu select.
            // In these cases, the picker function arg isn't actually a picker but the
            // button that was clicked, so redefine the picker.
            //
            // The focusEl is going to be the check item.
            picker = menu.getFocusEl().down('datepicker');
        }
        field = me.fields[picker.itemId];
        field.setChecked(true);
        if (field === fields.on) {
            fields.before.setChecked(false, true);
            fields.after.setChecked(false, true);
        } else {
            fields.on.setChecked(false, true);
            if (field === fields.after && me.getFieldValue('before') < date) {
                fields.before.setChecked(false, true);
            } else if (field === fields.before && me.getFieldValue('after') > date) {
                fields.after.setChecked(false, true);
            }   
        }   
        me.fireEvent('update', me);
        // The timepicker's getBubbleTarget() returns the boundlist's implementation,
        // so it doesn't look up ownerCt chain (it looks up this.pickerField).
        // This is a problem :)
        // This can be fixed by just walking up the ownerCt chain
        // (same thing, but confusing without comment).
        picker.ownerCt.ownerCt.hide();
    },
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs: function () {
        var me = this,
            key,
            fields = me.fields,
            args = [],
            date = Ext.apply(me.dateDefaults, me.date || {}),
            time = Ext.apply(me.timeDefaults, me.time || {});
        for (key in fields) {
            if (fields[key].checked) {
                args.push({
                    type: 'datetime',
                    comparison: me.compareMap[key],
                    value: Ext.Date.format(me.getFieldValue(key), date.format + ' ' + time.format)
                });
            }
        }
        return args;
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     * @param {Boolean} preserve true to preserve the checked status
     * of the other fields.  Defaults to false, unchecking the
     * other fields
     */
    setValue: function (value, preserve) {
        var me = this,
            fields = me.fields,
            key,
            val,
            datepicker;
        for (key in fields) {
            val = value[key];
            if (val) {
                datepicker = me.menu.down('datepicker[itemId="' + key + '"]');
                // Note that calling the Ext.picker.Date:setValue() calls Ext.Date.clearTime(),
                // which we don't want, so just call update() instead and set the value on the component.
                datepicker.update(val);
                datepicker.value = val;
                fields[key].setChecked(true);
            } else if (!preserve) {
                fields[key].setChecked(false);
            }
        }
        me.fireEvent('update', me);
    },
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord: function (record) {
        // remove calls to Ext.Date.clearTime
        var me = this,
            key,
            pickerValue,
            val = record.get(me.dataIndex);
        if(!Ext.isDate(val)){
            return false;
        }
        val = val.getTime();
        for (key in me.fields) {
            if (me.fields[key].checked) {
                pickerValue = me.getFieldValue(key).getTime();
                if (key === 'before' && pickerValue <= val) {
                    return false;
                }
                if (key === 'after' && pickerValue >= val) {
                    return false;
                }
                if (key === 'on' && pickerValue != val) {
                    return false;
                }
            }
        }
        return true;
    }
});

/**
 * List filters are able to be preloaded/backed by an Ext.data.Store to load
 * their options the first time they are shown. ListFilter utilizes the
 * {@link Ext.ux.grid.menu.ListMenu} component.
 *
 * List filters are also able to create their own list of values from  all unique values of
 * the specified {@link #dataIndex} field in the store at first time of filter invocation.
 *
 * Although not shown here, this class accepts all configuration options
 * for {@link Ext.ux.grid.menu.ListMenu}.
 *
 * Example Usage:
 *
 *     var filters = Ext.create('Ext.ux.grid.GridFilters', {
 *         ...
 *         filters: [{
 *             type: 'list',
 *             dataIndex: 'size',
 *             phpMode: true,
 *             // options will be used as data to implicitly creates an ArrayStore
 *             options: ['extra small', 'small', 'medium', 'large', 'extra large']
 *         }]
 *     });
 *
 */
Ext.define('Ext.ux.grid.filter.ListFilter', {
    extend: 'Ext.ux.grid.filter.Filter',
    alias: 'gridfilter.list',
    /**
     * @cfg {Array} [options]
     * `data` to be used to implicitly create a data store
     * to back this list when the data source is **local**. If the
     * data for the list is remote, use the {@link #store}
     * config instead.
     *
     * If neither store nor {@link #options} is specified, then the choices list is automatically
     * populated from all unique values of the specified {@link #dataIndex} field in the store at first
     * time of filter invocation.
     *
     * Each item within the provided array may be in one of the
     * following formats:
     *
     *   - **Array** :
     *
     *         options: [
     *             [11, 'extra small'],
     *             [18, 'small'],
     *             [22, 'medium'],
     *             [35, 'large'],
     *             [44, 'extra large']
     *         ]
     *
     *   - **Object** :
     *
     *         labelField: 'name', // override default of 'text'
     *         options: [
     *             {id: 11, name:'extra small'},
     *             {id: 18, name:'small'},
     *             {id: 22, name:'medium'},
     *             {id: 35, name:'large'},
     *             {id: 44, name:'extra large'}
     *         ]
     * 
     *   - **String** :
     *
     *         options: ['extra small', 'small', 'medium', 'large', 'extra large']
     *
     */
    /**
     * @cfg {Boolean} phpMode
     * Adjust the format of this filter. Defaults to false.
     *
     * When GridFilters `@cfg encode = false` (default):
     *
     *     // phpMode == false (default):
     *     filter[0][data][type] list
     *     filter[0][data][value] value1
     *     filter[0][data][value] value2
     *     filter[0][field] prod
     *
     *     // phpMode == true:
     *     filter[0][data][type] list
     *     filter[0][data][value] value1, value2
     *     filter[0][field] prod
     *
     * When GridFilters `@cfg encode = true`:
     *
     *     // phpMode == false (default):
     *     filter : [{"type":"list","value":["small","medium"],"field":"size"}]
     *
     *     // phpMode == true:
     *     filter : [{"type":"list","value":"small,medium","field":"size"}]
     *
     */
    phpMode : false,
    /**
     * @cfg {Ext.data.Store} [store]
     * The {@link Ext.data.Store} this list should use as its data source
     * when the data source is **remote**. If the data for the list
     * is local, use the {@link #options} config instead.
     *
     * If neither store nor {@link #options} is specified, then the choices list is automatically
     * populated from all unique values of the specified {@link #dataIndex} field in the store at first
     * time of filter invocation.
     */
    /**
     * @private
     * Template method that is to initialize the filter.
     * @param {Object} config
     */
    init : function (config) {
        this.dt = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },
    /**
     * @private
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        var menu = Ext.create('Ext.ux.grid.menu.ListMenu', config);
        menu.on('checkchange', this.onCheckChange, this);
        return menu;
    },
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getSelected();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.menu.setSelected(value);
        this.fireEvent('update', this);
    },
    /**
     * Template method that is to return true if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.getValue().length > 0;
    },
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'list', value: this.phpMode ? this.getValue().join(',') : this.getValue()};
    },
    /** @private */
    onCheckChange : function(){
        this.dt.delay(this.updateBuffer);
    },
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var valuesArray = this.getValue();
        return Ext.Array.indexOf(valuesArray, record.get(this.dataIndex)) > -1;
    }
});

/**
 * Filters using an Ext.ux.grid.menu.RangeMenu.
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('Ext.ux.grid.GridFilters', {
    ...
    filters: [{
        type: 'numeric',
        dataIndex: 'price'
    }]
});
 * </code></pre>
 * <p>Any of the configuration options for {@link Ext.ux.grid.menu.RangeMenu} can also be specified as
 * configurations to NumericFilter, and will be copied over to the internal menu instance automatically.</p>
 */
Ext.define('Ext.ux.grid.filter.NumericFilter', {
    extend: 'Ext.ux.grid.filter.Filter',
    alias: 'gridfilter.numeric',
    uses: ['Ext.form.field.Number'],
    /**
     * @private
     * Creates the Menu for this filter.
     * @param {Object} config Filter configuration
     * @return {Ext.menu.Menu}
     */
    createMenu: function(config) {
        var me = this,
            menu;
        menu = Ext.create('Ext.ux.grid.menu.RangeMenu', config);
        menu.on('update', me.fireUpdate, me);
        return menu;
    },
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.menu.getValue();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.menu.setValue(value);
    },
    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        var values = this.getValue(),
            key;
        for (key in values) {
            if (values[key] !== undefined) {
                return true;
            }
        }
        return false;
    },
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        var key,
            args = [],
            values = this.menu.getValue();
        for (key in values) {
            args.push({
                type: 'numeric',
                comparison: key,
                value: values[key]
            });
        }
        return args;
    },
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex),
            values = this.getValue(),
            isNumber = Ext.isNumber;
        if (isNumber(values.eq) && val != values.eq) {
            return false;
        }
        if (isNumber(values.lt) && val >= values.lt) {
            return false;
        }
        if (isNumber(values.gt) && val <= values.gt) {
            return false;
        }
        return true;
    }
});

/**
 * Filter by a configurable Ext.form.field.Text
 * <p><b><u>Example Usage:</u></b></p>
 * <pre><code>
var filters = Ext.create('Ext.ux.grid.GridFilters', {
    ...
    filters: [{
        // required configs
        type: 'string',
        dataIndex: 'name',
        // optional configs
        value: 'foo',
        active: true, // default is false
        iconCls: 'ux-gridfilter-text-icon' // default
        // any Ext.form.field.Text configs accepted
    }]
});
 * </code></pre>
 */
Ext.define('Ext.ux.grid.filter.StringFilter', {
    extend: 'Ext.ux.grid.filter.Filter',
    alias: 'gridfilter.string',
    /**
     * @cfg {String} iconCls
     * The iconCls to be applied to the menu item.
     * Defaults to <tt>'ux-gridfilter-text-icon'</tt>.
     */
    iconCls : 'ux-gridfilter-text-icon',
    emptyText: 'Enter Filter Text...',
    selectOnFocus: true,
    width: 125,
    /**
     * @private
     * Template method that is to initialize the filter and install required menu items.
     */
    init : function (config) {
        Ext.applyIf(config, {
            enableKeyEvents: true,
            labelCls: 'ux-rangemenu-icon ' + this.iconCls,
            hideEmptyLabel: false,
            labelSeparator: '',
            labelWidth: 29,
            listeners: {
                scope: this,
                keyup: this.onInputKeyUp,
                el: {
                    click: function(e) {
                        e.stopPropagation();
                    }
                }
            }
        });
        this.inputItem = Ext.create('Ext.form.field.Text', config);
        this.menu.add(this.inputItem);
        this.menu.showSeparator = false;
        this.updateTask = Ext.create('Ext.util.DelayedTask', this.fireUpdate, this);
    },
    /**
     * @private
     * Template method that is to get and return the value of the filter.
     * @return {String} The value of this filter
     */
    getValue : function () {
        return this.inputItem.getValue();
    },
    /**
     * @private
     * Template method that is to set the value of the filter.
     * @param {Object} value The value to set the filter
     */
    setValue : function (value) {
        this.inputItem.setValue(value);
        this.fireEvent('update', this);
    },
    /**
     * Template method that is to return <tt>true</tt> if the filter
     * has enough configuration information to be activated.
     * @return {Boolean}
     */
    isActivatable : function () {
        return this.inputItem.getValue().length > 0;
    },
    /**
     * @private
     * Template method that is to get and return serialized filter data for
     * transmission to the server.
     * @return {Object/Array} An object or collection of objects containing
     * key value pairs representing the current configuration of the filter.
     */
    getSerialArgs : function () {
        return {type: 'string', value: this.getValue()};
    },
    /**
     * Template method that is to validate the provided Ext.data.Record
     * against the filters configuration.
     * @param {Ext.data.Record} record The record to validate
     * @return {Boolean} true if the record is valid within the bounds
     * of the filter, false otherwise.
     */
    validateRecord : function (record) {
        var val = record.get(this.dataIndex);
        if(typeof val != 'string') {
            return (this.getValue().length === 0);
        }
        return val.toLowerCase().indexOf(this.getValue().toLowerCase()) > -1;
    },
    /**
     * @private
     * Handler method called when there is a keyup event on this.inputItem
     */
    onInputKeyUp : function (field, e) {
        var k = e.getKey();
        if (k == e.RETURN && field.isValid()) {
            e.stopEvent();
            this.menu.hide();
            return;
        }
        // restart the timer
        this.updateTask.delay(this.updateBuffer);
    }
});

/**
 * A Header subclass which renders a checkbox in each column cell which toggles the truthiness of the associated data field on click.
 *
 * Example usage:
 * 
 *    // create the grid
 *    var grid = Ext.create('Ext.grid.Panel', {
 *        ...
 *        columns: [{
 *           text: 'Foo',
 *           ...
 *        },{
 *           xtype: 'checkcolumn',
 *           text: 'Indoor?',
 *           dataIndex: 'indoor',
 *           width: 55
 *        }]
 *        ...
 *    });
 *
 * In addition to toggling a Boolean value within the record data, this
 * class adds or removes a css class <tt>'x-grid-checked'</tt> on the td
 * based on whether or not it is checked to alter the background image used
 * for a column.
 */
Ext.define('Ext.ux.CheckColumn', {
    extend: 'Ext.grid.column.Column',
    alias: 'widget.checkcolumn',
    /**
     * @cfg {Boolean} [stopSelection=true]
     * Prevent grid selection upon mousedown.
     */
    stopSelection: true,
    tdCls: Ext.baseCSSPrefix + 'grid-cell-checkcolumn',
    constructor: function() {
        this.addEvents(
            /**
             * @event beforecheckchange
             * Fires when before checked state of a row changes.
             * The change may be vetoed by returning `false` from a listener.
             * @param {Ext.ux.CheckColumn} this CheckColumn
             * @param {Number} rowIndex The row index
             * @param {Boolean} checked True if the box is to be checked
             */
            'beforecheckchange',
            /**
             * @event checkchange
             * Fires when the checked state of a row changes
             * @param {Ext.ux.CheckColumn} this CheckColumn
             * @param {Number} rowIndex The row index
             * @param {Boolean} checked True if the box is now checked
             */
            'checkchange'
        );
        this.callParent(arguments);
    },
    /**
     * @private
     * Process and refire events routed from the GridView's processEvent method.
     */
    processEvent: function(type, view, cell, recordIndex, cellIndex, e, record, row) {
        var me = this,
            key = type === 'keydown' && e.getKey(),
            mousedown = type == 'mousedown';
        if (mousedown || (key == e.ENTER || key == e.SPACE)) {
            var dataIndex = me.dataIndex,
                checked = !record.get(dataIndex);
            // Allow apps to hook beforecheckchange
            if (me.fireEvent('beforecheckchange', me, recordIndex, checked) !== false) {
                record.set(dataIndex, checked);
                me.fireEvent('checkchange', me, recordIndex, checked);
                // Mousedown on the now nonexistent cell causes the view to blur, so stop it continuing.
                if (mousedown) {
                    e.stopEvent();
                }
                // Selection will not proceed after this because of the DOM update caused by the record modification
                // Invoke the SelectionModel unless configured not to do so
                if (!me.stopSelection) {
                    view.selModel.selectByPosition({
                        row: recordIndex,
                        column: cellIndex
                    });
                }
                // Prevent the view from propagating the event to the selection model - we have done that job.
                return false;
            } else {
                // Prevent the view from propagating the event to the selection model if configured to do so.
                return !me.stopSelection;
            }
        } else {
            return me.callParent(arguments);
        }
    },
    // Note: class names are not placed on the prototype bc renderer scope
    // is not in the header.
    renderer : function(value){
        var cssPrefix = Ext.baseCSSPrefix,
            cls = [cssPrefix + 'grid-checkheader'];
        if (value) {
            cls.push(cssPrefix + 'grid-checkheader-checked');
        }
        return '<div class="' + cls.join(' ') + '">&#160;</div>';
    }
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.HelpWrapperComponent',{
	extend:'Ext.container.Container',
	config:{
		inputComp:null,
		helpStr:null,
		helpExpanded:false,
		flexInputComp:false
	},
	layout:'anchor',
	defaults:{
		anchor:'100%'
	},
	border:false,
	bodyBorder:false,
	btnHelp:null,helpArea:null,panWrapper:null,
	initComponent: function(){
		var me=this;
		if(CWHF.isNull(me.helpExpanded)){
			me.helpExpanded=false;
		}
		if(CWHF.isNull(me.flexInputComp)){
			me.flexInputComp=false;
		}
		me.callParent();
		var items=me.createChildren(me.disabled || me.inputComp.disabled);
		me.add(items);
		me.setDisabled(me.disabled || me.inputComp.disabled);
	},
	createChildren:function(disabled){
		var me=this;
		var items=new Array();
		me.btnHelp=Ext.create('Ext.button.Button',{
			style:{ marginBottom: '5px', marginLeft: '5px',border:'none',background:'none'},
			iconCls: 'help16',
			enableToggle:false,
			scale: 'small',
			handler:me.showHideHelpArea,
			disabled:disabled,
			scope:me
		});
		me.btnHelp.focusable =false;
		if(me.flexInputComp===true){
			me.inputComp.flex=1;
		}
		me.panWrapper=Ext.create('Ext.container.Container', {
			border:false,
			itemId: 'panWrapper',
			layout: 'hbox',
			items: [me.inputComp, me.btnHelp]
		});
		me.helpArea=Ext.create('Ext.Component',{
			html: me.helpStr,
			margin:'0 5 5 5',
			border:true,
			disabled:disabled,
			cls:'infoBox2',
			hidden:(me.helpExpanded===false)
		});
		items.push(me.panWrapper);
		items.push(me.helpArea);
		return items;
	},
	showHideHelpArea:function(){
		var me=this;
		me.helpArea.setVisible(!me.helpArea.isVisible());
	},
	setDisabled:function(disabled){
		var me=this;
		me.callParent(false);
		if(me.inputComp.setDisabled&&Ext.isFunction(me.inputComp.setDisabled)){
			me.inputComp.setDisabled(disabled);
		}
		me.btnHelp.setDisabled(disabled);
		me.helpArea.setDisabled(disabled);
	},
	getInputComponent:function(){
		return this.inputComp;
	},
	getHelpButton:function(){
		return this.btnHelp;
	}
});
Ext.define('com.trackplus.SpellCheckTextField',{
	extend:'Ext.form.field.Text',
	initComponent: function(){
		var me=this;
		me.addListener('afterrender',me.initSpellCheck,me);
		me.callParent();
	},
	initSpellCheck:function(){
		var me=this;
		me.inputEl.dom.setAttribute('spellcheck','true');
		me.inputEl.on('contextmenu', function(e){
			e.stopPropagation();
			return false;
		}, me);
	}
});
Ext.define('util.ControlWithHelpFactory',{
	extend:'Ext.Base',
	singleton:true,
	constructor: function(config) {
	},
	labelWidth:250,
	textFieldWidth:250+300,
	textFieldWidthShort:250+70,
	alignR:"right",
	FieldSetWidth:250+300+150,
	/**
	 * Creates the help button that controls the help area that appears underneath an input element.
	 *
	 * @param {String} idee The itemId or id of the associated input component. The id of the help button
	 * is constructed from the idee plus '.hlp' appended.
	 * @param {String} helpStr The localized help string
	 * @param {String} intId An auto-generated internal id for connecting the help area to this button.
	 * @return {Ext.button.Button} The help button
	 */
	/*createHelpCmp:function(idee,helpStr,intId){
		var me=this;
		var helpComp={
				xtype:'button',
				style:{ marginBottom: '5px', marginLeft: '5px',border:'none',background:'none'},
				iconCls: 'help16',
				enableToggle:false,
				scale: 'small',
				itemId: idee+'.hlp',
				handler:function(){
					Ext.getCmp(intId).setVisible(!Ext.getCmp(intId).isVisible());
				}
		};
		return helpComp;
	},*/
	/**
	 * Creates a wrapper panel that encloses an in input component, a help button, and a help
	 * area that can appear underneath the input element. The id of the complete
	 * wrapper component is created from the id in <code>otherSettings</code>, if any is given,
	 * plus '.wrp' appended. Same is true for itemId.
	 *
	 * @param {xtype} inputComp The input component that is being wrapped together with a help
	 * button and help area.
	 * @param {String} name The form field name of the associated input component.
	 * @param {helpStr} The localized help string.
	 * @return {Ext.panel.Panel} The wrapper panel
	 */
	/*createWrapperHelp:function(inputComp,name,helpStr,otherSettings){
		var me=this;
		var idee = name;
		var intId = Ext.id();
		if (otherSettings) {
			for (propertyName in otherSettings) {
				if (propertyName==='id') idee = otherSettings[propertyName];
				if (propertyName==='itemId') idee = otherSettings[propertyName];
			}
		}
		var helpComp=me.createHelpCmp(idee,helpStr,intId);
		var panWrapper={
				xtype: 'panel',
				border:false,
				bodyBorder:false,
				layout: 'hbox',
				itemId: idee+'.wrp',
				items: [inputComp,helpComp]
		};
		var helpArea={
				xtype: 'panel',
				id:intId,
				html: helpStr,
				margin:'0 5 5 5',
				border:false,
				bodyBorder:true,
				width:me.textFieldWidth-5,
				bodyCls:'infoBox2',
				hidden:true
		};
		return [panWrapper,helpArea];
	},*/
	/**
	 * Gets a control by the path specified in the "arguments", starting form the scope
	 * The scope should be the main container the components are searched from
	 */
	getControl: function() {
		var container = this;
		Ext.Array.each(arguments, function(argument, index, allArguments) {
			container = container.getComponent(argument);
			if (CWHF.isNull(container)) {
				return false;
			}
		}, this);
		return container;
	},
	/**
	 * Similar like getControl but gets the help wrapper container, not the included control
	 * although the path in the "arguments" should be the control path
	 */
	getHelpWrapper: function() {
		var container = this;
		Ext.Array.each(arguments, function(argument, index, allArguments) {
			if (index===allArguments.length-1) {
				container = container.getComponent(CWHF.getWrapperItemId(argument));
			} else {
				container = container.getComponent(argument);
			}
			if (CWHF.isNull(container)) {
				return false;
			}
		}, this);
		return container;
	},
	/**
	 * Gets the itemId of the help wrapper container based on the itemId of the included control
	 */
	getWrapperItemId: function(inputCompItemId) {
		return inputCompItemId +'_wrp';
	},
	/**
	 * Similar like getControl but gets the help-wrapped control,
	 * the path in the "arguments" should be the control path without help contained itemId
	 */
	getWrappedControl: function() {
		var container = this;
		Ext.Array.each(arguments, function(argument, index, allArguments ) {
			if (index===allArguments.length-1) {
				container = container.getComponent(CWHF.getWrapperItemId(argument));
			} else {
				container = container.getComponent(argument);
			}
			if (CWHF.isNull(container)) {
				return false;
			}
		}, this);
		if (container) {
			return container.getInputComponent();
		}
		return null;
	},
	getLabel: function(labelKey, otherSettings) {
		var label = '';
		if (labelKey && labelKey!=='') {
			if (otherSettings && otherSettings.labelIsLocalized) {
				label = labelKey;
			} else {
				label = getText(labelKey);
			}
		}
		return label;
	},
	addOtherSettings: function(fieldConfig, otherSettings, label) {
		if (otherSettings) {
			if (label) {
				this.addBlankText(fieldConfig, otherSettings, label);
			}
			for (propertyName in otherSettings) {
				fieldConfig[propertyName] = otherSettings[propertyName];
			}
		}
	},
	addBlankText: function(fieldConfig, otherSettings, label) {
		if (otherSettings && /*otherSettings.allowBlank &&*/ otherSettings.allowBlank===false && CWHF.isNull(otherSettings.blankText)) {
			fieldConfig.blankText = getText("common.err.required", label);
		}
	},
	/**
	 * Create a new Ext.Action action with localized text and tooltip
	 * label the localized label of the operation
	 * iconCls the icon class for the action
	 * handler the action handler
	 * tooltip makes sense only for toolbar buttons (not for context menu items)
	 * 		this is the localized tooltip not the tooltip key, because the tooltip for localized actions should not change
	 * 		depending on the context
	 * disabled whether by creation it should be disabled
	 */
	/*public*/createAction: function(labelKey, iconCls, handlerName, otherSettings) {
		var me = this;
		var label = this.getLabel(labelKey, otherSettings);
		var actionConfig = {
				text: label,
				overflowText: label,
				tooltip: label,
				iconCls: iconCls,
				handler: handlerName
				//handlerScope: handlerScope
		};
		this.addOtherSettings(actionConfig, otherSettings, label);
		return Ext.create("Ext.Action", actionConfig);
	},
	/**
	 * Create a text field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.TextField} A text field
	 */
	createHiddenField: function(name, otherSettings, listenerConfig) {
		var hiddenFieldConfig = {
				xtype: 'hiddenfield',
				name: name
				};
		if (otherSettings) {
			for (propertyName in otherSettings) {
				hiddenFieldConfig[propertyName] = otherSettings[propertyName];
			}
		}
		if (listenerConfig) {
			hiddenFieldConfig.listeners = listenerConfig;
		}
		return Ext.create('Ext.form.field.Hidden', hiddenFieldConfig);
	},
	/**
	 * Create a text field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.TextField} A text field
	 */
	createTextField: function(labelKey, name, otherSettings, listenerConfig) {
		var label = this.getLabel(labelKey, otherSettings);
		var textFieldConfig = {
				xtype: 'textfield',
				fieldLabel: label,
				name: name,
				msgTarget: 'under',
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth
				};
		if (listenerConfig) {
			textFieldConfig.listeners = listenerConfig;
		}
		this.addOtherSettings(textFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.Text', textFieldConfig);
	},
	/**
	 * Create a text field component together with a help button and help area.The label will be localized.
	 * The help string will be looked up under resource string <code>'labelKey.help'</code>.
	 * If an <code>id</code> and/or <code>itemId</code> is given in <code>otherSettings</code>,
	 * it will be for used the field component. The associated help button then has this id,
	 * with the string <code>'.hlp'</code> appended. The enclosing panel has this id,
	 * with the string <code>'.wrp'</code> appended.
	 *
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.panel.Panel} A panel enclosing a text field, a help button, and a help area.
	 */
	createTextFieldWithHelp: function(labelKey, name, otherSettings, listenerConfig, wrapperItemId) {
		var inputComp=this.createTextField(labelKey, name, otherSettings, listenerConfig);
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,name,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/*createFilterPicker: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var queryPickerConfig = {
			xtype: 'textfield',
			fieldLabel : this.getLabel(labelKey, otherSettings),
			name: name,
			itemId: name,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		this.addOtherSettings(queryPickerConfig, otherSettings, label);
		return Ext.create('com.trackplus.util.FilterPicker', queryPickerConfig);
	},*/
	/**
	 * Creates a report tree for multiple selection
	 */
	/*createReportTree: function(reportIDs, extraProxyParameters,
			hiddenFieldName, treeConfigOptions) {
		var treeConfig = {
				rootVisible: false,
				containerScroll: true,
				autoScroll: true,
				cls:"simpleTree"
			}
		this.addOtherSettings(treeConfig, treeConfigOptions, null);
		//extraProxyParameters for getting the tree nodes
		if (CWHF.isNull(extraProxyParameters)) {
			extraProxyParameters = new Object();
		}
		//report tree is with check boxes (report picker isn't but they use the same struts action)
		extraProxyParameters["useChecked"] = true;
		//to set the checked field on the server side and send back in json nodes
		extraProxyParameters["selectedIDs"] = reportIDs;
		return Ext.create("com.trackplus.util.ReportTree",
				{selectedIDs: reportIDs,//initialize the hidden field
				extraProxyParameters: extraProxyParameters,
				hiddenFieldName: hiddenFieldName,
				treeConfig: treeConfig});
	},*/
	/**
	 * Creates a multiple select project tree
	 */
	/*createProjectTree: function(projectIDs, extraProxyParameters,
			hiddenFieldName, treeConfigOptions, itemId, selectionChangeOptions) {
		var treeConfig = {
				//minHeight: 50,
				rootVisible: false,
				containerScroll: true,
				autoScroll: true,
				cls:"simpleTree"
			}
		this.addOtherSettings(treeConfig, treeConfigOptions, null);
		//extraProxyParameters for getting the tree nodes
		if (CWHF.isNull(extraProxyParameters)) {
			extraProxyParameters = new Object();
		}
		//project tree is with check boxes (project picker isn't but they use the same struts action)
		extraProxyParameters["useChecked"] = true;
		//to set the checked field on the server side and send back in json nodes
		extraProxyParameters["projectIDs"] = projectIDs;
		return Ext.create("com.trackplus.util.ProjectTree",
				{selectedIDs: projectIDs,//initialize the hidden field
				itemId: itemId,
				extraProxyParameters: extraProxyParameters,
				hiddenFieldName: hiddenFieldName,
				treeConfig: treeConfig,
				selectionChangeOptions:selectionChangeOptions});
	},*/
	/**
	 * Creates a project picker
	 */
	/*createProjectPicker: function(labelKey, name, otherSettings, listenerConfig) {
		var label = this.getLabel(labelKey, otherSettings);
		var projectPickerConfig = {
			//xtype: 'textfield',
			fieldLabel : label,
			name: name,
			itemId: name,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		if (listenerConfig) {
			projectPickerConfig.listeners = listenerConfig;
		}
		this.addOtherSettings(projectPickerConfig, otherSettings, label);
		return Ext.create("com.trackplus.util.ProjectPicker", projectPickerConfig);
	}, */
	/*createProjectPickerWithHelp: function(labelKey, name, otherSettings) {
		var inputComp=this.createProjectPicker(labelKey, name, otherSettings)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},*/
	/**
	 * Creates a multiple select release tree
	 */
	/*createReleaseTree: function(releaseIDs, extraProxyParameters,
			hiddenFieldName, treeConfigOptions, itemId) {
		var treeConfig = {
				rootVisible: false,
				containerScroll: true,
				autoScroll: true,
				cls:"simpleTree"
			}
		this.addOtherSettings(treeConfig, treeConfigOptions, null);
		//extraProxyParameters for getting the tree nodes
		if (CWHF.isNull(extraProxyParameters)) {
			extraProxyParameters = new Object();
		}
		//project tree is with check boxes (project picker isn't but they use the same struts action)
		extraProxyParameters["useChecked"] = true;
		//to set the checked field on the server side and send back in json nodes
		extraProxyParameters["releaseIDs"] = releaseIDs;
		return Ext.create("com.trackplus.util.ReleaseTree",
				{releaseIDs: releaseIDs,
				itemId: itemId,
				extraProxyParameters: extraProxyParameters,
				hiddenFieldName: hiddenFieldName,
				treeConfig: treeConfig});
	},*/
	/*createReleasePicker: function(labelKey, name, otherSettings, listenerConfig) {
		var label = this.getLabel(labelKey, otherSettings);
		var releasePickerConfig = {
			fieldLabel : label,
			name: name,
			itemId: name,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		if (listenerConfig) {
			releasePickerConfig.listeners = listenerConfig;
		}
		this.addOtherSettings(releasePickerConfig, otherSettings, label);
		return Ext.create('com.trackplus.util.ReleasePicker', releasePickerConfig);
	},*/
	/**
	 * Create a department picker
	 */
	/*createDepartmentPicker: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var departmentPickerConfig = {
			xtype: 'textfield',
			fieldLabel : label,
			name: name,
			itemId: name,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		this.addOtherSettings(departmentPickerConfig, otherSettings, label);
		return Ext.create('com.trackplus.util.DepartmentPicker', departmentPickerConfig);
	},*/
	/*createDepartmentPickerWithHelp: function(labelKey, name, otherSettings) {
		var inputComp=this.createDepartmentPicker(labelKey, name, otherSettings)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},*/
	/**
	 * Creates a multiple select department tree
	 */
	/*createDepartmentTree: function(departmentIDs, extraProxyParameters,
			hiddenFieldName, treeConfigOptions, itemId, selectionChangeOptions) {
		var treeConfig = {
				rootVisible: false,
				containerScroll: true,
				autoScroll: true,
				cls:"simpleTree"
			}
		this.addOtherSettings(treeConfig, treeConfigOptions, null);
		//extraProxyParameters for getting the tree nodes
		if (CWHF.isNull(extraProxyParameters)) {
			extraProxyParameters = new Object();
		}
		//project tree is with check boxes (project picker isn't but they use the same struts action)
		extraProxyParameters["useChecked"] = true;
		//to set the checked field on the server side and send back in json nodes
		extraProxyParameters["departmentIDs"] = departmentIDs;
		return Ext.create("com.trackplus.util.DepartmentTree",
				{selectedIDs: departmentIDs,//initialize the hidden field
				extraProxyParameters: extraProxyParameters,
				hiddenFieldName: hiddenFieldName,
				treeConfig: treeConfig,
				itemId: itemId,
				selectionChangeOptions:selectionChangeOptions});
	},*/
	getTreeWithLabel: function(label, tree, treeWithLabelID, labelWidth, labelAlign) {
		if (CWHF.isNull(labelWidth)) {
			labelWidth=150;
		}
		if (CWHF.isNull(labelAlign)) {
			labelAlign='right';
		}
		if (CWHF.isNull(label)){
			return tree;
		}
		tree.flex=1;
		var labelCmp = this.getLabelCmp(label, labelAlign, labelWidth);
		return this.wrapLabelAndTree(labelCmp,tree,treeWithLabelID);
	},
	getLabelCmp: function(label, labelAlign, labelWidth) {
		return Ext.create('Ext.Component',{
			cls:labelAlign==='right'?'x-form-item-label-right x-form-item-label':'x-form-item-label',
			style:{
				marginRight:'5px'
			},
			html:label+":",
			width:labelWidth
		});
	},
	wrapLabelAndTree: function(labelCmp, treeObject,treeWithLabelID) {
		return Ext.create('Ext.container.Container', {
			itemId: treeWithLabelID,
			border:false,
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			items: [labelCmp, treeObject]
		});
	},
	/**
	 * Create a department picker
	 */
	createColorPicker: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var colorPickerConfig = {
			xtype: 'textfield',
			fieldLabel : label,
			name: name,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		this.addOtherSettings(colorPickerConfig, otherSettings, label);
		return Ext.create('com.trackplus.util.ColorField', colorPickerConfig);
	},
	/**
	 * Create a number field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {Integer} decimalPrecision Number of digits after the decimal character
	 * @param {Number} minValue Minimum value
	 * @param {Number} maxValue Maximum value
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.field.Number} A number field
	 */
	createNumberField: function(labelKey, name, decimalPrecision, minValue, maxValue, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var numberFieldConfig = {
				xtype: 'numberfield',
				fieldLabel : label,
				hideLabel:(CWHF.isNull(labelKey)),
				msgTarget: 'under',
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth,
				decimalSeparator:com.trackplus.TrackplusConfig.DecimalSeparator
		};
		if (decimalPrecision) {
			numberFieldConfig.decimalPrecision = decimalPrecision;
		}
		if (minValue) {
			numberFieldConfig.minValue = minValue;
		}
		if (maxValue) {
			numberFieldConfig.maxValue = maxValue;
		}
		this.addOtherSettings(numberFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.Number', numberFieldConfig);
	},
	/**
	 * Create a number field component together with a help button and help area.The label will be localized.
	 * The help string will be looked up under resource string <code>'labelKey.help'</code>.
	 * If an <code>id</code> and/or <code>itemId</code> is given in <code>otherSettings</code>,
	 * it will be for used the field component. The associated help button then has this id,
	 * with the string <code>'.hlp'</code> appended. The enclosing panel has this id,
	 * with the string <code>'.wrp'</code> appended.
	 *
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {Integer} decimalPrecision Number of digits after the decimal character
	 * @param {Number} minValue Minimum value
	 * @param {Number} maxValue Maximum value
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.panel.Panel} A panel enclosing a number field, a help button, and a help area.
	 */
	createNumberFieldWithHelp: function(labelKey, name, decimalPrecision, minValue, maxValue, otherSettings, wrapperItemId) {
		var inputComp=this.createNumberField(labelKey, name, decimalPrecision, minValue, maxValue, otherSettings)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Create a time field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {String} format Format of the time, e.g., 'H:i'
	 * @param {String} altFormats Alternative formats
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.field.TimeField} A time field
	 */
	createDateField: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var dateFieldConfig = {
				xtype: 'datefield',
				fieldLabel : label,
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth,
				format: com.trackplus.TrackplusConfig.DateFormat,
				//the short format interpretable by struts2 (two year digit)
				submitFormat:com.trackplus.TrackplusConfig.DateSubmitFormat
				};
		this.addOtherSettings(dateFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.Date', dateFieldConfig);
	},
	/**
	 * Create a time field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {String} format Format of the time, e.g., 'H:i'
	 * @param {String} altFormats Alternative formats
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.field.TimeField} A time field
	 */
	createTimeField: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings)
		var timeFieldConfig = {
				xtype: 'timefield',
				fieldLabel : label,
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth,
				//format: com.trackplus.TrackplusConfig.TimeFormat
				format: com.trackplus.TrackplusConfig.TimeFormatNoSeconds
				};
		this.addOtherSettings(timeFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.Time', timeFieldConfig);
	},
	createTimeFieldWithHelp: function(labelKey, name, otherSettings, wrapperItemId) {
		var inputComp=this.createTimeField(labelKey, name, otherSettings)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Creates a field container for dateTime picker with a date and a time part
	 */
	createDateTimeField: function(labelKey, dateName, timeName, otherDateSettings, otherTimeSettings, fieldContainerSettings) {
		var label = this.getLabel(labelKey, otherDateSettings)
		var txtDate=CWHF.createDateField(null, dateName, otherDateSettings);
		var txtTime=CWHF.createTimeField(null, timeName, otherTimeSettings);
		var fieldContainerConfig = {
				xtype: 'fieldcontainer',
				fieldLabel : label,
				layout: 'hbox',
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				labelStyle:{overflow:'hidden'},
				items:[txtDate,txtTime]
		}
		this.addOtherSettings(fieldContainerConfig, fieldContainerSettings, label);
		return Ext.create('Ext.form.FieldContainer', fieldContainerConfig);
	},
	/**
	 * Create a text area field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.form.TextArea} A text area field.
	 */
	createTextAreaField: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var textAreaFieldConfig = {
				xtype: 'textareafield',
				fieldLabel : this.getLabel(labelKey, otherSettings),
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth
				};
		this.addOtherSettings(textAreaFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.TextArea', textAreaFieldConfig);
	},
	/**
	 * Create a text area field component together with a help button and help area.The label will be localized.
	 * The help string will be looked up under resource string <code>'labelKey.help'</code>.
	 * If an <code>id</code> and/or <code>itemId</code> is given in <code>otherSettings</code>,
	 * it will be for used the field component. The associated help button then has this id,
	 * with the string <code>'.hlp'</code> appended. The enclosing panel has this id,
	 * with the string <code>'.wrp'</code> appended.
	 *
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {Integer} decimalPrecision Number of digits after the decimal character
	 * @param {Number} minValue Minimum value
	 * @param {Number} maxValue Maximum value
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.panel.Panel} A panel enclosing a number field, a help button, and a help area.
	 */
	createTextAreaFieldWithHelp: function(labelKey, name, otherSettings, wrapperItemId) {
		var inputComp=this.createTextAreaField(labelKey, name, otherSettings)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,name,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Create a text area field component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.form.TextArea} A text area field.
	 */
	createHtmlEditorField: function(labelKey, name, otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var htmlEditorFieldConfig = {
				fieldLabel: label,
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				defaultValue:""
				//padding: '20 0 0 0',
				//anchor:'100% -27'
				};
		this.addOtherSettings(htmlEditorFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.HtmlEditor', htmlEditorFieldConfig);
	},
	txtRTEIndex:0,
	RTEInstanceReady:new Object(),
	createRichTextEditorField:function(name,otherSettings,focus,resize,ckeditorCfg){
		var me=this;
		var idRTE;
		me.txtRTEIndex++;
		idRTE="rte"+me.txtRTEIndex;
		var rteCfg={
			name:name,
			id:idRTE
		};
		this.addOtherSettings(rteCfg, otherSettings);
		var txtArea=Ext.create('Ext.form.field.TextArea',rteCfg);
		txtArea.addListener('afterrender',me.initRTEditor,me,{id:idRTE,focus:focus,resize:resize,ckeditorCfg:ckeditorCfg});
		return txtArea;
	},
	resizeRTEditor:function(cmp,width,height,oldWidth,oldHeight,opts){
		var me=this;
		var difW=width-oldWidth;
		var difH=height-oldHeight;
		var idDescription=opts.id+'-inputEl';
		var o=CKEDITOR.instances[idDescription];
		var isReady=me.RTEInstanceReady[opts.id]===true;
		var w=width;
		if(cmp.fieldLabel){
			w=w-cmp.labelWidth;
		}
		if (o&&isReady){
			o.resize( w, height);
		}
	},
	destroyRTEditor:function(comp,opts){
		var me=this;
		//var me=this;
		//alert(opts.id);
		var idDescription=opts.id+'-inputEl';
		//var toolbarFCKStartExpanded=true;
		//var resize=opts.resize;
		/*var sLang=null;
		if (CWHF.isNull(sLang)){
			sLang="en";
		}*/
		me.RTEInstanceReady[opts.id]=false;
		var o=CKEDITOR.instances[idDescription];
		if (o){
			CKEDITOR.remove(o);
			o.destroy();
		}
	},
	initRTEditor:function(comp, opts){
		var me=this;
		var idDescription=opts.id+'-inputEl';
		var toolbarFCKStartExpanded=true;
		var resize=opts.resize;
		var sLang=getLocale();
		if (CWHF.isNull(sLang)){
			sLang="en";
		}
		var o=CKEDITOR.instances[idDescription];
		if (o){
			me.RTEInstanceReady[opts.id]=false;
			CKEDITOR.remove(o);
		}
		if(comp&&comp.isDisabled()){
			return false;
		}
		var filebrowserImageBrowseUrl='';
		var filebrowserUploadUrl ='';// uploadUrl + '?Type=File';
		var filebrowserImageUploadUrl ='';// uploadUrl + '?Type=Image';
		var otherCkeditorCfg=opts.ckeditorCfg;
		var workItemID=null;
		var useInlineTask=false;
		var useBrowseImage=false;
		if(otherCkeditorCfg){
			useBrowseImage=otherCkeditorCfg.useBrowseImage;
			if(otherCkeditorCfg.workItemID) {
				workItemID = otherCkeditorCfg.workItemID;
			}
			if(useBrowseImage===true){
				filebrowserImageBrowseUrl = 'browseFile.action?type=Images';
				filebrowserUploadUrl = 'browseFile!uploadFile.action?Type=File';
				filebrowserImageUploadUrl = 'browseFile!uploadFile.action?Type=Image';
				if(workItemID!=null){
					filebrowserImageBrowseUrl+= '&workItemID=' + workItemID;
					filebrowserUploadUrl+= '&workItemID=' + workItemID;
					filebrowserImageUploadUrl+= '&workItemID=' + workItemID;
				}
			}
			useInlineTask=otherCkeditorCfg.useInlineTask;
		}
		var ckeditorCfg={
			customConfig:sBasePath+'cktrackplusconfig.js',
			contentsCss:com.trackplus.TrackplusConfig.htmlEditorCSS,
			filebrowserUploadUrl:filebrowserUploadUrl,
			filebrowserImageBrowseUrl:filebrowserImageBrowseUrl,
			filebrowserImageUploadUrl:filebrowserImageUploadUrl,
			simpleuploads_maxFileSize:com.trackplus.TrackplusConfig.MAXFILESIZE,
			language:sLang/*,
			 toolbarStartupExpanded:toolbarFCKStartExpanded*/
		};
		if(otherCkeditorCfg) {
			for (propertyName in otherCkeditorCfg) {
				ckeditorCfg[propertyName] = otherCkeditorCfg[propertyName];
			}
		}
		if(workItemID&&useInlineTask){
			var extraPlugins=ckeditorCfg['extraPlugins'];
			if(CWHF.isNull(extraPlugins)||extraPlugins===''){
				extraPlugins='issue,code,simpleuploads,image2,task';
			}else{
				extraPlugins=extraPlugins+",task";
			}
			ckeditorCfg['extraPlugins']=extraPlugins;
		}
		var ckEditor=CKEDITOR.replace(idDescription,ckeditorCfg);
		var focus=opts.focus;
		if(focus===true){
			ckEditor.on('instanceReady',function(evt) {
				ckEditor.focus();
			});
		}
		ckEditor.on('blur', function(e) {
			ckEditor.updateElement();
		});
		if(resize===true&&comp){
			comp.addListener('resize',me.resizeRTEditor,me,opts);
			ckEditor.on('instanceReady',function(evt) {
				me.RTEInstanceReady[opts.id]=true;
				var w=comp.getWidth();
				if(comp.fieldLabel){
					w=w-comp.labelWidth;
				}
				var h=comp.getHeight();
				ckEditor.resize(w,h);
			});
		}
		CKEDITOR.on('instanceReady', function(e) {
			var editor = e.editor;
			// When an upload starts
			editor.on('simpleuploads.startUpload', function (e) {
				//alert("Uploading " + e.data.name + ", please wait...");
			});
			// When the upload ends
			editor.on('simpleuploads.endUpload', function (e) {
				if (e.data.ok){
					//alert("File " + e.data.name + " uploaded correctly.");
				}
				else{
					alert("Upload of " + e.data.name + " has failed.");
				}
			})
			// When the upload has finished (the plugin has finished and the element is ready on the page
			editor.on( 'simpleuploads.finishedUpload' , function(ev) {
				var element = ev.data.element;
				var finishedUploadHandler=editor.config.finishedUploadHandler;
				if(finishedUploadHandler){
					finishedUploadHandler.call(editor,ev);
				}
				//element.addClass("picture");
			});
			editor.on('fileUploadResponse',function(ev){
				var finishedUploadHandler=editor.config.finishedUploadHandler;
				if(finishedUploadHandler){
					finishedUploadHandler.call(editor,ev);
				}
			});
		});
	},
	submitRTEditor:function(txtArea){
		var idDescription=txtArea.id+'-inputEl';
		var ckEditor=CKEDITOR.instances[idDescription];
		if (ckEditor){
			ckEditor.updateElement();
		}
	},
	refreshRTEditorValue:function(txtArea,value){
		txtArea.setValue(value);
		var idDescription=txtArea.id+'-inputEl';
		var o=CKEDITOR.instances[idDescription];
		if (o){
			o.setData( value, function() {
				this.checkDirty(); // true
			});
		}
	},
	/**
	 * Create a check box component. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @return {Ext.form.field.Checkbox} A checkbox component.
	 */
	createCheckbox: function(labelKey, name, otherSettings, listenerConfig) {
		var checkBoxConfig = {
				xtype: 'checkbox',
				inputValue : true,
				fieldLabel : this.getLabel(labelKey, otherSettings),
				//boxLabel : this.getLabel(labelKey, otherSettings),
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width:this.textFieldWidth
			};
		if (otherSettings && otherSettings.value) {
			checkBoxConfig.checked = otherSettings.value;
			delete otherSettings.value;
		}
		this.addOtherSettings(checkBoxConfig, otherSettings);
		if (listenerConfig) {
			checkBoxConfig.listeners = listenerConfig;
		}
		return Ext.create('Ext.form.field.Checkbox', checkBoxConfig);
	},
	/**
	 * Create a checkbox field component together with a help button and help area.The label will be localized.
	 * The help string will be looked up under resource string <code>'labelKey.help'</code>.
	 * If an <code>id</code> and/or <code>itemId</code> is given in <code>otherSettings</code>,
	 * it will be for used the field component. The associated help button then has this id,
	 * with the string <code>'.hlp'</code> appended. The enclosing panel has this id,
	 * with the string <code>'.wrp'</code> appended.
	 *
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @return {Ext.panel.Panel} A panel enclosing a checkbox, a help button, and a help area.
	 */
	createCheckboxWithHelp: function(labelKey, name, otherSettings, listenerConfig, wrapperItemId) {
		var inputComp=this.createCheckbox(labelKey, name, otherSettings, listenerConfig)
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,name,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Create a combobox component. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @param {String} itemId The itemId for the inner component.
	 * @return {Ext.form.field.Checkbox} A combobox component.
	*/
	createCombo: function(labelKey, name, otherSettings, listenerConfig/*, itemId*/) {
		var data = [];
		var includeEmpty=false;
		if (otherSettings && otherSettings.data) {
			data = otherSettings.data;
			delete otherSettings.data;
		}
		if (otherSettings && otherSettings.includeEmpty) {
			includeEmpty = otherSettings.includeEmpty;
			delete otherSettings.includeEmpty;
		}
		var idType = 'int';
		if (otherSettings && otherSettings.idType) {
			idType = otherSettings.idType;
			delete otherSettings.idType;
		}
		var displayField='label';
		if (otherSettings && otherSettings.displayField) {
			displayField = otherSettings.displayField;
		}
		var label = this.getLabel(labelKey, otherSettings);
		var comboConfig = {
			xtype	: 'combo',
			store	: Ext.create('Ext.data.Store', {
				data	: data,
				fields	: [{name:'id', type:idType, useNull:true}, {name:'label', type:'string'}],
				autoLoad: false
				}),
			displayField: 'label',
			valueField	: 'id',
			queryMode	: 'local',
			triggerAction: 'all',
			name:	name,
			editable: false,
			fieldLabel : label,
			labelStyle:{overflow:'hidden'},
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			width:this.textFieldWidth
		};
		if(includeEmpty===true){
			comboConfig.tpl= new Ext.XTemplate('<tpl for=".">' + '<li style="min-height:22px;" class="x-boundlist-item" role="option">' + '{'+displayField+'}' + '</li></tpl>');
		}
		if (listenerConfig) {
			comboConfig.listeners = listenerConfig;
		}
		this.addOtherSettings(comboConfig, otherSettings, label);
		return Ext.create('Ext.form.field.ComboBox', comboConfig);
	},
	/**
	 * Create a combobox field component together with a help button and help area.The label will be localized.
	 * The help string will be looked up under resource string <code>'labelKey.help'</code>.
	 * If an <code>id</code> and/or <code>itemId</code> is given in <code>otherSettings</code>,
	 * it will be for used the field component. The associated help button then has this id,
	 * with the string <code>'.hlp'</code> appended. The enclosing panel has this id,
	 * with the string <code>'.wrp'</code> appended.
	 *
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the inner component.
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @param {String} itemId The itemId for the inner component.
	 * @return {Ext.panel.Panel} A panel enclosing a combobox, a help button, and a help area.
	 */
	createComboWithHelp: function(labelKey, name, otherSettings, listenerConfig, wrapperItemId) {
		var inputComp=this.createCombo(labelKey, name, otherSettings, listenerConfig);
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,itemId,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Create a multiselect component. There is no label.
	 * @param {String} itemId The itemId of this component
	 * @param {String} name The field name of the inner component.
	 * @param {Boolean} modifiable If the selection list can be modified
	 * @param {JSONString} data The data for this component.
	 * @param {String} value The current value.
	 * @param {String} width The width of the box.
	 * @param {String} height The height of the box.
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @return {Ext.ux.form.MultiSelect} A multiselect component.
	*/
	createMultiSelect: function(labelKey, name, otherSettings, listenerConfig) {
		var data = [];
		if (otherSettings) {
			if (otherSettings.data) {
				data = otherSettings.data;
				delete otherSettings.data;
			}
			var idType = 'int';
			if (otherSettings.idType) {
				idType = otherSettings.idType;
				delete otherSettings.idType;
			}
			var fieldLabel = '';
			if (otherSettings.fieldLabel) {
				fieldLabel = this.getLabel(otherSettings.fieldLabel, otherSettings);
				delete otherSettings.fieldLabel;
			}
		}
		var multiSelectConfig = {
				xtype: 'multiselect',
				listTitle: this.getLabel(labelKey, otherSettings),
				fieldLabel: fieldLabel,
				store: Ext.create('Ext.data.Store', {
					data	: data,
					fields	: [{name:'id', type:idType}, {name:'label', type:'string'}],
					autoLoad: false
					}),
				displayField: 'label',
				valueField: 'id',
				labelAlign:this.alignR,
				name: name
		};
		if (listenerConfig) {
			multiSelectConfig.listeners = listenerConfig;
		}
//		if (itemId) {
//			multiSelectConfig.itemId=itemId;
//		}
		if (otherSettings) {
			for (property in otherSettings) {
				multiSelectConfig[property] = otherSettings[property];
			}
		}
		return Ext.create('Ext.ux.form.MultiSelect', multiSelectConfig);
	},
	/**
	 * Create a multiselect component with help. There is no label.
	 * @param {String} itemId The itemId of this component
	 * @param {String} name The field name of the inner component.
	 * @param {Boolean} modifiable If the selection list can be modified
	 * @param {JSONString} data The data for this component.
	 * @param {String} value The current value.
	 * @param {String} width The width of the box.
	 * @param {String} height The height of the box.
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @return {Ext.ux.form.MultiSelect} A multiselect component.
	 */
	/*createMultiSelectWithHelp: function(itemId, name, modifiable, data, value, width, height, listenerConfig, wrapperItemId) {
		var inputComp=this.createMultiSelect(itemId, name, modifiable, data, value, width, height, listenerConfig);
		var helpStr = getText(itemId+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,name,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},*/
	/**
	 * Create a radiogroup component. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} itemdId The itemId of the inner component.
	 * @param {Number} width The width of the group
	 * @param {Array} items The items of the radio group
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @param {String} itemId The itemId for the inner component.
	 * @return {Ext.form.RadioGroup} A radio group component.
	*/
	getRadioGroup:function(labelKey, width, items, otherSettings, listenerConfig) {
		var radioGroupConfig = {
				xtype	: 'radiogroup',
				layout: 'hbox',
				defaults : {margin:"0 5 0 0"},
				labelStyle:{overflow:'hidden'},
				//labelWidth:this.labelWidth,
				labelAlign:this.alignR,
				width: width
				//disabled: !modifiable
			}
		if (CWHF.isNull(items)) {
			items = [];
		}
		radioGroupConfig.items = items;
		if (listenerConfig) {
			radioGroupConfig.listeners = listenerConfig;
		}
		if (CWHF.isNull(labelKey)) {
			radioGroupConfig.fieldLabel = '';
			radioGroupConfig.labelSeparator = '';
			radioGroupConfig.labelWidth = 0;
		} else {
			radioGroupConfig.fieldLabel = this.getLabel(labelKey, otherSettings);
			radioGroupConfig.labelWidth = this.labelWidth;
		}
		this.addOtherSettings(radioGroupConfig, otherSettings);
		return Ext.create('Ext.form.RadioGroup', radioGroupConfig);
	},
	/**
	 * Create a radiogroup component with help. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} itemdId The itemId of the inner component.
	 * @param {Number} width The width of the group
	 * @param {Array} items The items of the radio group
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	 * @param {String} itemId The itemId for the inner component.
	 * @return {Ext.form.RadioGroup} A radio group component.
	*/
	getRadioGroupWithHelp:function(labelKey, width, items, otherSettings, listenerConfig, wrapperItemId) {
		var inputComp=this.getRadioGroup(labelKey, width, items, otherSettings, listenerConfig);
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,itemId,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	/**
	 * Add radio buttons to radio group
	 */
	getRadioButtonItems: function(list,
			commonName, id, label, checkedValue, disabled, labelIsLocalized) {
		var radioButtons = [];
		Ext.Array.each(list, function(listEntry) {
			radioButtons.push({
				name:commonName,
				inputValue: listEntry[id],
				boxLabel: this.getLabel(listEntry[label], {labelIsLocalized:labelIsLocalized}),
				checked: listEntry[id]===checkedValue,
				disabled: disabled
			});
		}, this);
		return radioButtons;
	},
	/**
	 * Gets the value of the selecetd radio button
	 */
	getSelectedRadioButtonValue:function(radioButtonGroup) {
		var checkedArr = radioButtonGroup.getChecked();
		var checkedRadioValue = null;
		if (checkedArr.length>0) {
			checkedRadio = checkedArr[0];
			if (checkedRadio) {
				checkedRadioValue = checkedRadio.getSubmitValue();
			}
		}
		return checkedRadioValue;
	},
	/**
	 * Create a localized label component.
	 * The resource help key is derived from the standard label key plus ".help".
	 * @param {String} fieldLabelKey The label key for this field, used for localization
	 * @param {Object} value the currently selected value
	 * @return {Object} The localized label component
	 */
	createLabelComponent:function(fieldLabelKey, name, otherSettings){
		var me=this;
		var label = this.getLabel(fieldLabelKey, otherSettings);
		var labelComp={
				xtype:'displayfield',
				fieldLabel:label,
				name: name,
				labelStyle:{overflow:'hidden'},
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				fieldStyle : {
					height:'auto'
				}
		};
		this.addOtherSettings(labelComp, otherSettings);
		return labelComp;
	},
	/**
	 * Create a file upload component with proper sizing. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name of the component.
	 * @param {String} otherSettings Any other configuration parameters, e.g., <code>{width:'200px', id:'myId'}</code>.
	 * @return {Ext.form.field.File} A file upload field
	 */
	createFileField: function(labelKey, name, otherSettings, listenerConfig) {
		var label = this.getLabel(labelKey, otherSettings);
		var fileFieldConfig = {
				xtype: 'filefield',
				fieldLabel : label,
				name: name,
				buttonText: getText("common.btn.browse"),
				labelWidth:this.labelWidth,
				labelAlign:this.alignR};
		if (listenerConfig) {
			fileFieldConfig.listeners = listenerConfig;
		}
		this.addOtherSettings(fileFieldConfig, otherSettings, label);
		return Ext.create('Ext.form.field.File', fileFieldConfig);
	},
	/**
	 * Create a multiple select combobox like component. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name
	 * @param {array} data The data source
	 * @param {array} valus The selected values
	 * @param {JSONString} iconSettings settings for getting the icons dynamically
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	*/
	createMultipleSelectPicker: function(labelKey, name, data, value, /*iconSettings,*/ otherSettings) {
		var label = this.getLabel(labelKey, otherSettings);
		var multipleSelectPickerConfig = {
				localizedLabel:label,
				name:name,
				options:data,
				value: value,
				width:200,
				margin:'0 5 0 0',
				useRemoveBtn:true
				}
		/*if (iconSettings) {
			var iconUrl = iconSettings.iconUrl;
			if (iconUrl) {
				//exclude from properties
				delete iconSettings.iconUrl;
				var valueName = iconSettings.valueName;
				if (valueName) {
					//exclude from for cycle
					delete iconSettings.valueName;
				}
				var parameterSeparator = "?";
				for (propertyName in iconSettings) {
					var propertyValue = iconSettings[propertyName];
					if (propertyValue) {
						iconUrl = iconUrl + parameterSeparator + propertyName + "=" + propertyValue;
						parameterSeparator = "&";
					}
				}
				if (valueName) {
					iconUrl = iconUrl + parameterSeparator + valueName + "="
				}
				multipleSelectPickerConfig.iconUrlPrefix = iconUrl;
			}
		}*/
		this.addOtherSettings(multipleSelectPickerConfig, otherSettings, label);
		/*if (listenerConfig) {
			multipleSelectPickerConfig.listeners = listenerConfig;
		}*/
		return Ext.create('com.trackplus.util.MultipleSelectPicker', multipleSelectPickerConfig);
	},
    /**
     * Create a single selectable tree like component. The label will be localized.
     * @param {String} labelKey The resource key for the label.
     * @param {String} name The field name
     * @param {array} data The data source
     * @param  value The selected value
     * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
     * @param {JSONString} listenerConfig The associated listeners for this component
     */
    createSingleTreePicker: function(labelKey, name, data, value, otherSettings, listenerConfig) {
        var label = this.getLabel(labelKey, otherSettings);
        var singleSelectPickerConfig = {
            fieldLabel:label,
            name:name,
            options:data,
            value: value,
            width:200,
            margin:'0 5 0 0',
            labelAlign:this.alignR,
            useRemoveBtn:false
        }
        this.addOtherSettings(singleSelectPickerConfig, otherSettings, label);
        if (listenerConfig) {
            singleSelectPickerConfig.listeners = listenerConfig;
        }
        return Ext.create('com.trackplus.util.SingleTreePicker', singleSelectPickerConfig);
    },
    /**
     * Create a single selectable tree like component. The label will be localized.
     * @param {String} labelKey The resource key for the label.
     * @param {String} name The field name
     * @param {array} data The data source
     * @param  value The selected value
     * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
     * @param {JSONString} listenerConfig The associated listeners for this component
     */
    createSingleTreePickerWithHelp: function(labelKey, name, data, value, otherSettings, listenerConfig) {
        var inputComp=this.createSingleTreePicker(labelKey, name, data, value, otherSettings, listenerConfig)
        var helpStr = getText(labelKey+'.help');
        if(CWHF.isNull(helpStr)){
            return inputComp;
        }
        wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
        return Ext.create("com.trackplus.util.HelpWrapperComponent",
            {inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId/*, flexInputComp:true*/});
    },
	/**
	 * Create a multiple selectable tree like component. The label will be localized.
	 * @param {String} labelKey The resource key for the label.
	 * @param {String} name The field name
	 * @param {array} data The data source
	 * @param {array} valus The selected values
	 * @param {JSONString} iconSettings settings for getting the icons dynamically
	 * @param {JSONString} otherSettings Any other configuration parameters, e.g., {width:'200px', id:'myId'}
	 * @param {JSONString} listenerConfig The associated listeners for this component
	*/
	createMultipleTreePicker: function(labelKey, name, data, value, otherSettings, listenerConfig) {
		var label = this.getLabel(labelKey, otherSettings);
		var multipleSelectPickerConfig = {
                localizedLabel:label,
				name:name,
				options:data,
				value: value,
				width:200,
				margin:'0 5 0 0',
				useRemoveBtn:true
		};
        if (otherSettings && otherSettings.useNull) {
            multipleSelectPickerConfig.fieldLabel = label;
        }
		this.addOtherSettings(multipleSelectPickerConfig, otherSettings, label);
		if (listenerConfig) {
			multipleSelectPickerConfig.listeners = listenerConfig;
		}
		return Ext.create('com.trackplus.util.MultipleTreePicker', multipleSelectPickerConfig);
	},
	createMultipleTreePickerWithHelp: function(labelKey, name, data, value, otherSettings, listenerConfig, wrapperItemId) {
		var inputComp=this.createMultipleTreePicker(labelKey, name, data, value, otherSettings, listenerConfig);
		var helpStr = getText(labelKey+'.help');
		if(CWHF.isNull(helpStr)){
			return inputComp;
		}
		//return this.createWrapperHelp(inputComp,itemId,helpStr,otherSettings);
		if (CWHF.isNull(wrapperItemId)) {
			wrapperItemId = this.getWrapperItemId(inputComp.getItemId());
		}
		return Ext.create("com.trackplus.util.HelpWrapperComponent",
				{inputComp:inputComp, helpStr:helpStr, itemId: wrapperItemId});
	},
	isNull: function(variable) {
		if( typeof variable === 'undefined' || variable === null ){
			return true;
		}
		return false;
	},
	/**
	 * Creates a selectControl and possibly
	 */
	/*createSelectPanel: function(scope, selectPanelItems, selectControl, panelID ,title, controlIsTree,
			changeHandler, changeHandlerScope) {
		return Ext.create("Ext.panel.Panel", {
			itemId: panelID,
			border:	true,
			bodyBorder:false,
			bodyStyle:{
				border:'medium none'
			},
			margin:"0 5 0 0",
			//title: title,
			cls:'selectPanelWrp',
			//height: selectControl.height,
			//width: selectControl.width,
			tools: [{type: 'plus',
					scope: scope,
					tooltip: getText('common.btn.all'),
					handler: function(event, toolElement, owner, tool) {
						if (selectControl) {
							if (CWHF.isNull(controlIsTree) || !controlIsTree) {
								var store = selectControl.store;
								var values = [];
								store.each(function(record) {
									values.push(record.get("id"));
								});
								selectControl.setValue(values);
							} else {
								var rootNode = selectControl.getRootNode();
								rootNode.cascadeBy(function(currentNode) {
									if (currentNode.get('checked')) {
										currentNode.set('checked', true);
									}
								}, scope);
								if (changeHandler) {
									changeHandler.call(changeHandlerScope);
								}
							}
						}
					}
					},{
					type: 'minus',
					scope: scope,
					tooltip: getText('common.btn.reset'),
					handler: function(event, toolElement, owner, tool) {
						if (selectControl) {
							//although clearing the value triggers the selectProject method it will not go to the server because newValue is empty...
							if (CWHF.isNull(controlIsTree) || !controlIsTree) {
								if (selectControl.getValue() && selectControl.getValue().length!==0) {
									selectControl.clearValue();
								}
							} else {
								var rootNode = selectControl.getRootNode();
								rootNode.cascadeBy(function(currentNode) {
									if (currentNode.get('checked')) {
										currentNode.set('checked',  false);
									}
								}, scope);
								if (changeHandler) {
									changeHandler.call(changeHandlerScope);
								}
							}
						}
					}
				}],
			items: selectPanelItems
		})
	},*/
	msgCt:null,
	showMsgInfo: function(msg, isTopDownDirection){
		this.showMsg(msg,'info', isTopDownDirection);
	},
	showMsgError: function(msg){
		this.showMsg(msg,'error');
	},
	showMsg: function(msg,cls,isTopDownDirection){
		var divID = "msg-div";
		if(isTopDownDirection && isTopDownDirection!==undefined) {
			if(isTopDownDirection) {
				divID = "msg-div";
			}else {
				divID = "msg-div-bottom";
			}
		}
		if (!this.msgCt) {
			this.msgCt = Ext.DomHelper.insertFirst(document.body, {id: divID}, true);
		}else{
			if(this.msgCt.id !== divID) {
				this.msgCt.remove();
				this.msgCt = Ext.DomHelper.insertFirst(document.body, {id: divID}, true);
			}
		}
		var zIndex=null;
		var active=Ext.WindowManager.getActive();
		if(active){
			zIndex = parseInt(active.el.getStyle('zIndex'), 10);
		}
		if(zIndex){
			this.msgCt.setStyle('z-index',''+(zIndex+1));
		}
		var boxHtml='<div class="msg msg-'+cls+'"<p>' + msg + '</p></div>';
		var m = Ext.DomHelper.append(this.msgCt,boxHtml, true);
		m.hide();
		var direction = "t";
		if(isTopDownDirection && isTopDownDirection!==undefined) {
			if(!isTopDownDirection) {
				direction = "b";
			}
		}
		m.slideIn("t",{easing: 'ease', duration: 400}).ghost(direction, {delay: 3000, duration: 600, easing: 'ease', remove: true});
	},
	log1:function(text) {
		if(com.trackplus.TrackplusConfig.isDebugEnabled) {
			console.log(text);
		}
	},
	showDialogMsgWarning:function(title, message){
		Ext.Msg.show({
			title: title,
			message: message,
			buttonText:{'cancel':getText('common.btn.close')},
			buttons:Ext.Msg.CANCEL,
			icon: Ext.Msg.WARNING
		});
	}
},
/**
 * Global shortcut accessor for ControlWithHelpFactory
 */
function() {
	CWHF = this;
})

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('util.Upload',{
	extend:'Ext.Base',
	singleton:true,
	constructor: function(config) {
	},
	validateUpload: function(submit) {
		var theForm = this.formEdit.getForm();
		if (!theForm.isValid()) {
			Ext.MessageBox.show({
				title: getText("common.lbl.import"),
				msg: getText("common.err.fileNotSpecified"),
			    buttons: Ext.Msg.OK,
			    icon: Ext.MessageBox.ERROR
			});
			return false;
		}
		var uploadFile = this.formEdit.getComponent("uploadFile");
		var expectedFileType = submit.expectedFileType;
		if (expectedFileType) {
			if (!expectedFileType.test(uploadFile.getRawValue())) {
				Ext.MessageBox.alert(this.getTitle("common.lbl.import"),
					getText("common.err.fileExpectedType", submit.expectedFileType));
				return false;
			}
		}
	}
},
/**
 * Global shortcut accessor for upload util methods
 */
function() {
   Upload = this;
})

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.util.errorWin=null;
/**
 * Show an error messgae
 * params:
 * title:String
 * errorMessage:String
 */
com.trackplus.util.showErrorMessage=function(title,errorMessage){
	if(com.trackplus.util.errorWin){
		com.trackplus.util.errorWin.destroy();
	}
	var panel=new Ext.Panel({
		collapsible:false,
		region:'center',
		bodyBorder:true,
		border:false,
		layout:'fit',
		html:errorMessage
	});
	com.trackplus.util.errorWin = new Ext.Window({
		layout      : 'border',
		width       : 425,
		height      : 215,
		minWidth    : 425,
		closeAction :'hide',
		plain       : true,
		title       :title,
		modal       :true,
		items       :panel,
		autoScroll  :true,
		buttons: [
			{text : closeLabel,
				handler  : function(){
					com.trackplus.util.errorWin.hide();
				}
			}
		]
	});
	com.trackplus.util.errorWin.show();
};
com.trackplus.util.win=null;
com.trackplus.util.showHtmlDetail=function(title,htmlContent){
	if(com.trackplus.util.win){
		com.trackplus.util.win.destroy();
	}
	htmlDinamicContent=htmlContent;
	var htmlFrameWrapper='<div class="containerRow1" style="width:100%;height:100%;border:medium none;"><iframe allowtransparency="true" frameborder="0" width="100%" style="height:250px;background-color: transparent;"  '+
	'src="richTextPreview.action"></iframe></div>';
	var panel=new Ext.Panel({
		collapsible:false,
		autoWidth:true,
		autoHeight:true,
		bodyBorder:false,
		border:false,
		id:"panelContent",
		html:htmlFrameWrapper
	})
	com.trackplus.util.win = new Ext.Window({
		layout      : 'fit',
		width       : 550,
		height      : 350,
		closeAction :'hide',
		plain       : true,
		title       :title,
		modal       :true,
		items       :panel,
		autoScroll  :true,
		buttons: [{text : getText("common.btn.close"),
			handler  : function(){
				com.trackplus.util.win.hide();
			}
		}]
	});
	com.trackplus.util.win.show();
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.ColorField', {
		extend: 'Ext.form.field.Trigger',
		triggerTip: 'Please select a color.',
		onTriggerClick: function() {
		var me = this;
		picker = Ext.create('Ext.picker.Color', {
			//pickerField: this,
			ownerCt: this,
			renderTo: Ext.getBody(),//document.body,
			floating: true,
			hidden: true,
			focusOnShow: true,
			defaultAlign:"tl-bl?",
			style: {
					backgroundColor: "#fff"
				},
			listeners: {
					scope:this,
					select: function(field, value, opts){
						me.setValue(value);
						//me.inputEl.setStyle({backgroundColor:'#' + value});
						me.setFieldStyle('background-color:#'+value +'; background-image: none;');
						picker.hide();
					},
					show: function(field, opts){
						field.getEl().monitorMouseLeave(500, field.hide, field);
					}
					/*activate: function(field, opts) {
						me.setFieldStyle('background-color:#'+me.value +'; background-image: none;');
					}*/
			}
		});
		//picker.alignTo(me.inputEl/*, 'tl-bl?'*/);
		//picker.setWidth(me.inputEl.getWidth());
		picker.showBy(me.inputEl);
		}
	});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.AbstractMultiplePicker', {
    extend : 'Ext.form.field.Picker',
    config : {
        localizedLabel : '',
        options : null,
        value : null,
        store : null,
        displayField : 'label',
        valueField : 'id',
        includeClear : true,
        useNull : false,
        useTooltip : true,
        extraComponent : null,
        useRemoveBtn : false,
        removeHandler : null,
        pickerWidth : null,
        maxSelectionCount : null,
        includeSearch : true
    },
    displayValue : null,
    editable : false,
    tip : null,
    allText : getText('common.btn.all'),
    lblClearSelection : getText('common.lbl.clearSelectedItems'),
    lblSelectAll : getText('common.lbl.selectAll'),
    allItemSelected : false,
    initComponent : function() {
	    var me = this;
	    if (me.useNull === true) {
		    me.emptyText = null;
	    } else {
		    me.emptyText = me.localizedLabel + ":" + me.allText;
	    }
	    me.tooltip = me.emptyText;
	    if (me.useRemoveBtn === true) {
		    me.trigger2Cls = Ext.baseCSSPrefix + 'form-clear-trigger';
	    }
	    me.callParent(arguments);
	    if (CWHF.isNull(me.store)) {
		    me.store = me.createStore();
	    }
	    if (me.useTooltip) {
		    me.on('afterrender', me.updateTooltip, me);
	    }
    },
    onTrigger2Click : function() {
	    var me = this;
	    if (me.removeHandler  && Ext.isFunction(me.removeHandler)) {
		    me.removeHandler.call(me);
	    } else {
		    me.ownerCt.remove(me);
	    }
    },
    initEvents : function() {
	    var me = this;
	    me.callParent();
	    // if (me.includeSearch) {
	    me.mon(me.inputEl, 'keyup', me.onKeyUpHandler, me);
	    // }
    },
    onKeyUpHandler : function(e, t) {
	    var me = this;
	    var key = e.getKey();
	    if (!e.isSpecialKey()) {
		    if (!me.isExpanded) {
			    this.onTriggerClick();
			    if (me.includeSearch) {
				    var charCode = e.getCharCode();
				    var cc = String.fromCharCode(e.keyCode);
				    me.searchField.setValue(cc);
				    me.searchField.focus();
			    }
		    }
	    }
    },
    /* abstract */
    createStore : function() {
	    return null;
    },
    /* abstract */
    createBoundList : function() {
	    return null;
    },
    /* abstract */
    addBoundListListeners : function() {
    },
    /* abstract */
    syncSelection : function() {
    },
    clearOrSelectAll : function() {
	    var me = this;
	    if ((me.maxSelectionCount  && me.maxSelectionCount > 0) || me.allItemSelected === true) {
		    me.clearSelection();
	    } else {
		    me.selectAll();
	    }
    },
    selectAll : function() {
    },
    /* abstract */
    updateMyOptions : function(options) {
    },
    updateTooltip : function() {
	    var me = this;
	    if (me.useTooltip === true) {
		    if (me.tooltip ) {
			    me.setToolTip(me.tooltip);
		    }
	    }
    },
    createSearchField : function() {
	    var me = this;
	    var searchField = Ext.create('Ext.form.field.Text', {
	        emptyText : getText('common.btn.search') + ' ' + me.localizedLabel + "...",
	        cls : 'searchfield',
	        paramName : me.displayField,
	        width : CWHF.isNull(me.pickerWidth) ? me.inputEl.getWidth() - 5 : me.pickerWidth - 15,
	        margin : '5 15 5 5'
	    });
	    searchField.on('change', function(cmp, value) {
		    me.filter.call(me, value);
	    });
	    return searchField;
    },
    filter : function(value) {
	    var me = this;
	    if (value.length > 0) {
		    me.store.filter({
		        id : me.displayField,
		        property : me.displayField,
		        value : value
		    });
	    } else {
		    me.clearFilter();
	    }
    },
    clearFilter : function() {
	    var me = this;
	    me.store.clearFilter();
    },
    getClearSelectionLabel : function() {
	    var me = this;
	    if (me.maxSelectionCount  && me.maxSelectionCount > 0) {
		    var count = me.getSelectedItemsCount();
		    return me.lblClearSelection + " (" + count + ' from ' + me.maxSelectionCount + ')';
	    }
	    return me.allItemSelected === true ? me.lblClearSelection : me.lblSelectAll;
    },
    createPicker : function() {
	    var me = this;
	    me.boundList = me.createBoundList();
	    var label;
	    me.linkClearSelection = Ext.create('Ext.ux.LinkComponent', {
	        handler : me.clearOrSelectAll,
	        clsLink : 'link_blue',
	        margin : '2 5 7 5',
	        scope : me,
	        label : me.getClearSelectionLabel()
	    });
	    var items = new Array();
	    if (me.extraComponent ) {
		    items.push(me.extraComponent);
	    }
	    if (me.includeSearch === true) {
		    me.searchField = me.createSearchField();
		    items.push(me.searchField);
	    }
	    if (me.includeClear === true) {
		    items.push(me.linkClearSelection);
	    }
	    items.push(me.boundList);
	    me.picker = Ext.create('Ext.panel.Panel', {
	        hidden : true,
	        floating : true,
	        width : me.pickerWidth,
	        items : items
	    });
	    me.addBoundListListeners();
	    return me.picker;
    },
    onListRefresh : function() {
	    var me = this;
	    me.setValue(me.getValue(), true);
    },
    selectionChange : function(selectedRecords) {
	    var me = this;
	    var hasRecords = selectedRecords.length > 0;
	    if (me.isExpanded) {
		    me.setValue(selectedRecords, false);
	    }
    },
    getDisplayValue : function() {
	    return this.displayValue;
    },
    getSelectableItemsCount : function() {
	    var me = this;
	    if (CWHF.isNull(me.store)) {
		    me.store = me.createStore();
	    }
	    var items = me.store.getRange();
	    return items.length;
    },
    getSelectedItemsCount : function() {
	    return 0;
    },
    findRecord : function(field, value) {
	    var me = this;
	    if (CWHF.isNull(me.store)) {
		    me.store = me.createStore();
	    }
	    var ds = this.store, idx = ds.findExact(field, value);
	    return idx !== -1 ? ds.getAt(idx) : false;
    },
    findRecordByValue : function(value) {
	    return this.findRecord(this.valueField, value);
    },
    getRecordDisplayValue : function(record) {
	    var me = this;
	    return record.get(me.displayField)
    },
    getRecordValue : function(record) {
	    var me = this;
	    return record.get(me.valueField)
    },
    setValue : function(value, doSelect) {
	    var me = this;
	    var processedValue = new Array();
	    var displayData = new Array();
	    me.valueModels = new Array();
	    if (CWHF.isNull(value) || value === '') {
		    me.value = null;
		    me.displayValue = null;
	    } else {
		    value = Ext.Array.from(value);
		    var record;
		    for (i = 0, len = value.length; i < len; i++) {
			    record = value[i];
			    if (!record || !record.isModel) {
				    record = me.findRecordByValue(record);
			    }
			    // record found, select it.
			    if (record) {
				    me.valueModels.push(record);
				    displayData.push(me.getRecordDisplayValue(record));
				    processedValue.push(me.getRecordValue(record));
			    }
		    }
		    if (processedValue.length > 0) {
			    me.value = processedValue;
			    me.displayValue = displayData.join(', ');
		    } else {
			    me.value = null;
			    me.displayValue = null;
		    }
	    }
	    if (doSelect !== false) {
		    me.syncSelection();
	    }
	    var tooltipBegin = "";
	    if (me.localizedLabel  && me.localizedLabel !== "") {
		    tooltipBegin = me.localizedLabel + ":";
	    }
	    if (CWHF.isNull(me.value)) {
		    me.tooltip = tooltipBegin + me.allText;
		    me.allItemSelected = false;
	    } else {
		    me.tooltip = tooltipBegin + me.displayValue;
		    var count = me.getSelectableItemsCount();
		    if (count === me.value.length) {
			    me.allItemSelected = true;
		    } else {
			    me.allItemSelected = false;
		    }
	    }
	    if (me.linkClearSelection ) {
		    var oldLabel = me.linkClearSelection.getMyLabel();
		    var newLabel = me.getClearSelectionLabel();// me.allItemSelected===true?me.lblClearSelection:me.lblSelectAll;
		    if (oldLabel !== newLabel) {
			    me.linkClearSelection.suspendLayout = true;
			    me.linkClearSelection.setLabel(newLabel);
			    me.linkClearSelection.suspendLayout = false;
		    }
	    }
	    me.updateTooltip();
	    me.setRawValue(me.getDisplayValue());
	    me.checkChange();
	    me.applyEmptyText();
	    return me;
    },
    clearSelection : function() {
	    var me = this;
	    if (me.boundList ) {
		    me.boundList.getSelectionModel().deselectAll(true);
	    }
	    me.setValue(null);
    },
    getSubmitValue : function() {
	    var value = this.getValue();
	    if (value ) {
		    value = value.join();
	    }
	    return value;
    },
    getValue : function() {
	    return this.value;
    },
    setToolTip : function(str) {
	    var me = this;
	    if (CWHF.isNull(str)) {
		    if (CWHF.isNull(me.tip)) {
			    me.tip.destroy();
			    delete me.tip;
		    }
		    return;
	    }
	    var domEl = me.getEl();
	    if (domEl ) {
		    if (CWHF.isNull(me.tip)) {
			    me.tip = Ext.create('Ext.tip.ToolTip', {
			        target : domEl,
			        html : str
			    });
		    } else {
			    me.tip.update(str);
		    }
	    }
    }
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.MultipleSelectPicker',{
	extend:'com.trackplus.util.AbstractMultiplePicker',
	config:{
		multiSelect:true,
		iconUrlPrefix:null,
		useIconCls:false
	},
	displayField:'label',
	valueField:'id',
	ignoreSelection:0,
	createStore:function(){
		var me=this;
		return Ext.create('Ext.data.Store', {
				data	:(CWHF.isNull(me.getOptions())?[]:me.getOptions()),
				fields	: [{name:'id', type:'int',useNull:true}, {name:'label', type:'string'},{name:'icon', type:'string'},{name:'iconCls', type:'string'}],
				autoLoad: false
		});
	},
	updateMyOptions:function(options){
		var me=this;
		me.setOptions(options);
		if(me.store){
			me.store.loadData.call(me.store,options,false);
		}
	},
	createBoundList:function(){
		var me=this;
		var tpl='';
		if(me.getMultiSelect()===true){
			tpl+='<div class="x-combo-list-item"><img src="' + Ext.BLANK_IMAGE_URL + '" class="chkCombo-default-icon chkCombo" /> ';
		}
		var iconUrlPrefix =me.getIconUrlPrefix();
		var useIconCls=me.getUseIconCls();
		if(iconUrlPrefix){
			var urlStr=iconUrlPrefix+'{'+me.valueField+'}';
			tpl+='<img  style="width:16px;height:16px;vertical-align: bottom; margin-bottom: 2px;margin-right: 5px;" src="'+urlStr+'"/>';
		}else if(useIconCls){
			tpl+='<img  style="width:16px;height:16px;vertical-align: bottom; margin-bottom: 2px;margin-right: 5px;" src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="{iconCls}"/>';
		}
		tpl+='{'+ me.displayField+'} </div>';
		var listCfg = {
			xtype: 'boundlist',
			region:'center',
			autoScroll:true,
			border:false,
			selModel: {
				mode: me.multiSelect ? 'SIMPLE' : 'SINGLE'
			},
			store: me.store,
			displayField: me.displayField,
			focusOnToFront: false,
			pageSize: me.pageSize,
			getInnerTpl : function() {
				return tpl;
			},
			//minHeight:75,
			maxHeight: 200
		};
		return Ext.widget(listCfg);
	},
	getSelectedItemsCount:function(){
		var me=this;
		return me.boundList.getSelectionModel().getCount();
	},
	addBoundListListeners:function(){
		var me=this;
		me.boundList.getSelectionModel().on('beforeselect',me.onListBeforeSelect,me);
		me.boundList.getSelectionModel().on('selectionchange',me.onListSelectionChange,me);
		me.boundList.on('refresh',me.onListRefresh,me);
	},
	onListBeforeSelect:function(){
		var me=this;
		if(me.maxSelectionCount&&me.maxSelectionCount>0){
			var selectedIssues=me.getSelectedItemsCount();
			return selectedIssues<me.maxSelectionCount;
		}
		return true;
	},
	onListSelectionChange:function(list,records){
		this.selectionChange(records);
	},
	findRecord: function(field, value) {
		var me=this;
		if(CWHF.isNull(me.store)){
			me.store=me.createStore();
		}
		var ds = this.store,
			idx = ds.findExact(field, value);
		return idx !== -1 ? ds.getAt(idx) : false;
	},
	syncSelection: function() {
		var me = this,
			boundList = me.boundList,
			selection, selModel,
			values = me.valueModels || [],
			vLen  = values.length, v, value;
	  	if (boundList) {
			// From the value, find the Models that are in the store's current data
			selection = [];
			for (v = 0; v < vLen; v++) {
				value = values[v];
				if (value && value.isModel && me.store.indexOf(value) >= 0) {
					selection.push(value);
				}
			}
			// Update the selection to match
			me.ignoreSelection++;
			selModel = boundList.getSelectionModel();
			selModel.deselectAll();
			if (selection.length) {
				selModel.select(selection, false, true);
			}
			me.ignoreSelection--;
		}
	},
	clearSelection:function(){
		var me=this;
        if (me.boundList) {
		    me.boundList.getSelectionModel().deselectAll(true);
        }
		me.setValue(null);
	},
	selectAll:function(){
		var me=this;
		if (me.boundList) {
			me.boundList.getSelectionModel().selectAll();
		}
		//me.setValue(null);
	},
	filter:function(value){
		var me = this;
		if (Ext.isEmpty(value)) {
			me.clearFilter();
		}else{
			var matches = [];
			var property = me.displayField;
			var escapeRe      = Ext.String.escapeRegex;
			//value = '^' + escapeRe(value);
			value = escapeRe(value);
			var re=new RegExp(value, "ig");
			for(var i=0;i<me.store.getCount();i++){
				var item=me.store.getAt(i);
				var viewNode = Ext.fly(me.boundList.getNode(item));
				viewNode.setVisibilityMode(Ext.Element.DISPLAY);
				if(item.get(property).match(re)){
					viewNode.setVisible(true);
				}else{
					viewNode.setVisible(false);
				}
			}
		}
		me.picker.updateLayout();
	},
	clearFilter: function () {
		var me = this;
		for(var i=0;i<me.store.getCount();i++){
			var item=me.store.getAt(i);
			var viewNode = Ext.fly(me.boundList.getNode(item));
			viewNode.setVisibilityMode(Ext.Element.DISPLAY);
			viewNode.setVisible(true);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.SingleSelectPicker',{
	extend:'com.trackplus.util.MultipleSelectPicker',
	useNull:true,
	useTooltip:false,
	multiSelect:false,
	includeClear:false,
	onListSelectionChange:function(list,records){
		var me=this;
		if(me.ignoreSelection>0){
			return;
		}
		me.setValue(records,false);
		me.collapse();
	},
	clearSelection:function(){
		var me=this;
		me.callParent(arguments);
		me.collapse();
	},
	getSubmitValue: function() {
		return this.getValue();
	},
	getValue: function() {
		if(this.value){
			var value = Ext.Array.from(this.value);
			if(value.length>0) {
				return value[0];
			}
		}
		return null;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.util.MultipleTreePicker",{
	extend:"com.trackplus.util.AbstractMultiplePicker",
	displayField:'text',
	valueField:'id',
	createStore:function(){
		var me=this;
		var options=me.getOptions();
		return  Ext.create("Ext.data.TreeStore", {
			fields: [
				{name : "id", mapping : "id", type: "string"},
				{name : "text", mapping : "text", type: "string"},
				{name : "leaf", mapping : "leaf", type: "boolean"},
				{name : "iconCls", mapping : "iconCls", type: "string"},
				{name: "selectable", mapping: "selectable", type: "boolean", allowNull: true}
			],
			root: {
				expanded: true,
				children:(CWHF.isNull(options)?[]:options)
			},
			originalData:CWHF.isNull(options)?[]:options
		});
	},
	updateMyOptions:function(options){
		var me=this;
		var newOptions=Ext.clone(options);
		me.setOptions(newOptions);
		if(me.store){
			var rootNode=me.store.getRootNode();
			rootNode.removeAll(false);
			if(newOptions&&newOptions.length>0){
				rootNode.appendChild(newOptions);
			}
		}
	},
	createBoundList:function(){
		var treeConfig = {
			maxHeight: 200,
			height:200,
			store:this.store,
			rootVisible: false,
			containerScroll: true,
			autoScroll: true,
			cls:"simpleTree",
			border:false,
			//selModel : Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"}),
			plugins: [{
				ptype: 'treefilter',
				allowParentFolders: true
			}]
		};
		var tree= Ext.create("Ext.tree.Panel", treeConfig);
		return tree;
	},
	addBoundListListeners:function(){
		var me=this;
		me.boundList.addListener('checkchange',me.treeCheckChange,me);
		me.boundList.on('afterrender',me.onListRefresh,me);
		me.boundList.on('beforeselect',me.onBeforeselect,me);
	},
	findRecord: function(field, value) {
		var me=this;
		var store =me.getStore();
		if(CWHF.isNull(store)){
			store=me.createStore();
			me.setStore(store);
		}
		var nodeToSelect=store.getNodeById(value);
		if(nodeToSelect){
			return nodeToSelect;
		}else{
			return false;
		}
	},
	getRecordDisplayValue:function(record){
		return record.data.text;
	},
	getRecordValue:function(record){
		return record.data.id;
	},
	syncSelection: function() {
		var me = this;
		var values=new Array();
		if(me.valueModels){
			for(var i=0;i<me.valueModels.length;i++){
				values.push(me.getRecordValue(me.valueModels[i]));
			}
		}
		if(this.boundList){
			this.boundList.getRootNode().cascadeBy(function(){
				var checked=this.get('checked');
				if(!CWHF.isNull(checked)){
					this.set( 'checked', Ext.Array.contains(values, this.data.id));
				}
			});
		}
	},
	onBeforeselect:function(rowModel, record, index, eOpts){
		var me=this;
		var selectable=record.data['selectable'];
		if(selectable===false){
			return false;
		}
		return true;
	},
	treeCheckChange: function(node, checked, options) {
		var me=this;
		var records = this.boundList.getView().getChecked();
		me.selectionChange(records);
	},
	selectAll:function(){
		var me=this;
		var value=new Array();
		if (me.boundList) {
			this.boundList.getRootNode().cascadeBy(function(){
				if(this.get('checked')!==undefined){
					this.set( 'checked', true);
					value.push(this);
				}
			});
			this.boundList.expandAll();
		}
		me.setValue(value);
	},
	getSelectableItemsCount:function(){
		var me=this;
		var count=0;
		if (me.boundList) {
			this.boundList.getRootNode().cascadeBy(function(){
				if(this.get('checked')!==undefined){
					count++;
				}
			});
		}
		return count;
	},
	clearSelection:function(){
		var me=this;
        if (me.boundList) {
            this.boundList.getRootNode().cascadeBy(function(){
                if(this.get('checked')!==undefined){
                    this.set( 'checked', false );
                }
            });
        }
		me.setValue(null);
        if (me.searchField) {
		    me.searchField.setValue(null);
        }
	},
	filter : function(value){
		var me = this;
		if (value.length > 0) {
			me.boundList.filter(value);
		}else{
			me.clearFilter();
		}
	},
	clearFilter:function(){
		var me=this;
		me.boundList.clearFilter();
	}
});
Ext.define('TreeFilter', {
	extend: 'Ext.AbstractPlugin'
	, alias: 'plugin.treefilter'
	, collapseOnClear: true                                                 // collapse all nodes when clearing/resetting the filter
	, allowParentFolders: false                                             // allow nodes not designated as 'leaf' (and their child items) to  be matched by the filter
	, init: function (tree) {
		var me = this;
		me.tree = tree;
		tree.filter = Ext.Function.bind(me.filter, me);
		tree.clearFilter = Ext.Function.bind(me.clearFilter, me);
	},
	filter: function (value, property, re) {
		var me = this;
		if (Ext.isEmpty(value)) {                                           // if the search field is empty
			me.clearFilter();
			return;
		}
		var escapeRe      = Ext.String.escapeRegex;
		//value = '^' + escapeRe(value);//start with
		value = escapeRe(value);
		var tree = me.tree
			, matches = []                                                  // array of nodes matching the search criteria
			, root = tree.getRootNode()                                     // root node of the tree
			, property = property || 'text'                                 // property is optional - will be set to the 'text' propert of the  treeStore record by default
			, re = re || new RegExp(value, "ig")                            // the regExp could be modified to allow for case-sensitive, starts  with, etc.
			, visibleNodes = []                                             // array of nodes matching the search criteria + each parent non-leaf  node up to root
			, viewNode;
		tree.expandAll();                                                   // expand all nodes for the the following iterative routines
		// iterate over all nodes in the tree in order to evalute them against the search criteria
		root.cascadeBy(function (node) {
			if (node.get(property).match(re)) {                             // if the node matches the search criteria and is a leaf (could be  modified to searh non-leaf nodes)
				matches.push(node);                                         // add the node to the matches array
			}
		});
		if (me.allowParentFolders === false) {                              // if me.allowParentFolders is false (default) then remove any  non-leaf nodes from the regex match
			Ext.each(matches, function (match) {
				if (!match.isLeaf()) {
					Ext.Array.remove(matches, match);
				}
			});
		}
		Ext.each(matches, function (item, i, arr) {                         // loop through all matching leaf nodes
			root.cascadeBy(function (node) {                                // find each parent node containing the node from the matches array
				if (node.contains(item) === true) {
					visibleNodes.push(node);                                // if it's an ancestor of the evaluated node add it to the visibleNodes  array
				}
			});
			if (me.allowParentFolders === true && !item.isLeaf()) {        // if me.allowParentFolders is true and the item is  a non-leaf item
				item.cascadeBy(function (node) {                            // iterate over its children and set them as visible
					visibleNodes.push(node);
				});
			}
			visibleNodes.push(item);                                        // also add the evaluated node itself to the visibleNodes array
		});
		root.cascadeBy(function (node) {                                    // finally loop to hide/show each node
			viewNode = Ext.fly(tree.getView().getNode(node));               // get the dom element assocaited with each node
			if (viewNode) {                                                 // the first one is undefined ? escape it with a conditional
				viewNode.setVisibilityMode(Ext.Element.DISPLAY);            // set the visibility mode of the dom node to display (vs offsets)
				viewNode.setVisible(Ext.Array.contains(visibleNodes, node));
			}
		});
	}
	, clearFilter: function () {
		var me = this
			, tree = this.tree
			, root = tree.getRootNode();
		if (me.collapseOnClear) {
			tree.collapseAll();                                             // collapse the tree nodes
		}
		root.cascadeBy(function (node) {                                    // final loop to hide/show each node
			viewNode = Ext.fly(tree.getView().getNode(node));               // get the dom element assocaited with each node
			if (viewNode) {                                                 // the first one is undefined ? escape it with a conditional and show  all nodes
				viewNode.show();
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.SingleTreePicker',{
	extend:'com.trackplus.util.MultipleTreePicker',
	useNull:true,
	useTooltip:false,
	includeClear:false,
	addBoundListListeners:function(){
		var me=this;
		me.callParent(arguments);
		me.boundList.addListener("select", me.treeSelect, me);
	},
	treeSelect:function(rowModel,record) {
		var me=this;
		var selectable = record.data["selectable"];
		if (selectable && selectable===false) {
			return;
		}
		me.setValue(record,false);
		me.collapse();
		me.fireEvent('select', me, record);
	},
	getClearSelectionLabel:function(){
		var me=this;
		return me.lblClearSelection;
	},
	clearSelection:function(){
		var me=this;
		me.callParent(arguments);
		me.collapse();
	},
	getSubmitValue: function() {
		return this.getValue();
	},
	getValue: function() {
		if(this.value&&this.value.length>0){
			return this.value[0];
		}
		return null;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.PersonPickerDialog',{
	extend:'Ext.Base',
	config: {
		title:"",
		options:null,
		includeEmail:false,
		includeGroups:false,
		handler:null,
		scope:null,
		ajaxContext:null,
		width:250,
		height:400
	},
	controller:null,
	constructor : function(config) {
		var me = this
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	showDialog:function(){
		var me=this;
		me.view=Ext.create('com.trackplus.util.PersonPickerDialogView',{
			options:me.getOptions()
		});
		if(me.win){
			me.win.destroy();
		}
		var w=me.getWidth();
		var h=me.getHeight();
		if(CWHF.isNull(w)){
			w=250;
		}
		if(CWHF.isNull(h)){
			h=400;
		}
		me.win = Ext.create('Ext.window.Window',{
			layout      : 'fit',
			cls:'bottomButtonsDialog',
			border:false,
			bodyBorder:true,
			margin:'0 0 0 0',
			style:{
				padding:'5px 0px 0px 0px'
			},
			bodyPadding:'0px',
			iconCls:'user16',
			width:w,
			height:h,
			closeAction :'destroy',
			title:me.title,
			modal:true,
			items:[me.view],
			autoScroll  :false,
			buttons: [
				{
					text : getText('common.btn.ok'),
					formBind: true, //only enabled once the form is valid
					handler  : function(){
						me.okHandler.call(me);
					}
				},{
					text : getText('common.btn.cancel'),
					handler  : function(){
						me.win.hide();
						me.win.destroy();
					}
				}
			]
		});
		me.win.show();
		if(CWHF.isNull(me.getOptions())){
			me.refreshMyOptions();
		}
	},
	refreshMyOptions:function(){
		var me=this;
		me.view.setLoading(true);
		var urlStr='personPicker.action';
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				me.view.setLoading(false);
				var responseJson = Ext.decode(result.responseText);
				var data=responseJson.data;
				me.view.replaceOptions.call(me.view,data);
			},
			failure: function(){
				me.view.setLoading(false);
			},
			method:'POST',
			params:{includeEmail:me.includeEmail,includeGroups:me.includeGroups}
		});
	},
	okHandler:function(){
		var me=this;
		var value=me.view.getValue.call(me.view);
		var displayValue=me.view.getDisplayValue.call(me.view);
		me.win.hide();
		me.win.destroy();
		if(me.handler){
			me.handler.call(me.scope,value,displayValue);
		}
	}
});
Ext.define('com.trackplus.util.PersonPickerDialogView',{
	extend: 'Ext.panel.Panel',
	config:{
		options:[],
		maxSelectionCount : null
	},
	layout:'border',
	border:false,
	bodyBorder:false,
	bodyStyle:{
		padding:'0px 0px 0px 0px'
	},
	lblSelectAll : getText('common.lbl.selectAll'),
	lblClearSelection : getText('common.lbl.clearSelectedItems'),
	allItemSelected : false,
	initComponent: function(){
		var me=this;
		if(CWHF.isNull(me.selectedDatasourceType)){
			me.selectedDatasourceType=1;
		}
		me.store=me.createStore();
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		me.searchField=Ext.create('Ext.form.field.Text',{
			emptyText:getText('common.btn.search')+"...",
			cls: 'searchfield',
			anchor:'100%',
			//width:me.inputEl.getWidth()-5,
			margin:'5 15 5 5'
		});
		me.searchField.on('change', function(cmp,value){
			me.filter.call(me,value);
		});
		me.linkClearSelection=Ext.create('Ext.ux.LinkComponent',{
			handler:me.clearOrSelectAll,
			anchor:'100%',
			clsLink:'link_blue',
			margin:'2 5 7 5',
			scope:me,
			label : me.getClearSelectionLabel()
		});
		var panelNorth=Ext.create('Ext.panel.Panel',{
			border:false,
			bodyBorder:false,
			region:'north',
			layout:'anchor',
			items:[me.searchField,me.linkClearSelection]
		})
		me.boundList= me.createBoundList();
		me.boundList.addListener('checkchange',me.treeCheckChange,me);
		var items=new Array();
		items.push(panelNorth);
		items.push(me.boundList);
		return items;
	},
	replaceOptions:function(options){
		var me=this;
		var rootNode=me.store.getRootNode();
		rootNode.removeAll();
		if(options&&options.length>0){
			rootNode.appendChild(options);
		}
	},
	treeCheckChange: function(node, checked, options) {
		var me=this;
		var records = me.boundList.getView().getChecked();
		if (CWHF.isNull(records)||records.length===0) {
			me.allItemSelected = false;
		} else {
			var allCount =me.getSelectableItemsCount();
			if (allCount === records.length) {
				me.allItemSelected = true;
			} else {
				me.allItemSelected = false;
			}
		}
		if (me.linkClearSelection ) {
			var oldLabel = me.linkClearSelection.getMyLabel();
			var newLabel = me.getClearSelectionLabel();// me.allItemSelected===true?me.lblClearSelection:me.lblSelectAll;
			if (oldLabel !== newLabel) {
				me.linkClearSelection.suspendLayout = true;
				me.linkClearSelection.setLabel(newLabel);
				me.linkClearSelection.suspendLayout = false;
			}
		}
	},
	getSelectableItemsCount:function(){
		var me=this;
		var count=0;
		if (me.boundList) {
			this.boundList.getRootNode().cascadeBy(function(){
				if(this.get('checked')!==undefined){
					count++;
				}
			});
		}
		return count;
	},
	getClearSelectionLabel : function() {
		var me = this;
		return me.allItemSelected === true ? me.lblClearSelection : me.lblSelectAll
	},
	clearOrSelectAll : function() {
		var me = this;
		if ((me.maxSelectionCount  && me.maxSelectionCount > 0) || me.allItemSelected === true) {
			me.clearSelection();
		} else {
			me.selectAll();
		}
	},
	clearSelection:function(){
		var me=this;
		this.boundList.getRootNode().cascadeBy(function(){
			if(this.get('checked')!==undefined){
				this.set( 'checked', false );
			}
		});
		me.searchField.setValue(null);
		me.allItemSelected = false;
		me.changeLinkClearSelection();
	},
	selectAll : function() {
		var me=this;
		var value=new Array();
		if (me.boundList) {
			this.boundList.getRootNode().cascadeBy(function(){
				if(this.get('checked')!==undefined){
					this.set( 'checked', true);
					value.push(this);
				}
			});
			this.boundList.expandAll();
		}
		me.searchField.setValue(null);
		me.allItemSelected = true;
		me.changeLinkClearSelection();
	},
	changeLinkClearSelection:function(){
		var me=this;
		if (me.linkClearSelection ) {
			var oldLabel = me.linkClearSelection.getMyLabel();
			var newLabel = me.getClearSelectionLabel();// me.allItemSelected===true?me.lblClearSelection:me.lblSelectAll;
			if (oldLabel !== newLabel) {
				me.linkClearSelection.suspendLayout = true;
				me.linkClearSelection.setLabel(newLabel);
				me.linkClearSelection.suspendLayout = false;
			}
		}
	},
	filter : function(value){
		var me = this;
		if (value.length > 0) {
			me.boundList.filter(value);
		}else{
			me.clearFilter();
		}
	},
	clearFilter:function(){
		var me=this;
		me.boundList.clearFilter();
	},
	createStore:function(){
		var me=this;
		return  Ext.create("Ext.data.TreeStore", {
			fields: [
				{name : "id", mapping : "id", type: "string"},
				{name : "text", mapping : "text", type: "string"},
				{name : "leaf", mapping : "leaf", type: "boolean"},
				{name : "iconCls", mapping : "iconCls", type: "string"},
				{name: "selectable", mapping: "selectable", type: "boolean"}
			],
			autoLoad: false,
			root: {
				expanded: true,
				children:(CWHF.isNull(me.getOptions())?[]:me.getOptions())
			},
			originalData:CWHF.isNull(me.getOptions())?[]:me.getOptions()
		});
	},
	createBoundList:function(){
		var treeConfig = {
			store:this.store,
			rootVisible: false,
			containerScroll: true,
			autoScroll: true,
			cls:"simpleTree",
			border:false,
			region:'center',
			//selModel : Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"}),
			plugins: [{
				ptype: 'treefilter',
				allowParentFolders: true
			}]
		}
		var tree= Ext.create("Ext.tree.Panel", treeConfig);
		return tree;
	},
	findRecord: function(field, value) {
		var me=this;
		var nodeToSelect=me.store.getNodeById(value);
		if(nodeToSelect){
			return nodeToSelect;
		}else{
			return false;
		}
	},
	getValue:function(){
		var me=this;
		var records = me.boundList.getView().getChecked();
		return records;
	},
	getDisplayValue:function(){
		var me=this;
		var records = me.boundList.getView().getChecked();
		if(CWHF.isNull(records)||records.length===0){
			return null;
		}
		var displayData=new Array();
		for (var i = 0; i < records.length;i++) {
			var record = records[i];
			displayData.push(record.data.text);
		}
		return displayData;
	}
});

/* Copyright (C) 2012 Trackplus
 * $Id$
 */
Ext.define('Ext.ux.LinkColumn', {
	extend: 'Ext.grid.column.Column',
	alias: ['widget.linkcolumn'],
	config:{
		handler:null,
		scope:null,
		isLink:null,
		suffix:null,
		postProcessRenderer:null,
		clsLink:'synopsis_blue'
	},
	//clsLink:'synopsis_blue',
	constructor: function(config) {
		var me = this;
		var cfg = Ext.apply({}, config);
		me.callParent([cfg]);
		me.renderer = function(value,metaData,record,rowIndex,colIndex,store,view) {
			var renderAsLink=true
			if(me.isLink!=null&&Ext.isFunction(me.isLink)){
				renderAsLink=me.isLink.call(me.scope||me,value,metaData,record,rowIndex,colIndex,store,view);
			}
			var htmlStr="";
			if(renderAsLink){
				htmlStr='<a class="'+me.clsLink+'" href="javascript:void(0)">'+value+'</a>'
			}else{
				htmlStr=value;
			}
			if(me.suffix!=null){
				htmlStr+=me.suffix;
			}
			//v = Ext.isFunction(cfg.renderer) ? cfg.renderer.apply(this, arguments)||'' : '';
			if(me.postProcessRenderer!=null){
				htmlStr=me.postProcessRenderer.call(me.scope||me,htmlStr,metaData,record,rowIndex,colIndex,store,view);
			}
			return htmlStr;
		};
	},
	processEvent : function(type, view, cell, recordIndex, cellIndex, e){
		var me = this;
		var match = e.getTarget().className.indexOf(me.clsLink)!=-1;
		if (match) {
			if (type == 'click') {
				if(me.handler!=null){
					var record = view.panel.store.getAt(recordIndex);
					me.handler.call(me.scope||me,record,cellIndex);
				}
				e.stopEvent();
				return false;
			}else if (type == 'mousedown') {
				return false;
			}
		}
		return me.callParent(arguments);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.IssuePicker',{
	extend:'Ext.Base',
	config: {
		workItemID:null,
		parent:false,
		projectID:null,
		//projectName:null,
		title:"",
		handler:null,
		scope:null,
		ajaxContext:null,
		width:600,
		height:400,
		stateId:null
	},
	issuePikerController:null,
	constructor : function(config) {
		var me = this
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		me.issuePikerController=Ext.create('com.trackplus.util.IssuePickerController',{
			workItemID:me.getWorkItemID(),
			parent:me.getParent(),
			selectedProjectOrRelease:me.getProjectID(),
			//selectedProjectOrReleaseName:me.projectName,
			title:me.getTitle(),
			handler:me.getHandler(),
			scope:me.getScope(),
			ajaxContext:me.getAjaxContext(),
			width:me.getWidth(),
			height:me.getHeight(),
			stateId:me.getStateId()
		});
	},
	showDialog:function(){
		var me=this;
		me.issuePikerController.showDialog.call(me.issuePikerController)
	}
});
Ext.define('com.trackplus.util.IssuePickerView',{
	extend: 'Ext.panel.Panel',
	config:{
		issuePikerController:null,
		selectedProjectOrReleaseName:null,
		selectedProjectOrRelease:null,
		selectedQueryName:null,
		selectedQueryID:null,
		selectedDatasourceType:1
	},
	margin: '0 0 0 0',
	border: false,
	bodyBorder:false,
	baseCls:'x-plain',
	layout:'border',
	bodyStyle:{
		padding:'0px 0px 0px 0px'
	},
	initComponent: function(){
		var me=this;
		if(CWHF.isNull(me.selectedDatasourceType)){
			me.selectedDatasourceType=1;
		}
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var itemsNorth=new Array();
		me.dataSourceType=CWHF.getRadioGroup(null, 500,
				[{boxLabel: getText('common.lbl.projectRelease'), name: 'dataSourceType',
						inputValue: '1', checked: true},
                 {boxLabel:getText('common.lbl.filter'), name: 'dataSourceType', inputValue: '2'}],
				{itemId:null,anchor:'100%',style:{ marginLeft: '155px',marginTop:'5px'},labelWidth:150,hideLabel:true},
				{change: {fn: me.datasourceTypeChanged, scope:me}});
		itemsNorth.push(me.dataSourceType);
        me.cmbProjects = CWHF.createSingleTreePicker("common.lbl.projectRelease",
            "projectOrRelease", [], me.selectedProjectOrRelease,
            {   labelStyle:{overflow:'hidden'},
                labelWidth:150,
                labelAlign:'right',
                style:{ marginRight: '5px'},
                anchor:'100%',
                margin: '0 5 5 0',
                itemId: "projectOrRelease"
            })
        Ext.Ajax.request({
            url: "releasePicker.action",
            scope:me,
            success: function(response){
                var projectReleaseTree = Ext.decode(response.responseText);
                me.cmbProjects.updateMyOptions(projectReleaseTree);
                me.cmbProjects.setValue(me.selectedProjectOrRelease);
            },
            failure: function(response){
                com.trackplus.util.requestFailureHandler(response);
            }
        });
		itemsNorth.push(me.cmbProjects);
        me.cmbQueries=CWHF.createSingleTreePicker("common.lbl.filter",
            "query", [], me.selectedQueryID,
            {   labelStyle:{overflow:'hidden'},
                labelWidth:150,
                labelAlign:'right',
                style:{ marginRight: '5px'},
                anchor:'100%',
                margin: '0 5 5 0',
                itemId: "query"
            });
		//me.cmbQueries=CWHF.createFilterPicker(getText('common.lbl.filter'), 'query',cfg);
		//me.cmbQueries.setValue(me.selectedQueryName);
        Ext.Ajax.request({
            url: "categoryPicker.action",
            params: {node:"issueFilter"},
            success: function(response){
                var filterTree = Ext.decode(response.responseText);
                me.cmbQueries.updateMyOptions(filterTree);
                me.cmbQueries.setValue(me.selectedQueryID);
            },
            failure: function(response){
                com.trackplus.util.requestFailureHandler(response);
            }})
		itemsNorth.push(me.cmbQueries);
		//project=1,query=2
		me.cmbProjects.setDisabled(me.selectedDatasourceType!==1);
		me.cmbQueries.setDisabled(me.selectedDatasourceType===1);
		me.chkIncludeClosed= Ext.create('Ext.form.field.Checkbox',{
			name:'includeClosed',
			fieldLabel:getText('item.lbl.includeClosed'),
			labelStyle:{overflow:'hidden'},
			labelWidth:150,
			labelAlign:'right'
		});
			//boxLabel:'Project/Release',
		itemsNorth.push(me.chkIncludeClosed);
		me.txtIssueNumber= Ext.create('Ext.form.field.Text',{
			name:'searchIssueKey',
			fieldLabel:getText('item.lbl.itemNumber'),
			labelStyle:{overflow:'hidden'},
			labelWidth:150,
			width:250,
			labelAlign:'right'
		});
		itemsNorth.push(me.txtIssueNumber);
		me.btnSearch=Ext.create('Ext.button.Button',{
			text: getText('common.btn.search'),
			margin:'0 5 10 155',
			formBind: true, //only enabled once the form is valid
			handler: function() {
				me.issuePikerController.search.call(me.issuePikerController);
			}
		});
		itemsNorth.push(me.btnSearch);
		me.storeIssues = Ext.create('Ext.data.Store', {
			fields:['id', 'title','objectID'],
			data:[],
			proxy: {
				type: 'ajax',
				url:'issuePicker!search.action',
				reader: {
					type: 'json'
				}
			}
		});
		me.gridIssues =Ext.create('Ext.grid.Panel',{
			store      : me.storeIssues,
			columns    : [
				{
					xtype:'linkcolumn',
					text: getText('item.lbl.itemNumber'),
					dataIndex: 'id',
					width: 75,
					align :'right',
					handler:me.issuePikerController.clickOnItem,
					scope:me.issuePikerController
				},{
					xtype:'linkcolumn',
					text: getText('item.prompt.synopsys'),
					dataIndex: 'title',
					width: 420,
					handler:me.issuePikerController.clickOnItem,
					scope:me.issuePikerController
				}
			],
			minHeight:75,
			border: true,
			margin:'0 0 0 0',
			bodyBorder:false,
			cls:'gridNoBorder',
			bodyStyle:{
				border:'none'
			},
			//columnLines :true,
			region:'center',
			forceFit: true,
			viewConfig: {
				stripeRows: true,
				forceFit: true
			}
		});
		var items=new Array();
		var panelNorth=Ext.create('Ext.panel.Panel',{
			border:false,
			bodyBorder:false,
			region:'north',
			layout:'anchor',
			items:itemsNorth
		})
		items.push(panelNorth);
		items.push(me.gridIssues);
		return items;
	},
	datasourceTypeChanged:function(radioGroup, newValue, oldValue, options){
		var me=this;
		var checkedArr = radioGroup.getChecked();
		var checkedRadio;
		if (checkedArr.length===1) {
			checkedRadio = checkedArr[0];
			var value=checkedRadio.getSubmitValue();
			//project=1,query=2
			me.cmbProjects.setDisabled(value!==1);
			me.cmbQueries.setDisabled(value===1);
		}
	}
});
Ext.define('com.trackplus.util.IssuePickerController',{
	extend:'Ext.Base',
	config: {
		workItemID:null,
		parent:false,
		title:"",
		handler:null,
		scope:null,
		ajaxContext:null,
		selectedProjectOrReleaseName:null,
		selectedProjectOrRelease:null,
		selectedQueryName:null,
		selectedQueryID:null,
		selectedDatasourceType:1,
		width:600,
		height:400,
		stateId:null
	},
	view:null,
	win:null,
	constructor : function(config) {
		var me = this
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	showDialog:function(){
		var me=this;
		me.issuePikerView=Ext.create('com.trackplus.util.IssuePickerView',{
			issuePikerController:me,
			selectedProjectOrReleaseName:me.selectedProjectOrReleaseName,
			selectedProjectOrRelease:me.selectedProjectOrRelease,
			selectedQueryName:me.selectedQueryName,
			selectedQueryID:me.selectedQueryID,
			selectedDatasourceType:me.selectedDatasourceType
		});
		if(me.win){
			me.win.destroy();
		}
		me.win = Ext.create('Ext.window.Window',{
			layout      : 'fit',
			//iconCls:'buttonParent',
			width       : me.getWidth(),
			minWidth  : 350,
			minHeight  : 300,
			height      : me.getHeight(),
			closeAction :'destroy',
			plain       : true,
			title		:me.getTitle(),
			modal       :true,
			items       :[me.issuePikerView],
			border:false,
			bodyBorder:true,
			margin:'0 0 0 0',
			style:{
				padding:'5px 0px 0px 0px'
			},
			autoScroll  :false,
			stateId:me.getStateId(),
			stateful:me.getStateId(),
			listeners:{
				'staterestore':{
					fn:function(dialog,state){
						var w=state.width;
						var h=state.height;
						var x=null;
						var y=null;
						if(state.pos){
							x=state.pos[0];
							y=state.pos[1];
						}
						var size=borderLayout.ensureSize(state.width,state.height);
						if(dialog.x<0){
							dialog.x=10;
						}
						if(dialog.y<0){
							dialog.y=10;
						}
						if(w!==size.width){
							dialog.width=size.width;
							dialog.x=10;
						}
						if(h!==size.height){
							dialog.height=size.height;
							dialog.y=10;
						}
					}
				}
			}
		});
		me.win.show();
		if(me.selectedProjectOrRelease){
			me.search();
		}
	},
	search:function(){
		var me=this;
		var projectID=null;
		var queryID=null;
		var checkedArr = me.issuePikerView.dataSourceType.getChecked();
		var checkedRadio;
		var projectSelected=true;
		if (checkedArr.length===1) {
			checkedRadio = checkedArr[0];
			var value=checkedRadio.getSubmitValue();
			if(value===2){
				projectSelected=false;
			}
		}
		if(projectSelected){
			projectID=me.issuePikerView.cmbProjects.getValue();
            if (CWHF.isNull(projectID)) {
                //not yet selected by user, but preselected by issue's project
                projectID = me.selectedProjectOrRelease;
            }
		}else{
			queryID=me.issuePikerView.cmbQueries.getSubmitValue();
		}
		var includeClosed=me.issuePikerView.chkIncludeClosed.value;
		var searchIssueKey=me.issuePikerView.txtIssueNumber.value;
		me.issuePikerView.storeIssues.load({
			url:'issuePicker!search.action',
			params:{
				workItemID:me.workItemID,
				parent:me.parent,
				projectID:projectID,
				queryID:queryID,
				includeClosed:includeClosed,
				searchIssueKey:searchIssueKey
			},
			callback: function(records, operation, success) {
			}
		});
	},
	clickOnItem:function(record,cellIndex){
		var me=this;
		var item=record.data;
		if(me.ajaxContext){
			me.ajaxPick(item);
		}else{
			me.win.close();
			me.win.destroy();
			if(me.handler){
				me.handler.call(me.scope,item);
			}
		}
	},
	ajaxPick:function(item){
		var me=this;
		me.issuePikerView.setLoading(true);
		var urlStr=me.ajaxContext.url;
		var params=me.ajaxContext.params;
		var pickItemName=me.ajaxContext.pickItemName;
		if(CWHF.isNull(pickItemName)){
			pickItemName='workItemID';
		}
		if(CWHF.isNull(params)){
			params=new Object();
		}
		params[pickItemName]=item['objectID'];
		Ext.Ajax.request({
			url: urlStr,
			scope:me,
			params:params,
			success: function(response){
				me.issuePikerView.setLoading(false);
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success===true) {
					me.win.close();
					me.win.destroy();
					if(me.ajaxContext.successHandler){
						if(me.ajaxContext.successHandlerScope){
							me.ajaxContext.successHandler.call(me.ajaxContext.successHandlerScope,item);
						}else{
							me.ajaxContext.successHandler.call(me,item);
						}
					}
				}else{
					if (responseJson.errorMessage) {
						//parent change for an issue
						Ext.MessageBox.show({
							title: getText('common.warning'),
							msg: responseJson.errorMessage,
						    buttons: Ext.Msg.OK,
						    icon: Ext.MessageBox.WARNING
						});
					} else {
						Ext.MessageBox.show({
							title: getText('common.err.invalid.item'),
							msg: errorMessage,
						    buttons: Ext.Msg.OK,
						    icon: Ext.MessageBox.ERROR
						});
					}
				}
			},
			failure:function(){
				me.issuePikerView.setLoading(false);
				alert("failure");
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.util.NameAndPathPicker",{
	extend:'Ext.Base',
	config: {
		title:"",
		loadUrl: null,
		loadParams: null,
		pathTree: null,
		handler: null,
		//validateHandler: null,
		scope: null,
		width: 400,
		height: 170
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	showDialog:function(){
		var me=this;
		var items = [];
		me.filterName = CWHF.createTextField("common.lbl.name", "label", {labelWidth:80, width:350, allowBlank:false, msgTarget: "qtip"});
		me.pathPicker = CWHF.createSingleTreePicker("common.lbl.path", "path", me.pathTree, null, {labelWidth:80,width:350, allowBlank:false});
		me.includeInMenu = CWHF.createCheckbox("admin.customize.queryFilter.lbl.menu", "includeInMenu", {labelWidth:80, width: 100});
		items.push(me.filterName, me.pathPicker, me.includeInMenu);
		var windowParameters = {title:me.title,
				width:me.width,
				height:me.height,
				load: {loadUrl: this.loadUrl, loadUrlParams:this.loadParams},
				postDataProcess: this.loadPath,
				submit: {submitHandler: me.submitSaveAs, validateHandler: me.validateHandler},
				items: items};
			var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
			windowConfig.showWindowByConfig(this);
	},
	submitSaveAs: function(window, submitUrl, submitUrlParams) {
		var me=this;
		me.handler.call(me.scope, window, me.filterName.getValue(), me.pathPicker.getValue(), me.includeInMenu.getValue());
	},
	loadPath: function(data, panel, extraConfig)  {
		this.pathPicker.updateMyOptions(data);
	},
	validateHandler: function(submit, win) {
		var me=this;
		return me.formEdit.isValid();
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.Tab',{
	extend: 'Ext.panel.Panel',
	border:false,
	bodyBorder:false,
	cls:'gridNoBorder',
	config: {
		workItemID:null,
		projectID:null,
		issueTypeID:null,
		tabNo:null,
		jsonData:{},
		labelHAlign:'right',
		decimalSeparator:'.',
		decimalFormat:'0,000.00',
		jsDateFormat:'d/m/Y',
		keepSelection: false,
		lastModified:null
	},
	margin:'0 0 0 0',
	bodyPadding:0,
	TAB_HISTORY:1,
	TAB_COMMENTS:2,
	TAB_ATTACHMENTS:3,
	TAB_WORKLOG:4,
	TAB_WATCHERS:5,
	TAB_VERSION_CONTROL:6,
	TAB_LINKS:7,
	TAB_MIGRATIONS:8,
	initComponent : function(){
		var me = this;
		me.callParent();
	},
	fireItemChange:function(fields,lastEdit,values){
		var me=this;
		if(lastEdit){
			me.lastModified=lastEdit;
		}
		me.fireEvent.call(me,'itemChange',fields,lastEdit,values);
	},
	refresh:function(){
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//Grid tab class
Ext.define('com.aurel.trackplus.itemDetail.TabGrid',{
	extend:'com.aurel.trackplus.itemDetail.Tab',
	//layout:'border',
	config: {
		urlDeleteItems:null,
		handlerDeleteItem:null
	},
	gridConfig:null,
	gridLayoutData:null,
	grid:null,
	fieldsToNotifyOnDelete:null,
	COLUMN_TYPE:{
		STRING:0,
		DATETIME:1,
		INTEGER:2,
		DOUBLE:3,
		BYTES:4,
		IMAGE:5,
		DATE:6
	},
	createGrid:function(gridConfig,gridLayoutData,items){
		var me=this;
		var sortField=gridLayoutData.sortField;
		var sortDirection=gridLayoutData.sortDirection;
		var columnModel=new Array(0);
		var layoutData;
		var groupField=null;
		for(var i=0;i<gridLayoutData.layout.length;i++){
			layoutData=gridLayoutData.layout[i];
			colCfg={
				text:layoutData.header,
				dataIndex:layoutData.dataIndex,
				//itemId:gridConfig.id+'_'+layoutData.id,
				sortable:layoutData.sortable,
				hidden:layoutData.hidden
			};
			//if(layoutData.flex){
			//if(i===gridLayoutData.layout.length-1){
			//colCfg['flex']=1;
			//}else{
			colCfg['width']=layoutData.width;
			//}
			var colClassName= 'Ext.grid.column.Column';
			colClassName=me.gridConfig.updateColCfg.call(me.gridConfig,colCfg,layoutData,i);
			var col=Ext.create(colClassName,colCfg);
			if(layoutData.type===me.COLUMN_TYPE.DATETIME){
				col.renderer=Ext.util.Format.dateRenderer(com.trackplus.TrackplusConfig.DateTimeFormat);
			}
			if(layoutData.type===me.COLUMN_TYPE.DATE){
				col.renderer=Ext.util.Format.dateRenderer(com.trackplus.TrackplusConfig.DateFormat);
			}
			if(layoutData.type===me.COLUMN_TYPE.BYTES){
				col.renderer=me.formatBytes;
			}
			if(layoutData.type===me.COLUMN_TYPE.IMAGE){
				col.renderer=me.thumbnailRenderer(me.workItemID);
			}
			if(layoutData.dataIndex==='newValues'||layoutData.dataIndex==='oldValues'||
				layoutData.dataIndex==='comment'||layoutData.dataIndex==='diff'){
				col.renderer=function(value,metaData, record, rowIndex, colIndex, store) {
					if(this.isHidden()===true){
						metaData.tdCls = '';
						return '';
					}else{
						metaData.tdCls = 'wordWrapTd';
					}
					return value;
				};
				col.scope=col;
			}
			me.gridConfig.updateCol.call(me.gridConfig,col,layoutData,i);
			columnModel.push(col);
			if(layoutData.grouping){
				groupField=layoutData.dataIndex;
			}
		}
		var store = Ext.create('Ext.data.Store', {
			groupField:groupField,
			sortInfo:{field:gridConfig.sortField, direction:gridConfig.sortDirection},
			fields:gridConfig.fields,
			proxy: {
				type: 'ajax',
				url: gridConfig.urlStore,
				reader: {
					type: 'json'
				}
			}
		});
		if(items){
			store.loadData(items);
		}
		var groupingFeature = Ext.create('Ext.grid.feature.Grouping',{
			groupHeaderTpl: '{name} ({rows.length} Item{[values.rows.length > 1 ? "s" : ""]})'
		});
		var features=me.gridConfig.features;
		if(CWHF.isNull(features)){
			features=[];
		}
		features.push(groupingFeature);
		// create the grid
		me.grid=  Ext.create('Ext.grid.Panel', {
			cls:'itemDetailGrid',
			store	  : store,
			selModel   : gridConfig.selectionModel,
			columns	: columnModel,
			border	: false,
			bodyBorder:false,
			columnLines :true,
			features: features,
			viewConfig: me.getViewConfig(),
			dockedItems: [{
				xtype: 'toolbar',
				dock: 'top',//'bottom'
				items:gridConfig.tbar
			}]
		});
		if(CWHF.isNull(groupField)){
			me.grid.addListener('afterrender', function(){
				groupingFeature.disable();
			});
		}
		me.grid.addListener('itemdblclick', me.gridOnClickHandler,me);
		me.grid.addListener('cellclick', me.gridOnCellClickHandler,me);
		me.grid.addListener('columnmove',me.handleColChange,me);
		me.grid.addListener('columnresize', me.handleColChange,me);
		me.grid.addListener('sortchange', me.handleColChange,me);
		me.grid.addListener('columnhide',me.handleColChange,me);
		me.grid.addListener('columnshow',me.handleColChange,me);
		//grid.view.addListener('refresh',gridConfig.groupingChangeHandler,gridConfig);
		return me.grid;
	},
	formatBytes:function(value){
		return Ext.util.Format.fileSize(value);
	},
	thumbnailRenderer:function(workItemID) {
		var me=this;
		return function(value,metaData, record, rowIndex, colIndex, store) {
			return me.formatThumbnail(value,metaData, record, rowIndex, colIndex, store,workItemID);
		};
	},
	formatThumbnail:function(value,metaData, record, rowIndex, colIndex, store,workItemID){
		var result="";
		if(value){
			result= '<div style="text-align: center;height:100px;">';
			result+='<img src="thumbnailAttachment.action?attachKey='+record.data['id'];
			if(workItemID){
				result=result+'&workItemID='+workItemID;
			}
			result=result+'"></div>';
		}else{
			result="...";
		}
		return result;
	},
	getViewConfig: function() {
		return {
			stripeRows: true
		};
	},
	handleColChange:function(ct,column){
		var me=this;
		var sortField=null;
		var sortDir=null;
		var sorters=me.grid.getStore().sorters;
		if(sorters&&sorters.getCount()>0){
			var s=sorters.getAt(0);
			sortField=s.property;
			sortDir=s.direction;
		}
		var groupField=null;//me.grid.view.ds.groupField;
		var columns="";
		var gridColumns=ct.getGridColumns();
		var nr=gridColumns.length;
		var i=0;
		for(i=0;i<nr;i++){
			var col=gridColumns[i];
			var colId=null;
			var itemID=col.getItemId();
			if(itemID){
				var idx=itemID.indexOf("_");
				if(idx>0){
					colId=itemID.substring(idx+1);
				}
			}
			if(CWHF.isNull(colId)){
				continue;
			}
			var colWidth=col.getWidth();
			var colDataIndex=col.dataIndex;
			var colHidden=col.isHidden();
			var direction="-";
			if(sortField&&colDataIndex===sortField){
				if(sortDir==='ASC'){
					direction='Y'
				}else{
					direction='N';
				}
			}
			var grouping=false;
			if(groupField&&colDataIndex===groupField){
				grouping=true;
			}
			columns=columns+colId+":"+colHidden+":"+colWidth+":"+direction+":"+grouping+";";
		}
		Ext.Ajax.request({
			url: "saveGridConfig.action",
			disableCaching:true,
			success: function(result){
			},
			failure: function(){
			},
			method:'POST',
			params:{"columns":columns,"gridID":me.gridConfig.id}
		});
	},
	initComponent : function(){
		var me=this;
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=[];
		if(me.gridConfig&&me.jsonData&&me.jsonData.gridLayoutData){
			var someGrid=me.createGrid.call(me,me.gridConfig,me.jsonData.gridLayoutData,me.jsonData.items);
			me.gridConfig.grid=someGrid;
			items.push(someGrid);
		}
		return items;
	},
	refresh:function(){
		var me=this;
		Ext.suspendLayouts();
		if(CWHF.isNull(me.gridConfig.grid)){
			Ext.Ajax.request({
				url: me.gridConfig.urlStore,
				disableCaching:true,
				success: function(response){
					var responseJson = Ext.decode(response.responseText);
					var jsonData=responseJson.data;
					var someGrid=me.createGrid.call(me,me.gridConfig,jsonData.gridLayoutData,jsonData.items);
					me.gridConfig.grid=someGrid;
					me.add(someGrid);
					var records=new Array();
					var data=someGrid.store.data;
					if(data){
						for(var i=0;i<data.getCount();i++){
							records.push(data.getAt(i));
						}
					}
					me.refreshCallback.call(me,records,{},true);
					Ext.resumeLayouts(true);
				},
				failure: function(){
					Ext.resumeLayouts(true);
				},
				method:'POST',
				params:{includeLayout:true,tabID:me.gridConfig.id}
			});
		}else{
			if (!me.keepSelection) {
				me.gridConfig.grid.getSelectionModel().deselectAll();
			}
			me.gridConfig.grid.store.load({
				params:{tabID:me.gridConfig.id},
				callback : function(r,options,success){
					me.refreshCallback.call(me,r,options,success);
					Ext.resumeLayouts(true);
				}
			});
		}
	},
	replaceTitleNumber:function(title,nr){
		var p=" ";
		var idx=title.search(p);
		return title.substr(0,idx)+" ("+nr+")";
	},
	refreshCallback:function(r,options,success){
	},
	gridOnClickHandler:function(){
		var me=this;
		if(me.gridConfig.dblClickHandler){
			me.gridConfig.dblClickHandler.call(me);
		}
	},
	gridOnCellClickHandler:function(grid, td, cellIndex, record, tr, rowIndex, e, eOpts){
		var me=this;
		if(me.gridConfig.cellClickHandler){
			me.gridConfig.cellClickHandler.call(me, grid, td, cellIndex, record, tr, rowIndex, e, eOpts);
		}
	},
	deleteItems:function(){
		var me=this;
		var selections=me.gridConfig.selectionModel.getSelection();
		var titleNotSelected=com.trackplus.TrackplusConfig.getText("common.lbl.messageBox.title.notSelected");
		var messageConfirmDelete=com.trackplus.TrackplusConfig.getText("common.lbl.messageBox.removeSelected.confirm");
		var messageNoSelection=com.trackplus.TrackplusConfig.getText("common.lbl.messageBox.removeSelected.notSelected");
		var titleDelete=com.trackplus.TrackplusConfig.getText("common.btn.delete");
		var okLabel=com.trackplus.TrackplusConfig.getText("common.btn.ok");
		if(CWHF.isNull(selections)||selections.length===0){
			Ext.MessageBox.show({
				title:titleNotSelected,
				msg:messageNoSelection ,
				buttons:{ok : okLabel},
				icon: Ext.MessageBox.WARNING
			});
			return;
		}
		/*var rowData=selections[0].data;
		 if(rowData.editable===false){
		 return false;
		 }*/
		Ext.MessageBox.show({
			title:titleDelete,
			msg: messageConfirmDelete,
			//buttons:{yes : yesLabel, no : noLabel},
			buttons: Ext.MessageBox.YESNO,
			fn: function(btn){
				if(btn==="yes"){
					if(me.handlerDeleteItem){
						me.handlerDeleteItem();
					}else{
						var selections=me.gridConfig.selectionModel.getSelection();
						var deletedItems="";
						var row;
						var i;
						for(i=0;i<selections.length;i++){
							//row=selections[i];
							row=selections[i].data;
							if(row.editable===true) {
								deletedItems = deletedItems + row.id + ";";
							}
						}
						Ext.Ajax.request({
							url: me.urlDeleteItems,
							disableCaching:true,
							success: function(response){
								if(me.fieldsToNotifyOnDelete){
									var result = Ext.decode(response.responseText);
									var lastModified=result.data.lastModified;
									me.fireItemChange(me.fieldsToNotifyOnDelete,lastModified);
								}
								me.refresh.call(me);
								/*if (reloadFlatHistory) {
								 refreshFlatHistory();
								 }*/
							},
							failure: function(){
							},
							method:'POST',
							params:{"deletedItems":deletedItems,"workItemID":me.workItemID,"projectID":me.projectID,"issueTypeID":me.issueTypeID,"lastModified":me.lastModified}
						});
					}
				}
			},
			//animEl: 'mb4',
			icon: Ext.MessageBox.QUESTION
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Configuration for creating a grid in item detail
 */
com.trackplus.itemDetail.GridConfig=function(){
};
com.trackplus.itemDetail.GridConfig.prototype.id=null;
com.trackplus.itemDetail.GridConfig.prototype.tabId=null;
com.trackplus.itemDetail.GridConfig.prototype.urlStore=null;
com.trackplus.itemDetail.GridConfig.prototype.fields=null;
com.trackplus.itemDetail.GridConfig.prototype.tbar=null;
com.trackplus.itemDetail.GridConfig.prototype.grid=null;
com.trackplus.itemDetail.GridConfig.prototype.dblClickHandler=null;
com.trackplus.itemDetail.GridConfig.prototype.cellClickHandler=null;
com.trackplus.itemDetail.GridConfig.prototype.oldGroupField=null;
com.trackplus.itemDetail.GridConfig.prototype.updateCol=function(col,layout,index){
};
com.trackplus.itemDetail.GridConfig.prototype.updateColCfg=function(colCfg,layout,index){
	return 'Ext.grid.column.Column';
};
//Item detial component
com.trackplus.itemDetail.instanceID=0;
/**
 * Create the item detail tab panel
 * workItemID:int the ID of the item
 * tabsEnabled:Object contains the tabs enabled:
 * 		history,comments,attachments, worklog, watchers, links, migrations
 *
 */
com.trackplus.itemDetail.ItemDetailComponent=function(workItemID,projectID,issueTypeID,tabs,activeTab,fireEventFunction,fireEventScope,lastModified){
	this.workItemID=workItemID;
	this.projectID=projectID;
	this.issueTypeID=issueTypeID;
	com.trackplus.itemDetail.instanceID++;
	this.instanceID=com.trackplus.itemDetail.instanceID;
	this.tabs=tabs;
	this.activeTab=activeTab;
	this.fireEventFunction=fireEventFunction;
	this.fireEventScope=fireEventScope;
	this.lastModified=lastModified;
};
com.trackplus.itemDetail.ItemDetailComponent.prototype.instanceID=0;
com.trackplus.itemDetail.ItemDetailComponent.prototype.workItemID=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.projectID=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.issueTypeID=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.fireEventFunction=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.fireEventScope=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.lastModified=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.tabs=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.activeTab=1;
com.trackplus.itemDetail.ItemDetailComponent.prototype.tabPanel=null;
com.trackplus.itemDetail.ItemDetailComponent.prototype.getTabID=function(tabName){
	return "tabItemDetail_"+this.instanceID+tabName;
};
com.trackplus.itemDetail.ItemDetailComponent.prototype.createComponent=function(){
	var me=this;
	var tabItems=new Array(0);
	var aTab;
	for(var i=0;i<this.tabs.length;i++){
		aTab=this.tabs[i];
		var tab=Ext.create(aTab.extClassName,{
			id:this.getTabID(aTab.id),
			workItemID:this.workItemID,
			tabNo:aTab.id,
			projectID:this.projectID,
			issueTypeID:this.issueTypeID,
			lastModified:me.lastModified,
			jsonData:aTab.jsonData
		});
		if(me.fireEventFunction){
			tab.addListener('itemChange',function(){
				me.fireEventFunction.call(me.fireEventScope,'itemChange',arguments);
			},me);
			tab.addListener('clickOnLink',function(){
				me.fireEventFunction.call(me.fireEventScope,'clickOnLink',arguments);
			},me);
		}
		tabItems.push(tab);
		tab.addListener('activate',this.activateTab,this);
	};
	this.tabPanel=Ext.create('Ext.tab.Panel',{
		cls:'itemDetailTabPanel',
		bodyCls:'itemDetailTabPanel-body',
		margin: '0 0 0 0',
		autoHeight:true,
		plain:true,
		border:true,
		bodyBorder:false,
		deferredRender:true,
		defaults:{autoScroll: false,border:false,bodyBorder:false},
		//split: true,
		//collapsible: true,
		//title:'Item detail: History',
		tabPosition: 'top',
		items:tabItems,
		activeTab:this.activeTab
	});
	return this.tabPanel;
};
com.trackplus.itemDetail.ItemDetailComponent.prototype.refreshAttachments=function(){
	var me=this;
	var attachmentTabID=3;
	var tabID=me.getTabID(attachmentTabID);
	var attachmentTabCmp=me.tabPanel.getComponent(tabID);
	if(attachmentTabCmp){
		attachmentTabCmp.refresh();
	}
}
com.trackplus.itemDetail.ItemDetailComponent.prototype.activateTab=function(tab){
	var me=this;
	var tabNo=tab.tabNo;
	var idx = me.tabPanel.items.indexOf(tab);
	/*if(me.activeTab===idx){
		return;
	}*/
	me.activeTab=idx;
	tab.refresh.call(tab);
};
/**
 * Dialog configuration use to open a  modal dialog
 */
com.trackplus.itemDetail.DialogConfig=function(workItemID,projectID,issueTypeID){
	this.workItemID=workItemID;
	this.projectID=projectID;
	this.issueTypeID=issueTypeID;
}
com.trackplus.itemDetail.DialogConfig.prototype.workItemID=null;
com.trackplus.itemDetail.DialogConfig.prototype.projectID=null;
com.trackplus.itemDetail.DialogConfig.prototype.issueTypeID=null;
//title:String -title for dialog
com.trackplus.itemDetail.DialogConfig.prototype.title="";
//formPanel:Ext.form.Panel - main panel form
com.trackplus.itemDetail.DialogConfig.prototype.formPanel=null;
//w:int - width
com.trackplus.itemDetail.DialogConfig.prototype.w=400;
//h:int - height
com.trackplus.itemDetail.DialogConfig.prototype.h=300;
//layout:String - layout for dialog: 'fit','border'
com.trackplus.itemDetail.DialogConfig.prototype.layout="fit";
//autoScroll:boolean
com.trackplus.itemDetail.DialogConfig.prototype.autoScroll=false;
//iconCls:String - name of the CSS class for dialog
com.trackplus.itemDetail.DialogConfig.prototype.iconCls=null;
//okLabelt:String - label for ok button
com.trackplus.itemDetail.DialogConfig.prototype.okLabel=com.trackplus.TrackplusConfig.getText("common.btn.ok");
//resetLabelt:String - label for reset button
com.trackplus.itemDetail.DialogConfig.prototype.resetLabel=com.trackplus.TrackplusConfig.getText("common.btn.reset");
//closeLabelt:String - label for close button
com.trackplus.itemDetail.DialogConfig.prototype.closeLabel=com.trackplus.TrackplusConfig.getText("common.btn.close");
//a function to validate the form
//scope(this) must be the instance of DialogConfig class
com.trackplus.itemDetail.DialogConfig.prototype.validate=function(){
	var form=this.formPanel.getForm();
	return (form.isValid());
};
//validate and submit the form
//scope(this) must be the instance of DialogConfig class
//call like dialogCfgInstance.okHandler.call(dialogCfgInstance);
com.trackplus.itemDetail.DialogConfig.prototype.okHandler=function(){
	var me=this;
	if(!this.validate()){
		return false;
	}
	var form=this.formPanel.getForm();
	var myScope=this;
	com.trackplus.itemDetail.modalDialog.setLoading(true);
	form.submit({
		method :'POST',
		params:{workItemID:this.workItemID,projectID:me.projectID,issueTypeID:me.issueTypeID},
		scope:myScope,
		success: function(form, action) {
			com.trackplus.itemDetail.modalDialog.setLoading(false);
			com.trackplus.itemDetail.modalDialog.hide();
			com.trackplus.itemDetail.modalDialog.destroy();
			myScope.successHandler.call(myScope,action.result);
		},
		failure: function(form, action) {
			com.trackplus.itemDetail.modalDialog.setLoading(false);
			myScope.failureHandler.call(myScope,form,action);
		}
	});
};
//invoked after form is valid and submit with success
com.trackplus.itemDetail.DialogConfig.prototype.successHandler=function(){
};
com.trackplus.itemDetail.DialogConfig.prototype.failureHandler=function(form, action){
	var msg=action.result.errorMessage;
	if(CWHF.isNull(msg)||msg===''){
		msg=getText('common.err.failure.validate');
	}
	CWHF.showMsgError(msg);
};
com.trackplus.itemDetail.enterOnForm=function(e){
	var  dialogCfg=this;
	var target = e.getTarget();
	if(target['type']==='textarea'){
		return;
	}
	dialogCfg.okHandler.call(dialogCfg);
};
/**
 * Open a modal dialog for a DialogConfig
 */
com.trackplus.itemDetail.openDialog=function(dialogCfg){
	if(com.trackplus.itemDetail.modalDialog){
		com.trackplus.itemDetail.modalDialog.destroy();
	}
	var width=dialogCfg.w;
	var height=dialogCfg.h;
	var minHeight=null;
	var minWidth=null;
	if(dialogCfg.minw){
		minWidth=dialogCfg.minw;
	}
	if(dialogCfg.minh){
		minHeight=dialogCfg.minh;
	}
	var size=borderLayout.ensureSize(width,height);
	width=size.width;
	height=size.height;
	dialogCfg.formPanel.addListener('afterRender',function(thisForm, options){
		this.keyNav = Ext.create('Ext.util.KeyNav',{
			target:this.el,
			enter:{
				fn:com.trackplus.itemDetail.enterOnForm,
				defaultEventAction:false
			},
			scope: dialogCfg
		});
	});
	com.trackplus.itemDetail.modalDialog = Ext.create('Ext.window.Window',{
		layout		: dialogCfg.layout,
		width		: width,
		height		: height,
		minHeight	: minHeight,
		minWidth	: minWidth,
		iconCls		:dialogCfg.iconCls,
		closeAction :'destroy',
		cls:'bottomButtonsDialog',
		//border:false,
		bodyBorder:true,
		margin:'0 0 0 0',
		style:{
			padding:'5px 0px 0px 0px'
		},
		bodyPadding:'0px',
		title		:dialogCfg.title,
		modal		:true,
		items		:[dialogCfg.formPanel],
		autoScroll  :dialogCfg.autoScroll,
		buttons: [
			{text: dialogCfg.okLabel,
				handler  : function(){
					dialogCfg.okHandler.call(dialogCfg);
				}
			}/*,{text :dialogCfg.resetLabel,
				handler  : function(){
					dialogCfg.formPanel.getForm().reset();
					var ckeditors=CKEDITOR.instances;
					if(ckeditors){
						for(var x in ckeditors){
							var ckEditor=ckeditors[x];
							var txtArea=document.getElementById(x);
							if(txtArea&& ckEditor.checkDirty()){
								ckEditor.setData(txtArea.value);
							}
						}
					}
				}
			}*/,{text : dialogCfg.closeLabel,
				handler  : function(){
					com.trackplus.itemDetail.modalDialog.destroy();
				}
			}
		]
	});
	com.trackplus.itemDetail.modalDialog.show();
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.AttachmentsTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	urlDeleteItems:'deletedAttachments.action',
	readOnly:false,
	dropFileSupported:false,
	fieldsToNotifyOnDelete:[-1001, 15],
	initComponent : function(){
		var me = this;
		var attachmentNumber=0;
		if(me.jsonData.attachmentNumber){
			attachmentNumber=me.jsonData.attachmentNumber;
		}
		me.title=getText('item.printItem.lbl.tab.attachments')+" ("+attachmentNumber+")";
		if(typeof window.FileReader === 'undefined'){
			//drop file unsupported
			me.dropFileSupported=false;
		}else{
			me.dropFileSupported=true;
		}
		// me.iconCls='attachment16';
		me.gridConfig=me.createAttachmentsConfig();
		me.callParent();
		me.addListener('render',me.onReadyHandler,me);
	},
	onReadyHandler:function(){
		var me=this;
		if(me.dropFileSupported===false){
			return false;
		}
		var domEl=me.getEl().dom;
		domEl.addEventListener("dragenter", function(evt){
			evt.stopPropagation();
			evt.preventDefault();
			var mouseX=parseInt(evt.clientX);
			var mouseY=parseInt(evt.clientY);
			var winX=mouseX-150;
			if(winX<10){
				winX=10;
			}
			me.addCls("attachmentsTabBody");
			var btnDragDrop=me.gridConfig.grid.down("#dragDropAttachemnt");
			btnDragDrop.setIconCls('dragOver');
			btnDragDrop.setText(getText('item.tabs.attachment.drop'))
			btnDragDrop.setDisabled(false);
		}, false);
		domEl.addEventListener("dragexit",  function(evt){
			evt.stopPropagation();
			evt.preventDefault();
			me.removeCls("attachmentsTabBody");
			var btnDragDrop=me.gridConfig.grid.down("#dragDropAttachemnt");
			btnDragDrop.setIconCls('drag');
			btnDragDrop.setText(getText('item.tabs.attachment.dragDrop'))
			btnDragDrop.setDisabled(true);
		}, false);
		domEl.addEventListener("dragover",  function(evt){
			evt.stopPropagation();
			evt.preventDefault();
		}, false);
		domEl.addEventListener("drop",  function(evt){
			evt.stopPropagation();
			evt.preventDefault();
			me.removeCls("attachmentsTabBody");
			var btnDragDrop=me.gridConfig.grid.down("#dragDropAttachemnt");
			btnDragDrop.setIconCls('drag');
			btnDragDrop.setDisabled(true);
			btnDragDrop.setText(getText('item.tabs.attachment.dragDrop'))
			var files = evt.dataTransfer.files;
			if(files&&files.length>0){
				me.sendingFile(files);
			}
		}, false);
	},
	sendingFile:function(files){
		var me=this;
		var formData = new FormData();
		for (var i = 0; i < files.length; i++) {
			formData.append('theFile', files[i]);
		}
		// now post a new XHR request
		var xhr = new XMLHttpRequest();
		var urlStr='saveAttachment.action';
		urlStr+='?workItemID='+me.workItemID+'&lastModified='+me.lastModified;
		urlStr+='&projectID='+me.projectID;
		urlStr+='&issueTypeID='+me.issueTypeID;
		xhr.open('POST', urlStr);
		xhr.onload = function () {
			if (xhr.status === 200) {
				me.setLoading('Uploading: 100%');
				me.setLoading(false);
				me.refresh();
			} else {
				alert('Something went terribly wrong...');
				me.setLoading(false);
			}
		};
		xhr.onerror=function(e){
			me.setLoading(false);
			alert("error:"+e);
		};
		xhr.upload.onprogress = function (event) {
			if (event.lengthComputable) {
				var complete = (event.loaded / event.total * 100 | 0);
				me.setLoading('Uploading: '+complete+'%');
			}
		};
		xhr.onerror=function(e){
			me.setLoading(false);
			alert("error:"+e);
		}
		me.setLoading('Uploading...');
		xhr.send(formData);
	},
	createAttachmentsConfig:function(){
		var me=this;
		if(me.jsonData){
			me.readOnly=me.jsonData.readOnly;
		}
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="attachmentsTab";
		gridConfig.id=3;
		gridConfig.urlStore='itemAttachments.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID="+me.issueTypeID;
		gridConfig.fields=[
			{name:'id', type:'int'},
			{name:'fileName', type:'string'},
			{name:'fileSize', type:'int'},
			{name:'description', type:'string'},
			{name:'date', type:'date', dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat},
			{name:'author', type:'string'},
			{name:'authorID', type:'string'},
			{name: 'editable', type: 'boolean'},
			{name: 'thumbnail', type: 'boolean'},
			{name: 'isURL', type: 'boolean'}
		];
		gridConfig.selectionModel = Ext.create('Ext.selection.CheckboxModel', {
			listeners: {
				selectionchange: function(sm, selections) {
					var btnDelete=me.gridConfig.grid.down("#deleteAttachmentBtn");
					var btnEdit=me.gridConfig.grid.down("#editAttachmentBtn");
					var btnDownload=me.gridConfig.grid.down("#downloadAttachmentBtn");
					if(CWHF.isNull(selections)||selections.length===0){
						btnDelete.setDisabled(true);
						btnEdit.setDisabled(true);
						btnDownload.setDisabled(true);
					}else{
						btnDownload.setDisabled(false);
						if(selections.length===1){
							var rowData=selections[0].data;
							btnEdit.setDisabled(me.readOnly||rowData.editable===false);
							btnDelete.setDisabled(me.readOnly||rowData.editable===false);
							if(selections[0].data.isURL) {
								btnDownload.setDisabled(true);
							}
						}else{
							btnEdit.setDisabled(true);
							var enableDelete=false;
							var disableDownload = false;
							for(var i=0;i<selections.length;i++){
								var rowData=selections[i].data;
								if(!me.readOnly&&rowData.editable===true){
									enableDelete=true;
								}
								if(rowData.isURL) {
									disableDownload = true;
								}
							}
							btnDelete.setDisabled(!enableDelete);
							btnDownload.setDisabled(disableDownload);
						}
					}
				}
			}
		});
		//toolbar
		var tbarArray=new Array();
		tbarArray.push({
			text:getText('common.btn.add'),
			itemId:"addAttachmentBtn",
			disabled:me.readOnly,
			iconCls:'add16',
			handler:function(){
				me.addAttachment.call(me);
			}
		});
		tbarArray.push({
			text:getText('item.tabs.attachment.addScreenshot'),
			itemId:"addScreenshotBtn",
			disabled:me.readOnly,
			iconCls:'add16',
			handler:function(){
				me.addScreenshot.call(me);
			}
		});
		tbarArray.push({
			text: getText('item.tabs.attachment.addLink'),
			itemId:"addLinkBtn",
			disabled: me.readOnly,
			iconCls:'add16',
			handler:function(){
				me.addLink.call(me);
			}
		});
		tbarArray.push({
			text:getText('common.btn.delete'),
			itemId:"deleteAttachmentBtn",
			disabled:true,
			iconCls:'delete16',
			handler:function(){
				me.deleteItems.call(me);
			}
		});
		tbarArray.push({
			text:getText('common.btn.edit'),
			itemId:"editAttachmentBtn",
			disabled:true,
			iconCls:'edit16',
			handler:function(){
				me.editAttachment.call(me);
			}
		});
		tbarArray.push('-');
		tbarArray.push({
			text:getText('common.btn.download'),
			itemId:"downloadAttachmentBtn",
			disabled:true,
			iconCls:'download16',
			handler:function(){
				me.downloadAttachment.call(me);
			}
		});
		if(me.dropFileSupported===true){
			tbarArray.push({
				text:getText('item.tabs.attachment.dragDrop'),
				itemId:'dragDropAttachemnt',
				iconCls:'drag',
				disabled:true
			});
		}
		gridConfig.tbar=tbarArray;
		gridConfig.dblClickHandler=me.editAttachment;
		gridConfig.updateCol=function(col,layout,index){
			if(layout.dataIndex==='description'){
				col.flex=1;
			}
			if(layout.dataIndex==='fileName'){
				col.renderer =  function(value, metaData, record, row, col, store, gridView){
					if(record.data.isURL) {
						var synopsisClass='synopsis_blue newWindow';
						return '<a href="'+ record.data.fileName + '" class="'+synopsisClass + '" target = "_blank">'+record.data.fileName +'</a>';
					}else {
						return record.data.fileName;
					}
				 }
			}
		};
		/*if(newItem){
		 refreshGridSize(attachmentsGridConfig);
		 }*/
		/*
		 */
		return gridConfig;
	},
	refreshCallback:function(r,options,success){
		var me=this;
		var size=r.length;
		me.setTitle(me.replaceTitleNumber(me.title,size));
	},
	addAttachment:function() {
		var me=this;
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=getText("item.tabs.attachment.lbl.add");
		//url:addAttachment
		dialogCfg.formPanel=Ext.create('Ext.form.Panel', {
			itemId :'editAttachment',
			//autoScroll:true,
			layout:'anchor',
			border	: false,
			url: 'saveAttachment.action?lastModified='+me.lastModified,
			margin: '0 0 0 0',
			padding:0,
			bodyPadding:0,
			/*style:{
			 padding:'0px 0px 0px 0px'
			 },
			 bodyStyle:{
			 padding:'0px 0px 0px 0px'
			 },
			 /*style:{
			 borderBottom:'1px solid #D0D0D0'
			 },*/
			fileUpload: true,
			items:[
				{
					xtype: 'component',
					html: getText('item.tabs.attachment.explanation',me.jsonData.maxSize),
					anchor: '100%',
					border:true,
					cls: 'infoBox_bottomBorder'
				},{
					xtype: 'filefield',
					name: 'theFile',
					fieldLabel: getText('item.tabs.attachment.lbl.file'),
					labelWidth: 75,
					labelAlign:me.labelHAlign,
					msgTarget: 'side',
					allowBlank: false,
					anchor: '100%',
					buttonText: getText('common.btn.choose'),
					style:{
						marginTop:'5px',
						marginLeft:'10px',
						marginRight:'10px'
					}
				},{
					xtype:'textarea',
					fieldLabel: getText('common.lbl.description'),
					name:'description',
					labelWidth: 75,
					labelAlign:me.labelHAlign,
					height:75,
					anchor: '100% -90',
					style:{
						marginLeft:'10px',
						marginRight:'10px'
					}
				}
			]
		});
		dialogCfg.layout="fit";
		dialogCfg.w=500;
		dialogCfg.h=275;
		dialogCfg.minw=450;
		dialogCfg.minh=200;
		dialogCfg.autoScroll=false;
		dialogCfg.iconCls='attachment16';
		dialogCfg.successHandler=function(result){
			//ATTACHMENT_SYMBOL = -1001;
			var lastModified=result.data.lastModified;
			me.fireItemChange([-1001, 15],lastModified);
			me.refresh.call(me);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	},
	editAttachment:function(){
		var me=this;
		var selections=me.gridConfig.grid.getSelectionModel().getSelection();
		if(CWHF.isNull(selections)){
			return;
		}
		var rowData=selections[0].data;
		if(me.readOnly||rowData.editable===false){
			return;
		}
		var originalDescription=rowData.description;
		var attachmentID=rowData.id;
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=com.trackplus.TrackplusConfig.getText("item.tabs.attachment.lbl.edit");
		dialogCfg.formPanel=Ext.create('Ext.form.Panel', {
			itemId :'editAttachment',
			region:'center',
			layout:'anchor',
			url: 'editAttachment.action?attachmentID='+attachmentID+'&lastModified='+me.lastModified,
			autoScroll:false,
			fileUpload: true,
			margin: '0 0 0 0',
			border:false,
			bodyStyle:{
				padding:'10px'
			},
			/*style:{
			 borderBottom:'1px solid #D0D0D0'
			 },*/
			items:[
				{
					xtype:'textarea',
					fieldLabel:getText('common.lbl.description'),
					name:'description',
					labelWidth: 75,
					labelAlign:'right',
					value:originalDescription,
					height:75,
					anchor: '100%'
				}
			]
		});
		dialogCfg.w=500;
		dialogCfg.h=175;
		dialogCfg.autoScroll=false;
		dialogCfg.iconCls='attachment16';
		dialogCfg.successHandler=function(result){
			//ATTACHMENT_SYMBOL = -1001;
			var lastModified=result.data.lastModified;
			me.fireItemChange([-1001, 15],lastModified);
			me.refresh.call(me);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	},
	downloadAttachment:function(){
		var me=this;
		var selections=me.gridConfig.grid.getSelectionModel().getSelection();
		//var row=attachmentsGridConfig.grid.getSelectionModel().getSelected();
		if(CWHF.isNull(selections)||selections.length===0){
			return;
		}
		var row;
		var i;
		for(i=0;i<selections.length;i++){
			row=selections[i];
			var attachID=row.data.id;
			var attachmentURI;
			if(CWHF.isNull(me.workItemID)){
				attachmentURI='downloadAttachment.action?attachKey='+attachID;
			}else{
				attachmentURI='downloadAttachment.action?workItemID='+me.workItemID+'&attachKey='+attachID;
			}
			if(i===0){
				window.open(attachmentURI,'attachmentWindow');
			}else{
				window.open(attachmentURI);
			}
		}
	},
	addScreenshot:function(){
		var me=this;
		/*var javaEnabled=navigator.javaEnabled();
		 if(javaEnabled===false){
		 alert(msgAppletNotSupported);
		 return false;
		 }*/
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=getText("item.tabs.attachment.addScreenshot");
		dialogCfg.formPanel=Ext.create('Ext.form.Panel', {
			//region:'center',
			url: 'saveScreenshot.action',
			border	: false,
			autoScroll:true,
			margin: '0 0 0 0',
			bodyPadding:0,
			bodyStyle:{
				padding:'0px'
			},
			/*style:{
			 borderBottom:'1px solid #D0D0D0'
			 }, */
			defaults:{
				minWidth:550
			},
			items:[
				{
					xtype:'hidden',
					name:'bytes',
					id:'input_bytes'
				},{
					xtype: 'component',
					cls: 'infoBox_bottomBorder',
					border:true,
					html: getText('item.tabs.attachment.addScreenshot.explanation')
				},{
					xtype:'panel',
					layout:{
						type:'hbox'
					},
					border:false,
					bodyBorder:false,
					anchor:'100%',
					margin:'0 0 0 0',
					padding:0,
					items:[
						{
							xtype:'panel',
							border:false,
							bodyBorder:false,
							layout:'anchor',
							width:320,
							items:[
								Ext.create('Ext.form.FieldSet',{
									margin: '5 10 0 10',
									padding:3,
									width:310,
									title:getText('item.tabs.attachment.lbl.preview'),
									html:'<applet id="AddScreenshotApplet" code="com.trackplus.screenshot.AddScreenshotApplet"'+
										'archive="Screenshot.jar,commons-codec-1.5.jar" codebase="applet"	width="300" height="200" style="background-color:white">'+
										'<param name="prefWidth" value="300">'+
										'<param name="prefHeight" value="200">'+
										'<param name="permissions" value="all-permissions" />'+
										getText('item.tabs.attachment.addScreenshot.appletNotSupported')+
										'</applet>'
								}),
								Ext.create('Ext.panel.Panel',{
									layout:{
										type:'hbox'
									},
									border:false,
									bodyBorder:false,
									margin: '0 10 0 10',
									items:[
										Ext.create('Ext.Button', {
											text:getText('common.btn.paste'),
											iconCls:'copy16',
											handler:me.paste,
											margin:'5 5 5 0',
											scope:me
										}),
										Ext.create('Ext.Button', {
											text:getText('common.btn.clear'),
											iconCls:'delete16',
											handler:me.clearApplet,
											margin:'5 5 5 5',
											scope:me
										})
									]
								})
							]
						},{
							xtype:'panel',
							border:false,
							bodyBorder:false,
							flex:1,
							layout:'anchor',
							height:235,
							items:[
								{
									xtype:'textfield',
									fieldLabel: getText('item.tabs.attachment.lbl.file'),
									labelWidth: 75,
									labelAlign:'right',
									margin:'15 10 5 10',
									anchor: '100%',
									value:'screenshot',
									name:'file'
								},{
									xtype:'textarea',
									fieldLabel: getText('common.lbl.description'),
									name:'description',
									labelWidth: 75,
									margin:'5 10 10 10',
									labelAlign:'right',
									anchor: '100% -35'
								}
							]
						}
					]
				}
			]
		});
		dialogCfg.w=750;
		dialogCfg.h=400;
		dialogCfg.autoScroll=false;
		dialogCfg.layout='fit';
		dialogCfg.iconCls='attachment16';
		dialogCfg.validate=me.updateBytes;
		dialogCfg.successHandler=function(result){
			//ATTACHMENT_SYMBOL = -1001;
			var lastModified=result.data.lastModified;
			me.fireItemChange([-1001, 15],lastModified);
			me.refresh.call(me);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	},
	paste:function() {
		var CLIPBOARD_STATUS_OK=0;
		var CLIPBOARD_STATUS_EMPTY=1;
		var CLIPBOARD_STATUS_NOT_SUPPORTED=2;
		var CLIPBOARD_STATUS_UNKNOW=3;
		var javaEnabled=navigator.javaEnabled();
		var msgAppletNotSupported=getText('item.tabs.attachment.addScreenshot.appletNotSupported');
		var msgEmptyClipboard=getText('item.tabs.attachment.addScreenshot.emptyClipbaord');
		var msgClipboardNotSupported=getText('item.tabs.attachment.addScreenshot.clipboardNotSupported');
		var msgUnknownError=getText('item.tabs.attachment.addScreenshot.unknownError');
		if(javaEnabled===false){
			CWHF.showMsgError(msgAppletNotSupported);
			return false;
		}
		try {
			var applet = document.getElementById("AddScreenshotApplet");
			var err = applet.pasteFromClipboard();
			switch( err ) {
				case CLIPBOARD_STATUS_OK:
					break;
				case CLIPBOARD_STATUS_EMPTY:
					CWHF.showMsgError(msgEmptyClipboard);
					break;
				case CLIPBOARD_STATUS_NOT_SUPPORTED:
					CWHF.showMsgError(msgClipboardNotSupported);
					break;
				case CLIPBOARD_STATUS_UNKNOW:
					CWHF.showMsgError(msgUnknownError);
					break;
				default:
					CWHF.showMsgError( "Unknown error code: "+err );
			}
		}catch( e ) {
			CWHF.showMsgError(e);
			throw e;
		}
		return false;
	},
	clearApplet:function(){
		var me=this;
		var javaEnabled=navigator.javaEnabled();
		if(javaEnabled===false){
			CWHF.showMsgError(msgAppletNotSupported);
			return false;
		}
		document.getElementById('AddScreenshotApplet').clear();
		return false;
	},
	updateBytes:function() {
		var me=this;
		var msgNoData=getText('item.tabs.attachment.addScreenshot.noData');
		var cmpBytes=Ext.getCmp("input_bytes");
		cmpBytes.setValue(null);
		var applet = document.getElementById( "AddScreenshotApplet" );
		var bytes = applet.getEncodedString();
		if(CWHF.isNull(bytes)||bytes===""){
			CWHF.showMsgError(msgNoData);
			return false;
		}
		cmpBytes.setValue(bytes);
		return true;
	},
	addLink: function() {
		var me=this;
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=getText("item.tabs.attachment.lbl.add");
		//url:addAttachment
		dialogCfg.formPanel=Ext.create('Ext.form.Panel', {
			itemId :'editAttachment',
			//autoScroll:true,
			layout:'anchor',
			border	: false,
			url: 'saveAttachment!saveLink.action?lastModified='+me.lastModified,
			margin: '0 0 0 0',
			padding:0,
			bodyPadding:0,
			fileUpload: true,
			items:[
			   {
					xtype:'textfield',
					fieldLabel: 'Url',
					name:'theUrl',
					labelWidth: 75,
					labelAlign:me.labelHAlign,
					anchor: '100%',
					allowBlank: false,
					margin: '18 15 0 0',
					vtype:'url',
					style:{
						marginLeft:'10px',
						marginRight:'10px'
					}
				},{
					xtype:'textarea',
					fieldLabel: getText('common.lbl.description'),
					name:'description',
					labelWidth: 75,
					labelAlign:me.labelHAlign,
					height:75,
					anchor: '100% -90',
					margin: '10 15 0 0',
					style:{
						marginLeft:'10px',
						marginRight:'10px'
					}
				}
			]
		});
		dialogCfg.layout="fit";
		dialogCfg.w=500;
		dialogCfg.h=275;
		dialogCfg.minw=450;
		dialogCfg.minh=200;
		dialogCfg.autoScroll=false;
		dialogCfg.iconCls='attachment16';
		dialogCfg.successHandler=function(result){
			//ATTACHMENT_SYMBOL = -1001;
			var lastModified=result.data.lastModified;
			me.fireItemChange([-1001, 15],lastModified);
			me.refresh.call(me);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.CommentsTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	readOnly:false,
	cls:'ulist',
	urlDeleteItems:'deleteComments.action',
	fieldsToNotifyOnDelete:[23, 15],
	initComponent : function(){
		var me = this;
		var commentNumber=0;
		if(me.jsonData.commentNumber){
			commentNumber=me.jsonData.commentNumber;
		}
		me.title=getText('item.tabs.comment.lbl.title')+" ("+commentNumber+")";
		// me.iconCls='comment16';
		me.gridConfig=me.createCommentsConfig();
		me.callParent();
	},
	refreshCallback:function(r,options,success){
		var me=this;
		var size=r.length;
		me.setTitle(me.replaceTitleNumber(me.title,size));
	},
	createCommentsConfig:function(){
		var me=this;
		if(me.jsonData){
			me.readOnly=me.jsonData.readOnly;
		}
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="commentsTab";
		gridConfig.id=2;
		gridConfig.urlStore='itemComments.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID="+me.issueTypeID;
		gridConfig.fields=[
			{name: 'id',type: 'int'},
			{name: 'date',type: 'date',  dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat},
			{name: 'author',type: 'string'},
			{name: 'authorID',type: 'string'},
			{name: 'comment',type: 'string'},
			{name: 'editable',type: 'bool'}
		];
		gridConfig.selectionModel = Ext.create('Ext.selection.CheckboxModel', {
			listeners: {
				selectionchange: function(sm, selections) {
					var btnDelete=me.gridConfig.grid.down("#deleteCommentBtn");
					var btnEdit=me.gridConfig.grid.down("#editCommentBtn");
					if(CWHF.isNull(selections)||selections.length===0){
						btnDelete.setDisabled(true);
						btnEdit.setDisabled(true);
					}else{
						if(selections.length===1){
							var rowData=selections[0].data;
							btnEdit.setDisabled(rowData.editable===false);
							btnDelete.setDisabled(rowData.editable===false);
						}else{
							btnEdit.setDisabled(true);
							var enableDelete=false;
							for(var i=0;i<selections.length;i++){
								var rowData=selections[i].data;
								if(rowData.editable===true){
									enableDelete=true;
									break;
								}
							}
							btnDelete.setDisabled(!enableDelete);
						}
					}
				}
			}
		});
		//toolbar
		gridConfig.tbar=[
			{
				text:com.trackplus.TrackplusConfig.getText('common.btn.add'),
				disabled:me.readOnly,
				iconCls:'add16',
				handler:function(){
					me.addComment.call(me);
				}
			},{
				text:com.trackplus.TrackplusConfig.getText('common.btn.delete'),
				itemId:"deleteCommentBtn",
				disabled:true,
				iconCls:'delete16',
				handler:function(){
					me.deleteItems.call(me);
				}
			},{
				text:com.trackplus.TrackplusConfig.getText('common.btn.edit'),
				itemId:"editCommentBtn",
				disabled:true,
				iconCls:'edit16',
				handler:function(){
					me.editComment.call(me);
				}
			}
		];
		gridConfig.dblClickHandler=me.editComment;
		gridConfig.updateCol=function(col,layout,index){
			if(layout.dataIndex==='comment'){
				col.flex=1;
			}
		};
		return gridConfig;
	},
	addComment:function(){
		this.openEditComment();
	},
	editComment:function(){
		var me=this;
		if(me.gridConfig.grid.getStore().getCount()===1){
			//commentsGridConfig.grid.getSelectionModel().selectFirstRow();
		}
		var selections=me.gridConfig.grid.getSelectionModel().getSelection();
		if(CWHF.isNull(selections)){
			return;
		}
		var rowData=selections[0].data;
		var	localizedComment=com.trackplus.TrackplusConfig.getText('common.history.lbl.comment');
		if(rowData.editable===false){
			com.trackplus.util.showHtmlDetail(localizedComment,rowData.comment);
			return;
		}
		//var originalComment=rowData.comment;
		var commentID=rowData.id;
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: "itemDetail!editComment.action",
			params:{commentID:commentID},
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				var jsonData=responseJson.data;
				var originalComment=jsonData.comment;
				borderLayout.setLoading(false);
				me.openEditComment(originalComment,commentID);
			},
			failure: function(){
				borderLayout.setLoading(false);
			},
			method:'POST'
		});
	},
	openEditComment:function(originalValue,commentID){
		var me=this;
		var commentCfg={
			anchor:'100%',
			allowBlank:false,
			cls:'rteField ckeField100Percent'
		};
		if(originalValue){
			commentCfg.value=originalValue;
		}
		var ckeditorCfg={
			workItemID:me.workItemID,
			projectID:me.projectID,
			useInlineTask:true,
			useBrowseImage:true
		}
		me.txtArea=CWHF.createRichTextEditorField('comment',commentCfg,true,true,ckeditorCfg);
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=com.trackplus.TrackplusConfig.getText("item.tabs.comment.lbl.edit");
		var urlSave='saveComment.action?lastModified='+me.lastModified;
		if(commentID){
			urlSave+='&commentID='+commentID;
		}
		dialogCfg.formPanel=Ext.create('Ext.form.Panel', {
			cls:'ckeditor100Percent-noBorder',
			itemId :'editCommentForm',
			border	: false,
			bodyBorder: false,
			layout:'fit',
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'0px'
			},
			/*style:{
			 borderBottom:'1px solid #D0D0D0'
			 },*/
			url: urlSave,
			items:[me.txtArea]
		});
		dialogCfg.w=850;
		dialogCfg.h=300;
		dialogCfg.layout="fit";
		dialogCfg.autoScrol=false;
		dialogCfg.iconCls='comment16';
		dialogCfg.successHandler=function(result){
			var lastModified=result.data.lastModified;
			me.fireItemChange([23, 15],lastModified);
			me.refresh();
		};
		dialogCfg.validate=function(){
			var idDescription=me.txtArea.id+'-inputEl';
			var o=CKEDITOR.instances[idDescription];
			if(o){
				o.updateElement();
			}
			var form=this.formPanel.getForm();
			return (form.isValid());
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//History tab class
Ext.define('com.aurel.trackplus.itemDetail.HistoryTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	cls:'ulist',
	historyFull:true,
	showCommentsHistory:true,
	showFlatHistory:false,
	flatPanel:null,
	initComponent : function(){
		var me = this;
		me.title=getText('item.printItem.lbl.tab.commonHistory');
		// me.iconCls='history16';
		me.gridConfig=me.createHistoryConfig();
		var toolbarItems=new Array();
		//var btnFlatHistory=me.createViewButton('flatHistory','flatHistory',getText('common.history.lbl.flatHistory'),
		//	getText('common.history.lbl.flatHistory.tlt'));
		var btnGridHistory=me.createViewButton('gridHistory','gridHistory',getText('common.history.lbl.gridHistory'),
			getText('common.history.lbl.gridHistory.tlt'));
		if(me.showFlatHistory===true){
			btnGridHistory.pressed=false;
		}else{
			btnGridHistory.pressed=true;
		}
		//toolbarItems.push(btnFlatHistory);
		toolbarItems.push(btnGridHistory);
		if(me.historyFull){
			btnLabel=com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.collapse");
			iconCls='collapse16';
		}else{
			btnLabel=com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.expand");
			iconCls='expand16';
		}
		me.btnExpandCollapse=Ext.create('Ext.button.Button',{
			itemId:"expandCollapseHistoryBtn",
			text:btnLabel,
			iconCls:iconCls,
			handler:function(){
				me.expandCollapseHistory.call(me);
			},
			hidden:me.showFlatHistory
		})
		toolbarItems.push(me.btnExpandCollapse);
		if(me.showCommentsHistory){
			btnLabel=com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.hideComments");
			iconCls='collapse16';
		}else{
			btnLabel=com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.showComments");
			iconCls='expand16';
		}
		me.btnComments=Ext.create('Ext.button.Button',{
			itemId:"showHideCommentsBtn",
			text:btnLabel,
			iconCls:iconCls,
			handler:function(){
				me.showHideCommentsHistory.call(me);
			},
			hidden:me.showFlatHistory
		});
		toolbarItems.push(me.btnComments);
		me.dockedItems=[{
			xtype: 'toolbar',
			dock: 'top',//'bottom'
			items:toolbarItems,
			border:false
		}];
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=[];
		if(me.showFlatHistory===true){
			me.initFlatPanel();
			items.push(me.flatPanel);
		}else{
			if(me.gridConfig&&me.jsonData&&me.jsonData.gridLayoutData){
				var someGrid=me.createGrid.call(me,me.gridConfig,me.jsonData.gridLayoutData);
				me.gridConfig.grid=someGrid;
				items.push(someGrid);
			}
		}
		return items;
	},
	createHistoryConfig:function(){
		if(this.jsonData){
			this.historyFull=this.jsonData.historyFull;
			this.showCommentsHistory=this.jsonData.showCommentsHistory;
			this.showFlatHistory=this.jsonData.showFlatHistory;
		}
		var me=this;
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="historyTab";
		gridConfig.id=1;
		gridConfig.urlStore='itemHistory.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID"+me.issueTypeID;
		gridConfig.fields=[
			{name: 'id',type:'int'},
			{name: 'date',type: 'date', dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat},
			{name: 'author',type:'string'},
			{name: 'authorID',type:'string'},
			{name: 'typeOfChange',type:'string'},
			{name: 'newValues', type: 'string'},
			{name: 'newValuesFull', type: 'string'},
			{name: 'oldValues', type: 'string'},
			{name: 'oldValuesFull', type: 'string'},
			{name: 'comment', type: 'string'},
			{name: 'commentFull', type: 'string'},
			{name: 'diff', type: 'string'},
			{name: 'diffFull', type: 'string'}
		];
		gridConfig.cellClickHandler=me.cellClickHistory;
		return gridConfig;
	},
	createViewButton:function(id,iconCls,txt,tooltip){
		var me=this;
		return Ext.create('Ext.button.Button',{
			//itemId:id,
			iconCls:iconCls,
			enableToggle:true,
			allowDepress:true,
			toggleGroup:'itemDetailHistoryViewGroup',
			text:txt,
			overflowText :txt,
			tooltip :tooltip,
			handler:function(){
				me.changeViewMode();
			},
			scope:me
		});
	},
	changeViewMode:function(id){
		var me=this;
		if(me.showFlatHistory===false){
			me.showFlatHistory=true;
			if(me.gridConfig.grid){
				me.remove(me.gridConfig.grid,true);
				me.gridConfig.grid=null;
			}
			me.initFlatPanel();
			me.add(me.flatPanel);
			me.refreshFlatHistory();
		}else{
			me.showFlatHistory=false;
			if(me.flatPanel){
				me.remove(me.flatPanel);
				me.flatPanel=null;
			}
			me.refresh();
			me.add(me.gridConfig.grid);
		}
		me.btnExpandCollapse.setVisible(!me.showFlatHistory);
		me.btnComments.setVisible(!me.showFlatHistory);
		me.showHideFlatHistory();
	},
	refreshFlatHistory:function(){
		var me=this;
		if(me.flatPanel){
			me.flatPanel.setLoading(true);
		}
		Ext.suspendLayouts();
		//var urlStr='itemHistory.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID"+me.issueTypeID;
		var urlStr='itemDetailHistory.action?workItemID='+me.workItemID;
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(response){
				//var responseJson = Ext.decode(response.responseText);
				//var jsonData=responseJson;
				me.flatData=response.responseText;
				if(me.flatPanel){
					me.flatPanel.setLoading(false);
				}
				me.initFlatPanel();
				Ext.resumeLayouts(true);
			},
			failure: function(){
				Ext.resumeLayouts(true);
			},
			method:'POST',
			params:{includeLayout:false,tabID:me.gridConfig.id}
		});
	},
	cellClickHistory:function(grid, td, cellIndex, record, tr, rowIndex, e, eOpts){
		var me=this;
		var row=grid.getStore().getAt(rowIndex);
		var dataIndex = grid.getHeaderCt().getHeaderAtIndex(cellIndex).dataIndex;
		if (dataIndex==="oldValues"&&row.data.oldValuesFull&&row.data.oldValuesFull.length>0){
			me.showHtmlDetail(getText("common.history.lbl.oldValue"),row.data.oldValuesFull);
		}
		if (dataIndex==="newValues"&&
			row.data['newValuesFull']&&row.data['newValuesFull'].length>0){
			me.showHtmlDetail(getText("common.history.lbl.newValue"),row.data.newValuesFull);
		}
		if (dataIndex==="comment"&&
			row.data.commentFull&&row.data.commentFull.length>0){
			me.showHtmlDetail(getText("common.history.lbl.comment"),row.data.commentFull);
		}
		if (dataIndex==="diff"&&
			row.data.diffFull&&row.data.diffFull.length>0){
			me.showHtmlDetail(getText("common.history.lbl.comment"),row.data.diffFull);
		}
	},
	win:null,
	showHtmlDetail:function(title,htmlContent){
		var me=this;
		if(me.win){
			me.win.destroy();
		}
		htmlDinamicContent=htmlContent;
		var htmlFrameWrapper='<iframe allowtransparency="true" frameborder="0" width="100%" style="height:100%;background-color: transparent;"  '+
			'src="richTextPreview.action"></iframe>';
		var panel=Ext.create('Ext.panel.Panel',{
			collapsible:false,
			autoWidth:true,
			autoHeight:true,
			bodyBorder:false,
			bodyPadding:'5 5 5 5',
			autoScroll:true,
			border:false,
			id:"panelContent",
			html:htmlFrameWrapper
		});
		me.win = new Ext.Window({
			layout      : 'fit',
			iconCls:'history16',
			width       : 550,
			height      : 350,
			closeAction :'destroy',
			plain       : true,
			title       :title,
			modal       :true,
			items       :panel,
			autoScroll  :true,
			buttons:[{
				text : getText('common.btn.close'),
				itemId:'btnClose',
				handler  : function(){
					me.win.hide();
					me.win.destroy();
				}
			}],
			listeners:{
				show:function( win, eOpts ){
					win.down('#btnClose').focus(false,150);
				}
			}
		});
		me.win.show();
	},
	expandCollapseHistory:function(){
		var me=this;
		me.historyFull=!me.historyFull;
		Ext.Ajax.request({
			url: "userPreferences.action?property=historyFull&value="+me.historyFull,
			disableCaching:true,
			success: function(data){
				me.refresh();
			},
			failure: function(type, error){
			}
		});
	},
	showHideCommentsHistory:function(){
		var me=this;
		me.showCommentsHistory=!me.showCommentsHistory;
		Ext.Ajax.request({
			url: "userPreferences.action?property=showCommentsHistory&value="+me.showCommentsHistory,
			disableCaching:true,
			success: function(data){
				me.refresh();
			},
			failure: function(type, error){
			}
		});
	},
	showHideFlatHistory:function(){
		var me=this;
		Ext.Ajax.request({
			url: "userPreferences.action?property=showFlatHistory&value="+me.showFlatHistory,
			disableCaching:true,
			success: function(data){
			},
			failure: function(type, error){
			}
		});
	},
	refresh:function(){
		var me=this;
		if(me.showFlatHistory===true){
			me.refreshFlatHistory();
		}else{
			me.callParent();
		}
	},
	refreshCallback:function(r,options,success){
		var me=this;
		if(success===false){
			return;
		}
		if(me.historyFull){
			me.btnExpandCollapse.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.collapse"));
			me.btnExpandCollapse.setIconCls('collapse16');
		}else{
			me.btnExpandCollapse.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.expand"));
			me.btnExpandCollapse.setIconCls('expand16');
		}
		var btnShowHideComments=me.gridConfig.grid.down("#showHideCommentsBtn");
		if(me.showCommentsHistory){
			me.btnComments.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.hideComments"));
			me.btnComments.setIconCls('collapse16');
		}else{
			me.btnComments.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.showComments"));
			me.btnComments.setIconCls('expand16');
		}
		/*var btnShowHideFlatHistory=me.gridConfig.grid.down("#showHideFlatHistoryBtn");
		 if(me.showFlatHistory){
		 btnShowHideFlatHistory.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.hideFlatHistory"));
		 btnShowHideFlatHistory.setIconCls('collapse16');
		 }else{
		 btnShowHideFlatHistory.setText(com.trackplus.TrackplusConfig.getText("item.tabs.history.lbl.showFlatHistory"));
		 btnShowHideFlatHistory.setIconCls('expand16');
		 }*/
	},
	initFlatPanel:function(){
		var me=this;
		var html="";
		if(me.flatData/*&&me.flatData.length>0*/){
			html=me.flatData;
		}
		if(CWHF.isNull(me.flatPanel)){
			me.flatPanel=Ext.create('Ext.Component',{
				style:{
					borderTop:'1px solid #D0D0D0'
				},
				cls:'flatHistoryPanel',
				html:html
			});
		}else{
			me.flatPanel.update(html);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.LinksTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	urlDeleteItems:'itemLink!deleteLinks.action',
	fieldsToNotifyOnDelete:[19,20,-1009],
	readOnly:false,
	cmbLinkType:null,
	formPanel:null,
	//the visible item number: either global or project specific
	txtIssueNo:null,
	//the global item number
	hiddenIssueNo:null,
	txtSynopsis:null,
	keepSelection: false,
	btnAddLink:null,btnDeleteLink:null,btnEditLink:null,
	initComponent : function(){
		var me = this;
		var linkNumber=0;
		if(me.jsonData.linkNumber){
			linkNumber=me.jsonData.linkNumber;
		}
		me.title=getText('item.printItem.lbl.tab.links')+" ("+linkNumber+")";
		// me.iconCls='links16';
		me.gridConfig=me.createLinkConfig();
		me.callParent();
	},
	refreshCallback:function(r,options,success){
		var me=this;
		var size=r.length;
		me.setTitle(me.replaceTitleNumber(me.title,size));
		me.onSelectionChange(me.gridConfig.grid, me.gridConfig.grid.getSelectionModel().getSelection());
	},
	createLinkConfig:function(){
		var me=this;
		if(me.jsonData){
			me.readOnly=me.jsonData.readOnly;
		}
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="linksTab";
		gridConfig.id=7;
		gridConfig.urlStore='itemLink.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID="+me.issueTypeID;
		gridConfig.fields=[
			{name: 'id',type:'int'},
			{name: 'linkTypeID',type:'int'},
			{name: 'linkType',type:'string'},
			{name: 'workItemID',type:'int'},
			{name: 'itemID',type:'string'},
			{name: 'itemTitle',type: 'string'},
			{name: 'itemStatus',type: 'string'},
			{name: 'itemResponsible',type: 'string'},
			{name: 'parameters',type:'string'},
			{name: 'comment',type:'string'},
			{name: 'editable', type: 'boolean'}
		];
		me.btnAddLink=Ext.create('Ext.button.Button',{
			text:getText('common.btn.add'),
			disabled:me.readOnly,
			iconCls:'add16',
			tooltip:getText('item.tabs.itemLink.lbl.add'),
			handler:function(){
				me.addLink.call(me);
			}
		});
		me.btnDeleteLink=Ext.create('Ext.button.Button',{
			text:getText('common.btn.delete'),
			itemId:"deleteLinkBtn",
			disabled:true,
			iconCls:'delete16',
			handler:function(){
				me.deleteItems.call(me);
			}
		});
		me.btnEditLink=Ext.create('Ext.button.Button',{
			text:getText('common.btn.edit'),
			itemId:"editLinkBtn",
			disabled:true,
			iconCls:'edit16',
			handler:function(){
				me.editLink.call(me);
			}
		});
		me.btnUpLink=Ext.create('Ext.button.Button',{
			text:getText("common.btn.up"),
			tooltip: getText("item.tabs.itemLink.lbl.moveUp"),
			itemId:"moveUpBtn",
			disabled:true,
			iconCls:"moveUp",
			handler:function(){
				me.onMoveUpGridRow.call(me);
			}
		});
		me.btnDownLink=Ext.create('Ext.button.Button',{
			text:getText("common.btn.down"),
			tooltip: getText("item.tabs.itemLink.lbl.moveDown"),
			itemId:"moveDownBtn",
			disabled:true,
			iconCls:"moveDown",
			handler:function(){
				me.onMoveDownGridRow.call(me);
			}
		});
		gridConfig.tbar=[me.btnAddLink,me.btnDeleteLink,me.btnEditLink,me.btnUpLink,me.btnDownLink];
		gridConfig.dblClickHandler=me.editLink;
		gridConfig.selectionModel = Ext.create('Ext.selection.CheckboxModel', {
			listeners: {
				selectionchange: { fn : this.onSelectionChange,
						scope : me}
			}
		});
		gridConfig.updateColCfg=function(colCfg,layout,index){
			if(layout.dataIndex==='itemID'||layout.dataIndex==='itemTitle'){
				colCfg.xtype='linkcolumn';
				colCfg.handler=me.clickOnLinkItem;
				colCfg.scope=me;
				return 'Ext.ux.LinkColumn';
			}
			return 'Ext.grid.column.Column';
		};
		return gridConfig;
	},
	getViewConfig: function() {
		return {
				stripeRows: true,
				plugins: {
					ptype: "gridviewdragdrop",
					dragGroup: "itemLink" + "gridDDGroup",
					dropGroup: "itemLink" + "gridDDGroup",
					enableDrag: true,
					enableDrop: true
				},
				listeners: {
					drop: {scope:this, fn: function(node, data, dropRec, dropPosition) {
						this.onGridDrop(node, data, dropRec, dropPosition);
						}
					}
				}
		};
	},
	/**
	 * Method called on selection change
	 */
	onSelectionChange: function(sm, selections) {
		var me=this;
		if(CWHF.isNull(selections)||selections.length===0){
			me.btnDeleteLink.setDisabled(true);
			me.btnEditLink.setDisabled(true);
			me.btnUpLink.setDisabled(true);
			me.btnDownLink.setDisabled(true);
		}else{
			if(selections.length===1) {
				var rowData=selections[0].data;
				var editable = rowData.editable;
				me.btnEditLink.setDisabled(!editable);
				me.btnDeleteLink.setDisabled(!editable);
				var grid = me.gridConfig.grid;
				var store = grid.getStore();
				if (store) {
					//the records are not equal after reloading the store, so it is tested for id equality
					me.btnDownLink.setDisabled(rowData.id===store.last().data.id || !editable);
					me.btnUpLink.setDisabled(rowData.id===store.first().data.id || !editable);
				}
			}else{
				me.btnEditLink.setDisabled(true);
				me.btnUpLink.setDisabled(true);
				me.btnDownLink.setDisabled(true);
				var enableDelete=false;
				var enableMoveUp = true;
				var enableMoveDown = true;
				var grid = me.gridConfig.grid;
				var store = grid.getStore();
				for(var i=0;i<selections.length;i++){
					var record = selections[i];
					var rowData=record.data;
					if (rowData.editable===true) {
						enableDelete=true;
						if (rowData.id===store.first().data.id) {
							enableMoveUp = false;
						}
						if (rowData.id===store.last().data.id) {
							enableMoveDown = false;
						}
						//break;
					} else {
						enableMoveUp = false;
						enableMoveDown = false;
						break;
					}
				}
				me.btnDeleteLink.setDisabled(!enableDelete);
				me.btnUpLink.setDisabled(!enableMoveUp);
				me.btnDownLink.setDisabled(!enableMoveDown);
			}
		}
	},
	getSelectedIDs:function(){
		var me=this;
		var ids=null;
		var grid = me.gridConfig.grid;
		var selections=grid.getSelectionModel().getSelection();
		if (selections && selections.length>0) {
			ids=[];
			for(var i=0;i<selections.length;i++){
				ids.push(selections[i].data["id"]);
			}
		}
		return ids;
	},
	clickOnLinkItem:function(record,cellIndex){
		var me=this;
		var workItemID=record.data['workItemID'];
		me.fireEvent("clickOnLink",workItemID);
	},
	createFormPanel:function(linkID){
		var me=this;
		me.cmbLinkType = CWHF.createCombo("item.tabs.itemLink.lbl.thisIssue", "linkTypeWithDirection",
			{labelWidth:150, anchor:'100%', idType:"string"}, {select:{fn:me.selectLinkType, scope:me, linkID:linkID, workItemID:me.workItemID}});
		me.txtIssueNo = CWHF.createTextField(null, "linkedNumber", {itemId:'linkedNumber', width: 100,margin:'0 5 0 0', readOnly:true/*, allowBlank:false*/});
		me.hiddenIssueNo = CWHF.createHiddenField("linkedWorkItemID",{itemId:"linkedWorkItemID"});
		me.txtSynopsis = CWHF.createTextField(null, "linkedWorkItemTitle", {itemId:'linkedWorkItemTitle', margin:'0 10 0 0', readOnly:true, columnWidth:1/*, allowBlank:false*/});
		me.txtDescription = CWHF.createTextAreaField("item.tabs.itemLink.lbl.comment", "description", {height:125, anchor:'100%', labelWidth:150});
		var btnSearch={
			xtype: 'button',text:getText('common.btn.search'),
			handler:function(){
				me.chooseItem.call(me);
			}
		};
		var urlStr= 'itemLink!saveItemLink.action';
		if(linkID){
			urlStr=urlStr+'?linkID='+linkID;
		}
		me.formPanel=Ext.create('Ext.form.Panel', {
			itemId :'editLink',
			region:'center',
			layout:'anchor',
			url: urlStr,
			autoScroll:true,
			border : false,
			margins: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			items:[
				me.cmbLinkType,
				{
					xtype: 'fieldcontainer',
					itemId: "linkedItem",
					fieldLabel: getText('item.tabs.itemLink.lbl.issue'),
					labelWidth:150,
					labelStyle:"overflow:hidden;",
					labelAlign:'right',
					layout:'column',
					anchor:'100%',
					defaults: {
						hideLabel: true
					},
					items: [me.hiddenIssueNo, me.txtIssueNo, me.txtSynopsis, btnSearch]
				},me.txtDescription
			]
		});
		return me.formPanel;
	},
	chooseItem:function(){
		var me=this;
		var workItemID=me.workItemID;
		var projectID=me.projectID;
		var issuePicker=Ext.create('com.trackplus.util.IssuePicker',{
			workItemID:workItemID,
			projectID:projectID*-1,
			title:getText("common.btn.chooseItem"),
			handler:me.setIssue,
			scope:me
		});
		issuePicker.showDialog();
	},
	selectLinkType: function(combo, records, options) {
		Ext.Ajax.request({
			url:"itemLink!getSpecificPart.action",
			params:{"linkTypeWithDirection":combo.getValue(),"linkID":options["linkID"], "workItemID":options["workItemID"]},
			disableCaching:true,
			scope: this,
			success: function(response, opts){
				var responseJson = Ext.decode(response.responseText);
				this.replaceSpecificPart(this.formPanel, responseJson["linkTypeJSClass"], responseJson["specificData"]);
			},
			failure: function(response, opts) {
			},
			method:'POST'
		});
	},
	setIssue:function(item){
		var me=this;
		var key=item['id'];
		var synopsis=item['title'];
		me.txtIssueNo.setValue(key);
		me.hiddenIssueNo.setValue(item["objectID"]);
		me.txtSynopsis.setValue(synopsis);
	},
	addLink:function() {
		var me=this;
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=getText("item.tabs.itemLink.lbl.add");
		var formPanel=me.createFormPanel();
		dialogCfg.formPanel=formPanel;
		dialogCfg.w=700;
		dialogCfg.h=330;
		dialogCfg.autoScroll=false;
		dialogCfg.iconCls='links16';
		formPanel.getForm().load({
			url : 'itemLink!editItemLink.action',
			params:{workItemID:me.workItemID},
			scope: me,
			success : function(form, action) {
				var data=action.result.data;
				me.cmbLinkType.store.loadData(data["linkTypesList"],false);
				me.cmbLinkType.setValue(data["linkTypeWithDirection"]);
				this.replaceSpecificPart(formPanel, data["linkTypeJSClass"], data["specificData"]);
			},
			failure:function(){
				alert("failure");
			}
		});
		dialogCfg.successHandler=function(result){
			//STARTDATE = 19;
			//ENDDATE = 20;
			//LINKED_ITEMS = -1009
			//me.fireItemChange([19,20,-1009]);
			me.refresh.call(me);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	},
	/**
	 * Add the link type specific configuration
	 */
	replaceSpecificPart: function(panel, specificLinkTypeClass, specificData) {
		var specificPart = panel.getComponent("specificPart");
		if (specificPart) {
			specificPart.setDisabled(true);
			panel.remove(specificPart, true);
		}
		if (specificLinkTypeClass) {
			var specificPart = Ext.create(specificLinkTypeClass,{
				margin:'0 5 5 0'
			});
			//specificItem.setTitle(getText('admin.customize.field.config.detail.lbl.specificConfig'));
			if (specificPart) {
				//panel.add(specificItem);
				panel.insert(2, specificPart);
				//specificData["labelWidth"] = 100;
				specificPart.onDataReady(specificData);
				panel.updateLayout();
			}
		}
	},
	editLink:function(){
		var me=this;
		var selections=me.gridConfig.grid.getSelectionModel().getSelection();
		if(CWHF.isNull(selections)){
			return;
		}
		var rowData=selections[0].data;
		var linkID=null;
		if(rowData){
			linkID=rowData.id;
		}
		if(rowData.editable===false){
			return;
		}
		var dialogCfg= new com.trackplus.itemDetail.DialogConfig(me.workItemID,me.projectID,me.issueTypeID);
		dialogCfg.title=getText("item.tabs.itemLink.lbl.edit");
		var formPanel=me.createFormPanel(linkID);
		dialogCfg.formPanel=formPanel;
		dialogCfg.w=700;
		dialogCfg.h=330;
		dialogCfg.autoScroll=false;
		dialogCfg.iconCls='links16';
		formPanel.getForm().load({
			url : 'itemLink!editItemLink.action',
			params:{workItemID:me.workItemID,linkID:linkID},
			scope: me,
			success : function(form, action) {
				var data=action.result.data;
				me.cmbLinkType.store.loadData(data["linkTypesList"],false);
				me.cmbLinkType.setValue(data["linkTypeWithDirection"]);
				me.txtIssueNo.setValue(data["linkedWorkItemID"]);
				me.hiddenIssueNo.setValue(data["linkedWorkItemObjectID"]);
				me.txtSynopsis.setValue(data["linkedWorkItemTitle"]);
				me.txtDescription.setValue(data["description"]);
				this.replaceSpecificPart(formPanel, data["linkTypeJSClass"], data["specificData"]);
			},
			failure:function(){
				alert("failure");
			}
		});
		dialogCfg.successHandler=function(result){
			//STARTDATE = 19;
			//ENDDATE = 20;
			//LINKED_ITEMS = -1009
			//me.fireItemChange([19,20,-1009]);
			me.refresh.call(me);
		};
		dialogCfg.failureHandler=function(form, action){
			var violationError = action.result.errors['itemov.ganttView.dependency.violation'];
			if(violationError  || violationError !== undefined) {
				var title = getText("itemov.ganttView.dependency.violationTitle");
				Ext.Msg.show({
					title: title,
					msg: action.result.errors['itemov.ganttView.dependency.violation'],
					icon: Ext.Msg.ERROR,
					buttonText: {ok: getText("common.btn.ok")}
				});
			}
			var msg=action.result.errorMessage;
			if(CWHF.isNull(msg)||msg===''){
				msg=getText('common.err.failure.validate');
			}
			CWHF.showMsgError(msg);
		};
		com.trackplus.itemDetail.openDialog(dialogCfg);
	},
	onGridDrop: function(node, data, dropRec, dropPosition) {
		var before = false;
		if (dropPosition==="before") {
			before = true;
		}
		var draggedLinkIDs = this.getSelectedIDs();
		if (draggedLinkIDs) {
			var params = {workItemID: this.workItemID, draggedLinkIDs:draggedLinkIDs.join(), droppedToLinkID:dropRec.get("id"), before:before};
			this.onOrderChange("itemLink!droppedNear.action", params);
		}
	},
	/**
	 * Move the selected grid row up
	 */
	onMoveUpGridRow: function() {
		var draggedLinkIDs = this.getSelectedIDs();
		if (draggedLinkIDs) {
			this.onOrderChange("itemLink!moveUp.action", {workItemID: this.workItemID, draggedLinkIDs:draggedLinkIDs.join()});
		}
	},
	/**
	 * Move the selected grid row down
	 */
	onMoveDownGridRow: function() {
		var draggedLinkIDs = this.getSelectedIDs();
		if (draggedLinkIDs) {
			this.onOrderChange("itemLink!moveDown.action", {workItemID: this.workItemID, draggedLinkIDs:draggedLinkIDs.join()});
		}
	},
	/**
	 * Private function foe changing the order by drag and drop or move up/down
	 */
	onOrderChange: function(url, params) {
		Ext.Ajax.request({
			url: url,
			disableCaching: true,
			scope: this,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success !== true) {
					Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
				}
				if (this.workItemID) {
					this.keepSelection = true;
				}
				this.refresh.call(this);
				if (this.workItemID) {
					this.keepSelection = false;
				}
			},
			failure: function(reponse){
				Ext.MessageBox.alert(this.failureTitle, reponse.responseText);
			},
			isUpload: false,
			method:'POST',
			params: params
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.VersionControlTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	readOnly:false,
	showFlat:false,
	flatPanel:null,
	flatData:null,
	initComponent : function(){
		var me = this;
		me.title=getText('item.tabs.versionControl.lbl');
		// me.iconCls='versionControl16';
		me.gridConfig=me.createVersionConfig();
		var toolbarItems=new Array();
		//var btnFlatHistory=me.createViewButton('flatHistory','flatHistory',getText('common.history.lbl.flatHistory'),
		//	getText('common.history.lbl.flatHistory.tlt'));
		var btnGridView=me.createViewButton('gridHistory','gridHistory',getText('common.history.lbl.gridHistory'),
			getText('common.history.lbl.gridHistory.tlt'));
		if(me.showFlat===true){
			btnGridView.pressed=false;
		}else{
			btnGridView.pressed=true;
		}
		toolbarItems.push(btnGridView);
		me.dockedItems=[{
			xtype: 'toolbar',
			dock: 'top',//'bottom'
			items:toolbarItems,
			border:false
		}];
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=[];
		if(me.showFlat===true){
			me.initFlatPanel();
			items.push(me.flatPanel);
		}else{
			if(me.gridConfig&&me.jsonData&&me.jsonData.gridLayoutData){
				var someGrid=me.createGrid.call(me,me.gridConfig,me.jsonData.gridLayoutData);
				me.gridConfig.grid=someGrid;
				items.push(someGrid);
			}
		}
		return items;
	},
	createVersionConfig:function(){
		var me=this;
		var versionControlRevNoType='string';
		if(me.jsonData){
			me.readOnly=me.jsonData.readOnly;
			versionControlRevNoType=me.jsonData.versionControlRevNoType;
			me.showFlat=this.jsonData.showFlat;
		}
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="versionControlTab";
		gridConfig.id=6;
		gridConfig.urlStore='itemVersionControl.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID="+me.issueTypeID;
		gridConfig.fields=[
			{name: 'revision',type:versionControlRevNoType},
			{name:'revisionURL',type:'string'},
			{name: 'repository',type:'string'},
			{name: 'date',type: 'date', dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat},
			{name: 'user',type:'string'},
			{name: 'message',type:'string'}
		];
		return gridConfig;
	},
	createViewButton:function(id,iconCls,txt,tooltip){
		var me=this;
		return Ext.create('Ext.button.Button',{
			//itemId:id,
			iconCls:iconCls,
			enableToggle:true,
			allowDepress:true,
			toggleGroup:'itemDetailHistoryViewGroup',
			text:txt,
			overflowText :txt,
			tooltip :tooltip,
			handler:function(){
				me.changeViewMode();
			},
			scope:me
		});
	},
	changeViewMode:function(id){
		var me=this;
		if(me.showFlat===false){
			me.showFlat=true;
			if(me.gridConfig.grid){
				me.remove(me.gridConfig.grid,true);
				me.gridConfig.grid=null;
			}
			me.initFlatPanel();
			me.add(me.flatPanel);
			me.refreshFlat();
		}else{
			me.showFlat=false;
			if(me.flatPanel){
				me.remove(me.flatPanel);
				me.flatPanel=null;
			}
			me.refresh();
			me.add(me.gridConfig.grid);
		}
		me.showHideFlat();
	},
	showHideFlat:function(){
		var me=this;
		Ext.Ajax.request({
			url: "userPreferences.action?property=showFlatVersionControl&value="+me.showFlat,
			disableCaching:true,
			success: function(data){
			},
			failure: function(type, error){
			}
		});
	},
	refresh:function(){
		var me=this;
		if(me.showFlat===true){
			me.refreshFlat();
		}else{
			me.callParent();
		}
	},
	refreshFlat:function(){
		var me=this;
		if(me.flatPanel){
			me.flatPanel.setLoading(true);
		}
		//var urlStr='itemHistory.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID"+me.issueTypeID;
		var urlStr='itemDetailVersionControl.action?workItemID='+me.workItemID;
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(response){
				//var responseJson = Ext.decode(response.responseText);
				//var jsonData=responseJson;
				me.flatData=response.responseText;
				if(me.flatPanel){
					me.flatPanel.setLoading(false);
				}
				me.initFlatPanel();
			},
			failure: function(){
			},
			method:'POST',
			params:{includeLayout:false,tabID:me.gridConfig.id}
		});
	},
	initFlatPanel:function(){
		var me=this;
		var html="";
		if(me.flatData/*&&me.flatData.length>0*/){
			html=me.flatData;
		}
		if(CWHF.isNull(me.flatPanel)){
			me.flatPanel=Ext.create('Ext.panel.Panel',{
				style:{
					borderTop:'1px solid #D0D0D0'
				},
				bodyBorder:false,
				cls:'flatHistoryPanel',
				html:html
			});
		}else{
			me.flatPanel.update(html);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.itemDetail.WatchersTab',{
	extend:'com.aurel.trackplus.itemDetail.TabGrid',
	urlDeleteItems:'deleteWatchers.action',
	//readOnly:false,
	myID:0,
	meAsC:false,
	meAsI:false,
	watcherAddDeleteDisabled:false,
	watcherMeConsultedDisabled:false,
	watcherMeInformedDisabled:false,
	fieldsToNotifyOnDelete:[-1003,-1004],
	initComponent : function(){
		var me = this;
		var watchersNumber=0;
		if(me.jsonData.watchersNumber){
			watchersNumber=me.jsonData.watchersNumber;
		}
		me.title=getText('item.printItem.lbl.watchers')+" ("+watchersNumber+")";
		// me.iconCls='watcher16';
		me.gridConfig=me.createWatchersConfig();
		me.callParent();
	},
	createWatchersConfig:function(){
		var me=this;
		if(me.jsonData){
			//me.readOnly=me.jsonData.readOnly;
			me.myID=me.jsonData.myID;
			me.meAsC=me.jsonData.meAsC;
			me.meAsI=me.jsonData.meAsI;
			me.watcherAddDeleteDisabled=me.jsonData.watcherAddDeleteDisabled;
			me.watcherMeConsultedDisabled=me.jsonData.watcherMeConsultedDisabled;
			me.watcherMeInformedDisabled=me.jsonData.watcherMeInformedDisabled;
		}
		var gridConfig=new com.trackplus.itemDetail.GridConfig();
		gridConfig.tabID="watchersTab";
		gridConfig.id=5;
		gridConfig.urlStore='itemWatcher.action?workItemID='+me.workItemID+"&projectID="+me.projectID+"&issueTypeID="+me.issueTypeID;
		gridConfig.fields=[
			{name: 'objectID',type:'int'},
			{name: 'type',type:'string'},
			{name: 'raciRole',type:'string'},
			{name: 'person',type:'string'},
			{name: 'isGroup',type:'string'},
			{name: 'editable',type: 'boolean'}
		];
		//toolbar
		if(!me.watcherAddDeleteDisabled){
			gridConfig.selectionModel = Ext.create('Ext.selection.CheckboxModel', {
				listeners: {
					selectionchange: function(sm, selections) {
						var selections=me.gridConfig.selectionModel.getSelection();
						var btnDelete=me.gridConfig.grid.down("#deleteWatcherBtn");
						if(CWHF.isNull(selections)||selections.length===0){
							btnDelete.setDisabled(true);
						}else{
							btnDelete.setDisabled(false);
						}
					}
				}
			});
		}
		gridConfig.tbar=[
			{
				text:getText('common.btn.addConsultant'),
				disabled:me.watcherAddDeleteDisabled,
				iconCls:'add16',
				//disabled:me.readOnly,
				handler : function(){
					me.addRole.call(me,'c',getText('item.tabs.watchers.lbl.header.consultants'),400,300);
				}
			},{
				text:getText('common.btn.addInformant'),
				disabled:me.watcherAddDeleteDisabled,
				iconCls:'add16',
				handler : function(){
					me.addRole.call(me,'i',getText('item.tabs.watchers.lbl.header.informants'),400,300);
				}
			},{
				text:com.trackplus.TrackplusConfig.getText('common.btn.delete'),
				itemId:"deleteWatcherBtn",
				disabled:true,
				iconCls:'delete16',
				handler:function(){
					me.deleteItems.call(me);
				}
			},{
				text:com.trackplus.TrackplusConfig.getText('common.btn.addMeConsultant'),
				itemId:"addMeAsC",
				disabled:me.watcherMeConsultedDisabled,
				iconCls:'add16',
				handler:function(){
					me.addRemoveMeAsConsultant.call(me);
				}
			},'-',{
				text:com.trackplus.TrackplusConfig.getText('common.btn.addMeInformant'),
				itemId:"addMeAsI",
				disabled:me.watcherMeInformedDisabled,
				iconCls:'add16',
				handler:function(){
					me.addRemoveMeAsInformant.call(me);
				}
			}
		];
		return gridConfig;
	},
	addRole:function(role, name, w, h){
		var me=this;
		var params={projectID:me.projectID,issueTypeID:me.issueTypeID};
		if(me.workItemID){
			params.workItemID=me.workItemID;
		}
		Ext.Ajax.request({
			url: 'addRaciRole!load.action?raciRole=' + role,
			params:params,
			encoding: "utf-8",
			sync: true,
			success: function(response){
				var text = response.responseText;
				var data = Ext.decode(text);
				var personItems=[];
				var persons=data.persons;
				if(persons){
					for(var i=0;i<persons.length;i++){
						personItems.push(persons[i]);
					}
				}
				var groups=data.groups;
				if(groups){
					for(var i=0;i<groups.length;i++){
						personItems.push(groups[i]);
					}
				}
				var personPikerDialog=Ext.create('com.trackplus.util.PersonPickerDialog',{
					title:name,
					options:personItems,
					width:300,
					height:250,
					includeEmail:false,
					handler:function(value,displayValue){
						me.addPersonHandler.call(me,value,role);
					},
					scope:me
				});
				personPikerDialog.showDialog();
			}
		});
	},
	addPersonHandler:function(value,role){
		var me=this;
		if(CWHF.isNull(value)&&value.length===0){
			return ;
		}
		var urlStr='addRaciRole!save.action';
		var selectedPersons='';
		for(var i=0;i<value.length;i++){
			var id=value[i].data.id;
			if(i===0){
				selectedPersons=id;
			}else{
				selectedPersons+=','+id;
			}
		}
		var params={
			'raciRole':role,
			'consInfEdit.selectedPersonsStr':selectedPersons,
			issueTypeID:me.issueTypeID,
			projectID:me.projectID,
			workItemID:me.workItemID
		};
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(){
				// CONSULTANT_LIST = -1003;
				//INFORMANT_LIST = -1004;
				me.fireItemChange([-1003,-1004]);
				me.refresh.call(me);
			},
			failure: function(){
			},
			method:'POST',
			params:params
		});
		//consInfEdit.selectedPersons
		//consInfEdit.selectedGroups
		/*
		 url: 'addRaciRole!save.action?raciRole='+role,
		 items:[
		 {xtype: 'displayfield',value: getText('item.tabs.watchers.lbl.persons')},
		 checkPersons,
		 {xtype: 'displayfield',value: getText('item.tabs.watchers.lbl.groups')},
		 checkGroups
		 ]
		 */
	},
	handlerDeleteItem:function(){
		var me=this;
		var selections=me.gridConfig.selectionModel.getSelection();
		var deletedConsultants="";
		var deletedInformants="";
		var deletedConsultantGroups="";
		var deletedInformantGroups="";
		var row;
		var i;
		for(i=0;i<selections.length;i++){
			row=selections[i].data;
			if(row.raciRole==="i"){
				if(row.isGroup==="true"){
					deletedInformantGroups=deletedInformantGroups+row.objectID+";";
				}else{
					deletedInformants=deletedInformants+row.objectID+";";
				}
			}else{
				if(row.isGroup==="true"){
					deletedConsultantGroups=deletedConsultantGroups+row.objectID+";";
				}else{
					deletedConsultants=deletedConsultants+row.objectID+";";
				}
			}
		}
		var urlStr='deleteWatchers.action?projectID='+me.projectID+"&issueTypeID="+me.issueTypeID;
		if(me.workItemID){
			urlStr=urlStr+'&workItemID='+me.workItemID;
		}
		Ext.Ajax.request({
			url:urlStr,
			disableCaching:true,
			success: function(){
				// CONSULTANT_LIST = -1003;
				//INFORMANT_LIST = -1004;
				me.fireItemChange([-1003,-1004]);
				me.refresh.call(me);
			},
			failure: function(){
			},
			method:'POST',
			params:{"deletedConsultants":deletedConsultants,
				"deletedInformants":deletedInformants,
				"deletedInformantGroups":deletedInformantGroups,
				"deletedConsultantGroups":deletedConsultantGroups
			}
		});
	},
	addRemoveMeAsConsultant:function(){
		var me=this;
		var operation="";
		var raciRole="c";
		if(me.meAsC){
			operation="r";
			me.meAsC=false;
		}else{
			operation="a";
			me.meAsC=true;
		}
		me.doMe(operation,raciRole);
	},
	doMe:function(operation,raciRole){
		var me=this;
		var urlStr='editConsultants.action?projectID='+me.projectID+"&issueTypeID="+me.issueTypeID;
		if(me.workItemID){
			urlStr=urlStr+'&workItemID='+me.workItemID;
		}
		Ext.Ajax.request({
			url:urlStr,
			disableCaching:true,
			success: function(){
				// CONSULTANT_LIST = -1003;
				//INFORMANT_LIST = -1004;
				me.fireItemChange([-1003,-1004]);
				me.refresh.call(me);
			},
			failure: function(){
			},
			method:'POST',
			params:{"raciRole":raciRole,"operation":operation}
		});
	},
	addRemoveMeAsInformant:function(){
		var me=this;
		var operation="";
		var raciRole="i";
		if(me.meAsI){
			operation="r";
			me.meAsI=false;
		}else{
			operation="a";
			me.meAsI=true;
		}
		me.doMe(operation,raciRole);
	},
	refreshCallback:function(r,options,success){
		var me=this;
		if(success===false){
			return;
		}
		this.meAsC=false;
		this.meAsI=false;
		var i=0;
		for(i=0;i<r.length;i++){
			if(r[i].data.objectID===this.myID){
				if(r[i].data.raciRole==='i'){
					this.meAsI=true;
				}else{
					this.meAsC=true;
				}
			}
		}
		var btnAddMeAsC=this.gridConfig.grid.down("#addMeAsC");
		var btnAddMeAsI=this.gridConfig.grid.down("#addMeAsI");
		if(this.meAsC){
			btnAddMeAsC.setText(getText('common.btn.deleteMeConsultant'));
			btnAddMeAsC.setIconCls('delete16');
		}else{
			btnAddMeAsC.setText(getText('common.btn.addMeConsultant'));
			btnAddMeAsC.setIconCls('add16');
		}
		if(this.meAsI){
			btnAddMeAsI.setText(getText('common.btn.deleteMeInformant'));
			btnAddMeAsI.setIconCls('delete16');
		}else{
			btnAddMeAsI.setText(getText('common.btn.addMeInformant'));
			btnAddMeAsI.setIconCls('add16');
		}
		var size=r.length;
		me.setTitle(me.replaceTitleNumber(me.title,size));
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.item.action.StepRenderer',{
	extend:'Ext.Base',
	config: {
		issueNoLabel:'',
		workItemID:'',
		statusDisplay:'',
		synopsis:''
	},
	labelWidth:150,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	createFormPanel:function(data){
		return Ext.create('Ext.form.Panel',{
			padding: '5 5 5 5',
			bodyPadding:0
		});
	},
	showErrorMessage:function(data,form){
		CWHF.showMsgError(getText(data.localizedErrorKey));
	},
	createItemTitleHtml:function(issueNoLabel, workItemID,statusDisplay, synopsis) {
		return issueNoLabel + '<strong><span class="emphasize">&nbsp;'
			+ workItemID + '</span> : ' + '<span class="dataEmphasize">'
			+ statusDisplay + '</span>' + ' :&nbsp;' + synopsis + '</strong>';
	},
	createItemTitleSection:function(issueNoLabel, workItemID,statusDisplay, synopsis, region) {
		var htmlIssueNr = this.createItemTitleHtml(issueNoLabel,
			workItemID, statusDisplay, synopsis, region);
		return {
			xtype : 'box',
			// baseCls:'x-panel-body-default',
			style : {
				border : 'none',
				paddingTop : '2px'
			},
			region : region,
			margin : '0 0 0 0',
			border : false,
			height : 22,
			html : htmlIssueNr
		};
	}
});
Ext.define('com.trackplus.item.action.CopyItem1StepRenderer',{
	extend:'com.trackplus.item.action.StepRenderer',
	createFormPanel:function(data){
		var titleArea=this.createItemTitleSection(data.issueNoLabel,data.workItemID,data.statusDisplay,data.synopsis);
		return Ext.create('Ext.form.Panel', {
			region: 'center',
			layout:'anchor',
			padding: '5 5 5 5',
			bodyPadding:0,
			border:false,
			url: 'item!saveInFirstStep.action',
			items:[titleArea,
				{
					xtype:'checkboxgroup',
					columns: 1,
					labelWidth: 1,
					items: [
						{boxLabel:getText('item.action.copy.deepCopy'),inputValue : true, name: 'params.deepCopy',checked:data.deepCopy},
						{boxLabel:getText('item.action.copy.copyAttachments'),inputValue : true, name: 'params.copyAttachments', checked:data.copyAttachments},
						{boxLabel:getText('item.action.copy.copyChildren'),inputValue : true, name: 'params.copyChildren',checked:data.copyChildren,disabled:!data.hasChildren}
					]
				}
			]
		});
	}
});
Ext.define('com.trackplus.item.action.ItemLocationStepRenderer',{
	extend:'com.trackplus.item.action.StepRenderer',
	cmbIssueType:null,
	createCmbIssueType:function(jsonData){
		var me=this;
		var dsIssueType = Ext.create('Ext.data.Store', {
			fields	: [{name:'id', type:'int'}, {name:'label', type:'string'}],
			data:jsonData.issueTypeList
		});
		var cmbIssueType=Ext.create('Ext.form.ComboBox',{
			id: 'IssueTypeList',
			fieldLabel: jsonData.issueTypeLabel,
			store:dsIssueType,
			displayField : 'label',
			valueField: 'id',
			typeAhead:false,
			queryMode: 'local',
			triggerAction: 'all',
			name: 'params.issueTypeID',
			allowBlank :false,
			editable: false,
			disabled :(jsonData.fixedIssueType===true),
			//anchor:'100%',//anchor width by percentage
			hiddenId:'issueTypeID',
			labelWidth:me.labelWidth,
			labelAlign:'right',
			width:400
		});
		cmbIssueType.setValue(jsonData.issueTypeID);
		return cmbIssueType;
	},
	createFormPanel:function(jsonData){
		var me=this;
		me.jsonData = jsonData;
		var urlStr='item!next.action';
		me.form=Ext.create('Ext.form.Panel', {
			border:false,
			bodyBorder:false,
			region: 'center',
			url:urlStr,
			padding: '5 5 5 5',
			bodyPadding:0,
			layout:'anchor',
			items:me.createFormItems(jsonData)
		});
		return me.form;
	},
	createFormItems:function(jsonData){
		var me=this;
		if(CWHF.isNull(jsonData)){
			return[{
				xtype:'component',
				html:'no right to create items'
			}];
		}
		var listenerConfig=null;
		if(jsonData.fixedIssueType===true){
			listenerConfig=null;
		}else{
			listenerConfig=	{select:{fn: this.projectChange, scope:this}};
		}
		me.cmbProject = CWHF.createSingleTreePicker(jsonData.projectLabel,
			"params.projectID", jsonData["projectTree"], jsonData["projectID"],
			{
				allowBlank:true,
				labelIsLocalized:true,
				labelWidth: this.labelWidth,
				width:400,
				margin:'0 0 5 0'
			},listenerConfig );
		var items=new Array();
		me.cmbIssueType=me.createCmbIssueType(jsonData);
		var items=new Array();
		items.push(me.cmbProject);
		items.push(me.cmbIssueType);
		if(jsonData.fixedIssueType===true){
			items.push({
				xtype: 'hiddenfield',
				name: 'params.issueTypeID',
				value:jsonData.issueTypeID
			})
		}
		return items;
	},
	projectChange:function(){
		var me=this;
		var urlStr='item!reloadIssueTypes.action';
		var projectID=me.cmbProject.getSubmitValue();
		var issueTypeID=me.cmbIssueType.getValue();
		me.form.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching :true,
			params:{
				projectID:projectID,
				issueTypeID:issueTypeID,
				workItemID: me.jsonData.parentID
			},
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				me.cmbIssueType.store.loadData(jsonData.issueTypeList);
				me.cmbIssueType.setValue(jsonData.issueTypeID);
				me.cmbIssueType.setFieldLabel(jsonData.issueTypeLabel);
				me.form.setLoading(false);
			},
			failure: function(error){
				me.form.setLoading(false);
				alert("error refresh issue type: "+error.message);
			},
			method:"POST"
		});
	}
});
Ext.define('com.trackplus.item.action.MoveItemStepRenderer',{
	extend:'com.trackplus.item.action.ItemLocationStepRenderer',
	createOldLocationPanel:function(jsonData){
		var htmlStr=jsonData.projectLabel+': <b>'+jsonData.oldProject+'</b> &nbsp;';
		htmlStr+=jsonData.issueTypeLabel+': <b>'+jsonData.oldIssueType+'</b>';
		return {
			xtype: 'component',
			html: htmlStr,
			anchor: '100%',
			cls:'infoBox',
			margin:'0 0 10 0',
			border:true
		};
	},
	createCmbStatus:function(jsonData){
		var dsStatus = Ext.create('Ext.data.Store', {
			model: 'Status',
			fields : [{name:'id', type:'int'}, {name:'label', type:'string'}],
			data:jsonData.statusList
		});
		var cmbStatus=Ext.create('Ext.form.ComboBox',{
			id: 'StatusList',
			fieldLabel: jsonData.statusLabel,
			store:dsStatus,
			displayField : 'label',
			valueField: 'id',
			typeAhead:false,
			queryMode: 'local',
			triggerAction: 'all',
			name: 'params.statusID',
			allowBlank :false,
			//anchor:'100%',//anchor width by percentage
			hiddenId:'statusID'
		});
		cmbStatus.setValue(jsonData.statusID);
		return cmbStatus;
	},
	createFormItems:function(jsonData){
		var me=this;
		var items=me.superclass.createFormItems.call(me,jsonData.issueLocation);
		items.unshift(me.createOldLocationPanel(jsonData));
		var titleArea=me.createItemTitleSection(jsonData.issueNoLabel,jsonData.workItemID,jsonData.statusDisplay,jsonData.synopsis);
		items.unshift(titleArea);
		if (jsonData.statusNeeded){
			items.push(me.createCmbStatus(jsonData));
		}
		me.moveChildren = CWHF.createCheckbox("item.action.move.moveChildren", "params.moveChildren", {value:jsonData.moveChildren, labelWidth:150, disabled:!jsonData.hasChildren});
		items.push(me.moveChildren);
		return items;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.item.ItemErrorHandler={
	handleErrors:function(itemAction,data){
		var errorCode=data.errorCode;
		var fieldTypeRenderersMap=itemAction.itemComponent.screenFacade.controller.fieldTypeRenderersMap;
		var synopsisTxt=itemAction.itemComponent.txtTitleHeader;
		switch (errorCode){
			case 0://GENERAL
			case 1:{//CONVERSION
				var errorTxt="";
				var errors=data.errors;
				for(var i=0;i<errors.length;i++){
					var fieldID=errors[i].id;
					if(fieldID){
						var fieldTypeRenderer=fieldTypeRenderersMap["f"+fieldID];
						if(fieldTypeRenderer){
							fieldTypeRenderer.markInvalid(errors[i].label);
						}else{
							if(fieldID===17&&synopsisTxt){
								//synopsis
								synopsisTxt.markInvalid(errors[i].label);
							}
						}
					}
					errorTxt+=errors[i].label+"</BR>";
				}
				var msgError=getText(getText("item.err.saveFailed",itemAction.itemComponent.synopsis));
				if(errorTxt.length>0){
					msgError=errorTxt;
				}
				CWHF.showMsgError(msgError);
				break;
			}
			case 2:{//OUT_OF_DATE
				com.trackplus.item.ItemErrorHandler.outOfDateHandler(itemAction,data);
				break;
			}
		}
	},
	outOfDateHandler:function(itemAction,data){
		Ext.MessageBox.show({
			title:getText('item.err.wasModified'),
			msg: getText('item.err.modified'),
			buttons: Ext.MessageBox.YESNOCANCEL,
			buttonText: {yes: getText('item.err.btn.ignore'), no: getText('item.err.btn.overwrite'), cancel: getText('item.err.btn.merge')},
			fn: function(btn){
				if(btn==="yes"){
					com.trackplus.item.ItemErrorHandler.outOfDateHandler_ignore(itemAction,data);
					return;
				}
				if(btn==="no"){
					com.trackplus.item.ItemErrorHandler.outOfDateHandler_overwrite(itemAction,data);
					return;
				}
				if(btn==="cancel"){
					com.trackplus.item.ItemErrorHandler.outOfDateHandler_merge(itemAction,data);
					return;
				}
			},
			icon: Ext.MessageBox.QUESTION
		});
	},
	outOfDateHandler_ignore:function(itemAction,data){
		itemAction.lastModified=data.lastModified;
	},
	outOfDateHandler_overwrite:function(itemAction,data){
		var fieldTypeRenderersMap=itemAction.itemComponent.screenFacade.controller.fieldTypeRenderersMap;
		var workItemContext=data.workItemContext;
		var fieldConfigs=workItemContext.fieldConfigs;
		var fieldValues=workItemContext.fieldValues;
		var fieldDisplayValues=workItemContext.fieldDisplayValues;
		for(var f in fieldConfigs){
			var fieldCfg=fieldConfigs[f];
			var fieldTypeRenderer=fieldTypeRenderersMap[f];
			if(fieldTypeRenderer){
				fieldTypeRenderer.update.call(fieldTypeRenderer,{
					fieldConfig:fieldCfg,
					value:fieldValues[f],
					displayValue:fieldDisplayValues[f]
				});
			}
		}
		itemAction.lastModified=data.lastModified;
	},
	outOfDateHandler_merge:function(itemAction,data){
		var fieldTypeRenderersMap=itemAction.itemComponent.screenFacade.controller.fieldTypeRenderersMap;
		var workItemContext=data.workItemContext;
		var fieldConfigs=workItemContext.fieldConfigs;
		var fieldValues=workItemContext.fieldValues;
		var fieldDisplayValues=workItemContext.fieldDisplayValues;
		for(var f in fieldConfigs){
			var fieldCfg=fieldConfigs[f];
			var fieldTypeRenderer=fieldTypeRenderersMap[f];
			if(fieldTypeRenderer){
				var newValue=fieldValues[f];
				var myValue=fieldTypeRenderer.getValue();
				var originalValue=fieldTypeRenderer.getOriginalValue();
				if(newValue!==originalValue){
					//somebody else modify the field value
					if(myValue!==originalValue){
						//also modify by me ->conflict
						fieldTypeRenderer.markConflict(newValue);
					}else{
						fieldTypeRenderer.markModifiedByOther(newValue);
					}
				}else{
					//other people do not change the field value
					if(myValue!==originalValue){
						//I change the value
						fieldTypeRenderer.markModifiedByMe();
					}
				}
			}
		}
		itemAction.lastModified=data.lastModified;
	}
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//Item Action class
Ext.define('com.trackplus.item.ItemAction',{
	extend:'Ext.util.Observable',
	config: {
		workItemID:null,
		actionID:null,
		screenID:null,
		parentID:null,
		projectID:null,
		releaseID:null,
		issueTypeID:null,
		synopsis:null,
		description:null,
		successHandler:null,
		successExtra:null,
		readOnlyMode:false,
		scope:null,
		title:null,
		disabledNext:true,
		disabledPrev:true
	},
	lastModified:null,
	parentContainer:null,
	centerPanelCls:'itemscreen',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		this.listeners = config.listeners;
		this.callParent(arguments);
		Ext.apply(me, config);
		this.initConfig(config);
	},
	execute:function(){
		var me=this;
		var urlStr='item!executeAJAX.action';
		me.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			scope:me,
			params:{
				workItemID:me.workItemID,
				parentID:me.parentID,
				synopsis:me.synopsis,
				description:me.description,
				readOnlyMode:me.readOnlyMode,
				issueTypeID:me.issueTypeID,
				projectID:me.projectID,
				releaseID:me.releaseID,
				actionID:me.actionID
			},
			success: function(response){
				var dataAJAX=Ext.decode(response.responseText);
				me.setLoading(false);
				if(dataAJAX.success===true){
					me.loadSuccess.call(me,dataAJAX.data);
				}else{
					me.loadFailure.call(me,dataAJAX);
				}
			},
			failure:function(result){
				me.setLoading(false);
				Ext.MessageBox.show({
					title: getText('common.err.sorry'),
					msg: result.responseText,
					buttons: Ext.Msg.OK,
					icon: Ext.MessageBox.ERROR
				});
			}
		});
	},
	reExecute:function(){
		this.execute();
	},
	setLoading:function(b){
		borderLayout.setLoading(b);
	},
	createChildren:function(){
		var me=this;
		me.initToolbar('0 0 0 0');
		me.parentPanel= Ext.create('Ext.panel.Panel', {
			margin: '0 0 0 0',
			cls:me.centerPanelCls,
			bodyPadding:0,
			border: false,
			layout:'fit',
			region:'center'
		});
		var northPanel=Ext.create('Ext.panel.Panel',{
			border:false,
			bodyBorder:false,
			margin:'0 0 0 0',
			region:'north',
			layout: {
				type: 'hbox',
				padding:'0',
				align:'top'
			},
			items:[me.toolbar,me.extraToolbar]
		});
		return [northPanel,me.parentPanel];
	},
	initToolbar:function(){
		this.toolbar= Ext.create('Ext.toolbar.Toolbar', {
			layout: {
				overflowHandler: 'Menu'
			},
			enableOverflow: true,
			flex:1,
			cls:'toolbarActions',
			border: '1 0 1 0',
			defaults: {
				cls:'toolbarItemAction',
				scale:'small',
				iconAlign: 'left',
				enableToggle:false
			}
		});
		this.extraToolbar=Ext.create('Ext.toolbar.Toolbar', {
			enableOverflow: false,
			//region:'north',
			cls:'toolbarActions',
			border: '1 0 1 0',
			defaults: {
				cls:'toolbarItemAction',
				scale:'small',
				iconAlign: 'left',
				enableToggle:false
			}
		});
	},
	loadSuccess:function(data){
		var me=this;
		Ext.suspendLayouts();
		me.lastModified=data.lastModified;
		var useWizard=data.useWizard;
		if(me.toolbar){
			me.toolbar.removeAll();
			me.toolbar.updateLayout();
		}
		if(useWizard){
			me.title1=data.title1;
			me.title=data.title;
			me.openWizardItem.call(me,data);
		}else{
			me.title=data.title;
			me.openSimpleItem.call(me,data);
		}
		me.updateTitle.call(me,data);
		var toolbarData=data.toolbar;
		me.addToolbarButtons.call(me,toolbarData,useWizard);
		Ext.resumeLayouts(true);
	},
	loadFailure:function(response){
		if(response.localizedErrorKey){
			CWHF.showMsgError(getText(response.localizedErrorKey));
		}
		if(response.message){
			CWHF.showMsgError(response.message);
		}
		if(response.errorMessage){
			CWHF.showMsgError(response.errorMessage);
		}
	},
	updateTitle:function(data){
	},
	openSimpleItem:function(data){
		var me=this;
		/*var panelItem=Ext.create('Ext.panel.Panel',{
		 layout:'fit',
		 border:false
		 });
		 me.parentPanel.removeAll(true);
		 me.parentPanel.add(panelItem);
		 me.parentPanel.updateLayout();*/
		me.editItemScreen.call(me,data,me.parentPanel,true);
	},
	createParentContainer:function(){
		var me=this;
		return Ext.create('Ext.panel.Panel',{
			layout:'border',
			margin:'0 0 0 0',
			border:false,
			bodyBorder  :false,
			cls:'printItem',
			items:[{region:'center'}]
		});
	},
	addToolbarButtons:function(toolbarData, disableConfig){
		var me=this;
		if(me.toolbar){
			if(toolbarData){
				var items=[];
                var moreItems = [];
				for(var i=0;i<toolbarData.length;i++){
					if(me.isVisibleAction(toolbarData[i])){
                        var toolbarButtonConfig =  toolbarData[i];
                        var isMore = toolbarButtonConfig["isMore"];
                        var toolbarButton = me.createToolbarAction(toolbarButtonConfig);
                        if (isMore) {
                            moreItems.push(toolbarButton);
                        }  else {
                            items.push(toolbarButton);
                        }
					}
				}
				me.toolbar.add(items);
                if (moreItems.length>0) {
                    var moreItemActions=Ext.create('Ext.button.Split',{
                        text:getText('common.btn.moreActions'),
                        overflowText:getText('common.btn.moreActions'),
                        tooltip:getText('common.btn.moreActions.tt'),
                        iconCls: 'extraActions',
                        disabled:false,
                        menu:moreItems
                    });
                    me.toolbar.add(moreItemActions);
                }
			}
		}
		if(me.extraToolbar){
			me.extraToolbar.removeAll();
			var items=[];
			if(me.actionID===-2){//printItem
				items.push("-");
				items.push(Ext.create('Ext.button.Button',{
					itemId:'prevItem',
					overflowText:getText('common.btn.backward'),
					tooltip:getText('common.btn.backward.tt'),
					iconCls: 'itemAction_upward16',
					cls:'toolbarItemAction-noText',
					disabled:me.disabledPrev,
					handler:function(){
						me.executeToolbarAction.call(me,{id:com.trackplus.item.ToolbarItem.NAVIGATION_PREV});
					},
					scope:me
				}));
				items.push("-");
				items.push(Ext.create('Ext.button.Button',{
					itemId:'nextItem',
					overflowText:getText('common.btn.forward'),
					tooltip:getText('common.btn.forward.tt'),
					iconCls: 'itemAction_downward16',
					cls:'toolbarItemAction-noText',
					disabled:me.disabledNext,
					handler:function(){
						me.executeToolbarAction.call(me,{id:com.trackplus.item.ToolbarItem.NAVIGATION_NEXT});
					},
					scope:me
				}));
			}
			if(com.trackplus.TrackplusConfig.user.sys===true){
				//or projectAdmin ?
				if(CWHF.isNull(disableConfig)||disableConfig===false){
					items.push("-");
					items.push(Ext.create('Ext.button.Button',{
						overflowText:getText('common.btn.config'),
						tooltip:getText('common.btn.config'),
						iconCls: 'btnConfig',
						cls:'toolbarItemAction-noText',
						handler:me.onScreenConfig,
						scope:me
					}));
				}
			}
			me.extraToolbar.add(items);
		}
	},
	setDisabledNextButton:function(disabledNext){
		var me=this;
		me.disabledNext=disabledNext;
		if(me.extraToolbar){
			var btnNext=me.extraToolbar.getComponent('nextItem');
			if(btnNext){
				btnNext.setDisabled(disabledNext);
			}
		}
	},
	setDisabledPrevButton:function(disabledPrev){
		var me=this;
		me.disabledPrev=disabledPrev;
		if(me.extraToolbar){
			var btnPrev=me.extraToolbar.getComponent('prevItem');
			if(btnPrev){
				btnPrev.setDisabled(disabledPrev);
			}
		}
	},
	onScreenConfig:function(){
		var me=this;
		var id=me.screenID;
		var urlStr='screenEdit.action?componentID='+id+'&backAction=itemNavigator.action%3FactionID%3D'+me.actionID;
		if(me.workItemID){
			urlStr=urlStr+'%26workItemID%3D'+me.workItemID;
		}
		window.location.href=urlStr;
	},
	isVisibleAction:function(toolbarItem){
		var id=toolbarItem.id;
		if(id===com.trackplus.item.ToolbarItem.BACK){
			return false;
		}
		return true;
	},
	createToolbarAction:function(toolbarItem){
		var me=this;
		if (toolbarItem && toolbarItem.jsonData && toolbarItem.jsonData.actionID==6) {
			//add linked item from More actions 
			this.addLinkFromContextMenu = true;
		}
		return  {
            overflowText:getText(toolbarItem.labelKey),
            tooltip:getText(toolbarItem.tooltipKey),
            iconCls: toolbarItem.cssClass+'16',
            cls:'toolbarItemAction-noText',
            disabled:toolbarItem.condition===false,
            text:getText(toolbarItem.labelKey),
            handler:function(btn){
                me.executeToolbarAction.call(me,toolbarItem);
            }
        }
	},
	openWizardItem:function(data){
		var me=this;
		me.canFinish=data.canFinish;
		me.step1Renderer=Ext.create(data.extClassName);
		me.form1=me.step1Renderer.createFormPanel(data.jsonData);
		var panelStep2=Ext.create('Ext.form.Panel', {
			region: 'center',
			url: 'item!save.action',
			//standardSubmit : true,
			margins: '0 0 0 0',
			bodyPadding:0,
			border: false,
			baseCls:'x-plain',
			layout:'fit'
		});
		me.form2=panelStep2;
		me.btnPrev=Ext.create('Ext.Button',{
			text: /*'&laquo; '+*/getText('common.btn.backward'),
			iconCls:'itemAction_navigate_left',
			cls:'toolbarItemAction-noImage',
			disabled:true,
			scope:me,
			handler:function(btn){
				me.prev.call(me,data);
			}
		});
		me.btnNext=Ext.create('Ext.Button',{
			text: getText('common.btn.forward'),//+' &raquo;',
			iconCls:'itemAction_navigate_right',
			disabled:false,
			scope:me,
			formBind: true,
			iconAlign:'right',
			cls:'toolbarItemAction-noImage',
			handler:function(btn){
				me.next.call(me,data);
			}
		});
		me.btnFinish=Ext.create('Ext.Button',{
			text: data.finishLabel,
			iconCls:CWHF.isNull(data.cssClass)?'save':data.cssClass+'16',
			hidden :!data.canFinish,
			scope:me,
			handler:function(btn){
				me.finish.call(me,data);
			}
		});
		me.btnReset=Ext.create('Ext.Button',{
			text: 'Reset',
			scope:me,
			handler:function(btn){
				//
			}
		});
		me.btnCancel=Ext.create('Ext.Button',{
			text: 'Cancel',
			scope:me,
			handler:function(btn){
				if(me.dialogItemAction){
					me.dialogItemAction.close();
					me.dialogItemAction.destroy();
				}
			}
		});
		me.centerPanelWizard =Ext.create('Ext.panel.Panel',{
			layout      : 'card',
			//plain       : true,
			border:false,
			bodyBorder:false,
			autoScroll  :true,
			//baseCls:'x-plain',
			defaults: {
				//baseCls:'x-plain',
				margins: '0 0 0 0',
				bodyStyle:{padding:'5px'}
			},
			items:[me.form1,panelStep2]
		});
		//me.itemToolbar.add(Ext.create('Ext.toolbar.Fill',{}));
		me.toolbar.add(me.btnPrev);
		me.toolbar.add(borderLayout.createItemToolbarSeparator());
		me.toolbar.add(me.btnNext);
		me.toolbar.add(borderLayout.createItemToolbarSeparator());
		me.toolbar.add(me.btnFinish);
		me.toolbar.updateLayout();
		me.parentPanel.removeAll();
		me.parentPanel.add(me.centerPanelWizard);
		me.parentPanel.updateLayout();
		//In case of Add linked item(from item navigator context menu), the form must contain link initialization part
		//otherwise normal new item create form
		if(me.addLinkFromContextMenu) {
			me.addLinkDetailsToForm();
		}
	},
	/**
	 * Loading link form configuration data, when Add linked item (from item navigator context menu).
	 */
	addLinkDetailsToForm: function() {
		var me = this;
		var link=Ext.create('com.aurel.trackplus.itemDetail.LinksTab',{
			workItemID:me.workItemID/*,
			projectID:me.addLinkFromContextMenu.projectID,
			issueTypeID:me.addLinkFromContextMenu.issueTypeID*/
		});
		me.linkFormPanel = link.createFormPanel();
		me.linkFormPanel.getForm().load({
			url : 'itemLink!editItemLink.action',
			params:{workItemID:me.workItemID,
				addMeAsLinkToNewItem: true},
			scope: me,
			success : function(form, action) {
				var data=action.result.data;
				link.cmbLinkType.store.loadData(data["linkTypesList"],false);
				link.cmbLinkType.setValue(data["linkTypeWithDirection"]);
				link.txtIssueNo.setValue(data["linkedWorkItemID"]);
				link.hiddenIssueNo.setValue(data["linkedWorkItemObjectID"]);
				link.txtSynopsis.setValue(data["linkedWorkItemTitle"]);
				link.txtDescription.setValue("");
				link.replaceSpecificPart(me.linkFormPanel, data["linkTypeJSClass"], data["specificData"]);
			},
			failure:function(){
				alert("failure");
			}
		});
		//align to existing labels
		me.linkFormPanel.margin = '0 0 0 -12';
		me.form1.items.add(me.linkFormPanel);
	},
	prev:function(data){
		var me=this;
		me.navigate.call(me,'prev',data);
		var items=me.toolbar.items;
		while(items.getCount()>5){
			me.toolbar.remove(items.getAt(5));
		}
		if(me.extraToolbar){
			me.extraToolbar.removeAll();
		}
		me.btnFinish.setVisible(me.canFinish);
		me.toolbar.updateLayout();
	},
	next:function(data){
		var me=this;
		if(!me.form1.getForm().isValid()){
			return false;
		}
		var params = {};
		//In case of Add linked item  we need to append link config into submit parameters
		if(me.addLinkFromContextMenu) {
			params = me.linkFormPanel.getForm().getValues();
		}
		params.workItemID=me.workItemID;
		params.parentID=me.parentID;
		params.synopsis=me.synopsis;
		params.description=me.description;
		params.actionID=me.actionID;
		me.setLoading(true);
		me.form1.getForm().submit({
			url:'item!next.action',
			params:params,
			success: function(form, action) {
				me.navigate.call(me,'next',action.result.data);
				me.btnFinish.setVisible(false);
				me.editItemScreen(action.result.data,me.form2,true);
				me.addToolbarButtons.call(me,action.result.data.toolbar);
				me.setLoading(false);
			},
			failure: function(form, action) {
				me.setLoading(false);
				me.step1Renderer.showErrorMessage(action.result,me.form1);
			}
		});
	},
	navigate:function(direction,data){
		var me=this;
		var layout = me.centerPanelWizard.getLayout();
		layout[direction]();
		me.btnPrev.setDisabled(!layout.getPrev());
		me.btnNext.setDisabled(!layout.getNext());
		if(!data.canFinish){
			me.btnFinish.setDisabled(layout.getNext());
		}
	},
	finish:function(){
		var me=this;
		var firstStep=me.centerPanelWizard.getLayout().getNext();
		if(firstStep===false){
			me.save.call(me);
		}else{
			me.saveInFirstStep.call(me);
		}
	},
	saveInFirstStep:function(){
		var me=this;
		var successExtra={};
		if(me.successExtra){
			for(var x in me.successExtra){
				successExtra[x]=me.successExtra[x];
			}
			successExtra['actionID']=me.actionID;
			successExtra['workItemID']=me.workItemID;
		}
		me.form1.getForm().submit({
			url:'item!saveInFirstStep.action',
			params:{
				'workItemID':me.workItemID,
				'projectID':me.projectID,
				'issueTypeID':me.issueTypeID,
				'actionID':me.actionID//+'&forwardAction='+forwardAction,
			},
			success:function(form,action){
				me.saveSuccess.call(me,form,action);
			},
			scope:me,
			failure:me.saveFailure
		});
	},
	saveSuccess:function(form, action){
		var me=this;
		var data=null;
		if(action){
			data=action.result.data;
		}
		if(me.successHandler){
			me.successHandler.call(me.scope?me.scope:me,data,me.successExtra);
		}
	},
	saveFailure:function(form, action){
		alert("failure");
	},
	itemChangeHandler:function(fields){
		var me=this;
		me.fireEvent('itemChange',fields);
	},
	clickOnChild:function(workItemID){
		var me=this;
		me.fireEvent('clickOnChild',workItemID);
	},
	clickOnLink:function(workItemID){
		var me=this;
		me.fireEvent('clickOnLink',workItemID);
	},
	clickOnParent:function(parentID){
		var me=this;
		me.fireEvent('clickOnParent',parentID);
	},
	finishedUploadHandler:function(parentID){
		var me=this;
		me.fireEvent('finishedUpload',parentID);
	},
	changeToEditMode:function(){
		var me=this;
		var successExtra={};
		if(CWHF.isNull(me.successExtra)){
			me.successExtra={};
		}
		me.successExtra['actionID']=me.actionID;
		me.successExtra['workItemID']=me.workItemID;
		Ext.Ajax.request({
			url : "item!toolbarEdit.action",
			params : {
				'workItemID' : me.workItemID
			},
			success : function(response) {
				var jsonData = Ext.decode(response.responseText);
				var toolbarData=jsonData.data;
				var el=me.toolbar.getEl();
				el.fadeOut({
					opacity: 0.1, //can be any value between 0 and 1 (e.g. .5)
					easing: 'easeOut',
					duration: 150,
					remove: false,
					useDisplay: false,
					callback:function(){
						me.toolbar.removeAll();
						me.addToolbarButtons.call(me,toolbarData);
						el.fadeIn({
							opacity: 1, //can be any value between 0 and 1 (e.g. .5)
							easing: 'easeOut',
							duration: 300
						});
					}
				});
				me.actionID=2;//EDIT
				me.readOnlyMode=false;
			},
			failure : function() {
				alert("failed!");
			}
		});
	},
	changeLastModified:function(lastModified){
		var me=this;
		me.lastModified=lastModified;
	},
	editItemScreen:function(data,panel,tabsIncluded){
		var me=this;
		me.projectID=data.projectID;
		me.issueTypeID=data.issueTypeID;
		me.screenID=data.screen.id;
		me.itemComponent=Ext.create('com.trackplus.item.ItemComponent',{
			workItemID:data.workItemID,
			workItemIDDisplay:data.workItemIDDisplay,
			projectID:data.projectID,
			projectLabel:data.projectLabel,
			issueTypeID:data.issueTypeID,
			issueTypeLabel:data.issueTypeLabel,
			readOnlyMode:data.readOnlyMode,
			actionID:data.actionID,
			issueNoLabel:data.issueNoLabel,
			statusDisplay:data.statusDisplay,
			statusID:data.statusID,
			synopsis:data.synopsis,
			includeBottomTabs:data.includeBottomTabs,
			itemDetailData:data.itemDetail,
			includeItemTitle:false,
			synopsisReadonly:data.synopsisReadonly,
			inlineEdit:data.inlineEdit,
			lastModified:me.lastModified,
			itemLockedMessage:data.itemLockedMessage
		});
		me.itemComponent.addListener("editMode",me.changeToEditMode,me);
		me.itemComponent.addListener("lastModified",me.changeLastModified,me);
		me.itemComponent.addListener("itemChange",me.itemChangeHandler,me);
		me.itemComponent.addListener("clickOnChild",me.clickOnChild,me);
		me.itemComponent.addListener("clickOnLink",me.clickOnLink,me);
		me.itemComponent.addListener("clickOnParent",me.clickOnParent,me);
		me.itemComponent.addListener("finishedUpload",me.finishedUploadHandler,me);
		me.readOnlyMode=data.readOnlyMode;
		var container=me.itemComponent.createItemPanel();
		panel.removeAll();
		panel.add(container);
		if(tabsIncluded){
			me.itemComponent.replaceScreenItem(data.screen,data.children,data.readOnlyMode,data.workItemContext);
		}else{
			me.itemComponent.refreshItemPanel();
		}
	},
	refreshChildren:function(){
		var me=this;
		if(me.itemComponent){
			me.itemComponent.refreshChildren.call(me.itemComponent);
		}
	},
	executeToolbarAction:function(toolbarItem){
		var me=this;
		var id=toolbarItem.id;
		var url=toolbarItem.url;
		var jsonData=toolbarItem.jsonData;
		switch(id){
			case com.trackplus.item.ToolbarItem.ITEM_ACTION:
			case com.trackplus.item.ToolbarItem.SIBLING:
				me.executeItemAction.call(me,jsonData);
				break;
			case com.trackplus.item.ToolbarItem.CHOOSE_PARENT:
				me.chooseParent();
				break;
			case com.trackplus.item.ToolbarItem.PRINT:
				var url="printItem2.action?workItemID="+me.workItemID;
				window.open(url,'PrintItem','scrollbars=yes,resizable=yes,menubar=yes,location=yes,status=yes');
				break;
			case com.trackplus.item.ToolbarItem.PRINT_WITH_CHILDREN:
				var url="printItemWithChildren.action?workItemID="+me.workItemID;
				window.open(url,'PrintItem','scrollbars=yes,resizable=yes,menubar=yes,location=yes,status=yes');
				break;
				break;
			case com.trackplus.item.ToolbarItem.ACCESS_LEVEL:
				me.reverseAccessFlag();
				break;
			case com.trackplus.item.ToolbarItem.ARCHIVE:
				me.reverseArchive();
				break;
			case com.trackplus.item.ToolbarItem.DELETE:
				me.reverseDelete();
				break;
			case com.trackplus.item.ToolbarItem.MAIL:
				me.sendEmail();
				break;
			case com.trackplus.item.ToolbarItem.BACK:
				me.back();
				break;
			case com.trackplus.item.ToolbarItem.NAVIGATION_NEXT:
				me.navigateToItem.call(me,'next');
				break;
			case com.trackplus.item.ToolbarItem.NAVIGATION_PREV:
				me.navigateToItem.call(me,'prev');
				break;
			case com.trackplus.item.ToolbarItem.SAVE:
				me.save.call(me);
				break;
			case com.trackplus.item.ToolbarItem.RESET:
				me.reset();
				break;
			case com.trackplus.item.ToolbarItem.CANCEL:
				/*if(me.successHandler){
					me.successHandler.call(me.scope?me.scope:me,null,me.successExtra);
				}*/
				break;
			case com.trackplus.item.ToolbarItem.PRINT_ITEM:
				window.open("printItem.action?workItemID="+me.workItemID,'printItem'+me.workItemID);
				break;
			case com.trackplus.item.ToolbarItem.EXPORT:
				break;
		}
	},
	executeItemAction:function(jsonData){
		var me=this;
		var actionID=jsonData.actionID;
		var parentID=jsonData.parentID;
		if(CWHF.isNull(me.successExtra)){
			me.successExtra={};
		}
		me.successExtra['actionID']=me.actionID;
		me.successExtra['workItemID']=me.workItemID;
		me.actionID=actionID;
		me.parentID=parentID;
		me.reExecute();
		me.fireEvent.call(me,'activate',me);
		/*var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',{
			workItemID:me.workItemID,
			actionID:actionID,
			parentID:parentID,
			successHandler:me.successHandler,
			successExtra:successExtra,
			scope:me.scope,
			modal:false
		});
		itemAction.execute.call(itemAction);
		itemAction.addListener('activate',function(){
			me.fireEvent.call(me,'activate',me);
		},me);
		itemAction.addListener('deactivate',function(){
			me.fireEvent.call(me,'deactivate',me);
		},me);
		itemAction.addListener('close',function(){
			me.fireEvent.call(me,'close',me);
		},me);*/
	},
	chooseParent:function(){
		var me=this;
		var workItemID=me.workItemID;
		var projectID=me.projectID;
		//var projectName="";
		var ajaxContext=null;
		var handler=null;
		var scope=null;
		if(me.readOnlyMode===true){
			if(CWHF.isNull(me.successExtra)){
				me.successExtra={};
			}
			me.successExtra['actionID']=me.actionID;
			me.successExtra['workItemID']=me.workItemID;
			ajaxContext={
				url:'item!setParent.action',
				params:{
					'workItemID':workItemID
				},
				pickItemName:'parentID',
				successHandler:me.saveSuccess,
				successHandlerScope:me
			};
		}else{
			handler=me.setParent;
			scope=me;
		}
		var issuePicker=Ext.create('com.trackplus.util.IssuePicker',{
			workItemID:workItemID,
			parent:true,
			projectID:projectID*-1,
			//projectName:projectName,
			title:getText('common.btn.chooseParent'),
			ajaxContext:ajaxContext,
			handler:handler,
			scope:scope
		});
		issuePicker.showDialog();
	},
	reverseAccessFlag:function(){
		this.reverseFlag('item!reverseAccessFlag.action?workItemID='+this.workItemID);
	},
	reverseArchive:function(){
		this.reverseFlag('item!reverseArchive.action?workItemID='+this.workItemID);
	},
	reverseDelete:function(){
		this.reverseFlag('item!reverseDelete.action?workItemID='+this.workItemID);
	},
	reverseFlag:function(urlStr){
		var me=this;
		Ext.Ajax.request({
			url: urlStr,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success===true) {
					me.reExecute();
				}else{
					if (responseJson.errorMessage) {
						//parent change for an issue
						Ext.MessageBox.show({
							title: getText('common.warning'),
							msg: responseJson.errorMessage,
						    buttons: Ext.Msg.OK,
						    icon: Ext.MessageBox.ERROR
						});
					}
				}
			},
			failure:function(){
				var jsonData=Ext.decode(action.response.responseText);
				me.handleErrors.call(me,jsonData.data);
			}
		});
	},
	sendEmail:function(){
		var me=this;
		var sendItemEmail=Ext.create('com.trackplus.item.SendEmail',{
			workItemID:me.workItemID,
			projectID:me.projectID
		});
		sendItemEmail.show();
	},
	back:function(){
	},
	getMyPosition:function(){
		return null;
	},
	navigateToItem:function(direction){
		var me=this;
		me.fireEvent('navigateToItem',me,direction);
	},
	reset:function(){
		var me=this;
		var itemFormPanel=me.itemComponent.itemPanel;
		itemFormPanel.getForm().reset();
	},
	setLoading:function(b){
		var me=this;
		var itemFormPanel=me.itemComponent.itemPanel;
		itemFormPanel.setLoading(b);
	},
	save:function(confirm){
		var me=this;
		var synopsis=me.itemComponent.txtTitleHeader.getValue();
		var itemFormPanel=me.itemComponent.itemPanel;
		var fieldTypeRenderersMap=me.itemComponent.screenFacade.screenController.fieldTypeRenderersMap;
		var parentID=me.itemComponent.screenFacade.screenController.dataModel.fieldValues['f16'];
		var parentOnscreen=false;
		var fieldTypeRenderer;
		for(var x in fieldTypeRenderersMap){
			if(x==='f16'){
				parentOnscreen=true;
			}
			fieldTypeRenderer=fieldTypeRenderersMap[x];
			fieldTypeRenderer.beforeSubmit.call(fieldTypeRenderer);
		}
		if(!itemFormPanel.getForm().isValid()){
			CWHF.showMsgError(getText('item.err.invalidForm'));
			var firstInvalid = itemFormPanel.getForm().getFields().findBy(function(f){return !f.validate();});
			if (firstInvalid) {
				firstInvalid.focus();
			}
			return false;
		}
		var lastModified=me.lastModified;
		var parentID=me.itemComponent.screenFacade.screenController.dataModel.fieldValues['f16'];
		var params={
			confirm: confirm,
			'workItemID':me.workItemID,
			'projectID':me.projectID,
			'issueTypeID':me.issueTypeID,
			'lastModified':lastModified,
			'fieldValues.f17':synopsis,
			'actionID':me.actionID//+'&forwardAction='+forwardAction,
		};
		//include parent to submit
		if(parentID&&parentOnscreen===false){
			params['fieldValues.f16']=parentID;
		}
		me.setLoading(true);
		itemFormPanel.getForm().submit({
			url:'itemSave.action',
			params:params,
			success: function(form, action) {
				me.setLoading(false);
				me.saveSuccess.call(me,form, action);
			},
			failure: function(form, action) {
                me.setLoading(false);
                var jsonData = null;
                var errorCode = null;
                var errors = null;
                if (action.response) {
                   var responseText = action.response.responseText;
                   if (responseText) {
                       jsonData = Ext.decode(responseText);
                       if (jsonData && jsonData.data) {
                           errorCode = jsonData.data.errorCode;
                           errors = jsonData.data.errors;
                       }
                   }
                }
                if (errorCode===3 && errors) {
                    //conformation needed
                    var errorMessage = "";
                    Ext.Array.forEach(errors, function (error) {
                        errorMessage += error.label;
                    }, me);
                    Ext.MessageBox.confirm(getText("common.confirm"),
                        errorMessage,
                        function(btn){
                            if (btn==="no") {
                                var jsonData=Ext.decode(action.response.responseText);
                                me.handleErrors.call(me,jsonData.data);
                            } else {
                                me.save.call(me, true);
                            }
                        }, this);
                }  else {
                    me.handleErrors.call(me,jsonData.data);
                }
			}
		});
	},
	setParent:function(item){
		var me=this;
		var key=item['objectID'];
		var id=item['id'];
		me.itemComponent.setParent.call(me.itemComponent,key,item['title'],id);
	},
	reload:function(item){
		var me=this;
		me.itemComponent.refreshItemPanel.call(me.itemComponent);
		if(me.successHandler){
			me.successHandler.call(me.scope?me.scope:me);
		}
	},
	handleErrors:function(data){
		var me=this;
		com.trackplus.item.ItemErrorHandler.handleErrors(me,data);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.item.ItemActionDialog',{
	extend:'com.trackplus.item.ItemAction',
	config:{
		title:'...',
		modal:true,
		w:1000,
		h:600,
		createDialogBeforeLoaded:true,
		animateTarget:null,
		position:null,
		addLinkFromContextMenu:null
	},
	myPosition:null,
	centerPanelCls:'itemDialogBody',
	dialog:null,
	savedSuccessfully:false,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		this.initConfig(config);
		this.listeners = config.listeners;
		this.callParent(arguments);
	},
	getMyPosition:function(){
		var me=this;
		return me.myPosition;
	},
	reExecute:function(){
		this.execute(true);
	},
	execute:function(reExecute){
		var me=this;
		if(!(reExecute===true)&&me.getCreateDialogBeforeLoaded()){
			me.initDialog();
		}
		me.callParent();
	},
	initDialog:function(){
		var me=this;
		me.initToolbar();
		me.createDialog();
		me.dialog.show(me.animateTarget);
	},
	loadSuccess:function(data){
		var me=this;
		if(!me.getCreateDialogBeforeLoaded()){
			me.initDialog();
		}
		me.callParent(arguments);
	},
	loadFailure:function(response){
		var me=this;
		if(me.dialog){
			try{
				me.dialog.close();
			}catch(ex){}
			me.dialog=null;
		}
		me.callParent(arguments);
	},
	createDialog:function(){
		var me=this;
		me.parentPanel= Ext.create('Ext.container.Container', {
			margin: '0 0 0 0',
			padding:' 0 0 0 0',
			border: false,
			cls:'itemDialogBody',
			layout:'fit',
			region:'center'
		});
		//me.toolbar.height=27;
		var size=borderLayout.ensureSize(me.getW(),me.getH());
		me.w=size.width;
		me.h=size.height;
		var northPanel=Ext.create('Ext.panel.Panel',{
			border:false,
			bodyBorder:false,
			margin:'0 0 0 0',
			region:'north',
			layout: {
				type: 'hbox',
				padding:'0',
				align:'top'
			},
			items:[me.toolbar,me.extraToolbar]
		});
		me.dialog= Ext.create('Ext.window.Window',{
			cls:'workItemDialog itemscreen',
			constrainHeader: true,
			maximizable :true,
			layout      : 'border',
			width       : me.w,
			height      : me.h,
			//iconCls     : this.iconCls,
			closeAction :'destroy',
			stateful:true,
			stateId :'winItem',
			bodyBorder  :false,
			bodyStyle: {
				border:'none'
			},
			plain       : true,
			title		:me.title,
			modal       :me.modal,
			items       :[northPanel,me.parentPanel],
			afterSetPosition:me.afterSetPositionItemDialog,
			listeners:{
				'staterestore':{
					fn:function(dialog,state){
						borderLayout.ensureDialogSizeFromState(dialog,state,me.position);
						me.myPosition=[dialog.x,dialog.y];
					}
				},
				'activate':{
					fn:function(){
						me.fireEvent.call(me,'activate',me);
					}
				},
				'deactivate':{
					fn:function(){
						me.fireEvent.call(me,'deactivate',me);
					}
				},
				'close':{
					fn:function(){
						me.fireEvent.call(me,'close',me,{savedSuccessfully:me.savedSuccessfully});
						me.savedSuccessfully=false;
					}
				},
				'maximize':{
					fn:me.onMaximizeItemDialog,
					scope:me
				},
				'beforestatesave':{
					fn:function(){
						me.myPosition=me.dialog.getPosition();
					}
				}
			}
		});
	},
	afterSetPositionItemDialog:function(){
		if(this.maximized===true){
			var maxH=borderLayout.getHeight();
			var h=this.getHeight();
			var y=this.getY();
			var preferredH=maxH-(67+28);
			if(preferredH!==h||y!==67){
				this.setY(67);
				this.setHeight(preferredH);
				this.updateLayout();
			}
		}
	},
	onMaximizeItemDialog:function(win, eOpts){
		var me=this;
		var h=me.dialog.getHeight();
		var maxH=borderLayout.getHeight();
		me.dialog.setHeight(maxH-(67+28));
		me.dialog.setY(67);
		me.dialog.updateLayout();
	},
	updateTitle:function(data){
		var me=this;
		if(me.dialog){
			var useWizard=data.useWizard;
			if(useWizard){
				me.dialog.setTitle(data.title1);
			}else{
				me.dialog.setTitle(data.title);
			}
		}
	},
	navigate:function(direction,data){
		var me=this;
		me.callParent(arguments);
		if(me.dialog){
			if(direction==="prev"){
				me.dialog.setTitle(data.title1);
			}else{
				me.dialog.setTitle(data.title);
			}
		}
	},
	saveSuccess:function(form, action){
		var me=this;
		var data=null;
		var workItemID=null;
		if(action){
			data=action.result.data;
			workItemID=data.workItemID;
		}
		if(me.successExtra&&me.successExtra['actionID']===-2){
			me.actionID=-2;
			if(CWHF.isNull(workItemID)){
				workItemID=me.successExtra['workItemID']
			}
			me.workItemID=workItemID;
			me.successExtra['actionID']=null;
			me.successExtra['workItemID']=null;
			me.reExecute();
		}else{
			try{
				me.savedSuccessfully=true;
				me.dialog.close();
				me.dialog.destroy();
			}catch(ex){}
			me.dialog=null;
		}
		me.callParent(arguments);
	},
	saveFailure:function(form, action){
		var me=this;
		if(me.dialog){
			try{
				me.dialog.destroy();
			}catch(ex){}
			me.dialog=null;
		}
		me.callParent(arguments);
	},
	executeToolbarAction:function(toolbarItem){
		var me=this;
		var id=toolbarItem.id;
		switch(id){
			case com.trackplus.item.ToolbarItem.ITEM_ACTION:
			case com.trackplus.item.ToolbarItem.SIBLING:
			case com.trackplus.item.ToolbarItem.BACK:
				break;
			case com.trackplus.item.ToolbarItem.NAVIGATION_NEXT:
				break;
			case com.trackplus.item.ToolbarItem.NAVIGATION_PREV:
				break;
			case com.trackplus.item.ToolbarItem.CANCEL:
				if(me.dialog) {
					if (me.successExtra  && me.successExtra['actionID'] === -2) {
						me.actionID = -2;
						me.workItemID  = me.successExtra['workItemID']
						me.successExtra['actionID'] = null;
						me.successExtra['workItemID'] = null;
						me.reExecute();
					} else {
						try {
							me.dialog.close();
							me.dialog.destroy();
						} catch (ex) {
						}
						me.dialog = null;
					}
				}
				break;
		}
		me.callParent(arguments);
	},
	setLoading:function(b){
		if(this.dialog){
			this.dialog.setLoading(b);
		}else{
			borderLayout.setLoading(b);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//MODEL
Ext.define('com.trackplus.screen.Screen',{
	extend:'Ext.Base',
	config: {
		id:null,
		label:null,
		name:null,
		description:null,
		personID:null,
		tabs:[]
	},
	type:'Screen',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	}
});
Ext.define('com.trackplus.screen.Tab',{
	extend:'Ext.Base',
	config: {
		id:null,
		name:null,
		label:null,
		description:null,
		panels:[]
	},
	type:'Tab',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	}
});
Ext.define('com.trackplus.screen.Panel',{
	extend:'Ext.Base',
	config: {
		id:null,
		label:null,
		description:null,
		colsNo:1,
		rowsNo:1,
		fields:[]
	},
	type:'Panel',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	}
});
//FIXME extends fields
Ext.define('com.trackplus.screen.Field',{
	extend:'Ext.Base',
	config: {
		id:null,
		title:null,
		extClassName:null,
		extReadOnlyClassName:null,
		label:null,
		value:null,
		displayValue:null,
		name:null,
		nameMapping:null,
		jsonData:{},
		empty:false,
		colSpan:0,
		rowSpan:0,
		row:0,
		col:0,
		labelHAlign:null,
		labelVAlign:null,
		valueHAlign:null,
		valueVAlign:null,
		hideLabel:false,
		iconRendering:null,
		fieldID:null
	},
	type:'Field',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	}
});
//Helpers
com.trackplus.screen.createScreenModel=function(jsonData){
	var screenModel=Ext.create('com.trackplus.screen.Screen',{
		id:jsonData.id,
		name:jsonData.name,
		label:jsonData.label,
		description:jsonData.description
	});
	var tabsJson=jsonData.tabs;
	if(tabsJson){
		var tabs=[];
		for(var i=0;i<tabsJson.length;i++){
			tabs.push(com.trackplus.screen.createTabModel(tabsJson[i]));
		}
		screenModel.setTabs(tabs);
	}
	return screenModel;
};
com.trackplus.screen.createTabModel=function(jsonData){
	var tabModel=Ext.create('com.trackplus.screen.Tab',{
		id:jsonData.id,
		name:jsonData.name,
		label:jsonData.label,
		description:jsonData.description
	});
	var panelsJson=jsonData.panels;
	if(panelsJson){
		var panels=[];
		for(var i=0;i<panelsJson.length;i++){
			panels.push(com.trackplus.screen.createPanelModel(panelsJson[i]));
		}
		tabModel.setPanels(panels);
	}
	return tabModel;
};
com.trackplus.screen.createPanelModel=function(jsonData){
	var panelModel=Ext.create('com.trackplus.screen.Panel',{
		id:jsonData.id,
		name:jsonData.name,
		label:jsonData.label,
		description:jsonData.description,
		colsNo:jsonData.colsNo,
		rowsNo:jsonData.rowsNo
	});
	var fieldsJson=jsonData.fields;
	if(fieldsJson){
		var fields=[];
		for(var i=0;i<fieldsJson.length;i++){
			fields.push(com.trackplus.screen.createFieldModel(fieldsJson[i]));
		}
		panelModel.setFields(fields);
	}
	return panelModel;
};
com.trackplus.screen.createFieldModel=function(fieldData){
	var fieldModel=Ext.create('com.trackplus.screen.Field',{
		id:fieldData.id,
		name:fieldData.name,
		nameMapping:fieldData.nameMapping,
		label:fieldData.label,
		description:fieldData.description,
		empty:fieldData.empty,
		row:fieldData.row,
		col:fieldData.col,
		rowSpan:fieldData.rowSpan,
		colSpan:fieldData.colSpan,
		jsonData:fieldData.jsonData,
		extClassName:fieldData.extClassName,
		extReadOnlyClassName:fieldData.extReadOnlyClassName,
		value:fieldData.value,
		displayValue:fieldData.displayValue,
		labelHAlign:fieldData.labelHAlign,
		labelVAlign:fieldData.labelVAlign,
		valueHAlign:fieldData.valueHAlign,
		valueVAlign:fieldData.valueVAlign,
		hideLabel:fieldData.hideLabel,
		iconRendering:fieldData.iconRendering,
		fieldID:fieldData.fieldID
	});
	return fieldModel;
};
//VIEW
Ext.define('com.trackplus.screen.ScreenView',{
	extend: 'Ext.container.Container',
	border: false,
	margin: '0 0 0 0',
	frame: false,
	collapsible:false,
	padding:0,
	plain:true,
	originalTitle:'',
	layout:'fit',
	region:'center',
	config: {
		model:null,
		parentView:null,
		oneTab:false
	},
	initComponent: function(){
		var me=this;
		if(me.oneTab){
			me.margin= '0 0 0 0';
		}else{
			me.margin= '0 0 0 0';
		}
		Ext.apply(this);
		me.callParent();
	},
	getSelectedTab:function(){
		var me=this;
		if(me.oneTab){
			return  me.items.get(0);
		}else{
			return  me.items.get(0).getActiveTab();
		}
	}
});
Ext.define('com.trackplus.screen.TabView',{
	extend: 'Ext.container.Container',
	config: {
		model:null,
		parentView:null,
		oneTab:false
	},
	oneTab:false,
	border:false,
	style:{
		overflow:'auto'
	},
	initComponent: function(){
		var me=this;
		if(me.oneTab===true){
			me.margin= '0 0 0 0';
			me.region='center';
		}else{
			me.margin='0 0 0 0';
			me.title=me.model.getLabel();
		}
		me.callParent();
	},
	unregister:function(){
		var me=this;
		var panels=me.items;
		var panelCmp;
		for(var i=0;i<panels.getCount();i++){
			panelCmp=panels.getAt(i);
			panelCmp.unregister.call(panelCmp);
		}
	}
});
Ext.define('com.trackplus.screen.PanelView',{
	extend: 'Ext.container.Container',
	config: {
		model:null,
		parentView:null,
		myIndex:0,
		myLength:1
	},
	dragDropObjects:[],
	margin:'0 0 0 0',
	border:false,
	myComponentCls:null,
	unregister:function(){
		var me=this;
		var ddObjects= me.dragDropObjects;
		for(var i=0;i<ddObjects.length;i++){
			var o=ddObjects[i];
			o.destroy();
			o=null;
		}
		me.dragDropObjects=[];
	},
	/*initComponent: function(){
		var me=this;
		var cfg=me.getPanelConfig.call(me,me.model,me.myIndex,me.myLength);
		Ext.apply(this,cfg);
		me.callParent();
	},*/
	getPanelConfig:function(model,index,length){
		var me=this;
		var cls="screenPanel";
		var margin='0 0 5 0';
		if(index===0){
			cls="screenPanel-first";
			margin='0 0 5 0';
		}
		if(index%2===1){
			cls="screenPanel-odd";
		}
		me.myComponentCls=cls;
		return {
			cls:cls,
			margin:margin,
			border:true,
			layout: {
				type: 'table',
				columns: model.colsNo,
				tableAttrs: {
					style: {
						minWidth: '100%'
					}
				},
				trAttrs:{
					'class':'screenField-tr',
					style:{
						'vertical-align':'top'
					}
				}
			},
			defaults: {frame:false, border: false}
		};
	}
});
Ext.define('com.trackplus.screen.FieldErrorView',{
	extend:'Ext.panel.Panel',
	config:{
		fieldModel:null,
		parentView:null,
		error:null
	},
	layout:'anchor',
	border:true,
	bodyBorder:false,
	bodyCls:'screeFieldError',
	initComponent : function(){
		var me=this;
		Ext.apply(this);
		var msgCmp=Ext.create('Ext.form.field.Display',{
			fieldLabel:'Class',
			anchor : '100%',
			value:me.fieldModel.extClassName
		});
		var errorCmp=Ext.create('Ext.form.field.Display',{
			fieldLabel:'Error',
			anchor : '100%',
			value:me.error.message
		});
		me.items=[msgCmp,errorCmp];
		me.callParent();
	}
});
Ext.define('com.trackplus.screen.BaseScreenController',{
	extend:'Ext.Base',
	mixins: {
		observable: 'Ext.util.Observable'
	},
	config: {
		screenModel:null,
		showOneTab:false,
		lastSelectedTab:null,
		refreshTabUrl:null,
		storeTabUrl:null,
		screenViewCls:'com.trackplus.screen.ScreenView',
		tabViewCls:'com.trackplus.screen.TabView',
		panelViewCls:'com.trackplus.screen.PanelView',
		fieldWrapperCls:null,
		fieldErrorCls:null,
		dataModel:null
	},
	screenViewCls:'com.trackplus.screen.ScreenView',
	tabViewCls:'com.trackplus.screen.TabView',
	panelViewCls:'com.trackplus.screen.PanelView',
	fieldErrorCls:'com.trackplus.screen.FieldErrorView',
	screenView:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.mixins.observable.constructor.call(this, config);
	},
	createScreenView:function(screenModel){
		var me=this;
		var tabsData=me.screenModel.getTabs();
		me.screenView=Ext.create(me.screenViewCls,{
			model:screenModel,
			oneTab:me.showOneTab&&tabsData.length===1
		});
		me.refreshScreenModel(me.screenView,screenModel,me.lastSelectedTab);
		me.afterScreenCreated.call(me,me.screenView);
		return me.screenView;
	},
	afterScreenCreated:function(screenCmp){
	},
	refreshScreenModel:function(screenView,screenModel,selectedTab){
		var me=this;
		me.screenModel=screenModel;
		me.lastSelectedTab=selectedTab;
		screenView.model=screenModel;
		screenView.removeAll(true);
		var tabsData=me.screenModel.getTabs();
		var cmp;
		if(me.showOneTab===true&&tabsData.length===1){
			cmp=me.createTab(screenView,tabsData[0],true);
		}else{
			cmp=me.createTabPanel(screenView,tabsData);
		}
		screenView.add(cmp);
		screenView.updateLayout();
	},
	createTabPanel:function(parentView,tabsData){
		var me=this;
		var tabsItems=[];
		var activeTab=0;
		for(var i=0;i<tabsData.length;i++){
			tabsItems.push(me.createTab(parentView,tabsData[i]));
			if(me.lastSelectedTab&&tabsData[i].getId()===me.lastSelectedTab){
				activeTab=i;
			}
		}
		var tabsPanel=Ext.create('Ext.tab.Panel',{
			plain:true,
			border:false,
			region:'center',
			bodyBorder:false,
			defaults:{autoScrollX: true},
			items:tabsItems,
			activeTab:activeTab,
			cls:'screenTabPanel'
		});
		me.afterTabPanelCreated.call(me,tabsPanel);
		return tabsPanel;
	},
	afterTabPanelCreated:function(tabsPanel){
	},
	createTab:function(parentView,tabModel,oneTab){
		var me=this;
		var cfg={
			parentView:parentView,
			model:tabModel,
			refreshTabUrl:me.refreshTabUrl,
			storeTabUrl:me.storeTabUrl,
			getPanelConfig:me.getPanelConfig,
			oneTab:oneTab
		};
		if(oneTab){
			cfg.region='center';
		}
		var tabCmp= Ext.create(me.tabViewCls,cfg);
		me.refreshTabModel.call(me,tabCmp,tabModel);
		tabCmp.addListener('activate',me.tabActivate,me);
		me.afterTabCreated.call(me,tabCmp);
		return tabCmp;
	},
	afterTabCreated:function(tabCmp){
	},
	tabActivate:function(tab){
		var me=this;
		var tabModel=tab.model;
		if(me.storeTabUrl){
			Ext.Ajax.request({
				url: me.storeTabUrl,
				disableCaching :true,
				method:'POST',
				params:{"tabID":tabModel.getId()}
			})
		}
		if(me.refreshTabUrl){
			me.refreshTab.call(me,tab);
		}
	},
	refreshTabModel:function(tabCmp,tabModel,idChild){
		var me=this;
		var panelsData=tabModel.getPanels();
		tabCmp.unregister();
		tabCmp.removeAll(true);
		tabCmp.tabModel=tabModel;
		var panels=new Array(0);
		var panelToSelect=null;
		if(panelsData&&panelsData.length>0){
			for(var i=0;i<panelsData.length;i++){
				var panCmp=me.createPanel(tabCmp,panelsData[i],i,panelsData.length);
				panels.push(panCmp);
				if(idChild&&idChild===panelsData[i].id){
					panelToSelect=panCmp;
				}
			}
		}
		tabCmp.add(panels);
		return panelToSelect;
	},
	refreshTab:function(tabCmp,url){
		var me=this;
		var tabModel=tabCmp.model;
		var urlStr=me.refreshTabUrl;
		if(url&&url.length>0){
			urlStr=url;
		}
		if(CWHF.isNull(urlStr)){
			return -1;
		}
		tabCmp.setLoading(getText("common.lbl.loading"));
		Ext.Ajax.request({
			url:urlStr ,
			disableCaching :true,
			encoding: "utf-8",
			params:{"tabID":tabModel.getId(),'componentID':tabModel.getId()},
			success: function(response){
				var jsonData=Ext.decode(response.responseText);
				var tabModelNew=com.trackplus.screen.createTabModel(jsonData.data);
				me.refreshTabModel.call(me,tabCmp,tabModelNew);
				tabCmp.setLoading(false);
			},
			failure: function(response){
				tabCmp.setLoading(false);
				com.trackplus.util.requestFailureHandler(response);
			}
		});
	},
	createPanel:function(parentView,model,index,length){
		var me=this;
		var panel=Ext.create(me.panelViewCls,{
			parentView:parentView,
			model:model,
			myIndex:index,
			myLength:length
		});
		me.refreshPanelModel(panel,model);
		me.afterPanelCreated.call(me,panel);
		return panel;
	},
	afterPanelCreated:function(panelCmp){
	},
	refreshPanelModel:function(panelCmp,panelModel,b){
		var me=this;
		var fieldsData=panelModel.getFields();
		var fields=new Array(0);
		panelCmp.unregister.call(panelCmp);
		panelCmp.removeAll(true);
		if(!b) {
			var cfg = panelCmp.getPanelConfig.call(panelCmp, panelModel, panelCmp.myIndex, panelCmp.myLength);
			Ext.apply(panelCmp, cfg);
		}
		if(fieldsData){
			for(var i=0;i<fieldsData.length;i++){
				fields.push(me.createField(panelCmp, fieldsData[i]));
			}
		}
		panelCmp.add(fields);
	},
	createField:function(parentView,aFieldData){
		var me=this;
		var aField;
		if(aFieldData.empty){
			aField=Ext.create('Ext.form.Label');
		}else{
			try{
				aField=Ext.create(aFieldData.extClassName,{jsonData:aFieldData.jsonData,parentView:parentView});
			}catch(e){
				aField=Ext.create(me.fieldErrorCls, {
					parentView:parentView,
					fieldModel:aFieldData,
					error:e
				});
			}
			aField.colspan=aFieldData.colSpan;
			aField.rowspan=aFieldData.rowSpan;
		}
		return aField;
	}
});
Ext.define('com.trackplus.screen.BaseScreenFacade',{
	extend:'Ext.Base',
	config: {
		screenModel:null,
		readOnlyMode:false,
		showOneTab:false,
		lastSelectedTab:null,
		refreshTabUrl:null,
		storeTabUrl:null,
		controllerCls:null,
		screenViewCls:'com.trackplus.screen.ScreenView',
		tabViewCls:'com.trackplus.screen.TabView',
		panelViewCls:'com.trackplus.screen.PanelView',
		fieldWrapperCls:null,
		fieldErrorCls:'com.trackplus.screen.FieldErrorView',
		dataModel:null
	},
	screenViewCls:'com.trackplus.screen.ScreenView',
	panelViewCls:'com.trackplus.screen.PanelView',
	fieldErrorCls:'com.trackplus.screen.FieldErrorView',
	controllerCls:'com.trackplus.screen.BaseScreenController',
	screenController:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
   	    Ext.apply(me, config);
		this.initConfig(config);
		me.screenController=Ext.create(me.controllerCls,{
			screenModel:me.screenModel,
			readOnlyMode:me.readOnlyMode,
			showOneTab:me.showOneTab,
			lastSelectedTab:me.lastSelectedTab,
			refreshTabUrl:me.refreshTabUrl,
			storeTabUrl:me.storeTabUrl,
            tabViewCls:me.tabViewCls,
			panelViewCls:me.panelViewCls,
			fieldErrorCls:me.fieldErrorCls,
			dataModel:me.dataModel
		});
	},
	screenView:null,
	createViewComponent:function(){
		var me=this;
		me.screenView=me.screenController.createScreenView.call(me.screenController,me.screenModel);
		return me.screenView;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.aurel.trackplus.field.FieldConfig',{
	extend:'Ext.Base',
	config: {
		fieldID:null,
		parameterCode:null,
		label:null,
		tooltip:null,
		required:false,
		readonly:false,
		invisible:false,
		jsonData:{}
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	}
});
Ext.define('com.aurel.trackplus.field.TypeRenderer',{
	extend:'Ext.Base',
	mixins: {
		observable: 'Ext.util.Observable'
	},
	config:{
		workItemID:null,
		projectID:null,
		fieldConfig:null,
		value:null,
		displayValue:null,
		name:null,
		labelHAlign:null,
		labelVAlign:null,
		valueHAlign:null,
		valueVAlign:null,
		hideLabel :false
	},
	view:null,
	tip:null,
	requiredHtmlTxt:'', //'<span style="color:#FF0000;">*</span>',
	requiredMarkup:'<span class="required">&nbsp;</span>',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		this.mixins.observable.constructor.call(this, config);
		/*this.initConfig(config);
		this.addEvents('valueChange');
		this.addEvents('dblclick');
		this.addEvents('layoutChange');
		this.addEvents('afterRender');*/
	},
	getOriginalValue:function(){
		return this.value;
	},
	beforeSubmit:function(){
	},
	getValue:function(){
		var me=this;
		var value=null;
		if(me.view){
			if(me.view.getSubmitValue&&Ext.isFunction(me.view.getSubmitValue)){
				value=me.view.getSubmitValue.call(me.view);
			}
		}
		return value;
	},
	getView:function(){
		var me=this;
		if(CWHF.isNull(me.view)){
			me.view=me.createView();
			me.view.addListener('render',function(c){
				c.getEl().on('dblclick', function(){
					me.itemDblClick.call(me,c);
				});
			});
		}
		return me.view;
	},
	itemDblClick:function(){
		var me=this;
		me.fireEvent('dblclick',me.fieldID);
	},
	createView:function(){
		return Ext.create('Ext.form.Label',{});
	},
	update:function(config){
		var me=this;
		Ext.apply(me, config);
		me.refreshView();
	},
	refreshView:function(){
	},
	focus:function(){
		var me=this;
		if(me.view){
			if(me.view.focus&&Ext.isFunction(me.view.focus)){
				me.view.focus.call(me.view);
			}
		}
	},
	markInvalid:function(str){
		var me=this;
		if(me.view){
			if(me.view.markInvalid&&Ext.isFunction(me.view.markInvalid)){
				me.view.markInvalid.call(me.view,str);
			}
		}
	},
	markConflict:function(newValue){
		var me=this;
		if(CWHF.isNull(newValue)){
			newValue='';
		}
		var str=getText('common.err.concurrentSave.conflict',newValue);
		if(me.view){
			me.view.addCls('fieldConflict');
			me.setToolTip(str);
		}
	},
	markModifiedByMe:function(){
		var me=this;
		var str=getText('common.err.concurrentSave.modifiedByMe');
		if(me.view){
			me.view.addCls('modifiedByMe');
			me.setToolTip(str);
		}
	},
	markModifiedByOther:function(newValue){
		var me=this;
		var str=getText('common.err.concurrentSave.modifiedByOther');
		if(me.view){
			me.view.addCls('modifiedByOther');
			me.view.setValue(newValue);
			me.setToolTip(str);
		}
	},
	setToolTip:function(str){
		var me=this;
		if(CWHF.isNull(str)){
			if(CWHF.isNull(me.tip)){
				me.tip.destroy();
				delete me.tip;
			}
			return;
		}
		if(me.view){
			var domEl=me.view.getEl();
			if(domEl){
			if(CWHF.isNull(me.tip)){
					var tip = Ext.create('Ext.tip.ToolTip', {
						target: domEl,
						html: str
					});
				}else{
					me.tip.update(str);
				}
			}
		}
	}
});
Ext.define('com.aurel.trackplus.field.LabelTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		return  Ext.create('Ext.form.field.Display',{
			fieldLabel: label,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden',width:'300px'},
			fieldStyle : {
				height:'auto',
				margin: '0 0 0 0'
			},
			value:me.displayValue,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		me.view.setFieldLabel(label);
		me.view.setValue(me.displayValue);
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.TextFieldTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			// label=label+me.requiredHtmlTxt;
			requiredMarkup='';
		}
		return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			labelStyle:{overflow:'hidden'},
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			name: name,
			allowBlank:!required,
			value:me.value,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.TextAreaTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var txtValue='';
		if(me.value){
			txtValue=me.value;
		}
		me.txtArea=Ext.create('Ext.form.field.TextArea',{
			//fieldLabel: label,
			//labelAlign:me.labelHAlign,
			//labelStyle:{overflow:'hidden'},
			hideLabel:true,
			name: name,
			allowBlank:!required,
			value:txtValue,
			hidden:hidden,
			style:{
				width: '100%'
			}
		});
		/*return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			labelStyle:{overflow:'hidden'},
			labelAlign:me.labelHAlign,
			name: name,
			allowBlank:!required,
			value:me.value,
			hidden:hidden
		});*/
		//return me.txtArea;
		return Ext.create('Ext.form.FieldContainer',{
			combineErrors: true,
			fieldLabel: label,
			afterLabelTextTpl: requiredMarkup,
			labelAlign:me.labelHAlign,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			layout:'anchor',
			defaults: {
				hideLabel: true
			},
			style:{
				width: '100%'
			},
			items :[me.txtArea],
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		var txtValue='';
		if(me.value){
			txtValue=me.value;
		}
		me.txtArea.setValue(txtValue);
		me.txtArea.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.SynopsisTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			afterLabelTextTpl: requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			name: name,
			allowBlank:!required,
			value:me.value,
			width:500,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.afterLabelTextTpl = requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.DateTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var dateField = CWHF.createDateField(label, name,{
			labelIsLocalized:true,
			allowBlank:!required,
			value:me.value,
			labelAlign:me.labelHAlign,
			afterLabelTextTpl: requiredMarkup,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			hidden:hidden, labelWidth:100, width:210,
			//same as format because the submit is parsed as a gui date string (with 4 digits year)
			//(not interpreted by struts2 (two digits year) to convert directly into a Date type object)
			submitFormat: com.trackplus.TrackplusConfig.DateFormat
		});
		dateField.addListener('change',me.valueChange,me);
		//dateField.addListener('afterRender',me.afterRender,me);
		return dateField;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabeltextTpl=requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	},
	valueChange:function(fieldCmp, newValue, oldValue){
		var me=this;
		var fieldValues={};
		fieldValues["f"+me.fieldID]=newValue;
		var oldFieldValues = {};
		oldFieldValues["f"+me.fieldID]=oldValue;
		me.fireEvent("valueChange",me.fieldID,fieldValues,oldFieldValues, me);
	}/*,
	afterRender:function(fieldCmp){
		var me=this;
		if (me.fieldID===20 || me.fieldID===30) {
			var fieldValues={};
			fieldValues["f"+me.fieldID]=fieldCmp.getValue();
			me.fireEvent("valueChange", me.fieldID, fieldValues, null, me);
		}
	}*/
});
Ext.define("com.aurel.trackplus.field.EndDateRenderer",{
	extend:"com.aurel.trackplus.field.DateTypeRenderer",
	config: {
		durationFieldID: 33,
		startDateFieldID: 19
	},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	},
	refreshDependentFields:function(fieldID, fieldValues, oldFieldValues, renderer, modelFieldValues, isFromGantt) {
		var me=this;
		var durationFieldID = renderer.durationFieldID;
		var startDateFieldID = renderer.startDateFieldID;
		var newEndDate = fieldValues["f"+fieldID];
		if(!isFromGantt) {
			modelFieldValues["f"+fieldID] = Ext.Date.format(newEndDate, com.trackplus.TrackplusConfig.DateFormat);;
		}
		var oldEndDate = null;
		if (oldFieldValues) {
			oldEndDate = me.getDateFromModel(oldFieldValues, "f"+fieldID, isFromGantt);//oldFieldValues["f"+fieldID];
		}
		var startDate = me.getDateFromModel(modelFieldValues, "f"+startDateFieldID, isFromGantt);//modelFieldValues["f"+startDateFieldID];
		if (CWHF.isNull(newEndDate)|| newEndDate.length===0
				|| CWHF.isNull(startDate) || startDate.length===0) {
			me.updateField(durationFieldID, null, "", modelFieldValues);
		} else {
			if (newEndDate !== oldEndDate) {
				var startDate = me.getDateFromModel(modelFieldValues, "f"+startDateFieldID, isFromGantt);//modelFieldValues["f"+startDateFieldID];
				var duration = me.getDurationBetweenDates(startDate, newEndDate);
				me.updateField(durationFieldID, duration, duration, modelFieldValues);
			}
		}
	}
});
Ext.define("com.aurel.trackplus.field.EndDateTargetRenderer",{
	extend:"com.aurel.trackplus.field.EndDateRenderer",
	config: {
		durationFieldID: 34,
		startDateFieldID: 29
	},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	}
});
Ext.define("com.aurel.trackplus.field.StartDateRenderer", {
	extend:"com.aurel.trackplus.field.DateTypeRenderer",
	config: {
		durationFieldID: 33,
		endDateFieldID: 20
		},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	},
	refreshDependentFields:function(fieldID, fieldValues, oldFieldValues, renderer, modelFieldValues, isFromGantt) {
		var me=this;
		var durationFieldID = renderer.durationFieldID;
		var endDateFieldID = renderer.endDateFieldID;
		var newStartDate = fieldValues["f"+fieldID];
		if(!isFromGantt) {
			modelFieldValues["f"+fieldID] = Ext.Date.format(newStartDate, com.trackplus.TrackplusConfig.DateFormat);
		}
		var oldStartDate = null;
		if (oldFieldValues) {
			oldStartDate = me.getDateFromModel(oldFieldValues, "f"+fieldID, isFromGantt);//oldFieldValues["f"+fieldID];
		}
		var duration = modelFieldValues["f"+durationFieldID];
		if (duration) {
			var endDate = me.getDateFromModel(modelFieldValues, "f"+endDateFieldID, isFromGantt);//modelFieldValues["f"+endDateFieldID];
			if (CWHF.isNull(newStartDate) || newStartDate.length===0 || CWHF.isNull(endDate) || endDate.length===0) {
				me.updateField(durationFieldID, null, "", modelFieldValues);
			} else {
				if (newStartDate !== oldStartDate) {
					endDate = this.addWeekdays(newStartDate, duration, true);
					me.updateField(endDateFieldID, endDate, endDate, modelFieldValues);
				}
			}
		}
	}
});
Ext.define("com.aurel.trackplus.field.StartDateTargetRenderer", {
	extend:"com.aurel.trackplus.field.StartDateRenderer",
	config: {
		durationFieldID: 34,
		endDateFieldID: 30
	},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	}
});
Ext.define('com.aurel.trackplus.field.HtmlReadOnlyTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		return  Ext.create('Ext.form.field.Display',{
			fieldLabel: label,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'olist-ulist htmlReadOnlyField labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			fieldStyle : {
				height:'auto'
			},
			value:me.displayValue,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		me.view.setFieldLabel(label);
		me.view.setValue(me.displayValue);
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.HtmlTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var txtValue='';
		if(me.value){
			txtValue=me.value;
		}
		var otherCfg={
			fieldLabel: label,
			afterLabelTextTpl: requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'rteField labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			value:txtValue,
			style:{
				width: '100%'
			},
			inputWidth:'300',
			height:175
		};
		var ckeditorCfg={
			//resize_enabled:true
			workItemID:me.workItemID,
			projectID:me.projectID,
			useInlineTask:true,
			useBrowseImage:true,
			finishedUploadHandler:function(data){
				me.fireEvent("finishedUpload");
			}
		}
		me.txtArea=CWHF.createRichTextEditorField(name,otherCfg,false,false,ckeditorCfg);
		return me.txtArea;
	},
	beforeSubmit:function(){
		CWHF.submitRTEditor(this.view);
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		CWHF.refreshRTEditorValue(me.view,me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
	//initEditor:function(c){
	//	var me=this;
	//	me.replaceTextArea(me.idDescription+"-inputEl");
	//},
	//replaceTextArea:function(idDescription,sLang){
	//	var me=this;
	//	var toolbarFCKStartExpanded=true;
	//	if (CWHF.isNull(sLang)){
	//		sLang="en";
	//	}
	//	var o=CKEDITOR.instances[idDescription];
	//	if (o){
	//		CKEDITOR.remove(o);
	//	}
	//	me.ckEditor=CKEDITOR.replace(idDescription,{
	//		customConfig:sBasePath+'cktrackplusconfig.js',
	//		contentsCss:com.trackplus.TrackplusConfig.htmlEditorCSS,
	//		language:sLang/*,
	//		toolbarStartupExpanded:toolbarFCKStartExpanded*/
	//	});
	//	me.ckEditor.on('blur', function(e) {
	//		me.ckEditor.updateElement();
	//	});
	//	me.ckEditor.on('instanceReady', function(e) {
	//		me.fireEvent('afterRender',me.fieldID);
	//	});
	//},
	//getValue:function(){
	//	var me=this;
	//	var value=null;
	//	if(me.ckEditor){
	//		value=me.ckEditor.getData();
	//		me.ckEditor.updateElement();
	//	}
	//	return value;
	//}
});
Ext.define('com.aurel.trackplus.field.SelectTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			// label=label+me.requiredHtmlTxt;
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var options=data.list;
		if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}
		var forceSelection=false;
		if(me.fieldConfig.jsonData.forceSelection){
			forceSelection=me.fieldConfig.jsonData.forceSelection;
		}
		var cmbCfg={
			forceSelection:forceSelection,
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			store:Ext.create('Ext.data.Store', {
				fields:[
					{type: 'int', name: 'id',allowNull:true},
					{type: 'string', name: 'label'}
				],
				data:options
			}),
			valueField:'id',
			displayField: 'label',
			queryMode: 'local',
			allowBlank:!required,
			name: name,
			editable:true,
			typeAhead: true,
			anyMatch:true,
			grow:true
		}
		if(required===false){
			cmbCfg.tpl= new Ext.XTemplate('<tpl for=".">' + '<li style="min-height:22px;" class="x-boundlist-item" role="option">' + '{label}' + '</li></tpl>');
		}
		var cmb=Ext.create('Ext.form.ComboBox',cmbCfg);
		cmb.setValue(me.value);
		cmb.addListener('change',me.valueChange,me);
		return cmb;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			//label=label+me.requiredHtmlTxt;
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var options=data.list;
		if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.store.loadData(options);
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	},
	valueChange:function(fieldCmp,newValue){
		var me=this;
		var fieldValues={};
		fieldValues['fieldValues.f'+me.fieldID]=newValue;
		me.fireEvent('valueChange',me.fieldID,fieldValues);
	}
});
Ext.define('com.aurel.trackplus.field.CrmContactRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var fieldID=me.fieldConfig.fieldID;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var cmb=Ext.create('Ext.form.ComboBox',{
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			valueField:'contactPartnerID',
			displayField: 'displayValue',
			allowBlank:!required,
			name: name,
			forceSelection:true,
			width: 500,
			hideTrigger: true,
			minChars: 2,
			triggerAction: 'query',
			typeAhead: true,
			store: {
				fields: [	{name: 'contactPartnerID', mapping: 'contactPartnerID'},
							{name: 'customerID', mapping: 'customerID'},
							{name: 'displayValue', mapping: 'displayValue'},
							{name: 'customerName', mapping: 'customerName'},
							{name: 'postalCode', mapping: 'postalCode'},
							{name: 'city', mapping: 'city'},
							{name: 'street', mapping: 'street'},
							{name: 'country', mapping: 'country'},
							{name: 'contactPartnerFirstName', mapping: 'contactPartnerFirstName'},
							{name: 'contactPartnerLastName', mapping: 'contactPartnerLastName'}],
				proxy: {
					type: 'ajax',
					url: 'remoteFiltering.action',
					extraParams: {fieldID:fieldID}
				},
				data:data.list
			},
			tpl:new Ext.XTemplate('<tpl for=".">' + '<li style="min-height:22px;" class="x-boundlist-item{[xindex % 2 === 0 ? "":" x-boundlist-item-odd"]}" role="option">' +
				'{customerID} {country} <br/> {customerName} <br/> {postalCode} {city}, {street} <br/> <b>{contactPartnerFirstName} {contactPartnerLastName}</b>' +
				'</li></tpl>')
			/*listConfig: {
				//loadingText: 'Searching...',
				//emptyText: 'No matching customer found.',
				getInnerTpl: function() {
					return '{customerID} {country} <br/> {customerName} <br/> {postalCode} {city}, {street} <br/> <b>{contactPartnerFirstName} {contactPartnerLastName}</b>';
				}
			}*/
		});
		cmb.setValue(me.value);
		//cmb.addListener('change',me.valueChange,me);
		return cmb;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.store.loadData(data.list);
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
	/*valueChange:function(fieldCmp,newValue){
		var me=this;
		var data=me.fieldConfig.jsonData;
		var fieldValues=[];
		fieldValues['fieldValues.f'+me.fieldID]=newValue;
		me.fireEvent('valueChange',me.fieldID,fieldValues);
	}*/
});
Ext.define('com.aurel.trackplus.field.ExtensibleSelectTypeRenderer',{
	extend:'com.aurel.trackplus.field.SelectTypeRenderer',
	createView:function(){
		var me=this;
		var cmb=me.callParent(arguments);
		cmb.editable=true;
		cmb.getSubmitValue=function(){
			var v=this.getValue();
			var record=this.findRecordByValue(v);
			if(record===false){
				return CWHF.isNull(v)?"":"'"+v+"'";
			}else{
				return v;
			}
		};
		return cmb;
	}
});
Ext.define('com.aurel.trackplus.field.MultipleSelectPickerRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	config:{
		useIconCls:false,
		iconFieldID:null,
		pikerWidth:300
	},
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var options=data.list;
		/*if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}*/
		var optionLength=0;
		if(options){
			optionLength=options.length;
		}
		var iconFieldID=me.getIconFieldID();
		console.log("me.useIconCls="+me.useIconCls);
		console.log("me.getUseIconCls()="+me.getUseIconCls());
		var picker =Ext.create('com.trackplus.util.MultipleSelectPicker',{
			options:options,
			includeSearch:optionLength>=7,
			labelStyle:{overflow:'hidden'},
			labelWidth:100,
			width:me.getPikerWidth(),
			name:name,
			value:me.value,
			fieldLabel:label,
			labelAlign:me.labelHAlign,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			useNull:true,
			afterLabelTextTpl:requiredMarkup,
			useIconCls:me.getUseIconCls(),
			iconUrlPrefix:CWHF.isNull(iconFieldID)?null:'optionIconStream.action?fieldID='+iconFieldID+"&optionID="
		});
		picker.addListener('change',me.valueChange,me);
		return picker;
	},
	valueChange:function(fieldCmp,newValue){
		var me=this;
		var name=me.fieldConfig.name;
		var fieldValues={};
		fieldValues['fieldValues.f'+me.fieldID]=newValue;
		me.fireEvent('valueChange',me.fieldID,fieldValues);
	},
	refreshView:function(){
		var me=this;
		var name=me.fieldConfig.name;
		var value=me.value;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			//label=label+me.requiredHtmlTxt;
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		var options=data.list;
		if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}
		me.view.updateMyOptions(options);
		me.view.setValue(value,true);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.MultipleSelectTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var cmb=Ext.create('Ext.ux.form.MultiSelect',{
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			store:Ext.create('Ext.data.Store', {
				fields:[
					{type: 'int', name: 'id'},
					{type: 'string', name: 'label'}
				],
				data:data.list
			}),
			valueField:'id',
			displayField: 'label',
			queryMode: 'local',
			allowBlank:!required,
			name: name,
			value:me.value,
			grow:true,
			//width:300,
			height:125
		});
		cmb.setValue(me.value);
		return cmb;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.ReleasePickerRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		var includeClear=!required;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var releaseTree = data["releaseTree"];
		var picker = CWHF.createSingleTreePicker(label,	name, releaseTree, me.value,
			{
				includeClear:includeClear,
				labelIsLocalized: true,
				afterLabelTextTpl: requiredMarkup,
				labelAlign:me.labelHAlign,allowBlank:!required,
				cls :'labelVerticalAlign-'+me.labelVAlign+
					' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
				labelStyle:{overflow:'hidden'},
				labelWidth:100,
				width:310
			}
		);
		return picker;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		var value=null;
		try{
			 value=parseInt(me.value);
			 if(isNaN(value)){
				value=null;
			}
		}catch(e){}
		var data=me.fieldConfig.jsonData;
		var releaseLabel=data.releaseLabel;
		me.view.setValue(releaseLabel);
		me.view.releaseID=value;
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.ProjectPickerRenderer',{
    extend:'com.aurel.trackplus.field.TypeRenderer',
    createView:function(){
        var me=this;
        var label=me.fieldConfig.label;
        var hidden=me.fieldConfig.invisible;
        var name=me.fieldConfig.name;
        var required=me.fieldConfig.required;
        var requiredMarkup=me.requiredMarkup;
        if(required===false){
            requiredMarkup='';
        }
        var data=me.fieldConfig.jsonData;
        var projectTree = data["projectTree"];
        var picker = CWHF.createMultipleTreePicker(label,
            name, projectTree, me.value,
            {   useRemoveBtn:false,
                useNull:true,
                //useTooltip:false,
                labelIsLocalized: true,
                afterLabelTextTpl: requiredMarkup,
                labelAlign:me.labelHAlign,
                allowBlank:!required,
                cls :'labelVerticalAlign-'+me.labelVAlign+
                    ' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
                labelStyle:{overflow:'hidden'},
                labelWidth:100,
                width:310
            });
        return picker;
    },
    refreshView:function(){
        var me=this;
        var label=me.fieldConfig.label;
        var hidden=me.fieldConfig.invisible;
        var required=me.fieldConfig.required;
        var requiredMarkup=me.requiredMarkup;
        if(required===false){
            requiredMarkup='';
        }
        me.view.setFieldLabel(label);
        me.view.afterLabelTextTpl=requiredMarkup;
        var data=me.fieldConfig.jsonData;
        me.view.allowBlank=!required;
        me.view.hidden=hidden;
    }
});
Ext.define('com.aurel.trackplus.field.ItemPickerRenderer',{
    extend:'com.aurel.trackplus.field.TypeRenderer',
    createView:function(){
        var me=this;
        var label=me.fieldConfig.label;
        var hidden=me.fieldConfig.invisible;
        var name=me.fieldConfig.name;
        var required=me.fieldConfig.required;
        var requiredMarkup=me.requiredMarkup;
        if(required===false){
            requiredMarkup='';
        }
        var data=me.fieldConfig.jsonData;
        var picker = CWHF.createMultipleTreePicker(label,
            name, data["itemTree"], me.value,
            {   useRemoveBtn:false,
                useNull:true,
                //useTooltip:false,
                labelIsLocalized: true,
                afterLabelTextTpl: requiredMarkup,
                labelAlign:me.labelHAlign,
                allowBlank:!required,
                cls :'labelVerticalAlign-'+me.labelVAlign+
                    ' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
                labelStyle:{overflow:'hidden'},
                labelWidth:100,
                width:310
            });
        return picker;
    },
    refreshView:function(){
        var me=this;
        var label=me.fieldConfig.label;
        var hidden=me.fieldConfig.invisible;
        var required=me.fieldConfig.required;
        var requiredMarkup=me.requiredMarkup;
        if(required===false){
            requiredMarkup='';
        }
        me.view.setFieldLabel(label);
        me.view.afterLabelTextTpl=requiredMarkup;
        var data=me.fieldConfig.jsonData;
        me.view.allowBlank=!required;
        me.view.hidden=hidden;
    }
});
Ext.define('com.aurel.trackplus.field.ParentTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	config:{
		readOnly:false
	},
	idField:null,
	labelField:null,
	constructor : function(config) {
		var me=this;
		me.callParent(arguments);
	},
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var data=me.fieldConfig.jsonData;
		var itemID=me.getValue();
		if(data.projectSpecificID&&data.projectSpecificID!==''){
			itemID=data.projectSpecificID;
		}
		var displayValue="";
		if(itemID){
			displayValue=itemID+': '+data.title;
		}
		me.idField= Ext.create('Ext.form.field.Hidden',{
			name: name,
			value:me.value,
			readOnly:true,
			margin:'0 0 0 0',
			cls:'insideFiledCointainer'
		});
		me.labelField=Ext.create('Ext.ux.LinkComponent',{
			handler:me.clickOnParent,
			scope:me,
			margin:'4 0 0 0',
			clsLink:'parentLink',
			style:{
				overflow:'hidden'
			},
			cls:'insideFiledCointainer',
			flex:1,
			label:displayValue
		});
		me.btnClear=Ext.create('Ext.button.Button',{
			margin:'0 5 0 0',
			iconCls:'delete16',
			cls:'insideFiledCointainer',
			handler:me.clearParent,
			hidden:(CWHF.isNull(me.value)||me.value===''),
			scope:me
		});
		var items=[];
		if(me.getReadOnly()===false){
			items.push(me.idField);
			items.push(me.btnClear);
		}
		items.push(me.labelField);
		return Ext.create('Ext.form.FieldContainer',{
			combineErrors: true,
			fieldLabel: label,
			labelAlign:me.getLabelHAlign(),
			hideLabel :me.getHideLabel(),
			cls :'labelVerticalAlign-'+me.getLabelVAlign()+
				' valueVerticalAlign-'+me.getValueVAlign()+' valueAlign-'+me.getValueHAlign(),
			labelStyle:{overflow:'hidden'},
			layout: 'hbox',
			defaults: {
				hideLabel: true
			},
			width:450,
			items :items,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var requiredMarkup=me.fieldConfig.required;
		var data=me.fieldConfig.jsonData;
		var itemID=me.value;
		if(data.projectSpecificID&&data.projectSpecificID!==''){
			itemID=data.projectSpecificID;
		}
		var displayValue="";
		if(itemID){
			displayValue=itemID+': '+data.title;
		}
		me.idField.setValue(me.value);
		me.labelField.setLabel(displayValue);
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.btnClear.setVisible(me.value&&me.value!=="");
		me.view.hidden=hidden;
	},
	clearParent:function(){
		var me=this;
		me.value=null;
		me.idField.setValue(null);
		me.labelField.setLabel(null);
		me.btnClear.setVisible(false);
		me.view.updateLayout();
		me.view.ownerCt.updateLayout();
	},
	clickOnParent:function(){
		var me=this;
		var parentID=me.value;
		me.fireEvent("clickOnParent",parentID);
		//var url="printItem.action?workItemID="+me.value;
		//window.open(url,'parentItem');
	}
});
Ext.define('com.aurel.trackplus.field.ParentTypeRendererReadOnly',{
	extend:'com.aurel.trackplus.field.ParentTypeRenderer',
	readOnly:true
});
Ext.define('com.aurel.trackplus.field.IntegerTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	config:{
		allowDecimals:false,
		decimalSeparator:'.'
	},
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var numberFieldConfig = {
				fieldLabel: label,
				afterLabelTextTpl:requiredMarkup,
				allowDecimals:me.allowDecimals,
				decimalSeparator:me.decimalSeparator,
				labelAlign:me.labelHAlign,
				hideLabel :me.hideLabel,
				cls :'labelVerticalAlign-'+me.labelVAlign+
					' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
				labelStyle:{overflow:'hidden'},
				name: name,
				allowBlank:!required,
				value:me.value,
				hidden:hidden
			};
		if (data) {
			if (data.minValue) {
				numberFieldConfig.minValue = data.minValue;
			}
		}
		var numberField = Ext.create('Ext.form.field.Number', numberFieldConfig);
		numberField.addListener('change', me.valueChange, me, me);
		return numberField;
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	},
	valueChange:function(fieldCmp, newValue, oldValue){
		var me=this;
		var fieldValues={};
		fieldValues["f"+me.fieldID]=newValue;
		var oldFieldValues = {};
		oldFieldValues["f"+me.fieldID]=oldValue;
		me.fireEvent("valueChange",me.fieldID,fieldValues,oldFieldValues, me);
	}
});
Ext.define('com.aurel.trackplus.field.DoubleTypeRenderer',{
	extend:'com.aurel.trackplus.field.IntegerTypeRenderer',
	allowDecimals:true,
	decimalSeparator:com.trackplus.TrackplusConfig.DecimalSeparator
});
Ext.define('com.aurel.trackplus.field.DurationRenderer',{
	extend:'com.aurel.trackplus.field.DoubleTypeRenderer',
	config: {
		startDateFieldID: 19,
		endDateFieldID: 20
	},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	},
	refreshDependentFields:function(fieldID, fieldValues, oldFieldValues, renderer, modelFieldValues, isFromGantt) {
		var me=this;
		var startDateFieldID = renderer.startDateFieldID;
		var endDateFieldID = renderer.endDateFieldID;
		var newDuration = fieldValues["f"+fieldID];
		modelFieldValues["f"+fieldID] = newDuration;
		var oldDuration = oldFieldValues["f"+fieldID];
		if (newDuration !== oldDuration) {
			var startDate = modelFieldValues["f"+startDateFieldID];
			var endDate = modelFieldValues["f"+endDateFieldID];
			if(isFromGantt) {
				startDate = Ext.util.Format.date(startDate, com.trackplus.TrackplusConfig.DateFormat);
				endDate = Ext.util.Format.date(endDate, com.trackplus.TrackplusConfig.DateFormat);
			}
			if (newDuration) {
				if (startDate && startDate.length>0) {
					endDate = me.addWeekdays(me.parseDate(startDate, true), newDuration, true);
					me.updateField(endDateFieldID, endDate, endDate, modelFieldValues);
				} else {
					if (endDate && endDate.length>0) {
						startDate = me.addWeekdays(me.parseDate(endDate, true), newDuration, false);
						me.updateField(startDateFieldID, startDate, startDate, modelFieldValues);
					} else {
						startDate = Ext.Date.format(new Date(), com.trackplus.TrackplusConfig.DateFormat);
						me.updateField(startDateFieldID, startDate, startDate, modelFieldValues);
						endDate = me.addWeekdays(me.parseDate(endDate, true), newDuration, true);
						me.updateField(endDateFieldID, endDate, endDate, modelFieldValues);
					}
				}
			}
		}
	}
});
Ext.define('com.aurel.trackplus.field.TargetDurationRenderer',{
	extend:'com.aurel.trackplus.field.DurationRenderer',
	config: {
		startDateFieldID: 29,
		endDateFieldID: 30
	},
	constructor : function(config) {
		var me=this;
		this.initConfig(config);
		me.callParent(arguments);
	}
});
Ext.define('com.aurel.trackplus.field.CheckBoxTypRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	config:{
		allowDecimals:false
	},
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		return Ext.create('Ext.form.field.Checkbox',{
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			allowDecimals:me.allowDecimals,
			decimalSeparator:me.decimalSeparator,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			name: name,
			margin: '3 0 0 0',
			allowBlank:!required,
			inputValue:'true',
			uncheckedValue:'false',
			value:me.value,
			checked:me.value===true,
			hidden:hidden
		});
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		me.view.setValue(me.value);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.CompositeTypeRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	parts:null,
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var items=[];
		var cascading=data.cascading;
		me.parts=[];
		for(var i=0;i<data.parts.length;i++){
			var hasDependences=(cascading&&i<data.parts.length-1);
			var partRenderer=Ext.create(data.parts[i].extClassName,{
				fieldID:me.fieldID,
				parameterCode:i+1,
				fieldConfig:{
					required:required,
					hasDependences:hasDependences,
					name:me.fieldConfig.name+"_"+(i+1),
					jsonData:data.parts[i].jsonData
				},
				value:CWHF.isNull(me.value)?null:me.value[''+(i+1)]
			});
			if(hasDependences){
				partRenderer.addListener('valueChange',me.partValueChange,me);
			}
			me.parts.push(partRenderer);
			items.push(partRenderer.getView());
		}
		return Ext.create('Ext.form.FieldContainer',{
			combineErrors: true,
			fieldLabel: label,
			afterLabelTextTpl:requiredMarkup,
			labelAlign:me.labelHAlign,
			hideLabel :me.hideLabel,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			layout:{
				type:'column'
			},
			defaults: {
				hideLabel: true,
				margin:'0 0 0 5'
			},
			style:{
				width: '100%'
			},
			items :items,
			hidden:hidden
		});
	},
	partValueChange:function(fieldID){
		var me=this;
		var fieldValues={};
		for(var i=0;i<me.parts.length;i++){
			var part=me.parts[i];
			fieldValues['fieldValues.f'+me.fieldID+"_"+(i+1)]=part.getValue();
		}
		me.fireEvent('valueChange',me.fieldID,fieldValues);
	},
	refreshView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		var data=me.fieldConfig.jsonData;
		for(var i=0;i<me.parts.length;i++){
			me.parts[i].value= CWHF.isNull(me.value)?null:me.value[''+(i+1)];
			me.parts[i].fieldConfig.jsonData=data.parts[i].jsonData;
			me.parts[i].refreshView();
		}
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.SingleSelectPickerRenderer',{
	extend:'com.aurel.trackplus.field.TypeRenderer',
	config:{
		useIconCls:false,
		iconFieldID:null,
		pikerWidth:300
	},
	createView:function(){
		var me=this;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var name=me.fieldConfig.name;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		var options=data.list;
		if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}
		var releaseTree = data["releaseTree"];
		var optionLength=0;
		if(options){
			optionLength=options.length;
		}
		var iconFieldID=me.getIconFieldID();
		var picker =Ext.create('com.trackplus.util.SingleSelectPicker',{
			options:options,
			includeSearch:optionLength>=7,
			cls :'labelVerticalAlign-'+me.labelVAlign+
				' valueVerticalAlign-'+me.valueVAlign+' valueAlign-'+me.valueHAlign,
			labelStyle:{overflow:'hidden'},
			labelWidth:100,
			width:me.getPikerWidth(),
			name:name,
			value:me.value,
			fieldLabel:label,
			labelAlign:me.labelHAlign,
			afterLabelTextTpl:requiredMarkup,
			useIconCls:me.getUseIconCls(),
			iconUrlPrefix:CWHF.isNull(iconFieldID)?null:'optionIconStream.action?fieldID='+iconFieldID+"&optionID="
		});
		picker.addListener('change',me.valueChange,me);
		return picker;
	},
	valueChange:function(fieldCmp,newValue){
		var me=this;
		var name=me.fieldConfig.name;
		var fieldValues={};
		fieldValues['fieldValues.f'+me.fieldID]=newValue;
		me.fireEvent('valueChange',me.fieldID,fieldValues);
	},
	refreshView:function(){
		var me=this;
		var name=me.fieldConfig.name;
		var value=me.value;
		var label=me.fieldConfig.label;
		var hidden=me.fieldConfig.invisible;
		var required=me.fieldConfig.required;
		var requiredMarkup=me.requiredMarkup;
		if(required===false){
			//label=label+me.requiredHtmlTxt;
			requiredMarkup='';
		}
		var data=me.fieldConfig.jsonData;
		me.view.setFieldLabel(label);
		me.view.afterLabelTextTpl=requiredMarkup;
		var options=data.list;
		if(required===false&&options&&options.length>0){
			options.unshift({id:null,label:''});
		}
		me.view.updateMyOptions(options);
		me.view.setValue(value,true);
		me.view.allowBlank=!required;
		me.view.hidden=hidden;
	}
});
Ext.define('com.aurel.trackplus.field.StateRenderer',{
	extend:'com.aurel.trackplus.field.SingleSelectPickerRenderer',
	iconFieldID:-4,
	pikerWidth:265
});
Ext.define('com.aurel.trackplus.field.PriorityRenderer',{
	extend:'com.aurel.trackplus.field.SingleSelectPickerRenderer',
	iconFieldID:-10,
	pikerWidth:265
});
Ext.define('com.aurel.trackplus.field.SeverityRenderer',{
	extend:'com.aurel.trackplus.field.SingleSelectPickerRenderer',
	iconFieldID:-11,
	pikerWidth:265
});
Ext.define('com.aurel.trackplus.field.PersonPickerRenderer',{
	extend:'com.aurel.trackplus.field.SingleSelectPickerRenderer',
	useIconCls:true,
	pikerWidth:310
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.screen.ItemTabView',{
	extend: 'com.trackplus.screen.TabView',
	firstTimeOverflow:true,
	layout: 'auto',
	border:false,
	style:{
		overflowX:'auto'
	},
	initComponent: function(){
		var me=this;
		me.callParent();
		if(me.oneTab===true){
			me.margin= '0 0 17 0';
			me.region='center';
		}else{
			me.margin='5 0 0 0';
			me.title=me.model.getLabel();
		}
	}
});
Ext.define('com.trackplus.screen.ItemScreenController', {
	extend : 'com.trackplus.screen.BaseScreenController',
	config : {
		children : null,
		readOnlyMode : false,
		dataModel : null
	},
	tabViewCls:'com.trackplus.screen.ItemTabView',
	showOneTab : true,
	fieldTypeRenderersMap : new Object(),
	fieldTypeWrappersMap : new Object(),
	fieldDataMap : new Object(),
	constructor : function(config) {
		this.callParent(arguments);
		//this.addEvents('editMode','lastModified','clickOnParent');
	},
	refreshScreenModel : function(screenView, screenModel, selectedTab) {
		var me = this;
		me.fieldTypeRenderersMap = new Object();
		me.fieldTypeWrappersMap = new Object();
		me.fieldDataMap = new Object();
		me.callParent(arguments);
	},
	createField : function(parentView, aFieldData) {
		var me = this;
		var aField;
		var editable=false;
		var fieldConfig;
		if (aFieldData.empty) {
			aField = Ext.create('Ext.form.Label', {});
		} else {
			var fieldID = aFieldData.fieldID;
			me.fieldDataMap['f' + fieldID]=aFieldData;
			fieldConfig = me.dataModel.fieldConfigs['f' + fieldID];
			fieldConfig['name'] = "fieldValues.f" + fieldID;
			var extClassName = aFieldData.extClassName;
			if (me.readOnlyMode||fieldConfig['readonly']===true) {
				extClassName = aFieldData.extReadOnlyClassName;
				editable=me.dataModel.inlineEdit&&!fieldConfig.readonly;
			}
			var fieldValue = me.dataModel.fieldValues['f' + fieldID];
			var displayValue = me.dataModel.fieldDisplayValues['f' + fieldID];
			var fieldTypeRenderer = Ext.create(extClassName, {
				workItemID:me.dataModel.workItemID,
				projectID:me.dataModel.projectID,
				fieldID:fieldID,
				fieldConfig : fieldConfig,
				value : fieldValue,
				displayValue : displayValue,
				labelHAlign : aFieldData.labelHAlign,
				labelVAlign : aFieldData.labelVAlign,
				valueHAlign : aFieldData.valueHAlign,
				valueVAlign : aFieldData.valueVAlign,
				hideLabel   : aFieldData.hideLabel
			});
			if (me.fieldTypeRenderersMap['f' + fieldID] ||fieldID===17) {
				aField = Ext.create('Ext.form.Label', {
					text : 'Field "'+fieldConfig.label+'" already on screen!'
				});
			} else {
				if (fieldConfig.hasDependences){
					fieldTypeRenderer.addListener('valueChange',me.fieldValueChange,me);
				}
				if (editable){
					fieldTypeRenderer.addListener('dblclick',me.fieldDblclick,me);
				}
				fieldTypeRenderer.addListener('afterRender',me.fieldAfterRender,me,{parentView:parentView});
				fieldTypeRenderer.addListener('finishedUpload',me.finishedUploadHandler,me);
				aField = fieldTypeRenderer.getView.call(fieldTypeRenderer);
				me.fieldTypeRenderersMap['f' + fieldID] = fieldTypeRenderer;
			}
			aField.colspan = aFieldData.colSpan;
			aField.rowspan = aFieldData.rowSpan;
			aField.addCls("screenField");
			if(fieldID===16){//parent
				fieldTypeRenderer.addListener('clickOnParent',me.clickOnParentHandler,me);
			}
		}
		if(editable&&!aFieldData.empty){
			var fieldID=aFieldData.fieldID;
			var fieldName="fieldValues.f" + fieldID;
			var fieldValue=me.dataModel.fieldValues['f' + fieldID];
			var extClassNameEditable=aFieldData.extClassName;
			var wrapperItems=[];
			wrapperItems.push(aField);
			if(extClassNameEditable==='com.aurel.trackplus.field.CompositeTypeRenderer'){
				if(fieldValue){
					for(var i=0;i<fieldConfig.jsonData.parts.length;i++){
						var hiddenField=CWHF.createHiddenField(fieldName+"_"+(i+1),{value:fieldValue[''+(i+1)]});
						wrapperItems.push(hiddenField);
					}
				}
			}else{
				var hiddenField=CWHF.createHiddenField(fieldName,{value:fieldValue});
				wrapperItems.push(hiddenField);
			}
			var wrapper=Ext.create('Ext.container.Container',{
				border:false,
				cls:'editableFieldWrapper',
				overCls:'editableFieldWrapper-over',
				bodyBorder:false,
				margin:'0 0 0 0',
				bodyPadding:0,
				colspan:aFieldData.colSpan,
				rowspan:aFieldData.rowSpan,
				items:wrapperItems,
				listeners: {
					afterrender:{
						fn:function(cmp){
							var html="";
							if(fieldConfig.tooltip&&fieldConfig.tooltip!==''){
								html=fieldConfig.tooltip+"<br/>"+getText('item.view.dblClickToEditField');
							}else{
								html=getText('item.view.dblClickToEditField');
							}
							Ext.create('Ext.tip.ToolTip', {
								target: cmp.el,
								trackMouse: true,
								dismissDelay: 0,
								html: html
							});
						}
					}
				}
			});
			me.fieldTypeWrappersMap['f'+fieldID]=wrapper;
			return wrapper;
		}else{
			if(me.dataModel.inlineEdit&&!aFieldData.empty){
				aField.addCls('readOnlyField');
			}
			if(fieldConfig&&fieldConfig.tooltip&&fieldConfig.tooltip!==''){
				aField.addListener('afterrender',function(cmp){
					Ext.create('Ext.tip.ToolTip', {
						target: cmp.el,
						trackMouse: true,
						dismissDelay: 0,
						html: fieldConfig.tooltip
					});
				});
			}
			return aField;
		}
	},
	editMode:false,
	fieldDblclick:function(fieldID){
		var me=this;
		var wrapper=me.fieldTypeWrappersMap['f'+fieldID];
		var aFieldData=me.fieldDataMap['f' + fieldID];
		var extClassName=aFieldData.extClassName;
		var fieldConfig = me.dataModel.fieldConfigs['f' + fieldID];
		fieldConfig['name'] = "fieldValues.f" + fieldID;
		var fieldValue = me.dataModel.fieldValues['f' + fieldID];
		var displayValue = me.dataModel.fieldDisplayValues['f' + fieldID];
		var fieldTypeRenderer = Ext.create(extClassName, {
			fieldID:fieldID,
			fieldConfig : fieldConfig,
			value : fieldValue,
			displayValue : displayValue,
			labelHAlign : aFieldData.labelHAlign,
			labelVAlign : aFieldData.labelVAlign,
			valueHAlign : aFieldData.valueHAlign,
			valueVAlign : aFieldData.valueVAlign,
			hideLabel : aFieldData.hideLabel
		});
		if(fieldConfig.hasDependences){
			fieldTypeRenderer.addListener('valueChange',me.fieldValueChange,me);
		}
		var aField = fieldTypeRenderer.getView.call(fieldTypeRenderer);
		aField.addCls('screenField');
		me.fieldTypeRenderersMap['f' + fieldID] = fieldTypeRenderer;
		var el=wrapper.getEl();
		el.fadeOut({
			opacity: 0.1, //can be any value between 0 and 1 (e.g. .5)
			easing: 'easeOut',
			duration: 150,
			remove: false,
			useDisplay: false,
			callback:function(){
				wrapper.removeAll(true);
				wrapper.add(aField);
				wrapper.removeCls("editableFieldWrapper");
				wrapper.ownerCt.updateLayout();
				el.fadeIn({
					opacity: 1, //can be any value between 0 and 1 (e.g. .5)
					easing: 'easeOut',
					duration: 500,
					callback:function(){
						fieldTypeRenderer.focus();
					}
				});
				if(me.editMode===false){
					me.fireEvent('editMode');
					me.editMode=true;
				}
			}
		});
	},
	finishedUploadHandler:function(){
		var me=this;
		me.fireEvent('finishedUpload');
	},
	fieldAfterRender:function(fieldID,opts){
		var me=this;
		var parentView=opts.parentView;
		parentView.ownerCt.updateLayout();
	},
	clickOnParentHandler:function(parentID){
		var me=this;
		me.fireEvent('clickOnParent',parentID);
	},
	fieldValueChange:function(fieldID, fieldValues, oldFieldValues, fieldTypeRenderer){
		var me=this;
		var modelFieldValues = me.dataModel.fieldValues;
		var fieldConfigs = me.dataModel.fieldConfigs;
		var fieldConfig = fieldConfigs["f"+fieldID];
		if (fieldConfig && fieldConfig.clientSideRefresh) {
			//client side refresh
			if (fieldTypeRenderer.refreshDependentFields) {
				fieldTypeRenderer.refreshDependentFields.call(me, fieldID, fieldValues, oldFieldValues, fieldTypeRenderer, modelFieldValues, false);
			}
		} else {
			//server side refresh
			var params={
					workItemID:me.dataModel.workItemID,
					projectID:me.dataModel.projectID,
					issueTypeID:me.dataModel.issueTypeID,
					actionID:me.dataModel.actionID,
					fieldID:fieldID
				};
			for(var x in fieldValues){
				params[x]=fieldValues[x];
			}
			me.screenView.setLoading(true);
			var urlStr="itemFieldRefresh.action";
			Ext.Ajax.request({
				url: urlStr,
				disableCaching:true,
				encoding: "utf-8",
				sync: true,
				success: function(result){
					var jsonData=Ext.decode(result.responseText);
					if(jsonData.success===true) {
						var data=jsonData.data;
						me.refreshDependentFields.call(me,data);
						me.screenView.setLoading(false);
					}else{
						me.screenView.setLoading(false);
					}
				},
				failure: function(type, error){
					me.screenView.setLoading(false);
					//alert("failure");
				},
				params :params,
				method:"POST"
			});
		}
	},
	updateField: function(fieldID, fieldValue, fieldDisplayValue, fieldValues) {
		var me=this;
		var data = {};
		var fieldName = "f"+fieldID;
		var fieldConfig = me.dataModel.fieldConfigs[fieldName];
		if (fieldConfig) {
			//field to update is present on form
			data.fieldConfigs = {};
			data.fieldConfigs[fieldName] = fieldConfig;
			data.fieldValues = {};
			data.fieldValues[fieldName] = fieldValue;
			//actualize the model (for later use)
			fieldValues[fieldName] = fieldValue;
			data.fieldDisplayValues = {};
			data.fieldDisplayValues[fieldName] = fieldDisplayValue;
			//actualize the controls
			me.refreshDependentFields.call(me,data);
		}
	},
	addWeekdays: function(date, weekdays, add) {
		var me=this;
		var i = 0;
	    var oneDay = 1;
	    if (!add) {
	    	oneDay = -1;
	    }
	    while (i < weekdays) {
	    	date.setDate(date.getDate() + oneDay);
	        var day = date.getDay();
	        if (day > 0 && day < 6) {
	            i++;
	        }
	    }
	    return Ext.Date.format(date, com.trackplus.TrackplusConfig.DateFormat);
	},
	parseDate: function(dateStr, nowIfNull) {
		if (CWHF.isNull(dateStr) || dateStr.length===0) {
			if (nowIfNull) {
				return new Date();
			} else {
				return null;
			}
		} else {
			return Ext.Date.parse(dateStr, com.trackplus.TrackplusConfig.DateFormat);
		}
	},
	/**
	 * Returns number of free days from given interval
	 * @param startDateStr
	 * @param endDateStr
	 * @return
	 */
	getDurationBetweenDates: function(startDateStr, endDate) {
		var me=this;
		var startDate = me.parseDate(startDateStr, false);
		//var endDate = me.parseDate(endDateStr, false);
		if (CWHF.isNull(startDate) || CWHF.isNull(endDate)) {
			return null;
		}
		var i=0;
		while (startDate<endDate) {
			startDate.setDate(startDate.getDate() + 1);
			var day = startDate.getDay();
	        if (day > 0 && day < 6) {
	            i++;
	        } else {
	        	//end date explicitly set on Saturday or Sunday: take this week end day(s) as working day
	        	if (startDate>=endDate) {
	        		if (day===6) {
	        			//add one day for task ending on Saturday
	        			i++;
	        		} else {
	        			//add two days for task ending on Sunday
	        			i = i+2;
	        		}
	        	}
	        }
		}
		return i;
	},
	getDateFromModel: function(model, fieldID, isFromGantt) {
		var me = this;
		var date = null;
		date = model[fieldID];
		if(isFromGantt) {
			date = Ext.util.Format.date(date, com.trackplus.TrackplusConfig.DateFormat);
		}
		return date;
	},
	getPresentFields:function(){
		var me=this;
		var fields=new Array();
		for (var f in me.fieldTypeRenderersMap){
			var fieldID=parseInt(f.substring(1));
			fields.push(fieldID);
		}
		return fields;
	},
	refreshByFields:function(fieldIds,lastModified){
		var me=this;
		var fieldsToReload=new Array();
		var presentFields=me.getPresentFields();
		for(var i=0;i<fieldIds.length;i++){
			if(Ext.Array.indexOf(presentFields,fieldIds[i])>0){
				fieldsToReload.push(fieldIds[i]);
			}
		}
		if(lastModified){
			me.fireEvent('lastModified',lastModified);
		}
		if(fieldsToReload.length===0){
			return false;
		}
		me.screenView.setLoading(true);
		var params={
			workItemID:me.dataModel.workItemID,
			projectID:me.dataModel.projectID,
			issueTypeID:me.dataModel.issueTypeID,
			actionID:me.dataModel.actionID,
			fields:fieldsToReload.join(",")
		};
		var urlStr="itemFieldRefresh!refreshFields.action";
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			encoding: "utf-8",
			sync: true,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===true) {
					var data=jsonData.data;
					me.refreshDependentFields.call(me,data);
					me.screenView.setLoading(false);
					me.fireEvent('lastModified',data.lastModified);
				}else{
					me.screenView.setLoading(false);
					alert("failure");
				}
			},
			failure: function(type, error){
				me.screenView.setLoading(false);
				alert("failure");
			},
			params :params,
			method:"POST"
		});
	},
	refreshDependentFields:function(data){
		var me=this;
		var fieldConfigs=data.fieldConfigs;
		var fieldValues=data.fieldValues;
		var fieldDisplayValues=data.fieldDisplayValues;
		for(var f in fieldConfigs){
			var fieldCfg=fieldConfigs[f];
			me.dataModel.fieldValues[f]=fieldValues[f];
			me.dataModel.fieldDisplayValues[f]=fieldDisplayValues[f];
			fieldCfg['name'] = "fieldValues.f" + fieldConfigs[f].fieldID;
			var fieldTypeRenderer=me.fieldTypeRenderersMap[f];
			if(fieldTypeRenderer) {
				//suspend events becasue setting the value would trigger triggering the change event (possibly infinit cycle)
				fieldTypeRenderer.suspendEvents(false);
				fieldTypeRenderer.update.call(fieldTypeRenderer,{
					fieldConfig:fieldCfg,
					value:fieldValues[f],
					displayValue:fieldDisplayValues[f]
				});
				//resume the event triggering
				fieldTypeRenderer.resumeEvents();
			}
			var wrapper=me.fieldTypeWrappersMap[f];
			if(wrapper){
				var hiddenField=null;
				if(wrapper.items.getCount()>1){
					hiddenField=wrapper.items.getAt(1);
				}
				if(hiddenField){
					hiddenField.setValue(fieldValues[f])
				}
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/* Toolbar items*/
com.trackplus.item.ToolbarItem = {
	SIBLING : 1,
	CHOOSE_PARENT : 2,
	PRINT : 3,
	PRINT_WITH_CHILDREN : 4,
	ACCESS_LEVEL : 5,
	ARCHIVE : 6,
	DELETE : 7,
	MAIL : 8,
	BACK : 9,
	NAVIGATION_NEXT : 10,
	NAVIGATION_PREV : 11,
	ITEM_ACTION : 12,
	SAVE : 13,
	RESET : 14,
	CANCEL : 15,
	PRINT_ITEM : 16,
	EXPORT : 17
};
Ext.define('com.trackplus.screen.ItemView',{
	extend : 'Ext.container.Container',
	config : {
		model : null,
		itemDetailComponent:null
	},
	// region: 'center',
	margin : '0 0 0 0',
	padding : '0 0 0 0',
	border : false,
	layout : {
		type : 'border'
	},
	itemPanel : null,
	initComponent : function() {
		var me = this;
		me.items = me.createChildren();
		me.callParent();
		me.addListener('afterrender',me.setFocusComponent,me);
	},
	setFocusComponent:function(){
		var me=this;
		if(me.txtTitleHeader&&!me.txtTitleHeader.isHidden()){
			me.txtTitleHeader.focus(false);
		}
	},
	createChildren : function() {
		var me = this;
		var children = [];
		/*if (me.model.includeItemTitle) {
			children.push(com.trackplus.item
					.createItemTitleSection(
							me.model.issueNoLabel,
							me.model.workItemID,
							me.model.statusDisplay,
							me.model.synopsis, 'north'));
		}*/
		var cgfItemPanel={
			border : false
		}
		if (me.model.includeBottomTabs) {
			cgfItemPanel.margin = '5 0 5 0';
			cgfItemPanel.anchor = '100%';
			cgfItemPanel.layout='fit';
		}else{
			cgfItemPanel.margin = '0 0 0 0';
			cgfItemPanel.padding = '0 5 5 5';
			cgfItemPanel.region='center';
			cgfItemPanel.autoScroll =true;
		}
		me.itemPanel = Ext.create('Ext.form.Panel', cgfItemPanel);
		children.push(me.itemPanel);
		// detail part
		// me.model.includeBottomTabs=false;
		if (me.model.includeBottomTabs) {
			var cmp = me.itemDetailComponent.createComponent();
			children.push(cmp);
		}
		var project=me.model.projectLabel;
		var issueNumber=me.model.workItemIDDisplay;
		var statusDisplay=me.model.statusDisplay;
		var itemLockedMessage=me.model.itemLockedMessage;
		var htmlProjectHeader='<img style="margin-bottom: -2px;" src="optionIconStream.action?fieldID=-2&optionID='+me.model.issueTypeID+'" title="'+me.model.issueTypeLabel+'">' +
			' <strong>'+project+'</strong>';
		if(issueNumber){
			htmlProjectHeader+='&nbsp;/&nbsp;<span class="emphasize"><strong>'+ issueNumber + '</strong></span>';
		}
		if(statusDisplay){
			htmlProjectHeader+="&nbsp;:&nbsp;"+ '<span class="dataEmphasize">'+ statusDisplay + '</span>';
		}
		if (!me.model.readOnlyMode) {
			htmlProjectHeader+='<span class=requiredHint><span class="requiredHintBar">&nbsp;</span> = ' + getText("common.lbl.requiredInfo") +'</span>';
		}
		if (itemLockedMessage) {
			htmlProjectHeader+='<span class="itemLock">' + itemLockedMessage +'</span>';
		}
		me.projectHeader=Ext.create('Ext.form.Label',{
			html: htmlProjectHeader,
			margin:'0 0 5 0'
		});
		me.lblWrapper=null;
		me.lblTitleHeader=Ext.create('Ext.form.Label',{
			text: me.model.synopsis,
			cls: 'titleHeader',
			margin:'0 0 5 0',
			hidden:!me.model.readOnlyMode
		});
		var editable=(me.model.readOnlyMode===true&&me.model.inlineEdit===true&&me.model.synopsisReadonly===false);
		if(editable){
			me.lblWrapper=Ext.create('Ext.container.Container',{
				border:false,
				cls:'editableFieldWrapper',
				overCls:'editableFieldWrapper-over',
				bodyBorder:false,
				margin:'0 0 2px 0',
				bodyPadding:0,
				items:[me.lblTitleHeader],
				listeners: {
					afterrender:{
						fn:function(cmp){
							Ext.create('Ext.tip.ToolTip', {
								target: cmp.el,
								trackMouse: true,
								dismissDelay: 0,
								html: getText('item.view.dblClickToEditField')
							});
						}
					}
				}
			});
		}else{
			me.lblWrapper=me.lblTitleHeader;
		}
		me.txtTitleHeader=Ext.create('com.trackplus.SpellCheckTextField',{
			beforeSubTpl:'<span class="required" style="height:27px">&nbsp;</span>',
			allowBlank:false,
			value: me.model.synopsis,
			cls: 'titleHeader',
			height:28,
			enforceMaxLength:true,
			maxLength:255,
			name:'fieldValues.f17',
			hideLabel:true,
			style:{
				opacity:me.model.readOnlyMode===true?0:1
			},
			hidden:me.model.readOnlyMode
		});
		me.headerPanel=Ext.create('Ext.container.Container', {
			padding:'10 5 0 5',
			margin:'0 0 0 0',
			border:false,
			cls:'itemHeader',
			region:'north',
			layout:{
				type:'vbox',
				align:'stretch'
			},
			items:[me.projectHeader,me.lblWrapper,me.txtTitleHeader]
		});
		me.panelWrapper=null;
		if(me.model.includeBottomTabs){
			//TODO removw this fix for IE
			if(Ext.isIE9){
				me.panelWrapper=Ext.create('Ext.panel.Panel',{
					layout:'anchor',
					defaults : {
						anchor : '100%'
					},
					margin : '0 0 0 0',
					padding : '0 5 5 5',
					border: false,
					bodyBorder:false,
					region:'center',
					autoScroll : true,
					items:children
				});
			}else{
				me.panelWrapper=Ext.create('Ext.container.Container',{
					layout:'anchor',
					defaults : {
						anchor : '100%'
					},
					margin : '0 0 0 0',
					padding : '0 5 5 5',
					border: false,
					region:'center',
					autoScroll : true,
					items:children
				});
			}
		}else{
			me.panelWrapper=me.itemPanel;
		}
		return [me.headerPanel,me.panelWrapper];
	}
});
Ext.define('com.trackplus.item.ItemComponent',{
	extend:'Ext.Base',
	mixins: {
		observable: 'Ext.util.Observable'
	},
	config:{
		includeItemTitle:false,
		workItemID:null,
		workItemIDDisplay:null,
		lastModified:null,
		projectID:null,
		projectLabel:null,
		issueTypeID:null,
		issueTypeLabel:null,
		actionID:null,
		readOnlyMode:false,
		includeBottomTabs:false,
		itemDetailData:null,
		issueNoLabel:'IssueNo',
		statusDisplay:null,
		statusID:null,
		synopsis:null,
		itemLockedMessage:null
	},
	itemPanel:null,
	itemScreenPanel:null,
	txtTitleHeader:null,
	itemDetailComponent:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.mixins.observable.constructor.call(this, config);
		this.initConfig(config);
	},
	createItemPanel:function() {
		var me = this;
		if(me.itemDetailData){
			var tabs = me.itemDetailData.tabs;
			var activeTab = me.itemDetailData.activeTab;
			me.itemDetailComponent = new com.trackplus.itemDetail.ItemDetailComponent(
				me.workItemID, me.projectID,
				me.issueTypeID, tabs, activeTab,me.eventHandlerTabDetail,me,me.lastModified);
		}
		var itemView = Ext.create('com.trackplus.screen.ItemView', {
			itemDetailComponent:me.itemDetailComponent,
			model : {
				workItemID : me.workItemID,
				projectID : me.projectID,
				projectLabel:me.projectLabel,
				issueTypeID : me.issueTypeID,
				issueTypeLabel:me.issueTypeLabel,
				issueNoLabel : me.issueNoLabel,
				workItemIDDisplay:me.workItemIDDisplay,
				statusDisplay : me.statusDisplay,
				statusID:me.statusID,
				synopsis : me.synopsis,
				includeItemTitle : me.includeItemTitle,
				includeBottomTabs : me.includeBottomTabs,
				itemDetailData : me.itemDetailData,
				readOnlyMode:me.readOnlyMode,
				synopsisReadonly:me.synopsisReadonly,
				inlineEdit:me.inlineEdit,
				itemLockedMessage:me.itemLockedMessage
			},
			region : 'center'
		});
		me.itemPanel = itemView.itemPanel;
		me.txtTitleHeader=itemView.txtTitleHeader;
		me.lblWrapper=itemView.lblWrapper;
		me.lblTitleHeader=itemView.lblTitleHeader;
		var editable=(me.readOnlyMode===true&&me.inlineEdit===true&&me.synopsisReadonly===false);
		if(editable){
			me.lblTitleHeader.addListener('afterrender',function(){
				me.lblTitleHeader.getEl().addListener('dblclick',me.lblTitleHeaderDblClick,me);
			});
		}
		return itemView;
	},
	eventHandlerTabDetail:function(eventName,args){
		var me=this;
		if(eventName==='itemChange'){
			me.screenFacade.screenController.refreshByFields.apply(me.screenFacade.screenController,args);
		}
		me.fireEventArgs(eventName,args);
	},
	lblTitleHeaderDblClick:function(){
		var me=this;
		//me.lblWrapper.setVisible(false);
		//me.txtTitleHeader.setVisible(true);
		//me.txtTitleHeader.focus();
		var el=me.lblWrapper.getEl();
		el.fadeOut({
			opacity: 0, //can be any value between 0 and 1 (e.g. .5)
			easing: 'easeOut',
			duration: 150,
			remove: false,
			useDisplay: false,
			callback:function(){
				me.lblWrapper.setVisible(false);
				me.txtTitleHeader.setVisible(true);
				me.txtTitleHeader.getEl().fadeIn({
					opacity: 1, //can be any value between 0 and 1 (e.g. .5)
					easing: 'easeOut',
					duration: 500,
					callback:function(){
						me.txtTitleHeader.focus();
					}
				});
			}
		});
		me.fireEvent('editMode');
	},
	refreshChildren:function(){
		var me=this;
		if(me.gridChildren){
			me.gridChildren.setLoading(true);
			var urlStr='item!loadChildren.action';
			Ext.Ajax.request({
				url : urlStr,
				params : {
					'workItemID' : me.workItemID
				},
				success : function(response) {
					var jsonData = Ext.decode(response.responseText);
					var children = jsonData.data.children;
					me.gridChildren.store.loadData(children);
					me.gridChildren.setLoading(false);
				},
				failure : function() {
					alert("failed!");
					me.gridChildren.setLoading(false);
				}
			});
		}
	},
	createChildrenPanel:function(panelsLength, children) {
		var me=this;
		var margin = '5 0 5 0';
		var cls = "screenPanel";
		//if(panelsLength%2===0){
			cls="screenPanel-odd";
		//}
		var panel = Ext.create('Ext.panel.Panel', {
			bodyPadding : 0,
			margin : margin,
			border : false,
			bodyBorder : false,
			cls:cls+' gridNoBorder',
			/*(bodyStyle:{
				borderRight:'1px solid #D0D0D0'
			},*/
			defaults : {
				frame : false,
				border : false
			},
			items : [ {
				xtype : 'displayfield',
				cls:'screenField',
				style:{marginLeft:'5px'},
				fieldLabel : getText('item.printItem.lbl.childIssues'),
				value : children.length
			} ]
		});
		var store = Ext.create('Ext.data.Store', {
			fields : [
				{name : 'workItemID',type : 'int'},
				{name : 'id'},
				{name : 'status'},
				{name : 'originator'},
				{name : 'responsible'},
				{name : 'synopsis'}
			],
			data : children
		});
		// create the Grid
		me.gridChildren = Ext.create('Ext.grid.Panel', {
			store : store,
			queryMode : 'local',
			border    : false,
			bodyBorder:false,
			columnLines :false,
			style:{
				 borderTop:'1px solid #D0D0D0'
			},
			stateId : 'stateGrid',
			columns : [ {
				text : getText('field.label12'),
				width : 75,
				sortable : true,
				menuDisabled:true,
				dataIndex : 'id',
				xtype:'linkcolumn',
				handler:me.clickChildItemNumber,
				scope:me
				/*renderer:function(value,metaData, record){
					var urlStr='printItem.action?key='+record.data.workItemID;
					var synopsisClass='synopsis_blue newWindow';
					return '<a href="'+urlStr+'" class="'+synopsisClass+'" target="printItem'+record.data.workItemID+'">'+record.data['id']+'</a>';
				}*/
			}, {
				text : getText('field.label4'),
				width : 125,
				sortable : true,
				menuDisabled:true,
				dataIndex : 'status'
			}, {
				text : getText('field.label13'),
				width : 150,
				sortable : true,
				menuDisabled:true,
				dataIndex : 'originator'
			}, {
				text : getText('field.label6'),
				width : 150,
				sortable : true,
				menuDisabled:true,
				dataIndex : 'responsible'
			}, {
				text : getText('field.label17'),
				flex : 1,
				//width:250,
				sortable : true,
				menuDisabled:true,
				dataIndex : 'synopsis'
			} ],
			viewConfig : {
				stripeRows : true
			}
		});
		me.gridChildren.addListener('celldblclick',me.onGridChildrenItemDblClick,me);
		panel.add(me.gridChildren);
		me.childrenPanel=panel;
		return panel;
	},
	clickChildItemNumber:function(record,cellIndex){
		var me=this;
		var workItemID=record.data['workItemID'];
		me.fireEvent("clickOnChild",workItemID);
	},
	onGridChildrenItemDblClick:function(view, td,cellIndex,record, tr, rowIndex,e){
		var me=this;
		e.stopEvent();
		var workItemID=record.data['workItemID'];
		me.fireEvent("clickOnChild",workItemID);
		return false;
	},
	refreshItemPanel:function() {
		var me = this;
		var urlStr = 'item!executeAJAX.action';
		Ext.Ajax.request({
			url : urlStr,
			params : {
				'workItemID' : me.workItemID,
				'projectID' : me.projectID,
				'issueTypeID' : me.issueTypeID,
				'readOnlyMode' : me.readOnlyMode,
				'actionID' : me.actionID
			// +'&forwardAction='+forwardAction,
			},
			success : function(response) {
				var jsonData = Ext.decode(response.responseText);
				me.lastModified = jsonData.data.lastModified;
				me.replaceScreenItem.call(me, jsonData.data.screen,
						jsonData.data.children, jsonData.data.readOnlyMode,
						jsonData.data.workItemContext);
			},
			failure : function() {
				alert("failed!");
			}
		});
	},
	replaceScreenItem:function(
			screenData, children, readOnlyMode, workItemContext) {
		var me = this;
		var screenModel = com.trackplus.screen.createScreenModel(screenData);
		me.screenFacade = Ext.create('com.trackplus.screen.BaseScreenFacade', {
			screenModel : screenModel,
			readOnlyMode : readOnlyMode,
			showOneTab : true,
			tabViewCls:'com.trackplus.screen.ItemTabView',
			controllerCls : 'com.trackplus.screen.ItemScreenController',
			dataModel : workItemContext
		});
		var screenView = me.screenFacade.createViewComponent();
		if (CWHF.isNull(children)|| children.length === 0) {
			me.itemScreenPanel = screenView;
		} else {
			me.itemScreenPanel = Ext.create('Ext.container.Container', {
				layout:'anchor',
				defaults:{
					anchor:'100%'
				},
				//border : false,
				//autoScroll : true,
				items : [ screenView, me.createChildrenPanel(0, children) ]
			});
		}
		me.screenFacade.screenController.addListener('editMode',function(){
			me.fireEvent('editMode');
		});
		me.screenFacade.screenController.addListener('clickOnParent',function(parentID){
			me.fireEvent('clickOnParent',parentID);
		});
		me.screenFacade.screenController.addListener('lastModified',function(lastModified){
			if(me.itemDetailComponent){
				me.itemDetailComponent.lastModified=lastModified;
			}
			me.lastModified=lastModified;
			me.fireEvent('lastModified',lastModified);
		});
		me.screenFacade.screenController.addListener('finishedUpload',function(){
			if(me.itemDetailComponent){
				me.itemDetailComponent.refreshAttachments();
			}
		});
		me.itemPanel.removeAll(true);
		me.itemPanel.add(me.itemScreenPanel);
	},
	setParent:function(objectID, label,id){
		var me=this;
		var fieldTypeRenderersMap=me.screenFacade.screenController.fieldTypeRenderersMap;
		var fieldTypeRenderer=fieldTypeRenderersMap['f16'];
		if(fieldTypeRenderer){
			var fieldConfig=fieldTypeRenderer.fieldConfig;
			fieldConfig.jsonData={
				projectSpecificID:id,
				title:label
			};
			fieldTypeRenderer.update.call(fieldTypeRenderer,{
				value:objectID,
				fieldConfig:fieldConfig
			});
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.item.SendEmail',{
	extend:'Ext.Base',
	config: {
		workItemID:null,
		projectID:null
	},
	constructor: function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	view:null,
	seController:null,
	show:function(){
		var me=this;
		if(CWHF.isNull(me.seController)){
			me.seController=Ext.create('com.trackplus.item.SendEmailController',{
				workItemID:me.getWorkItemID(),
				projectID:me.getProjectID()
			});
		}
		me.seController.show();
	}
});
Ext.define('com.trackplus.item.SendEmailView',{
	extend: 'Ext.form.Panel',
	config:{
		model:{},
		seController:null
	},
	layout:'border',
	border:false,
	padding:'0 0 0 0',
	cmbFromAddress:null,
	txtTo:null,
	txtCC:null,
	txtBCC:null,
	visibleCC:false,
	visibleBCC:false,
	visibleAttachments:false,
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.callParent();
	},
	createToolbarBtn:function(label,handler,cssClass,enableToggle){
		var me=this;
		return Ext.create('Ext.button.Button',{
			xtype:'button',
			overflowText:label,
			tooltip:label,
			iconCls:cssClass,
			cls:'toolbarItemAction-noText',
			text:label,
			handler:handler,
			enableToggle:enableToggle?enableToggle===true:false,
			scope:me
		});
	},
	createChildren:function(){
		var me=this;
		var labelWidth=70;
		me.btnCC=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.cc'),me.showHideCC,'user16',true);
		me.btnBCC=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.bcc'),me.showHideBCC,'user16',true);
		me.btnAttachemnt=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.attachments'),me.showHideAtachments,'attachment16',true);
		me.btnSend=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.send'),me.sendEmail,'buttonEmailSend');
		me.btnCancel=me.createToolbarBtn(getText('common.btn.cancel'),me.cancelHandler,'itemAction_cancel');
		var toolbarItems=new Array();
		toolbarItems.push(me.btnCC);
		toolbarItems.push(me.btnBCC);
		if(me.model.attachmentsList&&me.model.attachmentsList.length>0){
			toolbarItems.push(me.btnAttachemnt);
		}
		toolbarItems.push(me.btnSend);
		toolbarItems.push(me.btnCancel);
		me.toolbar=Ext.create('Ext.toolbar.Toolbar', {
			layout: {
				overflowHandler: 'Menu'
			},
			enableOverflow: true,
			anchor:'100%',
			cls:'toolbarActions',
			border: '1 0 1 0',
			defaults: {
				cls:'toolbarItemAction',
				overCls:'toolbarItemAction-over',
				scale:'small',
				iconAlign: 'left',
				enableToggle:false
			},
			items:toolbarItems
		});
		var submitterEmail=me.model['submitterEmail'];
		me.dsFromAddress=Ext.create('Ext.data.Store', {
			fields	: [{name:'id', type:'string'}, {name:'label', type:'string'}],
			data:me.model["fromAddressList"]
		});
		me.cmbFromAddress=Ext.create('Ext.form.ComboBox',{
			fieldLabel:getText('item.action.sendItemEmail.lbl.from'),
			labelStyle:"overflow:hidden;",
			labelAlign:'right',
			margin:'5 5 5 5',
			labelWidth: labelWidth,
			store:me.dsFromAddress,
			displayField : 'label',
			valueField: 'id',
			typeAhead:true,
			queryMode: 'local',
			triggerAction: 'all',
			name: 'from',
			value:me.model['from'],
			width:400
		});
		me.linkTo=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.to'),
			width:labelWidth,
			handler:me.openLinkTo,
			scope:me
		});
		me.txtTo=Ext.create('Ext.form.field.Text',{
			name:'toCustom',
			margin:'0 0 0 5',
			flex:1
		});
		me.btnChooseTo=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.to')),
			iconCls:'addressBook',
			handler:me.openLinkTo,
			margin:'0 0 0 5',
			scope:me
		})
		var containerTo={
			xtype:'container',
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			items:[me.linkTo,me.txtTo,me.btnChooseTo]
		}
		me.linkCC=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.cc'),
			width:labelWidth,
			handler:me.openLinkCC,
			scope:me
		});
		me.txtCC=Ext.create('Ext.form.field.Text',{
			name:'ccCustom',
			margin:'0 0 0 5',
			flex:1
		});
		me.btnChooseCC=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.cc')),
			iconCls:'addressBook',
			handler:me.openLinkCC,
			margin:'0 0 0 5',
			scope:me
		})
		me.containerCC=Ext.create('Ext.container.Container',{
			xtype:'container',
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			hidden:true,
			items:[me.linkCC,me.txtCC,me.btnChooseCC]
		});
		me.linkBCC=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.bcc'),
			width:labelWidth,
			handler:me.openLinkBCC,
			scope:me
		});
		me.txtBCC=Ext.create('Ext.form.field.Text',{
			margin:'0 0 0 5',
			flex:1,
			name:'bccCustom',
			anchor: '100%'
		});
		me.btnChooseBCC=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.bcc')),
			iconCls:'addressBook',
			handler:me.openLinkBCC,
			margin:'0 0 0 5',
			scope:me
		})
		me.containerBCC=Ext.create('Ext.container.Container',{
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			hidden:true,
			items:[me.linkBCC,me.txtBCC,me.btnChooseBCC]
		});
		me.containerAttachments= Ext.create('com.trackplus.util.MultipleSelectPicker',{
			data:me.model.attachmentsList,
			hidden:true,
			//width:400,
			anchor: '100%',
			margin:'10 5 5 5',
			name:'selectedAttachments',
			fieldLabel:getText('item.action.sendItemEmail.lbl.attachments'),
			labelStyle:"overflow:hidden;",
			labelAlign:'right',
			labelWidth: labelWidth,
			localizedLabel:getText('item.action.sendItemEmail.lbl.attachments'),
			useNull:true
			//iconUrlPrefix:'optionIconStream.action?fieldID=-'+fieldID+'&optionID='
		});
		me.chkSubmitter=Ext.create('Ext.form.field.Checkbox',{
			margin:'0 0 0 80',
			boxLabel:getText('item.action.sendItemEmail.lbl.submitterEmail')+'&nbsp;&lt;'+submitterEmail+'&gt;',
			name: 'includeSubmitterEmail',
			hidden:CWHF.isNull(submitterEmail),
			inputValue : true
		});
		me.txtSubjectPrefix=Ext.create('Ext.form.field.Text',{
			margin:'0 5 0 0',
			readOnly:true,
			name:'subjectReadonly',
			value:me.model['subjectReadolnyPart'],
			columnWidth:0.25
		});
		me.txtSubject=Ext.create('Ext.form.field.Text',{
			name:'subject',
			value:me.model['subject'],
			columnWidth:0.75
		})
		var subjectCmp={
			xtype: 'fieldcontainer',
			margin:'15 5 5 5',
			fieldLabel:getText('item.action.sendItemEmail.lbl.subject'),
			labelStyle:"overflow:hidden;",
			labelAlign:'right',
			labelWidth: labelWidth,
			layout:'column',
			anchor:'100%',
			defaults: {
				hideLabel: true
			},
			items:[me.txtSubjectPrefix,me.txtSubject]
		};
		var northPanel=Ext.create('Ext.panel.Panel',{
			layout:'anchor',
			border:false,
			bodyBorder:false,
			region:'north',
			padding: '0 0 0 0',
			items:[me.toolbar, me.cmbFromAddress,containerTo,me.containerCC,me.containerBCC, me.chkSubmitter,me.containerAttachments,subjectCmp]
		});
		var bodyCfg={
			region:'center',
			margin:'5 5 5 5',
			border:false,
			cls:'rteField',
			/*cls:'ckeField100Percent'*/
		};
		var ckeditorCfg={
			workItemID:me.seController.workItemID,
			projectID:me.seController.projectID
		}
		me.txtBody=CWHF.createRichTextEditorField('mailBody',bodyCfg,false,true,ckeditorCfg);
		me.chkIncludeItemInformation=Ext.create('Ext.form.field.Checkbox',{
			boxLabel:getText('item.action.sendItemEmail.lbl.includeItemInformation'),
			inputValue : true,
			name: 'includeItemInformation'
		});
		me.chkIncludeLink=Ext.create('Ext.form.field.Checkbox',{
			boxLabel:getText('item.action.sendItemEmail.lbl.includeItemLink'),
			inputValue : true,
			checked : true,
			name: 'includeItemLink'
		});
		var containerSouth=Ext.create('Ext.container.Container',{
			margin:'0 5 5 5',
			items:[me.chkIncludeItemInformation,me.chkIncludeLink],
			region:'south'
		});
		return [northPanel,me.txtBody,containerSouth];
	},
	showHideCC:function(){
		var me=this;
		me.visibleCC=!me.visibleCC;
		me.containerCC.setVisible(me.visibleCC);
	},
	showHideBCC:function(){
		var me=this;
		me.visibleBCC=!me.visibleBCC;
		me.containerBCC.setVisible(me.visibleBCC);
	},
	showHideAtachments:function(){
		var me=this;
		me.visibleAttachments=!me.visibleAttachments;
		me.containerAttachments.setVisible(me.visibleAttachments);
	},
	openLinkTo:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.to'));
		me.seController.openPersonDialog.call(me.seController,me.txtTo,title);
	},
	openLinkCC:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.cc'));
		me.seController.openPersonDialog.call(me.seController,me.txtCC,title);
	},
	openLinkBCC:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.bcc'));
		me.seController.openPersonDialog.call(me.seController,me.txtBCC,title);
	},
	sendEmail:function(){
		var me=this;
		me.seController.sendEmail.call(me.seController);
	},
	cancelHandler:function(){
		var me=this;
		me.seController.cancelHandler.call(me.seController);
	}
});
Ext.define('com.trackplus.item.SendEmailController',{
	extend:'Ext.Base',
	config: {
		workItemID:null
	},
	view:null,
	ERROR_NEED_FROM:1,
	ERROR_INVALID_EMAIL:2,
	ERROR_NEED_PERSON:3,
	ERROR_EMAIL_NOT_SEND:4,
	ERROR_NEED_MORE_TIME:5,
	constructor: function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	createView:function(data){
		var me=this;
		me.view=Ext.create('com.trackplus.item.SendEmailView',{
			model:data,
			seController:me
		});
		me.addListeners();
		return me.view;
	},
	addListeners:function(){
	},
	openPersonDialog:function(txtTo,title){
		var me=this;
		me.currentTxtTo=txtTo;
		var personPikerDialog=Ext.create('com.trackplus.util.PersonPickerDialog',{
			title:title,
			options:null,
			includeEmail:true,
			includeGroups:true,
			handler:me.addPersonHandler,
			scope:me
		});
		personPikerDialog.showDialog();
	},
	addPersonHandler:function(value,displayValue){
		var me=this;
		if(CWHF.isNull(displayValue)){
			return ;
		}
		var oldValue=me.currentTxtTo.getValue();
		var newValue="";
		if(oldValue&&oldValue!==''){
			newValue=oldValue+";"
		}
		newValue+=displayValue.join('; ');
		me.currentTxtTo.setValue(newValue);
	},
	show:function(){
		var me=this;
		var urlStr='sendItemEmail.action';
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			scope:me,
			params:{'workItemID':me.workItemID},
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				borderLayout.setLoading(false);
				if (responseJson.success===true) {
					me.successHandler.call(me,responseJson.data);
				}else{
					var errorCode=responseJson.errorCode;
					var errorMessage=responseJson.errorMessage;
					if(errorCode===me.ERROR_EMAIL_NOT_SEND){
						CWHF.showMsgError(getText('item.action.sendItemEmail.err.noSMTP'));
					}else{
						CWHF.showMsgError(errorMessage);
					}
				}
			},
			failure:function(){
				borderLayout.setLoading(false);
				alert("failure");
			}
		});
	},
	successHandler:function(data){
		var me=this;
		if(me.view){
			me.view.destroy();
		};
		me.view=me.createView(data);
		if(me.win){
			me.win.destroy();
			me.win=null;
		}
		me.win = Ext.create('Ext.window.Window',{
			layout      : 'fit',
			maximizable :true,
			border:false,
			bodyBorder:true,
			margin:'0 0 0 0',
			style:{
				padding:'5px 0px 0px 0px'
			},
			bodyStyle:{
				padding:'0 0 0 0',
				margin:'0 0 0 0'
			},
			iconCls:'buttonEmail16',
			width       : 880,
			height      : 600,
			closeAction :'destroy',
			plain       : true,
			title		:getText('item.action.sendItemEmail.lbl.title'),
			modal       :true,
			items       :[me.view],
			autoScroll  :true
		});
		var width=880;
		var height=600;
		var size=borderLayout.ensureSize(width,height);
		width=size.width;
		height=size.height;
		me.win.setWidth(width);
		me.win.setHeight(height);
		if(width<880||height<600){
			me.win.setPosition(10,10);
		}
		me.win.show();
	},
	sendEmail:function(){
		var me=this;
		CWHF.submitRTEditor(me.view.txtBody);
		var formPanel=me.view;
		formPanel.setLoading(com.trackplus.TrackplusConfig.getText("common.lbl.loading"));
		formPanel.getForm().submit({
			url:'sendItemEmail!sendEmail.action',
			params:{
				'workItemID':me.workItemID
			},
			success: function(form, action) {
				formPanel.setLoading(false);
				CWHF.showMsgInfo(getText('item.action.sendItemEmail.lbl.sentSuccessful'));
				me.win.hide();
				me.win.destroy();
			},
			failure: function(form, action) {
				formPanel.setLoading(false);
				var errorCode=action.result.errorCode;
				var errorMessage=action.result.errorMessage;
				CWHF.showMsgError(errorMessage);
				switch(errorCode){
					case me.ERROR_NEED_FROM:{
						me.view.cmbFromAddress.focus();
						break;
					}
					case me.ERROR_INVALID_EMAIL:{
						me.view.txtTo.focus();
						break;
					}
					case me.ERROR_NEED_PERSON:{
						me.view.txtTo.focus();
						break;
					}
				}
			}
		});
	},
	cancelHandler:function(){
		var me=this;
		me.win.hide();
		me.win.destroy();
		me.win=null;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.screen.FieldEditWrapperView', {
	extend : 'Ext.panel.Panel',
	config : {
		model : null,
		parentView : null,
		emptyText : getText('admin.customize.form.edit.emptyField')
	},
	bodyStyle : {
		overflow : 'hidden',
		background : 'transparent'
	},
	myComponentCls : null,
	getFieldCls : function() {
		return "designField";
	},
	initComponent : function() {
		var me = this;
		var cfg = me.getFieldWrapperConfig.call(me);
		var iconRendering = me.model.iconRendering
		if(iconRendering===2){
			//both
			this.layout="hbox";
		}
		Ext.apply(this, cfg);
		if (me.model.empty) {
			me.bodyStyle = {
				paddingTop : '3px',
				paddingBottom : '5px'
			};
			me.html = me.emptyText;
			me.addCls("emptyField");
			me.myComponentCls = "emptyField";
		} else {
			me.myComponentCls = me.getFieldCls();
			me.addCls(me.myComponentCls);
			var htmlStr = null;
			var missingPlugin = me.model.jsonData.missingPlugin;
			if (missingPlugin) {
				htmlStr = '<span>' + me.model.jsonData.htmlString + '</span>';
			} else {
				var srcImage = me.model.jsonData.srcImage;
				if (srcImage ) {
					var imgCmp = Ext.create('Ext.Img', {
						src : 'loadImage.action?imageName=' + srcImage,
						listeners : {
							render : function(c) {
								c.getEl().on('load', function() {
									me.ownerCt.ownerCt.updateLayout();
								});
							}
						}
					});
					me.items = [ imgCmp ];
				} else {
					var iconRendering = me.model.iconRendering  ? me.model.iconRendering : 0;
					switch (iconRendering) {
					case 0: {
						// label
						var extClassName = me.model.extClassName;
						if (extClassName ) {
							var fieldCmp = Ext.create(extClassName, {
								flex : 1
							}).render(me.model);
							me.items = [ fieldCmp ];
						}
						break;
					}
					case 1: {
						// icon
						var iconCmp = me.createIconCmp();
						me.items = [ iconCmp ];
						break;
					}
					case 2: {
						// both
						var iconCmp = me.createIconCmp();
						var extClassName = me.model.extClassName;
						if (extClassName ) {
							var fieldCmp = Ext.create(extClassName, {
								flex : 1
							}).render(me.model);
							me.items = [ iconCmp, fieldCmp ];
						} else {
							me.items = [ iconCmp ];
						}
						break;
					}
					}
				}
			}
			if (htmlStr ) {
				me.html = htmlStr;
			}
		}
		me.callParent();
	},
	createIconCmp : function() {
		var me = this;
		var icon = "data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
		var iconCls = 'customFields-ticon';
		switch (me.model.fieldID) {
		case 2: {
			// ISSUETYPE
			iconCls = "issueType-ticon";
			break;
		}
		case 4: {
			// STATE
			iconCls = "status-ticon";
			break;
		}
		case 10: {
			// PRIORITY
			iconCls = "priority-ticon";
			break;
		}
		case 11: {
			// SEVERITY
			iconCls = "severity-ticon";
			break;
		}
		}
		return Ext.create('Ext.Component', {
			width : 22,
			html : '<img class="' + iconCls + '" src="' + icon + '" height="16"/>'
		});
	},
	getFieldWrapperConfig : function() {
		var me = this;
		var cfg = {
			margin : '2 2 2 2',
			border : false
		};
		if (me.model.iconRendering === 1) {
			cfg['width'] = 25;
		}
		return cfg;
	}
});
Ext.define('com.trackplus.screen.PropertiesPanel', {
	extend : 'Ext.grid.property.Grid',
	componentModel : null,
	title : getText('admin.customize.form.edit.lbl.layoutProperties'),
	border : false,
	bodyBorder : false,
	height : 300,
	region : 'north',
	ALIGN_TOP : 0,
	ALIGN_BOTTOM : 1,
	ALIGN_MIDDLE : 2,
	ALIGN_LEFT : 3,
	ALIGN_RIGHT : 4,
	ALIGN_CENTER : 5,
	ALIGN_TOP_STR : getText('admin.customize.form.fieldProperties.align.top'),
	ALIGN_BOTTOM_STR : getText('admin.customize.form.fieldProperties.align.bottom'),
	ALIGN_MIDDLE_STR : getText('admin.customize.form.fieldProperties.align.middle'),
	ALIGN_LEFT_STR : getText('admin.customize.form.fieldProperties.align.left'),
	ALIGN_RIGHT_STR : getText('admin.customize.form.fieldProperties.align.right'),
	ALIGN_CENTER_STR : getText('admin.customize.form.fieldProperties.align.center'),
	ICON_RENDERING_LABEL : 0,
	ICON_RENDERING_ICON : 1,
	ICON_RENDERING_BOTH : 2,
	ICON_RENDERING_LABEL_STR : getText('admin.customize.form.fieldProperties.iconRendering.label'),
	ICON_RENDERING_ICON_STR : getText('admin.customize.form.fieldProperties.iconRendering.icon'),
	ICON_RENDERING_BOTH_STR : getText('admin.customize.form.fieldProperties.iconRendering.both'),
	propertyNames : {
		'screen.label' : getText('common.lbl.label'),
		'screen.name' : getText("common.lbl.name"),
		'screen.description' : getText("common.lbl.description"),
		'tab.label' : getText('common.lbl.label'),
		'tab.name' : getText("common.lbl.name"),
		'tab.description' : getText("common.lbl.description"),
		'panel.name' : getText("common.lbl.name"),
		'panel.description' : getText("common.lbl.description"),
		'panel.rowsNo' : getText("admin.customize.form.panelProperties.rows"),
		'panel.colsNo' : getText("admin.customize.form.panelProperties.columns"),
		'fieldType' : getText("admin.customize.form.fieldProperties.type"),
		'field.name' : getText("common.lbl.name"),
		'field.description' : getText("common.lbl.description"),
		'field.rowSpan' : getText("admin.customize.form.fieldProperties.rowSpan"),
		'field.colSpan' : getText("admin.customize.form.fieldProperties.colSpan"),
		'field.iconRendering' : getText('admin.customize.form.fieldProperties.iconRendering'),
		'field.labelHAlign' : getText('admin.customize.form.fieldProperties.labelHAlign'),
		'field.labelVAlign' : getText('admin.customize.form.fieldProperties.labelVAlign'),
		'field.valueHAlign' : getText('admin.customize.form.fieldProperties.valueHAlign'),
		'field.valueVAlign' : getText('admin.customize.form.fieldProperties.valueVAlign'),
		'field.hideLabelBoolean' : getText('admin.customize.form.fieldProperties.hideLabel')
	},
	source : {},
	createCombo : function(options) {
		var store = Ext.create('Ext.data.Store', {
			fields : [ {
				name : 'id',
				type : 'int'
			}, {
				name : 'label',
				type : 'string'
			} ],
			data : options
		});
		var inputComp = Ext.create('Ext.form.ComboBox', {
			store : store,
			queryMode : 'local',
			displayField : 'label',
			valueField : 'id'
		});
		return inputComp;
	},
	initComponent : function() {
		var me = this;
		Ext.apply(this);
		var valignList = [ {
			id : me.ALIGN_TOP,
			label : me.ALIGN_TOP_STR
		}, {
			id : me.ALIGN_BOTTOM,
			label : me.ALIGN_BOTTOM_STR
		}, {
			id : me.ALIGN_MIDDLE,
			label : me.ALIGN_MIDDLE_STR
		} ];
		var halignList = [ {
			id : me.ALIGN_LEFT,
			label : me.ALIGN_LEFT_STR
		}, {
			id : me.ALIGN_RIGHT,
			label : me.ALIGN_RIGHT_STR
		}, {
			id : me.ALIGN_CENTER,
			label : me.ALIGN_CENTER_STR
		} ];
		var iconRenderingList = [ {
			id : me.ICON_RENDERING_LABEL,
			label : me.ICON_RENDERING_LABEL_STR
		}, {
			id : me.ICON_RENDERING_ICON,
			label : me.ICON_RENDERING_ICON_STR
		}, {
			id : me.ICON_RENDERING_BOTH,
			label : me.ICON_RENDERING_BOTH_STR
		}
		];
		var comboIconRendering = me.createCombo(iconRenderingList);
		var comboHAlign = me.createCombo(halignList);
		var comboVAlign = me.createCombo(valignList);
		var comboHAlign1 = me.createCombo(halignList);
		var comboVAlign1 = me.createCombo(valignList);
		me.customEditors = {
			'fieldType' : Ext.create('Ext.form.field.Display', {}),
			'field.rowSpan' : Ext.create('Ext.form.field.Number', {
				minValue : 1,
				maxValue : 20,
				allowBlank : false
			}),
			'field.colSpan' : Ext.create('Ext.form.field.Number', {
				minValue : 1,
				maxValue : 10,
				allowBlank : false
			}),
			'panel.rowsNo' : Ext.create('Ext.form.field.Number', {
				minValue : 1,
				maxValue : 20,
				allowBlank : false
			}),
			'panel.colsNo' : Ext.create('Ext.form.field.Number', {
				minValue : 1,
				maxValue : 10,
				allowBlank : false
			}),
			'field.iconRendering' : comboIconRendering,
			'field.labelHAlign' : comboHAlign,
			'field.labelVAlign' : comboVAlign,
			'field.valueHAlign' : comboHAlign1,
			'field.valueVAlign' : comboVAlign1
		};
		me.customRenderers = {
			'field.iconRendering' : function(val, meta, r) {
				var record = comboIconRendering.findRecord(comboIconRendering.valueField, val);
				return record ? record.get(comboIconRendering.displayField) : comboIconRendering.valueNotFoundText;
			},
			'field.labelHAlign' : function(val, meta, r) {
				var record = comboHAlign.findRecord(comboHAlign.valueField, val);
				return record ? record.get(comboHAlign.displayField) : comboHAlign.valueNotFoundText;
			},
			'field.labelVAlign' : function(val, meta, r) {
				var record = comboVAlign.findRecord(comboVAlign.valueField, val);
				return record ? record.get(comboVAlign.displayField) : comboVAlign.valueNotFoundText;
			},
			'field.valueHAlign' : function(val, meta, r) {
				var record = comboHAlign1.findRecord(comboHAlign1.valueField, val);
				return record ? record.get(comboHAlign1.displayField) : comboHAlign1.valueNotFoundText;
			},
			'field.valueVAlign' : function(val, meta, r) {
				var record = comboVAlign1.findRecord(comboVAlign1.valueField, val);
				return record ? record.get(comboVAlign1.displayField) : comboVAlign1.valueNotFoundText;
			}
		};
		me.callParent();
	}
});
Ext.define('com.trackplus.screen.FieldListPanel', {
	extend : 'Ext.grid.GridPanel',
	config : {
		url : ''
	},
	stripeRows : true,
	border : false,
	bodyBorder : false,
	enableColumnHide : false,
	enableColumnMove : false,
	columnLines : true,
	region : 'center',
	collapsible : false,
	split : false,
	columns : [ {
		text : getText('common.lbl.name'),
		// flex: 1,
		width : 140,
		dataIndex : 'label',
		id : 'label',
		sortable : true
	}, {
		text : getText('common.lbl.description'),
		flex : 1,
		/* width:200, */dataIndex : 'description',
		id : 'description',
		sortable : false
	} ],
	viewConfig : {
		forceFit : true,
		plugins : {
			ddGroup : 'fields',
			ptype : 'gridviewdragdrop',
			enableDrop : false,
			enableDrag : true
		}
	},
	selModel : Ext.create('Ext.selection.RowModel', {
		singleSelect : true
	}),
	initComponent : function() {
		var me = this;
		var store = Ext.create('Ext.data.Store', {
			fields : [ {
				name : 'id'
			}, {
				name : 'name'
			}, {
				name : 'label'
			}, {
				name : 'description'
			} ],
			proxy : {
				type : 'ajax',
				url : me.url,
				reader : {
					type : 'json'
				}
			},
			sorters : [ {
				property : 'label',
				direction : 'ASC'
			} ]
		});
		me.store = store;
		me.callParent();
		store.load();
	}
});
Ext.define('com.trackplus.screen.FieldTreePanel', {
	extend : 'Ext.tree.Panel',
	config : {
		url : ''
	},
	useArrows : false,
	rootVisible : false,
	border : false,
	bodyBorder : false,
	region : 'center',
	height : 300,
	selModel : Ext.create('Ext.selection.RowModel', {
		singleSelect : true
	}),
	viewConfig : {
		forceFit : true,
		plugins : {
			ddGroup : 'fields',
			ptype : 'gridviewdragdrop',
			enableDrop : false,
			enableDrag : true
		}
	},
	columns : [ {
		xtype : 'treecolumn',
		text : getText('common.lbl.name'),
		// flex: 1,
		width : 140,
		dataIndex : 'label',
		id : 'label',
		sortable : true
	}, {
		text : getText('common.lbl.description'),
		flex : 1,
		/* width:200, */dataIndex : 'description',
		id : 'description',
		sortable : false
	} ],
	initComponent : function() {
		var me = this;
		var store = Ext.create('Ext.data.TreeStore', {
			fields : [ {
				name : 'id'
			}, {
				name : 'name'
			}, {
				name : 'label'
			}, {
				name : 'description'
			} ],
			proxy : {
				type : 'ajax',
				url : me.url,
				reader : {
					type : 'json'
				}
			}
		});
		me.store = store;
		me.callParent();
	}
});
Ext.define('com.trackplus.screen.ScreenEditView', {
	extend : 'Ext.panel.Panel',
	config : {
		screenView : null,
		urlFieldList : '',
		titleFieldList : 'Fields',
		fieldsAsTree : false
	},
	region : 'center',
	fieldsAsTree : false,
	margins : '0 0 0 0',
	border : false,
	baseCls : 'x-plain',
	layout : 'border',
	propertiesPanel : null,
	fieldListPanel : null,
	cls : 'screenEditViewWrapper',
	initComponent : function() {
		var me = this;
		me.items = [ me.screenView, me.createEastPanel() ];
		me.callParent();
	},
	createEastPanel : function() {
		var me = this;
		me.propertiesPanel = Ext.create('com.trackplus.screen.PropertiesPanel', {
			bodyBorder : false
		});
		if (me.fieldsAsTree) {
			me.fieldListPanel = Ext.create('com.trackplus.screen.FieldTreePanel', {
				url : me.urlFieldList,
				title : me.titleFieldList
			});
		} else {
			me.fieldListPanel = Ext.create('com.trackplus.screen.FieldListPanel', {
				url : me.urlFieldList,
				title : me.titleFieldList
			});
		}
		return Ext.create('Ext.panel.Panel', {
			layout : 'border',
			region : 'east',
			border : false,
			bodyBorder : false,
			bodyPadding : 0,
			width : 275,
			split : true,
			style : {
				borderLeft : '1px solid #D0D0D0'
			},
			margin : '0 0 0 -4',
			items : [ me.propertiesPanel, me.fieldListPanel ]
		});
	},
	getSelectedTab : function() {
		return this.screenView.getSelectedTab();
	}
});
Ext.define('com.trackplus.screen.ScreenEditFacade', {
	extend : 'com.trackplus.screen.BaseScreenFacade',
	config : {
		urlFieldList : null,
		fieldsAsTree : false,
		useConfig : false,
		configURL : null,
		lastSelectedTab : null,
		fieldWrapperCls : null,
		screenAction : null,
		screenActionParams : null,
		screenUpdateAction : null,
		tabAction : null,
		tabUpdateAction : null,
		panelAction : null,
		panelUpdateAction : null,
		fieldAction : null,
		fieldUpdateAction : null,
		messageDeletePanel : null,
		messageDeleteTab : null,
		messageDeleteField : null,
		messageCantDeleteScreen : null,
		messageCantDeleteLastTab : null,
		backAction : null
	},
	fieldsAsTree : false,
	baseScreenView : null,
	mainPanel : null,
	tabsPanel : null,
	propertiesPan : null,
	clickOnField : false,
	clickOnPanel : false,
	clickOnTab : false,
	screenEditView : null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		me.screenController = Ext.create(me.controllerCls, {
			screenModel : me.screenModel,
			showOneTab : me.showOneTab,
			lastSelectedTab : me.lastSelectedTab,
			refreshTabUrl : me.refreshTabUrl,
			storeTabUrl : me.storeTabUrl,
			panelViewCls : me.panelViewCls,
			fieldWrapperCls : me.fieldWrapperCls,
			screenAction : me.screenAction,
			screenActionParams : me.screenActionParams,
			screenUpdateAction : me.screenUpdateAction,
			tabAction : me.tabAction,
			tabUpdateAction : me.tabUpdateAction,
			panelAction : me.panelAction,
			panelUpdateAction : me.panelUpdateAction,
			fieldAction : me.fieldAction,
			fieldUpdateAction : me.fieldUpdateAction,
			useConfig : me.useConfig,
			configURL : me.configURL,
			messageDeletePanel : me.messageDeletePanel,
			messageDeleteTab : me.messageDeleteTab,
			messageDeleteField : me.messageDeleteField,
			messageCantDeleteScreen : me.messageCantDeleteScreen,
			messageCantDeleteLastTab : me.messageCantDeleteLastTab,
			backAction : me.backAction
		});
	},
	createScreenEditViewComponent : function() {
		var me = this;
		me.screenView = me.createViewComponent();
		me.screenView.addCls('designScreen');
		me.screenView.myComponentCls = 'designScreen';
		me.screenEditView = Ext.create('com.trackplus.screen.ScreenEditView', {
			screenView : me.screenView,
			urlFieldList : me.urlFieldList,
			fieldsAsTree : me.fieldsAsTree,
			titleFieldList : me.titleFieldList
		});
		me.screenEditView.propertiesPanel.addListener('propertychange', me.screenController.changeAttribute, me.screenController);
		me.screenController.screenEditView = me.screenEditView;
		return me.screenEditView;
	},
	getToolbar : function() {
		var me = this;
		return me.screenController.getToolbar.call(me.screenController);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//Component Controller
//Component Controller
Ext.define('com.trackplus.screen.ComponentController',{
	extend:'Ext.Base',
	config:{
		screenEditController:null,
		action:'',
		updateAction:''
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		//this.initConfig(config);
	},
	getUpdateLink:function(compID){
		if(CWHF.isNull(this.updateAction)){
			return null;
		}
		var screenID=this.screenEditController.screenModel.id;
		return this.updateAction+".action?componentID="+compID+"&screenID="+screenID;
	},
	getPropertyLink:function(compID){
		if(CWHF.isNull(this.updateAction)){
			return null;
		}
		return this.action+"!properties.action?componentID="+compID;
	},
	reload:function(compID,action,params, idChild){
	},
	click:function(comp){
		/*var me=this;
		me.setSelectedComponent(comp);
		var compControllerCfg=me.getComponentControllerCfg(comp);
		var componentID=comp.model.getId();
		var urlStr=compControllerCfg.getPropertyLink(componentID);
		me.refreshOutline.call(me,urlStr);*/
	}
});
//ScreenController
Ext.define('com.trackplus.screen.ScreenController',{
	extend:'com.trackplus.screen.ComponentController',
	reload:function(screenView,actionMethod,params, idChild){
		var me=this;
		if(CWHF.isNull(actionMethod)){
			actionMethod="reload";
		}
		var componentID=screenView.model.getId();
		var urlStr=me.action+"!"+actionMethod+".action?componentID="+componentID;
		if(me.projectID){
			urlStr=urlStr+"&projectID="+this.projectID+"&entityType="+this.entityType;
		}
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			params:params,
			success: function(resp){
				location.reload(true);
				/*var jsonData=Ext.decode(resp.responseText);
				var screenModel=com.trackplus.screen.createScreenModel(jsonData.data.screen);
				me.screenEditController.refreshScreenModel.call(me.screenEditController,screenView,screenModel,
					idChild?idChild:jsonData.data.selectedTab);
				screenView.setLoading(false);*/
			},
			failure:function(){
				alert("failed!");
				screenView.setLoading(false);
			}
		});
	},
	copy:function(screenID,sourceType,sourceID,succesHandler,scope){
		var me=this;
		borderLayout.setLoading(true);
		var urlStr=me.action+"!copy.action?componentID="+screenID;
		var params={
			sourceType:sourceType,
			sourceID:sourceID
		};
		Ext.Ajax.request({
			url: urlStr,
			params:params,
			success: function(resp){
				var jsonData=Ext.decode(resp.responseText);
				borderLayout.setLoading(false);
				if(succesHandler){
					succesHandler.call(scope);
				}
			},
			failure:function(){
				alert("failed!");
				borderLayout.setLoading(false);
			}
		});
	},
	paste:function(screenID,sourceType,sourceID,targetType,targetID,targetInfo,successHandler,scope){
		var me=this;
		borderLayout.setLoading(true);
		var urlStr=me.action+"!paste.action?componentID="+screenID;
		var params={
			sourceType:sourceType,
			sourceID:sourceID,
			targetType:targetType,
			targetID:targetID,
			targetInfo:targetInfo
		};
		Ext.Ajax.request({
			url: urlStr,
			params:params,
			success: function(resp){
				var jsonData=Ext.decode(resp.responseText);
				borderLayout.setLoading(false);
				if(successHandler){
					successHandler.call(CWHF.isNull(scope)?me:scope);
				}
			},
			failure:function(){
				alert("failed!");
				borderLayout.setLoading(false);
			}
		});
	}
});
//TabController
Ext.define('com.trackplus.screen.TabController',{
	extend:'com.trackplus.screen.ComponentController',
	unregister:function(tabCmp){
		tabCmp.unregister.call(tabCmp);
	},
	reload:function(tabCmp,actionMethod,params, idChild){
		var me=this;
		if(CWHF.isNull(me.action)){
			me.screenEditController.reload.call(me.screenEditController);
			return;
		}
		var compID=tabCmp.model.getId();
		tabCmp.setLoading(getText("common.lbl.loading"));
		//unregister
		me.unregister(tabCmp);
		if(CWHF.isNull(actionMethod)){
			actionMethod="reload";
		}
		var urlStr=me.action+"!"+actionMethod+".action?componentID="+compID;
		var screenID=me.screenEditController.screenModel.id;
		urlStr=urlStr+"&screenID="+screenID;
		if(me.projectID){
			urlStr=urlStr+"&projectID="+this.projectID+"&entityType="+this.entityType;
		}
		Ext.Ajax.request({
			url: urlStr,
			params:params,
			success: function(response){
				var jsonData=Ext.decode(response.responseText);
				var tabModel=com.trackplus.screen.createTabModel(jsonData.data);
				var panelToSelect=me.screenEditController.refreshTabModel(tabCmp,tabModel,idChild);
				tabCmp.setLoading(false);
				if(panelToSelect){
					me.screenEditController.setSelectedComponent(panelToSelect);
				}
			},
			failure:function(){
				alert("failed!");
				tabCmp.setLoading(false);
			}
		});
	}
});
//PanelController
Ext.define('com.trackplus.screen.PanelController',{
	extend:'com.trackplus.screen.ComponentController',
	unregister:function(panel){
		panel.unregister.call(panel);
	},
	reload:function(panel,action,params, idToSelect,handler){
		var me=this;
		me.unregister(panel);
		//set loading
		panel.setLoading(getText("common.lbl.loading"));
		if(CWHF.isNull(action)){
			action="reload";
		}
		var panelID=panel.model.getId();
		var urlStr=me.action+"!"+action+".action";
		urlStr=urlStr+"?componentID="+panelID;
		var screenID=me.screenEditController.screenModel.id;
		urlStr=urlStr+"&screenID="+screenID;
		if(me.projectID){
			urlStr=urlStr+"&projectID="+me.projectID+"&entityType="+me.entityType;
		}
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				var panelModel=com.trackplus.screen.createPanelModel(jsonData);
				me.screenEditController.refreshPanelModel(panel,panelModel,true);
				/*document.getElementById("div-p"+panelID).innerHTML=result.responseText;
				var domToSelect=null;
				if(idToSelect){
					domToSelect=document.getElementById(idToSelect);
				}
				if(domToSelect){
				ScreenEdit.selectedItem=null;
					ComponentController.instance.clickHandler(domToSelect);
			 	}*/
				if(handler){
					handler.call();
				}
				panel.setLoading(false);
			},
			failure: function(){
				alert("failure");
				panel.setLoading(false);
			},
			method:'POST',
			params:params
		});
	},
	registerDragDrop:function(panel){
		var me=this;
		var screenCtrl=me.screenEditController;
		var comp=panel;
		var dragSource = new Ext.dd.DragSource(panel.getEl(), {
			dragData:{'panel': panel},
			ddGroup:"panels"
		});
		var dropTarget = new Ext.dd.DropTarget(panel.getEl(), {
			ddGroup	: 'panels',
			notifyEnter : function(ddSource, e, data) {
				screenCtrl.setDragOver(comp);
			},
			notifyOut: function(ddSource, e, data) {
				screenCtrl.clearDragOn();
			},
			notifyDrop  : function(ddSource, e, data){
				screenCtrl.clearDragOn();
				var panelSource=data.panel;
				var panelTarget=panel;
				Ext.defer(me.onDropPanel, 100, me,[panelSource,panelTarget]);
				return true;
			}
		});
		panel.dragDropObjects.push(dragSource);
		panel.dragDropObjects.push(dropTarget);
	},
	onDropPanel:function(panelSource,panelTarget){
		var me=this;
		var sourceID=panelSource.model.getId();
		var targetID=panelTarget.model.getId();
		if(sourceID===targetID){
			return false;
		}
		var newIndex=panelTarget.myIndex;
		var action="moveChild";
		var params={
			"panelID":sourceID,
			"newIndex":newIndex
		};
		var tabCmp=panelSource.parentView;
		me.screenEditController.tabController.reload.call(me.screenEditController.tabController,tabCmp,action,params,sourceID);
		return true;
	}
});
//FieldController
Ext.define('com.trackplus.screen.FieldController',{
	extend:'com.trackplus.screen.ComponentController',
	config:{
		//screenView:null
	},
	registerDrag:function(field){
		var me=this;
		var panelCmp=field.parentView;
		var fieldID=field.model.getId();
		var dragSource = new Ext.dd.DragSource(field.getEl(), {
			dragData:{
				'panelCmp': panelCmp,
				'cell':field.model.row+";"+field.model.col,
				'fieldID':fieldID
			},
			ddGroup:"fields"
		});
		return dragSource;
	},
	registerDrop:function(field){
		var me=this;
		var comp=field;
		var screenCtrl=me.screenEditController;
		var dropTarget = new Ext.dd.DropTarget(field.getEl(), {
			ddGroup	: 'fields',
			notifyEnter : function(ddSource, e, data) {
				screenCtrl.setDragOver(comp);
			},
			notifyOut: function(ddSource, e, data) {
				screenCtrl.clearDragOn();
			},
			notifyOver : function(dd, e, data){
				if(CWHF.isNull(me.lastDropComponent)||me.lastDropComponent.model.getId()!==comp.id){
					screenCtrl.setDragOver(comp);
				}
				return this.dropAllowed;
			},
			notifyDrop  : function(ddSource, e, data){
				screenCtrl.clearDragOn();
				var fieldID=null;
				var fieldType=null;
				var sourcePanel=null;
				var sourceCell=null;
				var fieldModel=comp.model;
				var targetPanel=field.parentView;
				var targetCell=fieldModel.row+";"+fieldModel.col;
				if(data.records){
					//drop a new field
					fieldType=data.records[0].data.id;
				}else{
					fieldID=data.fieldID;
					sourcePanel=data.panelCmp;
					sourceCell=data.cell;
				}
				if(CWHF.isNull(fieldID)&&CWHF.isNull(fieldType)){
					return false;
				}
				Ext.defer(me.onDropField,100,me,[fieldType,fieldID,sourcePanel,sourceCell,targetPanel,targetCell]);
				return true;
			}
		});
		return dropTarget;
	},
	onDropField:function(fieldType,fieldID,sourcePanel,sourceCell,targetPanel,targetCell){
		var me=this;
		var sourcePanelID=null;
		if(sourcePanel){
			sourcePanelID=sourcePanel.model.getId();
		}
		var targetPanelID=targetPanel.model.getId();
		var screenCtrl=me.screenEditController;
		screenCtrl.clearSelectedComponent();
		var action;
		if(CWHF.isNull(sourceCell)){
			action="addField"
		}else{
			action="moveField";
		}
		var params={"fieldID":fieldID,
				"fieldType":fieldType,
				"source":sourceCell,
				"sourcePanelID":sourcePanelID,
				"target":targetCell,
				"targetPanelID":targetPanelID};
		var handler=null;
		if(sourcePanelID&&sourcePanelID!==targetPanelID){
			//drop in other panel
			action="moveFieldFromOther";
			handler=function(){
				screenCtrl.panelController.reload.call(screenCtrl.panelController,sourcePanel,"reload");
			}
		}
		if(sourcePanelID&&sourcePanelID===targetPanelID&&sourceCell===targetCell){
			return;
		}
		var idToSelect=targetPanelID;
		screenCtrl.panelController.reload.call(screenCtrl.panelController,targetPanel,action,params,idToSelect,handler);
		return true;
	}
});
Ext.define('com.trackplus.screen.ScreenEditController',{
	extend:'com.trackplus.screen.BaseScreenController',
	config: {
		fieldWrapperCls:null,
		screenAction:null,
		screenActionParams:null,
		screenUpdateAction:null,
		tabAction:null,
		tabUpdateAction:null,
		panelAction:null,
		panelUpdateAction:null,
		fieldAction:null,
		fieldUpdateAction:null,
		useConfig:false,
		messageDeletePanel:null,
		messageDeleteTab:null,
		messageDeleteField:null,
		messageCantDeleteScreen:null,
		messageCantDeleteLastTab:null,
		backAction:'cockpit.action'
	},
	showOneTab:false,
	selectedComponent:null,
	clipboard:null,
	lastDropComponent:null,
	clickOnTab:false,clickOnPanel:false,clickOnField:false,
	screenEditView:null,
	screenController:null,
	tabController:null,
	panelController:null,
	fieldController:null,
	actionsController:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		me.screenController=Ext.create('com.trackplus.screen.ScreenController',{
			screenEditController:me,
			action:me.screenAction,
			updateAction:me.screenUpdateAction
		});
		me.tabController=Ext.create('com.trackplus.screen.TabController',{
			screenEditController:me,
			action:me.tabAction,
			updateAction:me.tabUpdateAction
		});
		me.panelController=Ext.create('com.trackplus.screen.PanelController',{
			screenEditController:me,
			action:me.panelAction,
			updateAction:me.panelUpdateAction
		});
		me.fieldController=Ext.create('com.trackplus.screen.FieldController',{
			screenEditController:me,
			action:me.fieldAction,
			updateAction:me.fieldUpdateAction
		});
		me.actionsController=Ext.create('com.trackplus.screen.ScreenActionsController',{
			screenEditController:me,
			useConfig:me.useConfig
		});
		me.callParent();
	},
	afterScreenCreated:function(screenCmp){
		var me=this;
		screenCmp.addListener('render',function(c){
			c.getEl().on('click', function(){
				me.clickOnScreenHandler.call(me,c);
			});
			c.getEl().on('contextmenu', function(e,domEl){
				var result=me.clickOnScreenHandler.call(me,c);
				if(result===0){
					me.showPopup.call(me,e);
				}
			});
		});
	},
	showPopup:function(e,emptyFieldCmp){
		var me=this;
		me.emptyFieldCmp=emptyFieldCmp;
		var contextMenu=me.actionsController.createPopup.call(me.actionsController);
		if(contextMenu){
			contextMenu.showAt(e.getXY());
		}
		e.stopEvent();
	},
	clickOnScreenHandler:function(c){
		var me=this;
		if(me.clickOnField===true){
			me.clickOnField=false;
			return 1;
		}
		if(me.clickOnPanel===true){
			me.clickOnPanel=false;
			return 2;
		}
		if(me.clickOnTab===true){
			me.clickOnTab=false;
			return 3;
		}
		me.clickOnScreen=true;
		me.clickOnComponent.call(me,c);
		return 0;
	},
	clickOnTabHandler:function(c){
		var me=this;
		if(me.clickOnField===true){
			return 1;
		}
		if(me.clickOnPanel===true){
			return 2;
		}
		me.clickOnTab=true;
		me.clickOnComponent.call(me,c);
		return 0;
	},
	afterTabPanelCreated:function(tabPanel){
		var me=this;
		var items=tabPanel.tabBar.items;
		for(var i=0;i<items.getCount();i++){
			var item=items.getAt(i);
			item.addListener('render',function(c){
				c.getEl().addListener('click',me.clickOnTabBar,me,tabPanel);
			});
		}
		items.addListener('add',function(index,o){
			o.addListener('render',function(c){
				o.getEl().addListener('click',me.clickOnTabBar,me,tabPanel);
			});
		});
	},
	clickOnTabBar:function(e,t,tabPanel){
		var me=this;
		me.clickOnTabHandler.call(me,tabPanel.getActiveTab());
	},
	afterTabCreated:function(tabCmp){
		var me=this;
		tabCmp.addCls("designTab");
		tabCmp.myComponentCls="designTab";
		tabCmp.addListener('render',function(c){
			c.getEl().on('click', function(){
				me.clickOnTabHandler.call(me,c);
			});
			c.getEl().on('contextmenu', function(e,domEl){
				var result=me.clickOnTabHandler.call(me,c);
				if(result===0){
					me.showPopup.call(me,e);
				}
			});
		});
		tabCmp.addListener('activate',me.clickOnTabHandler,me);
	},
	clickOnPanelHandler:function(c){
		var me=this;
		if(me.clickOnField===true){
			return 1;
		}
		me.clickOnPanel=true;
		me.clickOnComponent.call(me,c,me);
		return 0;
	},
	afterPanelCreated:function(panelCmp){
		var me=this;
		panelCmp.addListener('render',function(c){
			c.getEl().on('click', function(){
				me.clickOnPanelHandler.call(me,c);
			});
			c.getEl().on('contextmenu', function(e,domEl){
				var result=me.clickOnPanelHandler.call(me,c);
				if(result===0){
					me.showPopup.call(me,e);
				}
			});
			me.panelController.registerDragDrop.call(me.panelController,c);
		});
	},
	clearDragOn:function(){
		var me=this;
		if(me.lastDropComponent){
			var clsToRemove="dragOver";
			if(me.lastDropComponent.myComponentCls){
				clsToRemove=me.lastDropComponent.myComponentCls+"-dragOver";
				me.lastDropComponent.addCls(me.lastDropComponent.myComponentCls);
			}
			me.lastDropComponent.removeCls(clsToRemove);
			me.lastDropComponent=null;
		}
	},
	setDragOver:function(comp){
		var me=this;
		if(me.lastDropComponent){
			me.clearDragOn();
		}
		var clsToAdd="dragOver";
		if(comp.myComponentCls){
			clsToAdd=comp.myComponentCls+"-dragOver";
			comp.removeCls(comp.myComponentCls);
		}
		comp.addCls(clsToAdd);
		me.lastDropComponent=comp;
	},
	clearSelectedComponent:function(){
		var me=this;
		if(me.selectedComponent&&me.selectedComponent.getEl()){
			//clear selecttion
			var clsToRemove="componentSelected";
			if(me.selectedComponent.myComponentCls){
				clsToRemove=me.selectedComponent.myComponentCls+"-selected";
				me.selectedComponent.addCls(me.selectedComponent.myComponentCls);
			}
			me.selectedComponent.removeCls(clsToRemove);
			me.selectedComponent=null;
		}
	},
	setSelectedComponent:function(comp){
		var me=this;
		if(me.selectedComponent){
			me.clearSelectedComponent();
		}
		var clsToAdd="componentSelected";
		if(comp.myComponentCls){
			clsToAdd=comp.myComponentCls+"-selected";
			comp.removeCls(comp.myComponentCls);
		}
		comp.addCls(clsToAdd);
		me.selectedComponent=comp;
		me.refreshActions();
	},
	refreshActions:function(){
		var me=this;
		var model=me.selectedComponent.model;
		if(CWHF.isNull(model)){
			return null;
		}
		var type=model.type;
		if(type==='Field'){
			me.actionsController.setActionConfigEnabled.call(me.actionsController,true);
		}else{
			me.actionsController.setActionConfigEnabled.call(me.actionsController,false);
		}
		if(type==='Screen'){
			me.actionsController.setActionCopyEnabled.call(me.actionsController,false);
			me.actionsController.setActionDeleteEnabled.call(me.actionsController,false);
		}else{
			var actionEnabled=true;
			if(CWHF.isNull(me.tabAction)){
				if(type==='Panel'||type==='Tab'){
					actionEnabled=false;
				}
			}
			me.actionsController.setActionDeleteEnabled.call(me.actionsController,actionEnabled);
			me.actionsController.setActionCopyEnabled.call(me.actionsController,actionEnabled);
		}
		actionPasteEnabled=me.allowPaste()
		me.actionsController.setActionPasteEnabled.call(me.actionsController,actionPasteEnabled);
	},
	clickOnComponent:function(comp){
		var me=this;
		me.setSelectedComponent(comp);
		var compController=me.getComponentController(comp);
		var componentID=comp.model.getId();
		var urlStr=compController.getPropertyLink(componentID);
		if(CWHF.isNull(urlStr)){
			return true;
		}
		me.refreshOutline.call(me,urlStr);
	},
	refreshOutline:function(urlStr,params,handler){
		var me=this;
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			params:params,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				me.screenEditView.propertiesPanel.setSource(jsonData);
				if(handler){
					handler.call(me);
				}
			},
			failure: function(){
			},
			method:'POST'
		});
	},
	getComponentController:function(comp){
		var me=this;
		var model=comp.model;
		if(CWHF.isNull(model)){
			return null;
		}
		var type=model.type;
		if(type==='Tab'){
			return me.tabController;
		}
		if(type==='Panel'){
			return me.panelController;
		}
		if(type==='Field'){
			return me.fieldController;
		}
		if(type==='Screen'){
			return me.screenController;
		}
		return null;
	},
	changeAttribute:function(property,value,oldValue){
		var me=this;
		var componentID;
		if(me.selectedComponent){
			var model=me.selectedComponent.model;
			var cmpController=me.getComponentController.call(me,me.selectedComponent);
			componentID=model.getId();
			var urlStr=cmpController.getUpdateLink(componentID);
			if(CWHF.isNull(urlStr)){
				return true;
			}
			var params={};
			var source=me.screenEditView.propertiesPanel.getSource();
			for(var x in source){
				params[x]=source[x];
			}
			var type=model.type;
			me.refreshOutline(urlStr,params, function(){
				if(type==='Field'){
					var panel=me.selectedComponent.parentView;
					me.panelController.reload(panel);
				}else if(type==='Panel'){
					var panel=me.selectedComponent;
					me.tabController.reload(panel.parentView,null,null,panel.model.id);
				}else{
					var parentView=me.selectedComponent.parentView;
					if(CWHF.isNull(parentView)){
						parentView=me.selectedComponent;
					}
					me.screenController.reload(parentView,null,null,me.selectedComponent.model.id);
					//mpController.reload(me.selectedComponent);
				}
			});
		}
	},
	createField:function(parentView,aFieldWrapperData){
		var me=this;
		if(CWHF.isNull(me.fieldWrapperCls)){
			me.fieldWrapperCls='com.trackplus.screen.FieldEditWrapperView';
		}
		var fieldWrapperCmp=Ext.create(me.fieldWrapperCls,{
			parentView:parentView,
			model:aFieldWrapperData
		});
		fieldWrapperCmp.addListener('render',function(c){
			if(!aFieldWrapperData.empty){
				c.getEl().on('click', function(e){
					me.clickOnField=true;
					me.clickOnComponent.call(me,c);
					e.stopEvent();
					return false;
				});
				c.getEl().on('contextmenu', function(e,domEl){
					me.clickOnField=true;
					me.clickOnComponent.call(me,c);
					me.showPopup.call(me,e);
				});
				var dragSource=me.fieldController.registerDrag.call(me.fieldController,c);
				parentView.dragDropObjects.push(dragSource);
			}else{
				c.getEl().on('contextmenu', function(e,domEl){
					me.clickOnPanel=true;
					me.clickOnComponent.call(me, c.parentView);
					me.showPopup.call(me,e,c);
				});
			}
			var dropTarget=me.fieldController.registerDrop.call(me.fieldController,c);
			parentView.dragDropObjects.push(dropTarget);
		});
		fieldWrapperCmp.colspan=aFieldWrapperData.colSpan;
		fieldWrapperCmp.rowspan=aFieldWrapperData.rowSpan;
		return fieldWrapperCmp;
	},
	getToolbar:function(){
		var me=this;
		return me.actionsController.getToolbar();
	},
	newTab:function(){
		var me=this;
		me.screenController.reload.call(me.screenController,me.screenView,"addTab",me.screenActionParams);
	},
	newPanel:function(){
		var me=this;
		var selectedTab=me.screenEditView.getSelectedTab();
		me.tabController.reload.call(me.tabController,selectedTab,"addPanel");
	},
	cutItem:function(){
		var me=this;
		me.copyItem(function(){
			me.deleteItem(true);
		},me);
	},
	copyItem:function(succesHandler,scope){
		var me=this;
		if(CWHF.isNull(me.selectedComponent)){
			return false;
		}
		var model=me.selectedComponent.model;
		var sourceType=model.type;
		var sourceID=model.getId();
		var copyModel={
			type:sourceType,
			id:sourceID
		};
		me.clipboard=copyModel;
		me.screenController.copy.call(me.screenController,me.screenModel.getId(),sourceType,sourceID,succesHandler,scope);
	},
	pasteItem:function(){
		var me=this;
		if(CWHF.isNull(me.selectedComponent)){
			return false;
		}
		var model=me.selectedComponent.model;
		var targetType=model.type;
		var targetID=model.getId();
		var targetInfo=null;
		if(me.clipboard){
			if(me.allowPaste()){
				var sourceType=me.clipboard.type;
				var sourceID=me.clipboard.id;
				if(me.emptyFieldCmp){
					var fieldModel=me.emptyFieldCmp.model;
					targetInfo=fieldModel.row+";"+fieldModel.col;
				}
				me.screenController.paste.call(me.screenController,me.screenModel.getId(),sourceType,sourceID,targetType,targetID,targetInfo,function(){
					var view=me.selectedComponent;
					var controller=null;
					if(targetType==="Screen"){
						controller=me.screenController;
					}
					if(targetType==="Tab"){
						controller=me.tabController;
					}
					if(targetType==="Panel"){
						controller=me.panelController;
						if(sourceType==="Panel"){
							controller=me.tabController;
							view=me.selectedComponent.parentView;
						}
					}
					if(targetType==="Field"){
						controller=me.panelController;
						view=me.selectedComponent.parentView;
					}
					controller.reload(view);
				},me);
			}
		}
	},
	allowPaste:function(){
		var me=this;
		if(CWHF.isNull(me.selectedComponent)){
			return false;
		}
		var compType=me.selectedComponent.model.type;
		if(me.clipboard){
			var clipboardType=me.clipboard.type;
			return ((compType==='Screen'&&clipboardType==='Tab')||
				(compType==='Tab'&&clipboardType==='Tab')||
				(compType==='Tab'&&clipboardType==='Panel')||
				(compType==='Panel'&&clipboardType==='Panel')||
				(compType==='Panel'&&clipboardType==='Field')||
				(compType==='Field'&&clipboardType==='Field'));
		}
		return false;
	},
	deleteItem:function(noAsk){
		var me=this;
		if(CWHF.isNull(me.selectedComponent)){
			return false;
		}
		var model=me.selectedComponent.model;
		var compType=model.type;
		var idComp=model.getId();
		var cname="";
		var msg;
		var controller;
		if(compType==="Screen"){
			alert(me.messageCantDeleteScreen);
			return -1;
		}
		var params={};
		if(compType==="Tab"){
			/*if(tabsItem1.items.length===1){
				alert(messageCantLastTab);
				return 0;
			}*/
			cname="tab";
			msg= me.messageDeleteTab;
			controller=me.screenController;
			if(me.screenActionParams){
				for(var x in me.screenActionParams){
					params[x]=me.screenActionParams[x];
				}
			}
		}
		if(compType==="Panel"){
			cname="panel";
			msg= me.messageDeletePanel;
			controller=me.tabController;
			//idParent=me.selectedTab;
		}
		if(compType==="Field"){
			cname="field";
			msg=me.messageDeleteField;
			controller=me.panelController;
		}
		var theName=model.name;
		msg=msg.replace("{0}",theName);
		if(CWHF.isNull(noAsk)||CWHF.isNull(noAsk)){
			var r=confirm(msg);
			if (r===false){
				return 0;
			}
		}
		var action="deleteChild";
		var property=cname+"ID";
		params[property]=idComp;
		var parentView=me.selectedComponent.parentView;
		controller.reload(parentView,action,params);
		me.selectedComponent=null;
	},
	isConfigurableItem:function(){
		return false;
	},
	configItem:function(){
	},
	back:function(){
		window.location.href=this.backAction;
	},
	reload:function(){
		borderLayout.setLoading(true);
		location.reload();
	}
});
Ext.define('com.trackplus.screen.ScreenActionsController',{
	extend:'Ext.Base',
	config: {
		screenEditController:null,
		useConfig:false
	},
	actionNewTab:null,
	actionNewPanel:null,
	actionDelete:null,
	actionConfig:null,
	actionCut:null,
	actionCopy:null,
	actionPaste:null,
	actions:null,
	actionConfigEnabled:false,
	actionDeleteEnabled:false,
	actionCopyEnabled:true,
	actionPasteEnabled:false,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	setActionConfigEnabled:function(b){
		var me=this;
		me.actionConfigEnabled=b;
		if(me.actionConfig){
			me.actionConfig.setDisabled(!b);
		}
	},
	setActionDeleteEnabled:function(b){
		var me=this;
		me.actionDeleteEnabled=b;
		if(me.actionDelete){
			me.actionDelete.setDisabled(!b);
		}
	},
	setActionCopyEnabled:function(b){
		var me=this;
		me.actionCopyEnabled=b;
		if(me.actionCut){
			me.actionCut.setDisabled(!b);
		}
		if(me.actionCopy){
			me.actionCopy.setDisabled(!b);
		}
	},
	setActionPasteEnabled:function(b){
		var me=this;
		me.actionPasteEnabled=b;
		if(me.actionPaste){
			me.actionPaste.setDisabled(!b);
		}
	},
	initToolbar:function(){
		var me=this;
		me.actionNewTab=Ext.create('Ext.Action',{
			id:'newTabBtn',
			itemId:'newTabBtnItemID',
			overflowText:getText('admin.customize.form.edit.newTab'),
			tooltip:getText('admin.customize.form.edit.newTab.tooltip'),
			text: getText('admin.customize.form.edit.newTab'),
			iconCls: 'newTab',
			disabled:false,
			handler:function(){
				me.screenEditController.newTab.call(me.screenEditController);
			}
		});
		me.actionNewPanel=Ext.create('Ext.Action',{
			id:'newPanelBtn',
			itemId:'newPanelBtnItemID',
			overflowText:getText('admin.customize.form.edit.newPanel'),
			tooltip:getText('admin.customize.form.edit.newPanel.tooltip'),
			text: getText('admin.customize.form.edit.newPanel'),
			iconCls: 'newPanel',
			disabled:false,
			handler:function(){
				me.screenEditController.newPanel.call(me.screenEditController);
			}
		});
		me.actionCut=Ext.create('Ext.Action',{
			id:'cutBtn',
			itemId:'cutBtnItemID',
			overflowText:getText('common.btn.cut'),
			tooltip:getText('common.btn.cut'),
			text: getText('common.btn.cut'),
			iconCls: 'cut',
			disabled:!me.actionCopyEnabled,
			handler:function(){
				me.screenEditController.cutItem.call(me.screenEditController);
			}
		});
		me.actionCopy=Ext.create('Ext.Action',{
			id:'copyBtn',
			itemId:'copyBtnItemID',
			overflowText:getText('common.btn.copy'),
			tooltip:getText('common.btn.copy'),
			text: getText('common.btn.copy'),
			iconCls: 'copy',
			disabled:!me.actionCopyEnabled,
			handler:function(){
				me.screenEditController.copyItem.call(me.screenEditController);
			}
		});
		me.actionPaste=Ext.create('Ext.Action',{
			id:'pasteBtn',
			itemId:'pasteBtnItemID',
			overflowText:getText('common.btn.paste'),
			tooltip:getText('common.btn.paste'),
			text: getText('common.btn.paste'),
			iconCls: 'paste',
			disabled:!me.actionPasteEnabled,
			handler:function(){
				me.screenEditController.pasteItem.call(me.screenEditController);
			}
		});
		me.actionDelete=Ext.create('Ext.Action',{
			id:'deleteBtn',
			itemId:'deleteBtnItemID',
			overflowText:getText('common.btn.delete'),
			tooltip:getText('common.btn.delete'),
			text: getText('common.btn.delete'),
			iconCls: 'delete',
			disabled:!me.actionDeleteEnabled,
			handler:function(){
				me.screenEditController.deleteItem.call(me.screenEditController);
			}
		});
		me.actionConfig=Ext.create('Ext.Action',{
			id:'configureBtn',
			itemId:'configureBtnItemID',
			overflowText:getText('common.btn.config'),
			tooltip:getText('common.btn.config'),
			text:getText('common.btn.config'),
			iconCls: 'btnConfig',
			disabled:!me.actionConfigEnabled,
			handler:function(){
				me.screenEditController.configItem.call(me.screenEditController);
			}
		});
		me.btnBack=Ext.create('Ext.Action',{
			id:'backBtn',
			itemId:'backBtnItemID',
			overflowText:getText('common.btn.done'),
			tooltip:getText('common.btn.done'),
			text: getText('common.btn.done'),
			iconCls: 'btnBack',
			disabled:false,
			handler:function(){
				me.screenEditController.back.call(me.screenEditController);
			}
		});
		me.actions=[];
		if(me.screenEditController.tabAction){
			me.actions.push(me.actionNewTab);
		}
		if(me.screenEditController.tabAction){
			me.actions.push(me.actionNewPanel);
		}
		me.actions.push(me.actionCut);
		me.actions.push(me.actionCopy);
		me.actions.push(me.actionPaste);
		me.actions.push(me.actionDelete);
		if(me.useConfig){
			me.actions.push(me.actionConfig);
		}
		me.actions.push(me.btnBack);
	},
	getToolbar:function(){
		var me=this;
		if(CWHF.isNull(me.actions)){
			me.initToolbar();
		}
		return me.actions;
	},
	createPopup:function(){
		var me=this;
		var contextMenu = new Ext.menu.Menu({
			items: []
		});
		var actions=[];
		if(me.screenEditController.tabAction){
			me.actions.push(me.actionNewTab);
		}
		if(me.screenEditController.tabAction){
			me.actions.push(me.actionNewPanel);
		}
		if(me.actionCopyEnabled===true){
			actions.push(me.actionCut);
		}
		if(me.actionCopyEnabled===true){
			actions.push(me.actionCopy);
		}
		if(me.actionPasteEnabled===true){
			actions.push(me.actionPaste);
		}
		if(me.actionDeleteEnabled===true){
			actions.push(me.actionDelete);
		}
		if(me.useConfig===true&&me.actionConfigEnabled===true){
			actions.push(me.actionConfig);
		}
		if(actions.length===0){
			return null;
		}
		for(var i=0;i<actions.length;i++){
			var action=actions[i];
			var contextMenuItemCfg = {
				text:action.getText(),
				iconCls:action.getIconCls()+"16",
				scope:action,
				tooltip:action.tooltip,
				handler:action.execute,
				itemId:action.itemId
			};
			contextMenu.add(contextMenuItemCfg);
		}
		return contextMenu;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.screen.ItemEditPanelView',{
	extend:'com.trackplus.screen.PanelView',
	getPanelConfig:function(model,index,length){
		var me=this;
		var cls="screenDesignPanel";
		var margin='0 0 5 0';
		me.myComponentCls=cls;
		return {
			cls:cls,
			margin:margin,
			border:true,
			layout: {
				type: 'table',
				columns: model.colsNo,
				tableAttrs: {
					style: {
						minWidth: '100%'
					}
				},
				trAttrs:{
					'class':'screenField-tr',
					style:{
						'vertical-align':'top'
					}
				}
			},
			defaults: {frame:false, border: false}
		};
	}
});
Ext.define('com.trackplus.layout.ItemScreenEditLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	screenModel:null,
	screenEditFacade:null,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		var data=me.initData;
		var backAction;
		if(data.backAction){
			backAction=data.backAction;
		}else{
			backAction='admin.action?selectedNodeID=customForms&sectionSelected=customizationSection';
		}
		me.screenModel=com.trackplus.screen.createScreenModel(me.initData.screen);
		me.screenEditFacade= Ext.create('com.trackplus.screen.ScreenEditFacade',{
			screenModel:me.screenModel,
			refreshTabUrl:'tab!reload.action',
			controllerCls:'com.trackplus.screen.ScreenEditController',
			urlFieldList:'screenTree!list.action',
			fieldsAsTree:true,
			titleFieldList:getText("admin.customize.form.edit.lbl.fields"),
			useConfig:false,
			panelViewCls:'com.trackplus.screen.ItemEditPanelView',
			screenAction:'screenEdit',
			screenUpdateAction:'updateScreenProperty',
			tabAction:'tab',
			tabUpdateAction:'updateTabProperty',
			panelAction:'panel',
			panelUpdateAction:'updatePanelProperty',
			fieldAction:'field',
			fieldUpdateAction:'updateFieldProperty',
			messageDeletePanel:getText('admin.customize.form.edit.question.deletePanel'),
			messageDeleteTab:getText('admin.customize.form.edit.question.deleteTab'),
			messageDeleteField:getText('admin.customize.form.edit.question.deleteField'),
			messageCantDeleteScreen:getText('admin.customize.form.edit.message.cantDeleteScreen'),
			messageCantDeleteLastTab:getText('admin.customize.form.edit.message.cantDeleteLastTab'),
			backAction:backAction
		});
		me.onReady(function(){
			var toolbar=me.screenEditFacade.getToolbar.call(me.screenEditFacade);
			me.borderLayoutController.setActiveToolbarActionList(toolbar);
		});
	},
	createCenterPanel:function(){
		var me=this;
		return me.screenEditFacade.createScreenEditViewComponent.call(me.screenEditFacade);
	}
});
/*field types*/
Ext.define('com.aurel.trackplus.field.design.TypeRenderer',{
	ALIGN_TOP: 0,
	ALIGN_BOTTOM:1,
	ALIGN_MIDDLE: 2,
	ALIGN_LEFT:3,
	ALIGN_RIGHT:4,
	ALIGN_CENTER:5,
	ALIGN_TOP_STR: 'top',
	ALIGN_BOTTOM_STR:'bottom',
	ALIGN_MIDDLE_STR: 'middle',
	ALIGN_LEFT_STR:'left',
	ALIGN_RIGHT_STR:'right',
	ALIGN_CENTER_STR:'center',
	render:function(model){
		return Ext.create('Ext.form.Label',{});
	},
	getAlignStr:function(align){
		var me=this;
		var align=null;
		switch (align) {
			case me.ALIGN_TOP:
				align=me.ALIGN_TOP_STR;
				break;
			case me.ALIGN_BOTTOM:
				align=me.ALIGN_BOTTOM_STR;
				break;
			case me.ALIGN_MIDDLE:
				align=me.ALIGN_MIDDLE_STR;
				break;
			case me.ALIGN_LEFT:
				align=me.ALIGN_LEFT_STR;
				break;
			case me.ALIGN_RIGHT:
				align=me.ALIGN_RIGHT_STR;
				break;
			case me.ALIGN_CENTER:
				align=me.ALIGN_CENTER_STR;
				break;
		}
		return align;
	}
});
Ext.define('com.aurel.trackplus.field.design.LabelTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		var value='abc';
		if(model.hideLabel===true){
			value="abc("+model.label+")";
		}
		return  Ext.create('Ext.form.field.Display',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			value:value,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.TextFieldTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			editable:false
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.TextAreaTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			editable:false
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.SynopsisTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Text',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			editable:false,
			width:500
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.DateTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Picker',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			triggerCls : Ext.baseCSSPrefix + 'form-date-trigger',
			editable:false,
			initTrigger:function(){
			}
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.CheckboxTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Checkbox',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			readOnly:true
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.NumberTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.Number',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			editable:false,
			initTrigger:function(){
			}
		});
	}
});
//
Ext.define('com.aurel.trackplus.field.design.HtmlTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		return Ext.create('Ext.form.field.HtmlEditor',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			editable:false,
			readOnly:true,
			height:100,
			style:{
				width: '100%',
				marginBottom:'5px'
			}
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.SelectTypeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	render:function(model){
		var label=model.label;
		var cmb=Ext.create('Ext.form.field.Picker',{
			fieldLabel: label,
			hideLabel :model.hideLabel,
			editable:false,
			labelAlign:model.labelHAlign,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			triggerCls: Ext.baseCSSPrefix + 'form-arrow-trigger',
			initTrigger:function(){
			}
		});
		return cmb;
	}
});
Ext.define('com.aurel.trackplus.field.design.CompositeRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	config:{
		parts:[]
	},
	render:function(model){
		var me=this;
		var items=new Array();
		var modelPart=new Object();
		for(var x in model){
			modelPart[x]=model[x];
		}
		modelPart['hideLabel']=true;
		for(var i=0;i<me.parts.length;i++){
			var partRenderer=Ext.create(me.parts[i].extClassName,{});
			items.push(partRenderer.render(modelPart));
		}
		return Ext.create('Ext.form.FieldContainer',{
			combineErrors: true,
			fieldLabel: model.label,
			labelAlign:model.labelHAlign,
			hideLabel :model.hideLabel,
			cls :'labelVerticalAlign-'+model.labelVAlign+
				' valueVerticalAlign-'+model.valueVAlign+' valueAlign-'+model.valueHAlign,
			labelStyle:{overflow:'hidden'},
			layout:{
				type:'column'
			},
			defaults: {
				hideLabel: true,
				margin:'0 0 0 5'
			},
			style:{
				width: '100%'
			},
			items :items
		});
	}
});
Ext.define('com.aurel.trackplus.field.design.SelectParentChildRenderer',{
	extend:'com.aurel.trackplus.field.design.CompositeRenderer',
	parts:[
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'},
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'}
	]
});
Ext.define('com.aurel.trackplus.field.design.SelectParentChildrenRenderer',{
	extend:'com.aurel.trackplus.field.design.TypeRenderer',
	parts:[
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'},
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'},
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'}
	]
});
Ext.define('com.aurel.trackplus.field.design.SelectParentChildGrandchildRenderer',{
	extend:'com.aurel.trackplus.field.design.CompositeRenderer',
	parts:[
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'},
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'},
		{extClassName:'com.aurel.trackplus.field.design.SelectTypeRenderer'}
	]
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.CardScreenEditLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	screenModel:null,
	screenEditFacade:null,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		var data=me.initData;
		var backAction;
		if(data.backAction){
			backAction=data.backAction;
		}else{
			backAction='admin.action?selectedNodeID=customForms&sectionSelected=customizationSection';
		}
		me.screenModel=com.trackplus.screen.createScreenModel(me.initData.screen);
		me.screenEditFacade= Ext.create('com.trackplus.screen.ScreenEditFacade',{
			screenModel:me.screenModel,
			showOneTab:true,
			refreshTabUrl:'tab!reload.action',
			controllerCls:'com.trackplus.screen.ScreenEditController',
			urlFieldList:'screenTree!listExtraFields.action',
			fieldsAsTree:true,
			titleFieldList:getText("admin.customize.form.edit.lbl.fields"),
			useConfig:false,
			panelViewCls:'com.trackplus.screen.ItemEditPanelView',
			screenAction:null,
			screenUpdateAction:null,
			tabAction:null,
			tabUpdateAction:null,
			panelAction:'cardPanel',
			panelUpdateAction:'updateCardPanelProperty',
			fieldAction:'cardField',
			fieldUpdateAction:'updateCardFieldProperty',
			messageDeletePanel:getText('admin.customize.form.edit.question.deletePanel'),
			messageDeleteTab:getText('admin.customize.form.edit.question.deleteTab'),
			messageDeleteField:getText('admin.customize.form.edit.question.deleteField'),
			messageCantDeleteScreen:getText('admin.customize.form.edit.message.cantDeleteScreen'),
			messageCantDeleteLastTab:getText('admin.customize.form.edit.message.cantDeleteLastTab'),
			backAction:backAction
		});
		me.onReady(function(){
			var toolbar=me.screenEditFacade.getToolbar.call(me.screenEditFacade);
			me.borderLayoutController.setActiveToolbarActionList(toolbar);
		});
	},
	createCenterPanel:function(){
		var me=this;
		return me.screenEditFacade.createScreenEditViewComponent.call(me.screenEditFacade);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.item.PrintItemAction',{
	extend:'com.trackplus.item.ItemAction',
	config:{
	},
	initData:null,
	constructor : function(config) {
		var me=this;
		me.callParent(arguments);
		me.centerPanel= Ext.create('Ext.panel.Panel',{
			layout:'border',
			margin:'0 0 0 0',
			border:false,
			bodyBorder  :false,
			cls:'printItem',
			items:me.createChildren()
		});
	},
	reExecute:function(){
		var me=this;
		var workItemID=me.initData.workItemID;
		window.location.href="printItem.action?workItemID="+workItemID;
	},
	execute:function(data){
		var me=this;
		me.initData=data;
		me.loadSuccess.call(me,data);
	},
	reload:function(item){
		var me=this;
		me.reExecute();
	},
	isVisibleAction:function(toolbarItem){
		var id=toolbarItem.id;
		if(id===com.trackplus.item.ToolbarItem.NAVIGATION_NEXT||
				id===com.trackplus.item.ToolbarItem.NAVIGATION_PREV){
			return false;
		}
		return true;
	},
	createToolbarAction:function(toolbarItem){
		var me=this;
		return {
			overflowText:getText(toolbarItem.labelKey),
			tooltip:getText(toolbarItem.tooltipKey),
			iconCls: toolbarItem.cssClass+'16',
			disabled:toolbarItem.condition===false,
			text:getText(toolbarItem.labelKey),
			handler:function(btn){
				me.executeToolbarAction.call(me,toolbarItem);
			}
		};
	},
	updateTitle:function(data){
	},
	saveSuccess:function(form, action){
		var me=this;
		if(me.successHandler){
			me.successHandler.call(me.scope?me.scope:me,action.result.data,me.successExtra);
		}
	},
	saveFailure:function(form, action){
		//me.callParent(arguments);
	},
	executeItemAction:function(jsonData){
		var me=this;
		var actionID=jsonData.actionID;
		var parentID=jsonData.parentID;
		var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',{
			workItemID:me.workItemID,
			actionID:actionID,
			parentID:parentID,
			successHandler:me.successHandler,
			scope:me,
			modal:true
		});
		itemAction.execute.call(itemAction);
	},
	clickOnChild:function(workItemID,extraAction){
		var me=this;
		me.clickOnExtraItem(workItemID,extraAction);
	},
	clickOnLink:function(workItemID,extraAction){
		var me=this;
		me.clickOnExtraItem(workItemID,extraAction);
	},
	clickOnParent:function(parentID,extraAction){
		var me=this;
		me.clickOnExtraItem(parentID,extraAction);
	},
	clickOnExtraItem:function(itemID,extraAction){
		var me=this;
		var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',{
			workItemID:itemID,
			actionID:-2,//printItem
			successHandler:extraAction?extraAction.refreshChildren:me.refreshChildren,
			scope:extraAction?extraAction:me,
			modal:false
		});
		itemAction.execute.call(itemAction);
		itemAction.addListener('clickOnChild',me.clickOnChild,me,itemAction);
		itemAction.addListener('clickOnLink',me.clickOnLink,me,itemAction);
		itemAction.addListener('clickOnParent',me.clickOnParent,me,itemAction);
	}
});
Ext.define('com.trackplus.layout.PrintItemLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		var data=me.initData;
		if(data.workItemID){
			me.printItemAction=Ext.create('com.trackplus.item.PrintItemAction',{
				workItemID:data.workItemID,
				successHandler:me.successHandler,
				actionID:-2,//PRINT
				scope:me
			});
			me.onReady(function(){
				var data=me.initData;
				me.printItemAction.execute.call(me.printItemAction,data);
			});
		}
	},
	createCenterPanel:function(){
		var me=this;
		if(CWHF.isNull(me.initData.workItemID)){
			return Ext.create('Ext.Component',{
				cls:'errorDiv ulist',
				html:'<ul><li>'+me.initData.error+'</li></ul>'
			});
		}else{
			return me.printItemAction.centerPanel;
		}
	},
	successHandler:function(data){
		//var newWorkItemID=data.workItemID;
		var me=this;
		var workItemID=me.initData.workItemID;
		window.location.href="printItem.action?workItemID="+workItemID;
	},
	reload:function(){
		var me=this;
		var workItemID=me.initData.workItemID;
		window.location.href="printItem.action?workItemID="+workItemID;
	}
});

/**
 * A control that allows selection of multiple items in a list.
 */
Ext.define('Ext.ux.form.MultiSelect', {
    extend: 'Ext.form.FieldContainer',
    mixins: [
        'Ext.util.StoreHolder',
        'Ext.form.field.Field'
    ],
    alternateClassName: 'Ext.ux.Multiselect',
    alias: ['widget.multiselectfield', 'widget.multiselect'],
    requires: ['Ext.panel.Panel', 'Ext.view.BoundList', 'Ext.layout.container.Fit'],
    uses: ['Ext.view.DragZone', 'Ext.view.DropZone'],
    layout: 'anchor',
    /**
     * @cfg {String} [dragGroup=""] The ddgroup name for the MultiSelect DragZone.
     */
    /**
     * @cfg {String} [dropGroup=""] The ddgroup name for the MultiSelect DropZone.
     */
    /**
     * @cfg {String} [title=""] A title for the underlying panel.
     */
    /**
     * @cfg {Boolean} [ddReorder=false] Whether the items in the MultiSelect list are drag/drop reorderable.
     */
    ddReorder: false,
    /**
     * @cfg {Object/Array} tbar An optional toolbar to be inserted at the top of the control's selection list.
     * This can be a {@link Ext.toolbar.Toolbar} object, a toolbar config, or an array of buttons/button configs
     * to be added to the toolbar. See {@link Ext.panel.Panel#tbar}.
     */
    /**
     * @cfg {String} [appendOnly=false] `true` if the list should only allow append drops when drag/drop is enabled.
     * This is useful for lists which are sorted.
     */
    appendOnly: false,
    /**
     * @cfg {String} [displayField="text"] Name of the desired display field in the dataset.
     */
    displayField: 'text',
    /**
     * @cfg {String} [valueField="text"] Name of the desired value field in the dataset.
     */
    /**
     * @cfg {Boolean} [allowBlank=true] `false` to require at least one item in the list to be selected, `true` to allow no
     * selection.
     */
    allowBlank: true,
    /**
     * @cfg {Number} [minSelections=0] Minimum number of selections allowed.
     */
    minSelections: 0,
    /**
     * @cfg {Number} [maxSelections=Number.MAX_VALUE] Maximum number of selections allowed.
     */
    maxSelections: Number.MAX_VALUE,
    /**
     * @cfg {String} [blankText="This field is required"] Default text displayed when the control contains no items.
     */
    blankText: 'This field is required',
    /**
     * @cfg {String} [minSelectionsText="Minimum {0}item(s) required"] 
     * Validation message displayed when {@link #minSelections} is not met. 
     * The {0} token will be replaced by the value of {@link #minSelections}.
     */
    minSelectionsText: 'Minimum {0} item(s) required',
    /**
     * @cfg {String} [maxSelectionsText="Maximum {0}item(s) allowed"] 
     * Validation message displayed when {@link #maxSelections} is not met
     * The {0} token will be replaced by the value of {@link #maxSelections}.
     */
    maxSelectionsText: 'Maximum {0} item(s) required',
    /**
     * @cfg {String} [delimiter=","] The string used to delimit the selected values when {@link #getSubmitValue submitting}
     * the field as part of a form. If you wish to have the selected values submitted as separate
     * parameters rather than a single delimited parameter, set this to `null`.
     */
    delimiter: ',',
    /**
     * @cfg {String} [dragText="{0} Item{1}"] The text to show while dragging items.
     * {0} will be replaced by the number of items. {1} will be replaced by the plural
     * form if there is more than 1 item.
     */
    dragText: '{0} Item{1}',
    /**
     * @cfg {Ext.data.Store/Array} store The data source to which this MultiSelect is bound (defaults to `undefined`).
     * Acceptable values for this property are:
     * <div class="mdetail-params"><ul>
     * <li><b>any {@link Ext.data.Store Store} subclass</b></li>
     * <li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally.
     * <div class="mdetail-params"><ul>
     * <li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">
     * A 1-dimensional array will automatically be expanded (each array item will be the combo
     * {@link #valueField value} and {@link #displayField text})</div></li>
     * <li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">
     * For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
     * {@link #valueField value}, while the value at index 1 is assumed to be the combo {@link #displayField text}.
     * </div></li></ul></div></li></ul></div>
     */
    ignoreSelectChange: 0,
    /**
     * @cfg {Object} listConfig
     * An optional set of configuration properties that will be passed to the {@link Ext.view.BoundList}'s constructor.
     * Any configuration that is valid for BoundList can be included.
     */
    /**
     * @cfg {Number} [pageSize=10] The number of items to advance on pageUp and pageDown
     */
    pageSize: 10,
    initComponent: function(){
        var me = this;
        me.items = me.setupItems();
        me.bindStore(me.store, true);
        if (me.store.autoCreated) {
            me.valueField = me.displayField = 'field1';
            if (!me.store.expanded) {
                me.displayField = 'field2';
            }
        }
        if (!Ext.isDefined(me.valueField)) {
            me.valueField = me.displayField;
        }
        me.callParent();
        me.initField();
    },
    setupItems: function() {
        var me = this;
        me.boundList = new Ext.view.BoundList(Ext.apply({
            anchor: 'none 100%',
            border: 1,
            multiSelect: true,
            store: me.store,
            displayField: me.displayField,
            disabled: me.disabled,
            tabIndex: 0,
            navigationModel: {
                type: 'default'
            }
        }, me.listConfig));
        me.boundList.getNavigationModel().addKeyBindings({
            pageUp: me.onKeyPageUp,
            pageDown: me.onKeyPageDown,
            scope: me
        });
        me.boundList.getSelectionModel().on('selectionchange', me.onSelectChange, me);
        // Boundlist expects a reference to its pickerField for when an item is selected (see Boundlist#onItemClick).
        me.boundList.pickerField = me;
        // Only need to wrap the BoundList in a Panel if we have a title.
        if (!me.title) {
            return me.boundList;
        }
        // Wrap to add a title
        me.boundList.border = false;
        return {
            xtype: 'panel',
            isAriaRegion: false,
            border: true,
            anchor: 'none 100%',
            layout: 'anchor',
            title: me.title,
            tbar: me.tbar,
            items: me.boundList
        };
    },
    onSelectChange: function(selModel, selections){
        if (!this.ignoreSelectChange) {
            this.setValue(selections);
        }    
    },
    getSelected: function(){
        return this.boundList.getSelectionModel().getSelection();
    },
    // compare array values
    isEqual: function(v1, v2) {
        var fromArray = Ext.Array.from,
            i = 0, 
            len;
        v1 = fromArray(v1);
        v2 = fromArray(v2);
        len = v1.length;
        if (len !== v2.length) {
            return false;
        }
        for(; i < len; i++) {
            if (v2[i] !== v1[i]) {
                return false;
            }
        }
        return true;
    },
    afterRender: function(){
        var me = this,
            boundList = me.boundList,
            records, panel;
        me.callParent();
        if (me.selectOnRender) {
            records = me.getRecordsForValue(me.value);
            if (records.length) {
                ++me.ignoreSelectChange;
                me.boundList.getSelectionModel().select(records);
                --me.ignoreSelectChange;
            }
            delete me.toSelect;
        }    
        if (me.ddReorder && !me.dragGroup && !me.dropGroup){
            me.dragGroup = me.dropGroup = 'MultiselectDD-' + Ext.id();
        }
        if (me.draggable || me.dragGroup){
            me.dragZone = Ext.create('Ext.view.DragZone', {
                view: me.boundList,
                ddGroup: me.dragGroup,
                dragText: me.dragText
            });
        }
        if (me.droppable || me.dropGroup){
            me.dropZone = Ext.create('Ext.view.DropZone', {
                view: me.boundList,
                ddGroup: me.dropGroup,
                handleNodeDrop: function(data, dropRecord, position) {
                    var view = this.view,
                        store = view.getStore(),
                        records = data.records,
                        index;
                    // remove the Models from the source Store
                    data.view.store.remove(records);
                    index = store.indexOf(dropRecord);
                    if (position === 'after') {
                        index++;
                    }
                    store.insert(index, records);
                    view.getSelectionModel().select(records);
                    me.fireEvent('drop', me, records);
                }
            });
        }
        panel = me.down('panel');
        if (panel && boundList) {
            boundList.ariaEl.dom.setAttribute('aria-labelledby', panel.header.id + '-title-textEl');
        }
    },
    onKeyPageUp: function(e) {
        var me = this,
            pageSize = me.pageSize,
            boundList = me.boundList,
            nm = boundList.getNavigationModel(),
            oldIdx, newIdx;
        oldIdx = nm.recordIndex;
        // Unlike up arrow, pgUp does not wrap but goes to the first item
        newIdx = oldIdx > pageSize ? oldIdx - pageSize : 0;
        nm.setPosition(newIdx, e);
    },
    onKeyPageDown: function(e) {
        var me = this,
            pageSize = me.pageSize,
            boundList = me.boundList,
            nm = boundList.getNavigationModel(),
            count, oldIdx, newIdx;
        count = boundList.getStore().getCount();
        oldIdx = nm.recordIndex;
        // Unlike down arrow, pgDown does not wrap but goes to the last item
        newIdx = oldIdx < (count - pageSize) ? oldIdx + pageSize : count - 1;
        nm.setPosition(newIdx, e);
    },
    isValid : function() {
        var me = this,
            disabled = me.disabled,
            validate = me.forceValidation || !disabled;
        return validate ? me.validateValue(me.value) : disabled;
    },
    validateValue: function(value) {
        var me = this,
            errors = me.getErrors(value),
            isValid = Ext.isEmpty(errors);
        if (!me.preventMark) {
            if (isValid) {
                me.clearInvalid();
            } else {
                me.markInvalid(errors);
            }
        }
        return isValid;
    },
    markInvalid : function(errors) {
        // Save the message and fire the 'invalid' event
        var me = this,
            oldMsg = me.getActiveError();
        me.setActiveErrors(Ext.Array.from(errors));
        if (oldMsg !== me.getActiveError()) {
            me.updateLayout();
        }
    },
    /**
     * Clear any invalid styles/messages for this field.
     *
     * __Note:__ this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return `true`
     * if the value does not _pass_ validation. So simply clearing a field's errors will not necessarily allow
     * submission of forms submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
     */
    clearInvalid : function() {
        // Clear the message and fire the 'valid' event
        var me = this,
            hadError = me.hasActiveError();
        me.unsetActiveError();
        if (hadError) {
            me.updateLayout();
        }
    },
    getSubmitData: function() {
        var me = this,
            data = null,
            val;
        if (!me.disabled && me.submitValue && !me.isFileUpload()) {
            val = me.getSubmitValue();
            if (val !== null) {
                data = {};
                data[me.getName()] = val;
            }
        }
        return data;
    },
    /**
     * Returns the value that would be included in a standard form submit for this field.
     *
     * @return {String} The value to be submitted, or `null`.
     */
    getSubmitValue: function() {
        var me = this,
            delimiter = me.delimiter,
            val = me.getValue();
        return Ext.isString(delimiter) ? val.join(delimiter) : val;
    },
    getValue: function(){
        return this.value || [];
    },
    getRecordsForValue: function(value){
        var me = this,
            records = [],
            all = me.store.getRange(),
            valueField = me.valueField,
            i = 0,
            allLen = all.length,
            rec,
            j,
            valueLen;
        for (valueLen = value.length; i < valueLen; ++i) {
            for (j = 0; j < allLen; ++j) {
                rec = all[j];   
                if (rec.get(valueField) == value[i]) {
                    records.push(rec);
                }
            }    
        }
        return records;
    },
    setupValue: function(value){
        var delimiter = this.delimiter,
            valueField = this.valueField,
            i = 0,
            out,
            len,
            item;
        if (Ext.isDefined(value)) {
            if (delimiter && Ext.isString(value)) {
                value = value.split(delimiter);
            } else if (!Ext.isArray(value)) {
                value = [value];
            }
            for (len = value.length; i < len; ++i) {
                item = value[i];
                if (item && item.isModel) {
                    value[i] = item.get(valueField);
                }
            }
            out = Ext.Array.unique(value);
        } else {
            out = [];
        }
        return out;
    },
    setValue: function(value){
        var me = this,
            selModel = me.boundList.getSelectionModel(),
            store = me.store;
        // Store not loaded yet - we cannot set the value
        if (!store.getCount()) {
            store.on({
                load: Ext.Function.bind(me.setValue, me, [value]),
                single: true
            });
            return;
        }
        value = me.setupValue(value);
        me.mixins.field.setValue.call(me, value);
        if (me.rendered) {
            ++me.ignoreSelectChange;
            selModel.deselectAll();
            if (value.length) {
                selModel.select(me.getRecordsForValue(value));
            }
            --me.ignoreSelectChange;
        } else {
            me.selectOnRender = true;
        }
    },
    clearValue: function(){
        this.setValue([]);    
    },
    onEnable: function(){
        var list = this.boundList;
        this.callParent();
        if (list) {
            list.enable();
        }
    },
    onDisable: function(){
        var list = this.boundList;
        this.callParent();
        if (list) {
            list.disable();
        }
    },
    getErrors : function(value) {
        var me = this,
            format = Ext.String.format,
            errors = [],
            numSelected;
        value = Ext.Array.from(value || me.getValue());
        numSelected = value.length;
        if (!me.allowBlank && numSelected < 1) {
            errors.push(me.blankText);
        }
        if (numSelected < me.minSelections) {
            errors.push(format(me.minSelectionsText, me.minSelections));
        }
        if (numSelected > me.maxSelections) {
            errors.push(format(me.maxSelectionsText, me.maxSelections));
        }
        return errors;
    },
    onDestroy: function(){
        var me = this;
        me.bindStore(null);
        Ext.destroy(me.dragZone, me.dropZone, me.keyNav);
        me.callParent();
    },
    onBindStore: function(store){
        var boundList = this.boundList;
        if (boundList) {
            boundList.bindStore(store);
        }
    }
});

/**
 * @deprecated
 * Ext.ux.RowExpander has been promoted to the core framework. Use
 * {@link Ext.grid.plugin.RowExpander} instead.  Ext.ux.RowExpander is now just an empty
 * stub that extends Ext.grid.plugin.RowExpander for backward compatibility reasons.
 */
Ext.define('Ext.ux.RowExpander', {
    extend: 'Ext.grid.plugin.RowExpander'
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.admin.Filter = function() {
};
com.trackplus.admin.Filter.tqlFilterWindowWidth = 500;
com.trackplus.admin.Filter.tqlFilterWindowHeight = 400;
com.trackplus.admin.Filter.issueFilterWindowWidth = 910;
com.trackplus.admin.Filter.issueFilterWindowHeight = 500;
com.trackplus.admin.Filter.notifyFilterWindowWidth = 900;
com.trackplus.admin.Filter.notifyFilterWindowHeight = 500;
com.trackplus.admin.Filter.nameWidth = 300;
com.trackplus.admin.Filter.nameLabelWidth = 80;
com.trackplus.admin.Filter.menuLabelWidth = 100;
com.trackplus.admin.Filter.styleFieldLabelWidth = 100;
com.trackplus.admin.Filter.styleFieldWidth = 200;
com.trackplus.admin.Filter.viewLabelWidth = 100;
com.trackplus.admin.Filter.viewFieldWidth = 250;
//the number of  upper selects columns
com.trackplus.admin.Filter.upperSelectColumns = 4;
//the width and height of the other multiple selects
com.trackplus.admin.Filter.multiSelectWidth = 210;
//com.trackplus.admin.Filter.multiSelectHeight = 120;
com.trackplus.admin.Filter.multipleTreePickerWidth = 500;
com.trackplus.admin.Filter.moreControlWidth = 500;
com.trackplus.admin.Filter.moreControlLabelWidth = 150;
com.trackplus.admin.Filter.matcherComboWidth = 150;
com.trackplus.admin.Filter.fieldNameComboWidth = 150;
com.trackplus.admin.Filter.operationComboWidth = 80;
com.trackplus.admin.Filter.parenthesisComboWidth = 50;
com.trackplus.admin.Filter.fieldMomentComboWidth = 70;
/**
 * Executes the last executed filter by refreshing th entire page
 */
com.trackplus.admin.Filter.executeInstantFilter = function(refreshParameters, result) {
	window.location.href = com.trackplus.TrackplusConfig.contextPath + "/itemNavigator.action";
};
/**
* Prepare adding/editing a tql filter
*/
com.trackplus.admin.Filter.getTQLFilterItems = function(modifiable) {
	return [CWHF.createHiddenField("modifiable", {value:modifiable}),
			CWHF.createTextField("common.lbl.name", "label",
				{disabled:!modifiable,
				allowBlank:false,
				width:com.trackplus.admin.Filter.nameWidth,
				labelWidth:com.trackplus.admin.Filter.nameLabelWidth,
				msgTarget: "qtip"}),
			CWHF.createCombo("admin.customize.queryFilter.lbl.filterType",
				"filterSubType", {disabled:!modifiable, labelWidth:com.trackplus.admin.Filter.styleFieldLabelWidth, itemId:"filterSubType"}),
			CWHF.createCheckbox("admin.customize.queryFilter.lbl.menu",
						"includeInMenu", {itemId:'includeInMenu', labelWidth:com.trackplus.admin.Filter.menuLabelWidth}),
			CWHF.createCombo("admin.customize.queryFilter.lbl.styleField",
				"styleField", {labelWidth: com.trackplus.admin.Filter.styleFieldLabelWidth, itemId:"styleField"}),
			CWHF.createCombo(
					"admin.customize.queryFilter.lbl.view",
					"viewID",
					{disabled:!modifiable,
					labelWidth:com.trackplus.admin.Filter.viewLabelWidth,
					width: com.trackplus.admin.Filter.viewFieldWidth,
					data:data["viewList"],
					value: data["viewID"]}),
			CWHF.createTextAreaField("admin.customize.queryFilter.lbl.filterExpression", "tqlExpression",
				{disabled:!modifiable,
				allowBlank:false,
				labelWidth:com.trackplus.admin.Filter.styleFieldLabelWidth,
				height:200})];
};
/**
* Prepare adding/editing a tree filter
*/
com.trackplus.admin.Filter.getTreeFilterItems = function(modifiable, instant) {
	var mainComponents = [CWHF.createHiddenField("filterSubType", {value:1}),
				CWHF.createHiddenField("modifiable", {value:modifiable})];
	var generalItems = [];
	if (!instant) {
		generalItems = [CWHF.createTextField("common.lbl.name", "label",
						{disabled:!modifiable,
						allowBlank:false,
						labelWidth:com.trackplus.admin.Filter.nameLabelWidth,
						width:com.trackplus.admin.Filter.nameWidth,
						msgTarget: "qtip"}),
					CWHF.createCheckbox("admin.customize.queryFilter.lbl.menu",
							"includeInMenu", {itemId:'includeInMenu', labelWidth:com.trackplus.admin.Filter.menuLabelWidth, width: 100})];
		mainComponents.push(Ext.create("Ext.panel.Panel", {
			itemId: "generalFilterFields",
			defaults:	{
				labelStyle:"overflow: hidden;",
				margin:"0 0 5 0"
			},
			layout: {
				type:"table",
				columns:4
			},
			border:false,
			items: generalItems}));
	}
	return mainComponents;
};
/**
* Prepare adding/editing tree filter parameters
*/
com.trackplus.admin.Filter.getTreeFilterParameterItems = function() {
	return [];
};
/**
 * Prepare adding/editing a notification filter
 */
com.trackplus.admin.Filter.getNotifyFilterItems = function(modifiable) {
	return [CWHF.createTextField("common.lbl.name", "label",
			{disabled:!modifiable,
		allowBlank:false,
		labelWidth:com.trackplus.admin.Filter.nameLabelWidth,
		width:com.trackplus.admin.Filter.nameWidth,
		msgTarget: "qtip"}),
	{	xtype:'hidden',
		name: 'filterSubType',
		value: 2
	},
	Ext.create('Ext.panel.Panel', {
		itemId: 'fieldExpressionsInTree',
		border: false
	})];
};
/**
 * Add map representing the order of the "in tree" field expressions to the submitUrlParams object
 */
com.trackplus.admin.Filter.preSubmitProcess = function(submitUrlParams, fieldExpressionsInTreePanel) {
	if (fieldExpressionsInTreePanel && fieldExpressionsInTreePanel.items.getCount()>1) {
		if (CWHF.isNull(submitUrlParams)) {
			submitUrlParams = new Object();
		}
	    fieldExpressionsInTreePanel.items.each(function(fieldExpressionInTreePanel, index, length) {
	         if (index>0) {
	             submitUrlParams['fieldExpressionOrderMap[' + index + ']']=fieldExpressionInTreePanel.index;
	         }
	    });
	}
	return submitUrlParams;
};
/**
 * Add map representing the order of the "in tree" field expressions to the submitUrlParams object
 */
com.trackplus.admin.Filter.preSubmitProcessNotifyFilter = function(submitUrlParams, panel) {
	var fieldExpressionsInTreePanel = panel.getComponent("fieldExpressionsInTree");
	return com.trackplus.admin.Filter.preSubmitProcess(submitUrlParams, fieldExpressionsInTreePanel);
};
/**
 * Add map representing the order of the "in tree" field expressions to the submitUrlParams object
 */
com.trackplus.admin.Filter.preSubmitProcessIssueFilter = function(submitUrlParams, panel) {
	var moreFieldSet = panel.getComponent("moreFieldSet");
	if (moreFieldSet) {
	    var fieldExpressionsInTreePanel = moreFieldSet.getComponent("fieldExpressionsInTree");
	    return com.trackplus.admin.Filter.preSubmitProcess(submitUrlParams, fieldExpressionsInTreePanel);
	}
	return submitUrlParams;
};
/**
 * The handler for the add "in tree" field expression button
 * fieldExpressionsInTreePanel panel for all "in tree" filterExpressions
 * expressionPanel the add was clicked from
 */
com.trackplus.admin.Filter.addFieldExpression = function(scope, fieldExpressionsInTreePanel, expressionPanel, projectTree, itemTypeList) {
	return Ext.create('Ext.Button', {
		text: getText('common.btn.add'),
		scope: scope,
		handler: function(button) {
			button.setDisabled(true);
			var requestParams = {index: scope.indexMax++,
								issueFilter: scope.issueFilter,
								instant: scope.instant};
			if (expressionPanel) {
				//add the field as request parameter to initialize new new field expression with the same field
				var fieldControl = expressionPanel.getComponent("fieldMap" + expressionPanel.index);
				if (fieldControl) {
					requestParams.fieldID = fieldControl.getValue();
				}
			}
			Ext.Ajax.request({
				url: 'fieldExpression!addField.action',
				params: requestParams,
				scope: scope,
				disableCaching:true,
				success: function(response) {
					var insertPosition = 1;
					var first = false;
					var defaultOperation = null;
					if (expressionPanel) {
						//add from an existing filter expression
						for (var i=1;i<fieldExpressionsInTreePanel.items.getCount();i++) {
							var currentExpressionPanel =  fieldExpressionsInTreePanel.items.getAt(i);
							if (currentExpressionPanel===expressionPanel) {
								insertPosition = i+1;
								//submit some default values for the filter expression to be added
								var operationControl = expressionPanel.getComponent("operationMap" + expressionPanel.index);
								if (operationControl) {
									defaultOperation = operationControl.getValue();
								}
							}
						}
					} else {
						//added from first position (no filter expression)
						first = true;
						nextExpressionPanel = fieldExpressionsInTreePanel.items.getAt(1);
						if (nextExpressionPanel) {
							//at least one filter expression exists already?
							operationControl = nextExpressionPanel.getComponent("operationMap" + nextExpressionPanel.index);
							if (operationControl) {
								//set the previous first expression's operation control as visible
								operationControl.setVisible(true);
								if (fieldExpressionsInTreePanel.items.getCount()>2) {
									nextNextExpressionPanel = fieldExpressionsInTreePanel.items.getAt(2);
									if (nextNextExpressionPanel) {
										var nextNextOperationControl = nextNextExpressionPanel.getComponent(
												"operationMap" + nextNextExpressionPanel.index);
										if (nextNextOperationControl) {
											//initialize the operation with the operation of the next filter expression if exists
											operationControl.setValue(nextNextOperationControl.getValue());
										}
									}
								}
							}
						}
					}
					var fieldExpression = Ext.decode(response.responseText);
					if (defaultOperation) {
						fieldExpression.operation = defaultOperation;
					}
					var addedExpressionPanel = com.trackplus.admin.Filter.createFieldExpressionInTreePanel(scope,
							fieldExpressionsInTreePanel, fieldExpression, true, first, projectTree, itemTypeList);
					fieldExpressionsInTreePanel.insert(insertPosition, addedExpressionPanel);
					button.setDisabled(false);
				},
				failure: function(result){
					button.setDisabled(false);
					Ext.MessageBox.alert(scope.failureTitle, result.responseText);
				},
				method:"POST"
			});
		}
	});
};
/**
 * The handler for the remove expression button
 */
com.trackplus.admin.Filter.deleteFieldExpression = function(scope, fieldExpressionsInTreePanel, expressionPanel) {
	return Ext.create('Ext.Button', {
		text: getText('common.btn.delete'),
		scope: scope,
		handler: function(button) {
			if (expressionPanel) {
				if (expressionPanel===fieldExpressionsInTreePanel.items.getAt(1) && fieldExpressionsInTreePanel.items.getCount()>2) {
					//set the next first expression's operation control as hidden
					nextExpressionPanel = fieldExpressionsInTreePanel.items.getAt(2);
					if (nextExpressionPanel) {
						operationControl = nextExpressionPanel.getComponent("operationMap["+ nextExpressionPanel.index +"]");
						if (operationControl) {
							operationControl.setVisible(false);
						}
					}
				}
				fieldExpressionsInTreePanel.remove(expressionPanel,true);
			}
		}
	});
};
/**
 * Load the combos after the result has arrived containing also the combo data sources
 */
com.trackplus.admin.Filter.postLoadProcessTQLFilter = function(data, panel) {
	var filterTypesCombo = panel.getComponent('filterSubType');
	filterTypesCombo.store.loadData(data['filterTypesList']);
	filterTypesCombo.setValue(data['filterSubType']);
	var styleFieldsCombo = panel.getComponent('styleField');
	styleFieldsCombo.store.loadData(data['styleFieldsList']);
	styleFieldsCombo.setValue(data['styleField']);
};
com.trackplus.admin.Filter.refreshReleaseData = function(checkboxField, newValue, oldValue, options) {
	var selectedProjectIDs = options.projectIDs;
	var hiddenShowClosed = options.hiddenShowClosed;
	hiddenShowClosed.setValue(newValue);
	var releaseTree = options.releaseTree;
	var selectedReleaseIDs = null;
	if (releaseTree) {
		selectedReleaseIDs = releaseTree.getValue();
	}
	var params = {
			withParameter:!this.instant,
			projectIDs: selectedProjectIDs,
			closedFlag: newValue,
			useChecked: true,
	        projectIsSelectable: false
		};
	Ext.Ajax.request({
		url: 'releasePicker.action',
		params: params,
		scope: this,
		disableCaching:true,
		success: function(response){
			var data = Ext.decode(response.responseText);
	        releaseTree.updateMyOptions(data);
			releaseTree.setValue(selectedReleaseIDs);
		},
		failure: function(result){
			Ext.MessageBox.alert(this.failureTitle, result.responseText);
		},
		method:"POST"
	});
};
/**
 * Refresh some upper selects after project change
 */
com.trackplus.admin.Filter.projectOrItemTypeChange = function(treePickerOrList, selectedProjects, oldValue, options){
	var upperSelects = options.panel;
	var withParameter = options.withParameter;
	var paramSetting = options.paramSetting;
	var projectChange = options.projectChange;
	var upperSelectFields = options.upperSelectFields.join();
	var projectIDs = null;
	var projectTree = upperSelects.getComponent('selectId1');
	if (projectTree) {
		var selectedProjects = projectTree.getValue();
		if (selectedProjects) {
			projectIDs = selectedProjects;
		}
	}
	var itemTypeIDs = null;
	var itemTypeList = upperSelects.getComponent('selectId2');
	if (itemTypeList) {
		var selectedItemTypes = itemTypeList.getValue();
		if (selectedItemTypes) {
			itemTypeIDs = selectedItemTypes;
		}
	}
	var releasePanel = upperSelects.getComponent('panel9');
	var showClosedReleases = false;
	if (releasePanel) {
		//refresh the release tree
		var showClosedReleasesCheckBox = releasePanel.getComponent('showClosedReleases');
		if (showClosedReleasesCheckBox) {
			showClosedReleases = showClosedReleasesCheckBox.getValue();
		}
	}
	//refresh the other selects
	var params = {
			upperSelectFields: upperSelectFields,
			instant: !withParameter,
			showClosedReleases: showClosedReleases,
			projectIDs: projectIDs,
			itemTypeIDs: itemTypeIDs,
			projectChange: projectChange
			};
	Ext.Ajax.request({
		url: 'filterUpperRefresh.action',
		params: params,
		scope: this,
		disableCaching:true,
		success: function(response){
			var data = Ext.decode(response.responseText);
			var upperSelects = options.panel;
	        com.trackplus.admin.Filter.reloadUpperSelects(upperSelects, data, paramSetting, false, projectChange);
		},
		failure: function(result){
			Ext.MessageBox.alert(this.failureTitle, result.responseText);
		},
		method:"POST"
	});
};
com.trackplus.admin.Filter.reloadUpperSelects = function(upperSelects, data, paramSetting, resetValue, projectChange) {
	if (data.selectFields) {
	    Ext.Array.forEach(data.selectFields, function(selectFieldData) {
	        var selectControl = null;
	        var fieldID = selectFieldData["fieldID"];
	        //do not set the value for itemType if the itemType change triggered this call
	        //because that would trigger a change event resulting in reloading the dependent fields second time
	        var noItemTypeChange = CWHF.isNull(projectChange) || projectChange || fieldID!==2;
	        //if the reload is caused by itemType change then the item type list control should not be actualized,
	        //because that would trigger a change event resulting in a second reload
	        if (!paramSetting && (fieldID===9 || fieldID===-1001)) {
	            //if no parameter settings an extra panel exists for project/release/watchers
	            var panelOfSelect = upperSelects.getComponent('panel'+fieldID);
	            if (panelOfSelect) {
	                selectControl = panelOfSelect.getComponent("selectId" + fieldID);
	            }
	        } else {
	            selectControl = upperSelects.getComponent("selectId" + fieldID);
	        }
	        if (selectControl) {
	            var selectedValue = selectControl.getValue();
	            var isTree =  selectFieldData["isTree"];
	            if (isTree) {
	                //tree
	                selectControl.updateMyOptions(selectFieldData["dataSource" + fieldID]);
	            } else {
	                //list
	            	if (noItemTypeChange) {
	            		selectControl.store.loadData(selectFieldData["dataSource" + fieldID]);
	            	}
	            }
	            if (resetValue) {
	                selectControl.clearSelection();
	            } else {
	            	if (noItemTypeChange) {
	            		selectControl.setValue(selectedValue);
	            	}
	            }
	        }
	    });
	}
	if (data.missingSelectFields) {
	    Ext.Array.forEach(data.missingSelectFields, function(selectFieldData) {
	        var selectControl = null;
	        var fieldID = selectFieldData["id"];
	        if (!paramSetting && (fieldID===9 || fieldID===-1001)) {
	            //if no parameter settings an extra panel exists for project/release/watchers
	            var panelOfSelect = upperSelects.getComponent('panel'+fieldID);
	            if (panelOfSelect) {
	                selectControl = panelOfSelect.getComponent("selectId" + fieldID);
	            }
	        } else {
	            selectControl = upperSelects.getComponent("selectId" + fieldID);
	        }
	        if (selectControl) {
	            selectControl.removeHandler();
	        }
	    });
	}
	upperSelects.updateLayout();
};
/**
 * Clear the filter
 */
com.trackplus.admin.Filter.clearFilter = function(refreshParameters, result) {
	 var filterSubTypeHiddenField =  refreshParameters.items[0];
	  var panel = filterSubTypeHiddenField.up("panel");
	  com.trackplus.admin.Filter.clearTreeFilter(panel, result.data);
};
/**
 * Clear the filter
 */
com.trackplus.admin.Filter.clearTreeFilter = function(panel, data) {
	var upperSelectsPanel = panel.getComponent("upperSelectsFieldSet");
	com.trackplus.admin.Filter.reloadUpperSelects(upperSelectsPanel, data, false, true);
	var moreFieldSet = panel.getComponent("moreFieldSet");
	if (moreFieldSet) {
	    var keywordTextField = moreFieldSet.getComponent("filterUpperTO.keyword");
	    if (keywordTextField) {
	        keywordTextField.setValue(null);
	    }
	    var linkTypeFilterSupersetCombo = moreFieldSet.getComponent("linkTypeFilterSuperset");
	    if (linkTypeFilterSupersetCombo) {
	        linkTypeFilterSupersetCombo.setValue(null);
	    }
	    var archivedCombo = moreFieldSet.getComponent("archived");
	    if (archivedCombo) {
	        archivedCombo.setValue(0);
	    }
	    var deletedCombo = moreFieldSet.getComponent("deleted");
	    if (deletedCombo) {
	        deletedCombo.setValue(0);
	    }
	    var fieldExpressionsSimple = moreFieldSet.getComponent("fieldExpressionsSimple");
	    if (fieldExpressionsSimple) {
	        fieldExpressionsSimple.items.each(function(fieldExpressionSimple, index, length) {
	            var combo = fieldExpressionSimple.getComponent(0);
	            if (combo) {
	                combo.setValue(-1);
	            }
	            var valueElement =  fieldExpressionSimple.getComponent(1);
	            if (valueElement) {
	                fieldExpressionSimple.remove(valueElement);
	            }
	        });
	    }
	    var fieldExpressionsInTree = moreFieldSet.getComponent("fieldExpressionsInTree");
	    if (fieldExpressionsInTree)  {
	        fieldExpressionsInTree.items.each(function(fieldExpressionInTree, index, length) {
	            if (index>0) {
	                //the first Add button should remain
	                fieldExpressionsInTree.remove(fieldExpressionInTree);
	            }
	        });
	    }
	}
};
/**
 * Add a new select field
 */
com.trackplus.admin.Filter.addNewSelection = function(button, options) {
	var upperSelectsPanel = this.upperSelectsPanel;
	var upperSelectFields = this.upperSelectFields;
	var projectTree = this.projectTree;
	var itemTypeList = this.itemTypeList;
	var instant = this.instant;
	var addSelectionFieldSplitter = this.addSelectionFieldSplitter;
	var fieldID = parseInt(button.getItemId().substr(1)); //remove "f"
	//add as used field to be removed from selectable list fields
	this.upperSelectFields.push(fieldID);
	var selectedProjectIDs = null;
	if (projectTree) {
		selectedProjectIDs = projectTree.getValue();
	}
	var selectedItemTypes = null;
	if (itemTypeList) {
		selectedItemTypes = itemTypeList.getValue();
	}
	Ext.Ajax.request({
		url: 'filterUpperRefresh!addSelectionField.action',
		params: {fieldID:fieldID,
				projectIDs:selectedProjectIDs,
				itemTypeIDs:selectedItemTypes,
				upperSelectFields: this.upperSelectFields.join(),
				instant: this.instant},
		disableCaching:true,
		scope: this,
		success: function(response) {
			var data = Ext.decode(response.responseText);
			var selectFieldData = data["selectField"];
			var missingSelectFields = data["missingSelectFields"];
			if (fieldID===1) {
				selectControl = com.trackplus.admin.Filter.createProjectTree(upperSelectFields,
						upperSelectsPanel, instant, 1, selectFieldData, true, addSelectionFieldSplitter);
				selectControl.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
						{upperSelectFields:upperSelectFields, panel:upperSelectsPanel, withParameter:!this.instant, paramSetting:false, projectChange:true});
			} else {
				if (fieldID===9) {
					//releaseTree
					selectControl = com.trackplus.admin.Filter.createReleaseTree(upperSelectFields,
							upperSelectsPanel, projectTree, instant, selectFieldData, 9, selectedProjectIDs, true, data['showClosedReleasesName'],
							data['showClosedReleases'], data["releaseTypeSelectorIsIncluded"],
							data['releaseTypeSelectorName'], data['releaseTypeSelector'], data['releaseTypeSelectorList'], addSelectionFieldSplitter);
				} else {
					if (fieldID===-1001) {
						//watchers
						selectControl = com.trackplus.admin.Filter.createWatcherList(upperSelectFields,
								upperSelectsPanel, projectTree, instant, selectFieldData, -1001, true,
								data['watcherSelectorName'], data['watcherSelector'], data['watcherSelectorList'], addSelectionFieldSplitter);
					} else {
						//other multiple selects
	                    var isTree =  selectFieldData["isTree"];
	                    if (isTree) {
	                        selectControl = CWHF.createMultipleTreePicker(selectFieldData["label"+fieldID],
	                            selectFieldData["name" + fieldID],
	                            selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
	                            {itemId:"selectId" + fieldID, labelIsLocalized:true,
	                                //matchFieldWidth:false,
	                                pickerWidth:com.trackplus.admin.Filter.multipleTreePickerWidth,
	                                removeHandler: function() {
	                                    this.setDisabled(true);
	                                    this.ownerCt.remove(this);
	                                    com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields,
	                                        upperSelectsPanel, projectTree, itemTypeList, instant, fieldID, addSelectionFieldSplitter);
	                                }
	                            });
	                    } else {
	                        selectControl = CWHF.createMultipleSelectPicker(selectFieldData["label"+fieldID], selectFieldData["name" + fieldID],
								selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
								{itemId:"selectId" + fieldID,
								labelIsLocalized:true,
								iconUrlPrefix:selectFieldData["iconUrlPrefix"],
								useIconCls:selectFieldData["useIconCls"],
								removeHandler: function() {
									this.setDisabled(true);
									this.ownerCt.remove(this);
									com.trackplus.admin.Filter.updateAfterRemove(
											upperSelectFields, upperSelectsPanel, projectTree, itemTypeList, instant, fieldID, addSelectionFieldSplitter);
								}
								});
								if (fieldID===2) {
									selectControl.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
										{upperSelectFields:upperSelectFields, panel:upperSelectsPanel, withParameter:!this.instant, paramSetting:false, projectChange:false});
								}
	                    }
				    }
			    }
			}
			//insert at the last but one position
			upperSelectsPanel.insert(upperSelectsPanel.items.getCount()-1, selectControl);
			var menuSelectionFields=com.trackplus.admin.Filter.getMissingSelectionFieldMenues(addSelectionFieldSplitter,
					missingSelectFields, upperSelectsPanel, upperSelectFields, projectTree, itemTypeList, instant);
			addSelectionFieldSplitter.menu.removeAll(true);
	        if (CWHF.isNull(menuSelectionFields) || menuSelectionFields.length===0) {
	            addSelectionFieldSplitter.setVisible(false);
	        } else {
	           addSelectionFieldSplitter.menu.add(menuSelectionFields);
	        }
		},
		failure: function(response) {
			com.trackplus.util.requestFailureHandler(response);
		}
	});
};
com.trackplus.admin.Filter.updateAfterRemove = function(upperSelectFields,
		upperSelectsPanel, projectTree, itemTypeList, instant, fieldID, addSelectionFieldSplitter) {
	var index = upperSelectFields.indexOf(fieldID);
	if (index!==-1) {
		//remove from this.upperSelectFields
		upperSelectFields.splice(index, 1);
	}
	//refresh the combo with list fields available to select after a remove
	Ext.Ajax.request({
		url: 'filterUpperRefresh!removeSelectionField.action',
		params: {upperSelectFields: upperSelectFields},
		disableCaching:true,
		scope: this,
		success: function(response) {
			var data = Ext.decode(response.responseText);
	        if (!addSelectionFieldSplitter.isVisible()) {
	            //after remove the addField should be visible
	            addSelectionFieldSplitter.setVisible(true);
	            upperSelectsPanel.updateLayout();
	        }
			var missingSelectFields = data["missingSelectFields"];
			var menuSelectionFields=com.trackplus.admin.Filter.getMissingSelectionFieldMenues(addSelectionFieldSplitter,
					missingSelectFields, upperSelectsPanel, upperSelectFields, projectTree, itemTypeList, instant);
			addSelectionFieldSplitter.menu.removeAll(true);
			addSelectionFieldSplitter.menu.add(menuSelectionFields);
			if (fieldID===1 || fieldID===2) {
				//project or itemType control was removed: reload the dependences
				var options = {panel:upperSelectsPanel, withParameter:!instant, paramSetting:false, upperSelectFields:upperSelectFields};
				options.projectChange = (fieldID===1);
				com.trackplus.admin.Filter.projectOrItemTypeChange(null, null, null, options);
			}
		},
		failure: function(response) {
			com.trackplus.util.requestFailureHandler(response);
		}
	});
};
com.trackplus.admin.Filter.createProjectTree = function(upperSelectFields, upperSelectsPanel, instant, fieldID, selectFieldData, modifiable, addSelectionFieldSplitter) {
	return CWHF.createMultipleTreePicker(selectFieldData["label"+fieldID],
			selectFieldData["name" + fieldID],
			selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
			{itemId:"selectId" + fieldID, labelIsLocalized:true,
			disabled:!modifiable,
			//matchFieldWidth:false,
			pickerWidth:com.trackplus.admin.Filter.multipleTreePickerWidth,
			removeHandler: function() {
				//remove from container
				this.setDisabled(true);
				this.ownerCt.remove(this);
				com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields,
						upperSelectsPanel, this, null, instant, fieldID, addSelectionFieldSplitter);
			}
		});
};
com.trackplus.admin.Filter.createReleaseTree = function(upperSelectFields, upperSelectsPanel, projectTree, instant, selectFieldData, fieldID,
		selectedProjectIDs, modifiable, showClosedReleasesName, showClosedReleases,
		releaseTypeSelectorIsIncluded, releaseTypeSelectorName, releaseTypeSelector, releaseTypeSelectorList, addSelectionFieldSplitter) {
	var hiddenShowClosed=CWHF.createHiddenField(showClosedReleasesName, {value:showClosedReleases});
	var checkShowClosed=CWHF.createCheckbox(
			'admin.customize.queryFilter.lbl.showClosedReleases',
			showClosedReleasesName,
			{
				itemId:'showClosedReleases',
				disabled:!modifiable,
				value:showClosedReleases,
				labelAlign:'left',
				labelWidth:com.trackplus.admin.Filter.multiSelectWidth-50,
				width:com.trackplus.admin.Filter.multiSelectWidth,
				border:true,
				cls:'extensionSelect1'
			}
	);
	var extraCmp=null;
	var hiddenReleaseTypeSelectorList = null;
	if (releaseTypeSelectorIsIncluded) {
		hiddenReleaseTypeSelectorList=CWHF.createHiddenField(releaseTypeSelectorName, {value:releaseTypeSelector});
		var releaseTypeRadioButtons = CWHF.getRadioButtonItems(releaseTypeSelectorList,
				releaseTypeSelectorName, 'id', 'label', releaseTypeSelector, !modifiable, true);
		var releaseTypeSelectorList = CWHF.getRadioGroup(null,com.trackplus.admin.Filter.multiSelectWidth, releaseTypeRadioButtons, {itemId:'releaseTypeSelectorList',disabled:!modifiable,border:true,cls:'extensionSelect'},
			{change: {fn: function(cmp){
				var newValue=CWHF.getSelectedRadioButtonValue(cmp);
				this.setValue(newValue);
			}, scope:hiddenReleaseTypeSelectorList}}
		);
		extraCmp=Ext.create('Ext.panel.Panel',{
			items:[checkShowClosed,releaseTypeSelectorList]
		});
	} else {
		extraCmp=checkShowClosed;
	}
	var releaseTree = CWHF.createMultipleTreePicker(selectFieldData["label"+fieldID],
		selectFieldData["name" + fieldID],
		selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
		{itemId:"selectId" + fieldID, labelIsLocalized:true, disabled:!modifiable,
		extraComponent:extraCmp,
		pickerWidth:com.trackplus.admin.Filter.multipleTreePickerWidth,
		removeHandler: function() {
			this.setDisabled(true);
			this.ownerCt.ownerCt.remove(this.ownerCt);
			com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields,
					upperSelectsPanel, projectTree, null, instant, fieldID, addSelectionFieldSplitter);
			}
		});
	checkShowClosed.addListener('change',com.trackplus.admin.Filter.refreshReleaseData,this,
			{projectIDs: selectedProjectIDs,releaseTree:releaseTree, hiddenShowClosed:hiddenShowClosed});
	return Ext.create('Ext.panel.Panel',{
		border:false,
		height: 22,
		itemId: "panel" + fieldID,
		items:[releaseTree,hiddenShowClosed, hiddenReleaseTypeSelectorList]
	});
};
com.trackplus.admin.Filter.createWatcherList = function(upperSelectFields, upperSelectsPanel, projectTree, instant,
		selectFieldData, fieldID, modifiable, watcherSelectorName, watcherSelector, watcherSelectorList, addSelectionFieldSplitter) {
	var hiddenField=CWHF.createHiddenField(watcherSelectorName, {value:watcherSelector});
	var watcherTypeRadioButtons = CWHF.getRadioButtonItems(watcherSelectorList,
			watcherSelectorName, 'id', 'label', watcherSelector, !modifiable, true);
	var watcherSelectorList = CWHF.getRadioGroup(null,com.trackplus.admin.Filter.multiSelectWidth, watcherTypeRadioButtons,
			{itemId:'watcherSelectorList1',disabled:!modifiable,border:true,cls:'extensionSelect'},
			{change: {fn: function(cmp){
				var newValue=CWHF.getSelectedRadioButtonValue(cmp);
				this.setValue(newValue);
			}, scope:hiddenField}}
	);
	var watchersControl = CWHF.createMultipleSelectPicker(selectFieldData["label"+fieldID], selectFieldData["name" + fieldID],
		selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
		{itemId:"selectId" + fieldID,
		labelIsLocalized:true,
		useIconCls:selectFieldData["useIconCls"],
		disabled:!modifiable,
		extraComponent:watcherSelectorList,
		removeHandler: function() {
			this.setDisabled(true);
			this.ownerCt.ownerCt.remove(this.ownerCt);
			com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields,
					upperSelectsPanel, projectTree, null, instant, fieldID, addSelectionFieldSplitter);
			}
		});
	return Ext.create('Ext.panel.Panel',{
		border:false,
		height: 22,
		itemId: "panel" + fieldID,
		items:[watchersControl,hiddenField]
	});
};
/**
 * Gets the menu entries for the missing selection fields
 */
com.trackplus.admin.Filter.getMissingSelectionFieldMenues = function(addSelectionFieldSplitter,
		missingSelectFields, upperSelectsPanel, upperSelectFields, projectTree, itemTypeList, instant) {
	var menuSelectionFields=[];
	if (missingSelectFields) {
		for(var i=0;i<missingSelectFields.length;i++){
			var missingSelectField=missingSelectFields[i];
			menuSelectionFields.push({
				text: missingSelectField["text"],
				itemId: "f"+missingSelectField["id"],//itemId should be string
				iconCls:missingSelectField["iconCls"],
				handler: com.trackplus.admin.Filter.addNewSelection,
				scope: {addSelectionFieldSplitter:addSelectionFieldSplitter,
						upperSelectsPanel:upperSelectsPanel,
						upperSelectFields:upperSelectFields,
						projectTree:projectTree,
						itemTypeList: itemTypeList,
						instant:instant}
			});
		}
	}
	return menuSelectionFields;
};
/**
 * Post process the data after the result has arrived containing the combo data sources and field expression configs.
 */
com.trackplus.admin.Filter.postLoadProcessTreeFilter = function(data, panel) {
	var modifiable = data['modifiable'];
	var selectColumnCount = data.selectColumnCount;
	if (CWHF.isNull(selectColumnCount)) {
		selectColumnCount = com.trackplus.admin.Filter.upperSelectColumns;
	}
	var instant = this.instant;
	if (CWHF.isNull(instant)) {
		instant = false;
	}
	var renderPath = this.renderPath;
	if (CWHF.isNull(renderPath)) {
		renderPath = false;
	}
	var generalFilterFields = panel.getComponent("generalFilterFields");
	if (generalFilterFields) {
		generalFilterFields.add(CWHF.createCombo(
			"admin.customize.queryFilter.lbl.styleField", "styleField",
			{labelWidth:com.trackplus.admin.Filter.styleFieldLabelWidth,
			width: com.trackplus.admin.Filter.styleFieldWidth,
			data:data["styleFieldsList"],
			value: data["styleField"]}));
		generalFilterFields.add(CWHF.createCombo(
				"admin.customize.queryFilter.lbl.view",
				"viewID",
				{
				labelWidth:com.trackplus.admin.Filter.viewLabelWidth,
				width: com.trackplus.admin.Filter.viewFieldWidth,
				 disabled:!modifiable,
				idType: "string",
				data:data["viewList"],
				value: data["viewID"]}));
		if (renderPath) {
			generalFilterFields.add(CWHF.createSingleTreePicker("common.lbl.path", "node", data["pathNodes"], null,
					{labelWidth:com.trackplus.admin.Filter.nameLabelWidth,
					width: com.trackplus.admin.Filter.nameWidth,
					allowBlank:false}));
		}
	}
	//upper selects
	this.upperSelectFields = []; //gather select fields to be used by project change
	var upperSelectsPanel = Ext.create("Ext.form.Panel", {
		//xtype: "fieldset",
		border: false,
		itemId: "upperSelectsFieldSet",
		padding:'5 5 10 10',
		layout: {
			type:'table',
			columns: selectColumnCount,
			tdAttrs:{
				style:{
					'vertical-align':'top',
					paddingBottom:'5px'
				}
			}
		},
		items:[]
	});
	panel.add(upperSelectsPanel);
	//add new select field combo
	var missingSelectFields = data["missingSelectFields"];
	var addSelectionFieldSplitter = Ext.create("Ext.button.Split", {
		text: getText('admin.customize.queryFilter.opt.addSelectField'),
		overflowText:getText('admin.customize.queryFilter.opt.addSelectField'),
		tooltip:getText('admin.customize.queryFilter.opt.addSelectField.tt'),
		iconCls: 'addCriteria',
		menu: {items:[]}
		});
	var projectTree = null;
	var itemTypeList = null;
	if (upperSelectsPanel) {
		var upperSelectControls = [];
		var selectedProjectIDs = null;
		Ext.Array.forEach(data.selectFields, function(selectFieldData, index) {
			var fieldID = selectFieldData["fieldID"];
			var selectControl;
			this.upperSelectFields.push(fieldID);
			if (fieldID===1) {
				selectedProjectIDs = selectFieldData["value" + fieldID];
				projectTree = com.trackplus.admin.Filter.createProjectTree(this.upperSelectFields,
						upperSelectsPanel, instant, fieldID, selectFieldData, modifiable, addSelectionFieldSplitter);
				projectTree.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
						{upperSelectFields:this.upperSelectFields, panel:upperSelectsPanel, withParameter:!instant, paramSetting:false, projectChange:true});
				selectControl = projectTree;
			} else {
				//gather the selects reloaded by project change
				if (fieldID===9) {
					//releaseTree
					selectControl = com.trackplus.admin.Filter.createReleaseTree(this.upperSelectFields,
							upperSelectsPanel, projectTree, instant,
							selectFieldData, fieldID, selectedProjectIDs, modifiable, data['showClosedReleasesName'],
							data['showClosedReleases'], data["releaseTypeSelectorIsIncluded"],
							data['releaseTypeSelectorName'], data['releaseTypeSelector'], data['releaseTypeSelectorList'], addSelectionFieldSplitter);
				} else {
					if (fieldID===-1001) {
						//watchers
						selectControl = com.trackplus.admin.Filter.createWatcherList(this.upperSelectFields,
								upperSelectsPanel, projectTree, instant, selectFieldData, fieldID, modifiable,
								data['watcherSelectorName'], data['watcherSelector'], data['watcherSelectorList'], addSelectionFieldSplitter);
					} else {
						//other selects
						//with this can't be used in removeHandler because the scope (this) is the picker
						var upperSelectFields = this.upperSelectFields;
	                    var isTree = selectFieldData["isTree"];
	                    if (isTree) {
	                        selectControl = CWHF.createMultipleTreePicker(selectFieldData["label"+fieldID],
	                            selectFieldData["name" + fieldID],
	                            selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
	                            {itemId:"selectId" + fieldID,
	                            disabled:!modifiable,
	                            labelIsLocalized:true,
	                            //matchFieldWidth:false,
	                            pickerWidth:com.trackplus.admin.Filter.multipleTreePickerWidth,
	                            removeHandler: function() {
	                                this.setDisabled(true);
	                                this.ownerCt.remove(this);
	                                com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields,
	                                    upperSelectsPanel, projectTree, itemTypeList, instant, fieldID, addSelectionFieldSplitter);
	                            }
	                            });
	                    } else {
	                        selectControl = CWHF.createMultipleSelectPicker(selectFieldData["label"+fieldID], selectFieldData["name" + fieldID],
	                            selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
	                            {itemId:"selectId" + fieldID,
	                            disabled:!modifiable,
	                            labelIsLocalized:true,
	                            useIconCls:selectFieldData["useIconCls"],
								iconUrlPrefix:selectFieldData["iconUrlPrefix"],
	                            removeHandler: function() {
	                                this.setDisabled(true);
	                                this.ownerCt.remove(this);
	                                com.trackplus.admin.Filter.updateAfterRemove(upperSelectFields, upperSelectsPanel,
	                                        projectTree, itemTypeList, instant, fieldID, addSelectionFieldSplitter);
	                                }
	                            });
	                        if (fieldID===2) {
	                        	itemTypeList = selectControl;
	                        	itemTypeList.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
	            						{upperSelectFields:this.upperSelectFields, panel:upperSelectsPanel, withParameter:!instant, paramSetting:false, projectChange:false});
	                        }
	                    }
					}
				}
			}
			upperSelectControls.push(selectControl);
		}, this);
		if (modifiable) {
			if (CWHF.isNull(missingSelectFields)) {
	            addSelectionFieldSplitter.setVisible(false);
			}
	        upperSelectControls.push(addSelectionFieldSplitter);
	    	var menuSelectionFields=com.trackplus.admin.Filter.getMissingSelectionFieldMenues(addSelectionFieldSplitter,
					missingSelectFields, upperSelectsPanel, this.upperSelectFields, projectTree, itemTypeList, instant);
			addSelectionFieldSplitter.menu.add(menuSelectionFields);
		}
		//add all selects at the same time
		upperSelectsPanel.add(upperSelectControls);
		upperSelectsPanel.updateLayout();
	}
	//add simple field expressions other than simple lists set in field configuration as appear in filter
	var treeExpressionsExist = (data["fieldsExpressionsInTree"]);
	var moreCriteriaExpanded = (data["keyword"] && data["keyword"]!=="") ||  (data['linkTypeFilterSuperset'] && data['linkTypeFilterSuperset']!=="") ||
	    (data["archived"] && data["archived"]!==0) ||
	    (data["deleted"] && data["deleted"]!==0) || data["hasSimpleFieldExpressions"] || treeExpressionsExist;
	var moreFieldSet = Ext.create("Ext.form.FieldSet", {xtype: 'fieldset',
	    itemId: "moreFieldSet",
	    border: "1 0 0 0",
	    title: getText('admin.customize.queryFilter.fieldset.moreFields'),
	    collapsible: true,
	    collapsed: !moreCriteriaExpanded,
	    layout: 'anchor',
	    items: []});
	panel.add(moreFieldSet);
	moreFieldSet.add(Ext.create('Ext.panel.Panel', {
	    itemId: "fieldExpressionsSimple",
	    padding: "0 0 5 0",
	    border:false
	}));
	var fieldsExpressionsSimple = data['fieldsExpressionsSimple'];
	if (fieldsExpressionsSimple) {
		com.trackplus.admin.Filter.populateFieldExpressionsSimplePanel(this, moreFieldSet.getComponent("fieldExpressionsSimple"),
				fieldsExpressionsSimple, modifiable, true, {projectTree:projectTree, itemTypeList:itemTypeList});
	}
	var upperComboControls = [];
	if (data["keywordIsIncluded"]) {
	    upperComboControls.push(CWHF.createTextField(
	        'admin.customize.queryFilter.lbl.keyword', data['keywordName'],
	        {disabled:!modifiable,
	            labelWidth:com.trackplus.admin.Filter.moreControlLabelWidth,
	            width:com.trackplus.admin.Filter.moreControlWidth,
	            value:data['keyword']}
	    ));
	}
	upperComboControls.push(CWHF.createCombo(
	    'admin.customize.queryFilter.lbl.linkTypeFilterSuperset',
	    data['linkTypeFilterSupersetName'],
	    {	itemId: "linkTypeFilterSuperset",
	    	disabled:!modifiable,
	        labelWidth:com.trackplus.admin.Filter.moreControlLabelWidth,
	        width:com.trackplus.admin.Filter.moreControlWidth,
	        data:data["linkTypeFilterSupersetList"],
	        value:data["linkTypeFilterSuperset"],
	        idType:'string'}));
	if (data["archivedDeletedIsIncluded"]) {
	    upperComboControls.push(
	        CWHF.createCombo('admin.customize.queryFilter.lbl.archived',
	            data['archivedName'],
	            {	itemId: "archived",
	        		disabled:!modifiable,
	                labelWidth:com.trackplus.admin.Filter.moreControlLabelWidth,
	                width:com.trackplus.admin.Filter.moreControlWidth,
	                data:data["archivedList"],
	                value:data["archived"]}));
	    upperComboControls.push(CWHF.createCombo('admin.customize.queryFilter.lbl.deleted',
	        data['deletedName'],
	        {	itemId: "deleted",
	    		disabled:!modifiable,
	            labelWidth:com.trackplus.admin.Filter.moreControlLabelWidth,
	            width:com.trackplus.admin.Filter.moreControlWidth,
	            data:data["deletedList"],
	            value:data["deleted"]}));
	}
	moreFieldSet.add(upperComboControls);
	if (modifiable || treeExpressionsExist) {
	    //add this fieldset only if has tree expressions or is modifiable
	   	var fieldExpressionsInTree = Ext.create("Ext.panel.Panel", {
	           itemId: "fieldExpressionsInTree",
	           border:false/*,
	           layout: {
	               type: 'table',
	               // The total column count must be specified here
	               columns: 8
	           } */
	        });
	        moreFieldSet.add(fieldExpressionsInTree);
	    com.trackplus.admin.Filter.populateFieldExpressionsInTreePanel(this, fieldExpressionsInTree,
	            data["fieldsExpressionsInTree"], modifiable, projectTree, itemTypeList);
	}
};
/**
 * Post process the data after filter parameter data has arrived containing the combo data sources and field expression configs .
 */
com.trackplus.admin.Filter.postLoadProcessTreeFilterParameters = function(data, panel) {
	this.upperSelectFields = []; //gather select fields to be used by project change
	var projectTree = null;
	var itemTypeList = null;
	var originalProjects = data["originalProjects"];
	var originalItemTypes = data["originalItemTypes"];
	//upper selects
	if (data.selectFields) {
		var upperSelectsPanel = Ext.create('Ext.panel.Panel', {
			itemId: "upperSelectsPanel",
			layout: {
				type:'table',
				columns:4,
				tdAttrs:{
					style:{
						'vertical-align':'top',
						paddingBottom:'5px'
					}
				}
			},
			border:false,
			items:[]
		});
		panel.add(upperSelectsPanel);
		var upperSelectControls = [];
		Ext.Array.forEach(data.selectFields, function(selectFieldData) {
			var fieldID = selectFieldData["fieldID"];
			var title = selectFieldData["label"+fieldID];
			if (fieldID===1) {
				selectControl = CWHF.createMultipleTreePicker(title,
						selectFieldData["name" + fieldID],
						selectFieldData["dataSource" + fieldID], originalProjects,
						{itemId:"selectId" + fieldID, labelIsLocalized:true, useRemoveBtn:false});
				projectTree = selectControl;
				selectControl.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
						{upperSelectFields:this.upperSelectFields, panel:upperSelectsPanel, withParameter:false, paramSetting:true, projectChange:true});
			} else {
				//gather the selects reloaded by project change
				this.upperSelectFields.push(fieldID);
				if (fieldID===9) {
					//release
					selectControl = CWHF.createMultipleTreePicker(title,
							selectFieldData["name" + fieldID],
							selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
							{itemId:"selectId" + fieldID, labelIsLocalized:true, useRemoveBtn:false});
				} else {
	                var isTree = selectFieldData["isTree"];
	                if (isTree) {
	                    selectControl = CWHF.createMultipleTreePicker(title,
	                        selectFieldData["name" + fieldID],
	                        selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
	                        {itemId:"selectId" + fieldID,
	                         labelIsLocalized:true,
	                         //matchFieldWidth:false,
	                         pickerWidth:com.trackplus.admin.Filter.multipleTreePickerWidth,
	                         useRemoveBtn:false
	                        });
	                }  else {
	                    selectControl = CWHF.createMultipleSelectPicker(title, selectFieldData["name" + fieldID],
	                            selectFieldData["dataSource" + fieldID], selectFieldData["value" + fieldID],
	                            {itemId:"selectId" + fieldID,
	                    		labelIsLocalized:true,
	                    		useIconCls:selectFieldData["useIconCls"],
	                    		iconUrlPrefix:selectFieldData["iconUrlPrefix"],
	                    		useRemoveBtn:false});
	                    if (fieldID===2) {
	                    	itemTypeList = selectControl;
	                    	selectControl.addListener('change', com.trackplus.admin.Filter.projectOrItemTypeChange, this,
	    						{upperSelectFields:this.upperSelectFields, panel:upperSelectsPanel, withParameter:false, paramSetting:true, projectChange:false});
	                    }
	                }
				}
			}
			upperSelectControls.push(selectControl);
		}, this);
		if (upperSelectControls.length>0) {
			upperSelectsPanel.add(upperSelectControls);
		}
	}
	//simple field expressions
	var selectedProjects = null;
	if (CWHF.isNull(projectTree)) {
		//project is not parameterized, the selected projects will not change in the replace parameters form
		selectedProjects = originalProjects;
	} else {
		//if the project is parameterized it might change during in the replace parameters form
		//and the changed value should be available in the simple filter expressions' listener
		//that's why the projectTree is sent as parameter
	}
	var selectedItemTypes = null;
	if (CWHF.isNull(itemTypeList)) {
		//itemType is not parameterized
		selectedItemTypes = originalItemTypes;
	}
	var fieldsExpressionsSimple = data["fieldsExpressionsSimple"];
	if (fieldsExpressionsSimple) {
		var moreFieldSet = Ext.create("Ext.panel.Panel", {
			itemId: "fieldExpressionsSimple",
			border:false,
			items: []});
		panel.add(moreFieldSet);
		com.trackplus.admin.Filter.populateFieldExpressionsSimplePanel(this, moreFieldSet,
			fieldsExpressionsSimple, true, true,
			{projectTree:projectTree, itemTypeList:itemTypeList, selectedProjects:selectedProjects, selectedItemTypes:selectedItemTypes});
	}
	//"in tree" field expressions
	var fieldExpressionsInTree = data["fieldsExpressionsInTree"];
	var fieldExpressionsInTreePanel = null;
	if (fieldExpressionsInTree) {
		fieldExpressionsInTreePanel = Ext.create('Ext.panel.Panel', {
			itemId: "fieldExpressionsInTree",
			border:false,
			items:[]
		});
		panel.add(fieldExpressionsInTreePanel);
	}
	com.trackplus.admin.Filter.populateFieldExpressionsSimplePanel(this, fieldExpressionsInTreePanel, fieldExpressionsInTree, true, false,
			{projectTree:projectTree, itemTypeList:itemTypeList, selectedProjects:selectedProjects, selectedItemTypes:selectedItemTypes});
};
/**
 * Load the notify filter expressions
 */
com.trackplus.admin.Filter.postLoadProcessNotifyFilter = function(data, panel) {
	com.trackplus.admin.Filter.populateFieldExpressionsInTreePanel(this, panel.getComponent("fieldExpressionsInTree"), data['fieldsExpressionsInTree'], data['modifiable']);
};
/**
 * Add the simple field expressions after the result has arrived
 */
com.trackplus.admin.Filter.populateFieldExpressionsSimplePanel =
	function (scope, fieldExpressionsSimplePanel, fieldsExpressionsSimple, modifiable, indexIsField, contextFields) {
		if (fieldExpressionsSimplePanel ) {
			if (fieldsExpressionsSimple ) {
				var fieldExpressionSimplePanels = [];
				Ext.Array.forEach(fieldsExpressionsSimple, function (fieldExpression) {
					var expressionPanel = com.trackplus.admin.Filter.createFieldExpressionSimplePanel(scope,
						fieldExpression, modifiable, indexIsField, contextFields);
					fieldExpressionSimplePanels.push(expressionPanel);
				}, scope);
				//add all panels at once
				fieldExpressionsSimplePanel.add(fieldExpressionSimplePanels);
			}
		}
	};
/**
 * Create a simple filter expression
 */
com.trackplus.admin.Filter.createFieldExpressionSimplePanel =
	function (scope, fieldExpression, modifiable, indexIsField, contextFields) {
		var expressionPanel = Ext.create("Ext.panel.Panel", {
			border:false,
			defaults:{margin:"4 4 0 0"},
			layout:{
				type:'hbox'
			}
		});
		var matcherCombo = CWHF.createCombo(fieldExpression.fieldLabel,
			fieldExpression.matcherName,
			{	itemId: fieldExpression.matcherItemId,
				disabled:!modifiable,
				width:com.trackplus.admin.Filter.matcherComboWidth + 200,
				labelWidth:com.trackplus.admin.Filter.moreControlLabelWidth,
				data:fieldExpression.matcherList,
				value:fieldExpression.matcher,
				labelIsLocalized:true},
			{select:{fn:com.trackplus.admin.Filter.selectMatcher, scope:scope,
				panel:expressionPanel, fieldExpression:fieldExpression,
				contextFields:contextFields}});
		expressionPanel.add(matcherCombo);
		com.trackplus.admin.Filter.addValuePart(scope, fieldExpression.valueRenderer,
				fieldExpression.jsonConfig, fieldExpression, expressionPanel, matcherCombo,
				null, contextFields);
	    if (!indexIsField) {
	        expressionPanel.add(CWHF.createHiddenField("fieldMap"+ fieldExpression.index, {value:fieldExpression.field}));
	    }
		return expressionPanel;
	};
/**
 * Add the "in tree" filter expressions after the result has arrived
 */
com.trackplus.admin.Filter.populateFieldExpressionsInTreePanel = function(scope, fieldExpressionsInTreePanel, fieldsExpressionsInTree, modifiable, projectTree, itemTypeList) {
	if (fieldExpressionsInTreePanel) {
		if (modifiable) {
			fieldExpressionsInTreePanel.add(com.trackplus.admin.Filter.addFieldExpression(scope, fieldExpressionsInTreePanel, null, projectTree, itemTypeList));
		}
		if (fieldsExpressionsInTree) {
			var fieldExpressionInTreePanels = [];
			scope.indexMax = 0;
			Ext.Array.forEach(fieldsExpressionsInTree, function(fieldExpression) {
				var expressionPanel = com.trackplus.admin.Filter.createFieldExpressionInTreePanel(scope,
						fieldExpressionsInTreePanel, fieldExpression, modifiable, scope.indexMax===0, projectTree, itemTypeList);
				fieldExpressionInTreePanels.push(expressionPanel);
				scope.indexMax++;
			}, scope);
			//add all panels at once
			fieldExpressionsInTreePanel.add(fieldExpressionInTreePanels);
		}
	}
};
/**
 * Create an "in tree" filter expression
 */
com.trackplus.admin.Filter.createFieldExpressionInTreePanel = function(scope, fieldExpressionsInTreePanel, fieldExpression, modifiable, first, projectTree, itemTypeList) {
	var expressionPanel = Ext.create("Ext.panel.Panel", {
		border:false,
		itemId: "filterExpressionInTreePanel"+fieldExpression.index,
		defaults: {margin:"4 4 0 0"},
		layout: {
			type:'hbox'
		}
	});
	expressionPanel.index = fieldExpression.index;
	expressionPanel.add(CWHF.createCombo(null,
			fieldExpression.operationsName,
			{itemId: fieldExpression.operationItemId,
			disabled:!modifiable,
			width:com.trackplus.admin.Filter.operationComboWidth,
			data:fieldExpression.operationsList,
			value:fieldExpression.operation,
			hidden:first}));
	expressionPanel.add(CWHF.createCombo(null,
			fieldExpression.parenthesisOpenName,
			{disabled:!modifiable, includeEmpty:true,
				width:com.trackplus.admin.Filter.parenthesisComboWidth,
				data:fieldExpression.parenthesisOpenList,
				value:fieldExpression.parenthesisOpen
			}));
	if (fieldExpression.withFieldMoment) {
		expressionPanel.add(CWHF.createCombo(null,
			fieldExpression.fieldMomentName,
			{disabled:!modifiable,
				width:com.trackplus.admin.Filter.fieldMomentComboWidth,
				data:fieldExpression.fieldMomentList,
				value:fieldExpression.fieldMoment
			}));
	}
	var contextFields = {projectTree:projectTree, itemTypeList:itemTypeList};
	expressionPanel.add(CWHF.createCombo(null,
			fieldExpression.fieldName,
			{	itemId: fieldExpression.fieldItemId,
				disabled:!modifiable,
				width:com.trackplus.admin.Filter.fieldNameComboWidth,
				data:fieldExpression.fieldList,
				value:fieldExpression.field
			},
			{select: {fn: com.trackplus.admin.Filter.selectField, scope:scope,
				panel:expressionPanel, fieldExpression:fieldExpression, contextFields:contextFields}}
			));
	var matcherCombo = CWHF.createCombo(null,
			fieldExpression.matcherName,
			{	itemId: fieldExpression.matcherItemId,
				disabled:!modifiable,
				width:com.trackplus.admin.Filter.matcherComboWidth,
				data:fieldExpression.matcherList,
				value:fieldExpression.matcher
			},
			{select: {fn: com.trackplus.admin.Filter.selectMatcher, scope:scope, panel:expressionPanel,
				fieldExpression:fieldExpression, contextFields:contextFields}});
	expressionPanel.add(matcherCombo);
	com.trackplus.admin.Filter.addValuePart(scope, fieldExpression.valueRenderer, fieldExpression.jsonConfig,
			fieldExpression, expressionPanel, matcherCombo, null, contextFields);
	expressionPanel.add(CWHF.createCombo(null,
		fieldExpression.parenthesisClosedName,
		{disabled:!modifiable, includeEmpty:true,
			width:com.trackplus.admin.Filter.parenthesisComboWidth,
			data:fieldExpression.parenthesisClosedList,
			value:fieldExpression.parenthesisClosed
		}));
	if (modifiable) {
		expressionPanel.add(com.trackplus.admin.Filter.addFieldExpression(scope, fieldExpressionsInTreePanel, expressionPanel, projectTree, itemTypeList));
		expressionPanel.add(com.trackplus.admin.Filter.deleteFieldExpression(scope, fieldExpressionsInTreePanel, expressionPanel));
	}
	return expressionPanel;
};
/**
 * Reload the value part of a simple or "in tree" filter expression after changing the matcher
 * or after changing any or the composite select part: in this latter case combo is not the matcher combo
 * but a composite select combo and the matcher combo is in options.matcherCombo
 */
com.trackplus.admin.Filter.selectMatcher = function(combo, records, options) {
	var fieldID = null;
	var fieldComponentItemId = options.fieldExpression.fieldItemId;
	if (fieldComponentItemId) {
		//"in tree" field expression: fieldID changed after field select
		var fieldComponent = options.panel.getComponent(fieldComponentItemId);
		if (fieldComponent) {
			fieldID = fieldComponent.getValue();
		}
	} else {
		//"simple" field expression: fieldID remains the same (no field select)
		fieldID = options.fieldExpression.field;
	}
	var valueComponentItemId = options.fieldExpression.valueItemId;
	var valueComponent = options.panel.getComponent(valueComponentItemId);
	var value = null;
	if (valueComponent) {
		value = valueComponent.getStringValue();
	}
	var matcherCombo = options.matcherCombo;
	var matcherID;
	var comboToInsertAfter;
	if (matcherCombo) {
		//combo is a composite select, the matcherCombo is got from options
		matcherID = matcherCombo.getValue();
		comboToInsertAfter = matcherCombo;
	} else {
		//combo is the matcherCombo
		matcherID = combo.getValue();
		comboToInsertAfter = combo;
	}
	var index = options.fieldExpression.index;
	var params = {
			index:index,//index is null for "simple" field expressions
			fieldID: fieldID,
			matcherID: matcherID,
			stringValue: value,//to maintain the value if possible
			issueFilter: this.issueFilter,
			instant:  this.instant
		};
	if (index) {
		params.inTree=true;
	}
	var contextFields = options.contextFields;
	var projectTree = null;
	var selectedProjects = null;
	var itemTypeList = null;
	var selectedItemTypes = null;
	if (contextFields) {
		projectTree = contextFields.projectTree;
		selectedProjects = contextFields.selectedProjects;
		itemTypeList = contextFields.itemTypeList;
		selectedItemTypes = contextFields.selectedItemTypes;
	}
	if (projectTree) {
		params.projectIDs = projectTree.getValue();
	} else {
		if (selectedProjects) {
			params.projectIDs = selectedProjects;
		}
	}
	if (itemTypeList) {
		params.itemTypeIDs = itemTypeList.getValue();
	} else {
		if (selectedItemTypes) {
			params.itemTypeIDs = selectedItemTypes;
		}
	}
	Ext.Ajax.request({
		url: 'fieldExpression!selectMatcher.action',
		params: params,
		scope: this,
		disableCaching:true,
		success: function(response){
			var responseJson = Ext.decode(response.responseText);
			if (valueComponent) {
				options.panel.remove(valueComponent);
			}
			if (responseJson.needMatcherValue && responseJson.valueRenderer) {
				var valueInsertPosition = 5;//a good default
				for (var i=0;i<options.panel.items.getCount();i++) {
					var fieldExpressionComponent = options.panel.items.getAt(i);
					if (comboToInsertAfter===fieldExpressionComponent) {
						valueInsertPosition = i+1;//insert seems to be 1 based
					}
				}
				options.fieldExpression.needMatcherValue = responseJson.needMatcherValue;
				options.fieldExpression.valueRenderer = responseJson.valueRenderer;
				com.trackplus.admin.Filter.addValuePart(this, responseJson.valueRenderer, responseJson.jsonConfig, options.fieldExpression,
						options.panel, comboToInsertAfter, valueInsertPosition, contextFields);
			}
		},
		failure: function(result){
			Ext.MessageBox.alert(this.failureTitle, result.responseText);
		},
		method:"POST"
	});
};
/**
 * Reload the matcher and value part of an "in tree" filter expression after changing the field
 */
com.trackplus.admin.Filter.selectField = function(combo, records, options) {
	var matcherComponentName = options.fieldExpression.matcherItemId;
	var matcherID = null;
	var matcherComponent = null;
	if (matcherComponentName) {
		matcherComponent = options.panel.getComponent(matcherComponentName);
		if (matcherComponent) {
			matcherID = matcherComponent.getValue();
		}
	}
	var valueComponentItemId = options.fieldExpression.valueItemId;
	var valueComponent = null;
	if (valueComponentItemId) {
		valueComponent = options.panel.getComponent(valueComponentItemId);
	}
	var index = options.fieldExpression.index;
	params = {
		index: index,
		fieldID: combo.getValue(),
		matcherID: matcherID,
		//stringValue: value,//do not maintain the value because a select controls option value may be transformed to integer control value
		issueFilter: this.issueFilter,
		instant:  this.instant
	};
	var contextFields = options.contextFields;
	if (contextFields) {
		var projectTree = contextFields.projectTree;
		if (projectTree) {
			params.projectIDs = projectTree.getValue();
		}
		var itemTypeList = contextFields.itemTypeList;
		if (itemTypeList) {
			params.itemTypeIDs = itemTypeList.getValue();
		}
	}
	Ext.Ajax.request({
		url: 'fieldExpression!selectField.action',
		params: params,
		scope: this,
		disableCaching:true,
		success: function(response){
			var responseJson = Ext.decode(response.responseText);
			if (matcherComponent) {
				matcherComponent.store.loadData(responseJson.matcherList);
				//actualize also the fieldExpression's matcherList used by ADD button
				//options.fieldExpression.matcherList = responseJson.matcherList;
				matcherComponent.setValue(responseJson.matcher);
			}
			if (valueComponent) {
				options.panel.remove(valueComponent);
			}
			if (responseJson.needMatcherValue && responseJson.valueRenderer) {
				var valueInsertPosition = 5;
				for (var i=0;i<options.panel.items.getCount();i++) {
					var fieldExpressionComponent = options.panel.items.getAt(i);
					if (matcherComponent===fieldExpressionComponent) {
						valueInsertPosition = i+1;//insert seems to be 1 based
					}
				}
				options.fieldExpression.needMatcherValue = responseJson.needMatcherValue;
				options.fieldExpression.valueRenderer = responseJson.valueRenderer;
				com.trackplus.admin.Filter.addValuePart(this, responseJson.valueRenderer, responseJson.jsonConfig,
						options.fieldExpression, options.panel, matcherComponent, valueInsertPosition, contextFields);
			}
		},
		failure: function(result){
			Ext.MessageBox.alert(this.failureTitle, result.responseText);
		},
		method:"POST"
	});
};
/**
 * Configures and adds the value part (the dynamic part) to the filter expressions by first rendering of
 * simple or "in tree" field expressions and after changing the matcher or the field
 */
com.trackplus.admin.Filter.addValuePart = function(scope, valueRenderer, jsonConfig, fieldExpression,
		expressionPanel, matcherCombo, insertPosition, contextFields) {
	if (fieldExpression.needMatcherValue && fieldExpression.valueRenderer && fieldExpression.valueRenderer!=="") {
		if (jsonConfig) {
			//the jsonConfig coming from the server for each fieldExpression or after a matcher or field change
			var valueComponent=Ext.create(valueRenderer, {jsonData:jsonConfig, itemId:fieldExpression.valueItemId});
			if (valueComponent) {
				if (valueComponent.addListeners) {
					valueComponent.scope = scope;
					valueComponent.selectHandler=com.trackplus.admin.Filter.selectMatcher;
					valueComponent.fieldExpression = fieldExpression;
					valueComponent.expressionPanel = expressionPanel;
					valueComponent.matcherCombo = matcherCombo;
					valueComponent.contextFields = contextFields;
					valueComponent.addListeners();
				}
				if (CWHF.isNull(insertPosition)) {
					expressionPanel.add(valueComponent);
				} else {
					expressionPanel.insert(insertPosition, valueComponent);
				}
			}
		}
	}
};
/**
 * Set the values on replace window when the data is available
 */
com.trackplus.admin.Filter.replacePostDataProcess =	function(data, panel) {
	var replaceLabel =  panel.getComponent('replacementWarning');
	replaceLabel.setText(data.replacementWarning, false);
	var replacementID = panel.getComponent('replacementID');
	//tree picker instead of plain list
	//replacementList.store.loadData(data.replacementList);
	//replacementList.setValue(null);
	replacementID.labelEl.dom.innerHTML = data.replacementListLabel;
};
/**
 * Whether the filter contains parameter(s)
 */
com.trackplus.admin.Filter.executeFilter = function(scope, filterID, ajax) {
	Ext.Ajax.request({
		url: 'filterParameters!containsParameter.action',
		params: {
			filterID: filterID
		},
		scope: scope,
		disableCaching:true,
		success: function(response){
			var data = Ext.decode(response.responseText);
			var containsParameter = data.success;
			if (containsParameter) {
				com.trackplus.admin.Filter.renderFilterParameter(scope, filterID,ajax);
			} else {
				com.trackplus.admin.Filter.executeParameterlessFilter(filterID,ajax);
			}
		},
		failure: function(result){
			Ext.MessageBox.alert(scope.failureTitle, result.responseText);
		},
		method:"POST"
	});
};
/**
 * Render the filter parameters
 */
com.trackplus.admin.Filter.renderFilterParameter = function(scope, filterID,ajax) {
	var title = getText('admin.customize.queryFilter.lbl.parameters');
	var width = 1000;
	var height = 800;
	var windowItems = com.trackplus.admin.Filter.getTreeFilterParameterItems();
	var loadUrl = 'filterParameters!renderParameters.action';
	var loadUrlParams = {filterID:filterID};
	var submitUrl = 'savedFilterExecute!replaceSubmittedParameters.action';
	var submitUrlParams = {
		filterID:filterID,
		ajax:ajax
	};
	var windowConfig = Ext.create('com.trackplus.util.WindowConfig',
			{postDataProcess:com.trackplus.admin.Filter.postLoadProcessTreeFilterParameters});
	windowConfig.showWindow(scope, title, width, height,
			{loadUrl:loadUrl, loadUrlParams:loadUrlParams},
			{submitUrl:submitUrl,
			submitUrlParams:submitUrlParams,
			submitButtonText:getText('common.btn.applyFilter'),
			standardSubmit:CWHF.isNull(ajax)||ajax===false},
			windowItems);
};
/**
 * Execute the parameterless filter
 */
com.trackplus.admin.Filter.executeParameterlessFilter = function(filterID,ajax) {
	var dummyForm = Ext.create('Ext.form.Panel', {
		items:[],
		url:'itemNavigator.action',
		baseParams: {
			queryType:1,//SAVED
			queryID: filterID,
			previousQuery:false,
			ajax:ajax
		},
		standardSubmit:CWHF.isNull(ajax)||ajax===false});
		dummyForm.getForm().submit();
};
/**
 * Render the filter parameters
 */
com.trackplus.admin.Filter.generateFilterLink = function(scope, node) {
	var title = getText('admin.customize.queryFilter.lbl.filterURL.report.encodedUrl');
	var width = 500;
	var height = 300;
	var windowItems = com.trackplus.admin.Filter.getFilterLinkItems();
	var loadUrl = 'filterLink.action';
	var loadUrlParams = {node:node};
	var windowConfig = Ext.create('com.trackplus.util.WindowConfig',{
		postDataProcess:com.trackplus.admin.Filter.postLoadProcessFilterLink,
		cancelButtonText:getText('common.btn.done')
	});
	windowConfig.showWindow(scope, title, width, height,
			{loadUrl:loadUrl, loadUrlParams:loadUrlParams},
			null, /*null,*/ windowItems);
};
/**
* Prepare adding/editing tree filter parameters
*/
com.trackplus.admin.Filter.getFilterLinkItems = function() {
	return [
		CWHF.getRadioGroup(null, 400,[{ boxLabel: getText("admin.customize.queryFilter.lbl.filterURL.reportOverviewLink"),
					name: 'urlType', inputValue: '1', checked: true },
				{ boxLabel: getText("admin.customize.queryFilter.lbl.filterURL.changesMavenPluginLink"),
					name: 'urlType', inputValue: '2', checked: false}],{itemId:'urlTypeRadio'}),
		CWHF.createCheckbox(
			"admin.customize.queryFilter.lbl.filterURL.encodeUserPassword",
			"encodePassword",
			{itemId:'encodePassword',
				disabled:false,
				checked:true,
				labelWidth:200}),
		CWHF.createCheckbox(
				"admin.customize.queryFilter.lbl.filterURL.keepMeLogged",
				"keepMeLogged",
				{itemId:'keepMeLogged',
				disabled:false,
				labelWidth:200}),
		CWHF.createTextAreaField(null, "filterLinkTextArea",{
			itemId: "filterLinkTextArea",
			anchor:'100% -45',
			listeners:{
				'render':{
					fn:function (comp) {
						comp.getEl().on('contextmenu', function(e){e.stopPropagation();}, null, {preventDefault: false});
					}
				}
			}
		})
	];
};
/**
 * Post process the data after filter parameter data has arrived containing the combo data sources and field expression configs .
 */
com.trackplus.admin.Filter.postLoadProcessFilterLink = function(data, panel) {
	var filterLinkTextArea = panel.getComponent("filterLinkTextArea");
	if (data["filterParams"]) {
		filterLinkTextArea.anchor='100% -70';
		panel.insert(1, CWHF.createCheckbox(
					"admin.customize.queryFilter.lbl.filterURL.showParameters",
					"showParameters",
					{itemId:'showParameters',
					labelWidth:200},
					{change: {fn:com.trackplus.admin.Filter.changeLinkType, scope:this, panel:panel, data:data}}));
	}
	var urlType = panel.getComponent("urlTypeRadio");
	if (urlType) {
		urlType.on("change", com.trackplus.admin.Filter.changeLinkType, this, {panel:panel, data:data});
	}
	var keepMeLogged = panel.getComponent("keepMeLogged");
	if (keepMeLogged) {
		keepMeLogged.on("change", com.trackplus.admin.Filter.changeLinkType, this, {panel:panel, data:data});
	}
	var encodePassword= panel.getComponent("encodePassword");
	if (encodePassword) {
		encodePassword.on("change", com.trackplus.admin.Filter.changeEncodePassword, this, {panel:panel, data:data});
	}
	filterLinkTextArea.setValue(data["filterUrlIssueNavigator"]);
};
/**
 * Set the URL after the link type is changed
 */
com.trackplus.admin.Filter.changeLinkType = function(radioGroupOrCheckbox, newValue, oldValue, options) {
	var panel = options.panel;
	var data = options.data;
	if (panel) {
		var filterLinkValue = null;
		var keepMeLogged = panel.getComponent("keepMeLogged");
		var encodePassword = panel.getComponent("encodePassword");
		var urlType = panel.getComponent("urlTypeRadio");
		var checkedArr = urlType.getChecked();
		var filterUrlChecked = false;
		var checkedRadio;
		if (checkedArr.length>0) {
			checkedRadio = checkedArr[0];
			if (checkedRadio.getSubmitValue()===1) {
				filterUrlChecked = true;
				keepMeLogged.setDisabled(false);
				encodePassword.setDisabled(false);
				if(encodePassword.getValue()===false){
					filterLinkValue = data["filterUrlIssueNavigatorNoUser"];
				}else{
					if (keepMeLogged.getValue()) {
						filterLinkValue = data["filterUrlIssueNavigatorKeep"];
					} else{
						filterLinkValue = data["filterUrlIssueNavigator"];
					}
				}
			} else {
				filterLinkValue = data["filterUrlMavenPlugin"];
				keepMeLogged.setDisabled(true);
				encodePassword.setDisabled(true);
			}
		}
		var showParameters = panel.getComponent("showParameters");
		if (showParameters) {
			if (showParameters.getValue()) {
				filterLinkValue = filterLinkValue+"&"+data["filterParams"];
			}
		}
		var filterLinkTextArea = panel.getComponent("filterLinkTextArea");
		if (filterLinkTextArea) {
			filterLinkTextArea.setValue(filterLinkValue);
		}
		if (keepMeLogged.getValue() && filterUrlChecked) {
			filterLinkTextArea.inputEl.setStyle("color", "red");
		} else {
			filterLinkTextArea.inputEl.setStyle("color", "black");
		}
	}
};
com.trackplus.admin.Filter.changeEncodePassword=function(radioGroupOrCheckbox, newValue, oldValue, options) {
	var panel = options.panel;
	var data = options.data;
	var filterLinkValue = null;
	if (panel) {
		var keepMeLogged = panel.getComponent("keepMeLogged");
		var encodePassword = panel.getComponent("encodePassword");
		if(encodePassword.getValue()){
			keepMeLogged.setDisabled(false);
			if (keepMeLogged.getValue()) {
				filterLinkValue = data["filterUrlIssueNavigatorKeep"];
			} else{
				filterLinkValue = data["filterUrlIssueNavigator"];
			}
		}else{
			filterLinkValue = data["filterUrlIssueNavigatorNoUser"];
			keepMeLogged.setValue(false);
			keepMeLogged.setDisabled(true);
		}
		var filterLinkTextArea = panel.getComponent("filterLinkTextArea");
		if (filterLinkTextArea) {
			filterLinkTextArea.setValue(filterLinkValue);
		}
		if (keepMeLogged.getValue() && filterUrlChecked) {
			filterLinkTextArea.inputEl.setStyle("color", "red");
		} else {
			filterLinkTextArea.inputEl.setStyle("color", "black");
		}
	}
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.IssueListViewDescriptor',{
	extend:'Ext.Base',
	config: {
		id:'',
		enabledColumnChoose:false,
		enabledGrouping:false,
		useLongFields:false,
		name:'',
		description:'',
		jsClass:null,
		iconCls:null,
		plainData:false
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	}
});
Ext.define('com.trackplus.itemNavigator.IssueListViewPlugin',{
	extend:'Ext.util.Observable',
	config: {
		id:'',
		descriptor:null,
		model:null,
		pluginCls:null,
		settingsVisible:false,
		plainGrid:false
	},
	view:null,
	/**
	 * @cfg {Function} refreshData
	 * @param {Object} data
	 */
	refreshData: function(data){
	},
	dataChangeSuccess:function(opts){
	},
	containsFields:function(fields){
		var me=this;
		if(fields){
            //TOTAL_EXPENSE_COST = -1100
            //TOTAL_EXPENSE_TIME = -1101
            // TOTAL_PLANNED_COST = -1300;
            //TOTAL_PLANNED_TIME = -1301;
            //REMAINING_PLANNED_COST = -1400;
            //REMAINING_PLANNED_TIME = -1401;
			var hardCodedRefreshFields=[-1100,-1101,-1300,-1301,-1400,-1401];
			for(var i=0;i<fields.length;i++){
				if(Ext.Array.indexOf(hardCodedRefreshFields,fields[i])!==-1){
					return true;
				}
				if(me.containsOneField(fields[i])){
					return true;
				}
			}
		}
		return false;
	},
	containsOneField:function(fieldID){
	    var me=this;
		var shortFields=me.model.layout.shortFields;
		for(var i=0;i<shortFields.length;i++){
			if(shortFields[i].reportField===fieldID){
				return true;
			}
		}
		if(me.descriptor.useLongFields){
			var longFields=me.model.layout.longFields;
			for(var i=0;i<longFields.length;i++){
				if(longFields[i].reportField===fieldID){
					return true;
				}
			}
		}
		return false;
	},
	createSettingsPanel:function(btnGroup, btnChooseColumns, btnSaveAsStandardLayout, btnUseStandardLayout, btnSaveAsFilterLayout){
		var me=this;
		var items=me.getSettingsToolbarItems(btnGroup, btnChooseColumns, btnSaveAsStandardLayout, btnUseStandardLayout, btnSaveAsFilterLayout);
		return Ext.create('Ext.toolbar.Toolbar', {
			region:'north',
			layout: {
				overflowHandler: 'Menu'
			},
			enableOverflow: true,
			cls:'toolbarActions',
			border: '0 0 1 0',
			//hidden:!me.settingsVisible,
			defaults: {
				cls:'toolbarItemAction',
				scale:'small',
				iconAlign: 'left',
				enableToggle:false
			},
			items:items
		});
	},
	getSettingsToolbarItems:function(btnGroup, btnChooseColumns, btnSaveAsStandardLayout, btnUseStandardLayout, btnSaveAsFilterLayout){
		var me=this;
		var items=new Array();
		items.push(btnGroup);
		items.push(btnChooseColumns);
		//items.push('->');
		if (btnSaveAsStandardLayout) {
			items.push(btnSaveAsStandardLayout);
		}
		if (btnUseStandardLayout) {
			items.push(btnUseStandardLayout);
		}
		if (btnSaveAsFilterLayout) {
			items.push(btnSaveAsFilterLayout);
		}
		return items;
	},
	getSettingsHeight:function(){
		return 27;
	},
	/**
	 * @cfg {Function} createView
	 *
	 */
	createView:function(){
		return Ext.create('Ext.panel.Panel',{
			html:'Implement me!'
		});
	},
	destroyView:function(){
	},
	/**
	 * @cfg {Function} getSelectedIssues
	 *
	 */
	getSelectedIssues:function(){
		return null;
	},
	selectItemByIndex:function(workItemIndex){
	},
	selectItem:function(workItemID,isArray){
	},
	deselectItem:function(workItemID,isArray){
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		//me.events=[];
		this.listeners = config.listeners;
		com.trackplus.itemNavigator.IssueListViewPlugin.superclass.constructor.call(this, config);
	},
	getPopupMenuItems:function(rowData,grid,index,record){
		return null;
	},
	destroy:function(){
		var me=this;
		me.id=null;
		me.descriptor=null;
		me.model=null;
		me.pluginCls=null;
		me.clearListeners();
		if(me.view){
			me.view.clearListeners.call(me.view);
			me.view.removeAll.call(me.view,true);
			me.view.destroy.call(me.view);
			me.view=null;
		}
	},
	createFields:function(){
		var me=this;
		var fields=[];
		var shortFields=me.model.layout.shortFields;
		var sfield;
		for(var i=0;i<shortFields.length;i++){
			sfield=shortFields[i];
			fields.push({name:'f'+sfield.reportField,type:sfield.extJsType,allowNull:true});
			if(sfield.so===true){
				var type='int';
				if(sfield.soType){
					type=sfield.soType;
				}
				fields.push({name:'f_so'+sfield.reportField,type:type,allowNull:true});
			}
		}
		fields.push({name:'group',type:'boolean'});
		fields.push({name:'accessLevelFlag',type:'boolean'});
		fields.push({name:'editable',type:'boolean'});
		fields.push({name:'linkable',type:'boolean'});
		fields.push({name:'notEditableFields'});
		fields.push({name:'leaf',type:'boolean'});
		fields.push({name:'workItemID',type:'int',allowNull:true});
		fields.push({name:'attachmentIds'});
		fields.push({name:'workItemIndex',type:'int',allowNull:true});
		fields.push({name:'projectID',type:'int'});
		fields.push({name:'issueTypeID',type:'int'});
		fields.push({name:'parentID',type:'int',allowNull:true});
		fields.push({name:'originatorID',type:'int'});
		fields.push({name:'projectName'});
		fields.push({name:'longFields'});
		fields.push({name:'iconCls'});
		fields.push({name:'cssColorClass'});
		fields.push({name:'cssColorClassGroup'});
		fields.push({name:'queryFieldCSS'});
		fields.push({name:'Name'});
		return fields;
	},
	createColumn:function(i,layoutData,sortable,useTree){
		var me=this;
		var colType='Ext.grid.column.Column';
		var colID='ID_'+layoutData.id;
		if(i===0&&useTree){
			colType='Ext.tree.Column';
		}
		var colHeader='&nbsp;';
		var colCls=null;
		var colResizable=true;
		var align='left';
		if(i===0&&useTree){
			colHeader='&nbsp;<span class="expandAll" id="rowExpandAllTrg">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="collapseAll" id="rowCollapseAllTrg">&nbsp;&nbsp;&nbsp;&nbsp;</span>&nbsp;&nbsp;'+layoutData.label;
		}else{
			if(layoutData.renderContentAsImg===true||layoutData.reportField===-1001){
				colCls='headerIcon headerIcon'+layoutData.reportField;
				if(layoutData.reportField!==-10001){
					colResizable=false;
				}
				if (layoutData.fieldIsCustomIcon) {
					colCls='headerIcon headerIcon-customOption';
					//true beacause multiple icons are possible
					colResizable=true;
				}
				align='center';
			}else{
				colHeader=layoutData.label;
			}
		}
		var colCfg={
			text:colHeader,
			draggable :true,//(i!==0),
			hideable:(i!==0),
			menuDisabled:true,
			width:layoutData.fieldWidth,
			dataIndex:'f'+layoutData.reportField,
			fieldID: layoutData.reportField,
			fieldIsCustomIcon: layoutData.fieldIsCustomIcon,
			itemId:'R_'+layoutData.id,
			sortable:sortable,
			sortWithSO:(layoutData.so===true),
			hidden:false,//layoutData.hidden,
			tdCls:'simpleTreeGridCell',
			id:colID,
			cls:colCls,
			align:align,
			resizable:colResizable
		};
		var col=Ext.create(colType,colCfg);
		if(layoutData.so===true){
			col.getSortParam=function(){
				return 'f_so'+this.dataIndex.substring(1);
			};
		}
		if(i===0&&me.plainGrid===true){
			col.renderer=function(value,metaData,record,rowIndex,colIndex,store,view){
				var iconCls=record.data.iconCls;
				return '<img class="x-tree-icon '+iconCls+'" role="presentation" src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==">'+
					'<span class="x-tree-node-text">'+value+'</span>';
			};
		}
		/*if(com.trackplus.TrackplusConfig.mobile===true&&
			layoutData.reportField===17&&i!==0){
			//synopsis
			col.renderer=function(value,metaData,record,rowIndex,colIndex,store,view){
				var urlStr='printItem.action?key='+record.data.workItemID;
				var synopsisClass='synopsis_blue newWindow';
				return '<a href="'+urlStr+'" class="'+synopsisClass+'" target="printItem'+record.data.workItemID+'">'+value+'</a>';
			};
		}*/
		if(layoutData.reportField===-1001){//attachments
			if(i===0){
				col.renderer = function (value, metaData, record, rowIndex, colIndex, store, view) {
					if(record.data['group']===true) {
						return record.data['Name'];
					}else{
						if (CWHF.isNull(value)) {
							return "";
						}
						return '<a href="javaScript:openAttachments(' + record.data.workItemID + ',&quot;' + record.data['attachmentIds'] + '&quot;)" class="downloadAttachments">' + value + '</a>';
					}
				};
			}else {
				col.renderer = function (value, metaData, record, rowIndex, colIndex, store, view) {
					if (CWHF.isNull(value)) {
						return "";
					}
					return '<a href="javaScript:openAttachments(' + record.data.workItemID + ',&quot;' + record.data['attachmentIds'] + '&quot;)" class="downloadAttachments">' + value + '</a>';
				};
			}
		}
		if(layoutData.renderContentAsImg===true&&i!==0){
			var fieldWidth = layoutData["fieldWidth"];
			if (CWHF.isNull(fieldWidth)) {
				col.width=25;
			} else {
				col.width=fieldWidth;
			}
			col.tdCls='iconTreeGridCell';
			col.renderer=function(value,metaData,record,rowIndex,colIndex,store,view){
				var myIndex=colIndex;
				if(me.model.layout.bulkEdit){
					myIndex=colIndex-1;
				}
				var reportField=this.columns[myIndex].dataIndex.substring(1);
				var fieldIsCustomIcon = this.columns[myIndex].fieldIsCustomIcon;
				if (reportField===-1006 || reportField===-1010){
					//private symbol
					if (reportField===-1006) {
						if(value&&value!==''){
							return '<img src="'+com.trackplus.TrackplusConfig.icon16Path+value+'">';
						}else{
							return '';
						}
					} else {
						//overflow icons
						if (reportField===-1010) {
							if (value && value.length>0) {
								var selectedValues = value.split(",");
								//valuesArr = value.split()
								var outOfBoundIcons = "";
								Ext.Array.forEach(selectedValues, function(option) {
									if (option) {
										var srcImg='<img src="'+com.trackplus.TrackplusConfig.icon16Path+option+'">';
										outOfBoundIcons = outOfBoundIcons + srcImg;
									}
								}, this);
								return outOfBoundIcons;
							} else {
								return '';
							}
						}
					}
				}else{
					if(value&&value!==''){
						if (fieldIsCustomIcon) {
							var selectedValues = value.split(",");
							var images = "";
							Ext.Array.forEach(selectedValues, function(option) {
								if (option) {
									var srcImg="optionIconStream.action?&optionID="+option;
									images = images + '<img src="'+srcImg+'">';
								}
							} , this);
							return images;
						} else {
							var srcImg="optionIconStream.action?fieldID="+reportField+"&optionID="+value;
							return '<img src="'+srcImg+'" ">';
						}
					}else{
						return "";
					}
				}
			};
		}
		return col;
	},
	createSelModel:function(){
		var me=this;
		me.useSelectionModel=me.model.layout.bulkEdit;
		var selModel=null;
		if(me.model.layout.bulkEdit===true){
			selModel=Ext.create('com.trackplus.itemNavigator.CheckboxModel',{
				allowDeselect:true,
				checkOnly:false,
				mode:'MULTI'
			});
		}
		return selModel;
	},
	columnMoveHandler:function(ct,column,fromIdx,toIdx){
		var me=this;
		var urlStr="layoutColumns!moveColumn.action";
		var layoutID=column.itemId.substring(2);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===false){
					var msg=getText(jsonData.errorMessage);
					CWHF.showMsgError(msg);
				}
				me.fireEvent.call(me,'layoutchange');
			},
			failure: function(response){
				com.trackplus.util.requestFailureHandler(result);
			},
			method:'POST',
			//index in layout start from 1.
			params:{
				layoutID:layoutID,
				fromIdx:fromIdx,
				toIdx:toIdx,
				filterType:me.model.queryContext.queryType,
				filterID:me.model.queryContext.queryID
			}
		});
	},
	onGridSelectionChange:function(sm, selections){
		var me=this;
		me.fireEvent.call(me,'selectionchange',selections);
		return false;
	},
	getRowClass: function(record, rowIndex, rp, ds){
     	var me=this;
		var cls="";
		if(record.data['group']===true){//grouping
			cls+=" reportsTableGrouping";
			if(record.data['cssColorClassGroup']){
				cls+=" "+record.data['cssColorClassGroup'];
			}
		}
		if(record.data['cssColorClass']){
			cls+=" "+record.data['cssColorClass'];
		}
		if(me.queryFieldCSS&&record.data['queryFieldCSS']){
			cls+=' queryFieldCSS rowCls_'+me.queryFieldCSS+"_"+ record.data['queryFieldCSS'];
		}
		return cls;
     },
	updatePossibleFieldOptions:function(jsonData,extraParams){
	}
});
Ext.define('com.trackplus.itemNavigator.IssueListViewFacade',{
	extend:'Ext.Base',
	config: {
		descriptor:null,
		model:null,
		itemNavigatorController:null,
		queryContext:null
	},
	listViewPlugin:null,
	settingsPanel:null,
	filterPanel:null,
	settingsHeight:null,
	view:null,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	destroy:function(){
		var me=this;
		if(me.listViewPlugin){
			me.listViewPlugin.destroyView.call(me.listViewPlugin);
		}
		me.listViewPlugin=null;
		me.descriptor=null;
		me.model=null;
		delete me.listViewPlugin;
		delete me.descriptor;
		delete me.model;
	},
	createView:function(model,settingsVisible){
		var me=this;
		me.model=model;
		var pluginCls=me.descriptor.jsClass;
		if(me.listViewPlugin){
			me.listViewPlugin.destroyView.call(me.listViewPlugin);
		}
		if(CWHF.isNull(me.listViewPlugin)){
			me.listViewPlugin=Ext.create(pluginCls,{
				descriptor:me.descriptor,
				model:me.model,
				settingsVisible:settingsVisible,
				itemNavigatorController:me.itemNavigatorController
			});
			me.addViewPluginListeners();
		}
		me.listView=me.listViewPlugin.createView.call(me.listViewPlugin);
		var btnGroup=Ext.create('Ext.button.Button',{
			//margin:'3 5 3 3',
			//id:'btnGroupBy',
			iconCls:'group',
			//itemId:'btnGroupByItemID',
			hidden:(me.descriptor.enabledGrouping===false),
			text:getText('itemov.lbl.groupBy'),
			tooltip:getText('itemov.lbl.groupBy'),
			handler:function(){
				me.itemNavigatorController.showGroupByPopup.call(me.itemNavigatorController);
			}
		 });
		 var btnChooseColumns=Ext.create('Ext.button.Button',{
			//margin:'3 5 3 3',
			//id:'btnChooseColumns',
			iconCls:'column',
			//itemId:'btnChooseColumnsItemID',
			hidden:(me.descriptor.enabledColumnChoose===false),
			text:getText('itemov.lbl.chooseColumns'),
			tooltip:getText('itemov.lbl.chooseColumns'),
			handler:function(){
				 me.itemNavigatorController.showColumnsPopup.call(me.itemNavigatorController);
			}
		 });
		 var btnSaveAsStandardLayout = null;
		 if (com.trackplus.TrackplusConfig.user.sys||com.trackplus.TrackplusConfig.user.projectAdmin) {
			 btnSaveAsStandardLayout=Ext.create("Ext.button.Button",{
					text:getText('itemov.btn.saveAsStandardLayout'),
					overflowText:getText('itemov.btn.saveAsStandardLayout'),
					tooltip:getText('itemov.btn.saveAsStandardLayout'),
					iconCls: me.descriptor.iconCls,
					handler:function(){
						me.saveAsStandardLayout.call(me);
					}
				});
			 }
		 var btnUseStandardLayout=Ext.create("Ext.button.Button",{
				text:getText('itemov.btn.useStandardLayout'),
				overflowText:getText('itemov.btn.useStandardLayout'),
				tooltip:getText('itemov.btn.useStandardLayout'),
				iconCls: me.descriptor.iconCls,
				handler:function(){
					me.useStandardLayout.call(me);
				}
			});
		 var btnSaveAsFilterLayout=Ext.create("Ext.button.Button",{
				text:getText('itemov.btn.saveAsFilterLayout'),
				overflowText:getText('itemov.btn.saveAsFilterLayout'),
				tooltip:getText('itemov.btn.saveAsFilterLayout'),
				iconCls: me.descriptor.iconCls,
				handler:function(){
					me.saveAsFilterLayout.call(me);
				}
			});
		 	if (me.model.isFilterView===true) {
		 		if (btnSaveAsStandardLayout) {
		 			btnSaveAsStandardLayout.setVisible(false);
		 		}
		 		btnUseStandardLayout.setVisible(false);
		 		var maySaveFilterLayout=me.model.maySaveFilterLayout;
				btnSaveAsFilterLayout.setVisible(maySaveFilterLayout/*true*/);
				/*if(maySaveFilterLayout===true){
					//only save as filter
					btnSaveAsFilterLayout.setDisabled(false);
				} else {
					//nothing
					btnSaveAsFilterLayout.setDisabled(true);
				}*/
			} else {
				btnSaveAsFilterLayout.setVisible(false);
				if (btnSaveAsStandardLayout) {
		 			btnSaveAsStandardLayout.setVisible(true);
		 		}
				btnUseStandardLayout.setVisible(true);
			}
		me.settingsPanel=me.listViewPlugin.createSettingsPanel(btnGroup, btnChooseColumns, btnSaveAsStandardLayout, btnUseStandardLayout, btnSaveAsFilterLayout);
		Ext.apply(me.settingsPanel, {
			region:'north',
			hidden:!settingsVisible
		});
		me.settingsHeight= me.listViewPlugin.getSettingsHeight();
		me.view=Ext.create('Ext.panel.Panel',{
			layout:'border',
			border:false,
			bodyBorder:false,
			items:[me.settingsPanel,me.listView]
		});
		return me.view;
	},
	useStandardLayout:function(){
		var me=this;
		var urlStr="itemNavigator!useStandardLayout.action";
		me.itemNavigatorController.refresh.call(me.itemNavigatorController,urlStr,null,true);
		//me.refresh(urlStr,null,true);
	},
	saveAsStandardLayout:function(){
		var urlStr="itemNavigator!saveAsStandardLayout.action";
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('itemov.msg.saveAsStandardLayoutSuccess'));
			},
			failure: function(){
				borderLayout.setLoading(false);
				CWHF.showMsgError('Failure');
			},
			method:'POST'
		});
	},
	saveAsFilterLayout:function(){
		var urlStr="itemNavigator!saveAsFilterLayout.action";
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('itemov.msg.saveAsFilterLayoutSuccess'));
			},
			failure: function(){
				borderLayout.setLoading(false);
				CWHF.showMsgError('Failure');
			},
			method:'POST'
		});
	},
	viewContainsFields:function(fields){
		var me=this;
		if(me.listViewPlugin){
			return me.listViewPlugin.containsFields(fields);
		}
		return false;
	},
	getView:function(model){
		var me=this;
		if(model){
			me.model=model;
		}
		if(CWHF.isNull(me.view)){
			me.createView(me.model);
		}
		return me.view;
	},
	addViewPluginListeners:function(){
		var me=this;
		me.listViewPlugin.addListener('datachange',me.onDataChange,me);
		me.listViewPlugin.addListener('layoutchange',me.onLayoutChange,me);
		me.listViewPlugin.addListener('sortchange',me.onSortChange,me);
		me.listViewPlugin.addListener('itemcontextmenu',me.onItemContextMenu,me);
		me.listViewPlugin.addListener('itemdblclick',me.onItemDblClick,me);
		me.listViewPlugin.addListener('selectionchange',me.onSelectionChange,me);
		me.listViewPlugin.addListener('totalChange',me.onTotalChange,me);
		me.listViewPlugin.addListener('startDragItems',me.onStartDragItems,me);
		me.listViewPlugin.addListener('afterDropItems',me.onAfterDropItems,me);
	},
	onDataChange:function(opts){
		var me=this;
		//urlStr,queryContextID,createView,
		me.itemNavigatorController.refresh.call(me.itemNavigatorController,null,null,false,function(){
			//here the scope is ItemNavigatorController
			var listViewPlugin=this.issueListFacade.listViewPlugin;
			listViewPlugin.dataChangeSuccess.call(listViewPlugin,opts);
		});
	},
	onLayoutChange:function(){
		var me=this;
		me.itemNavigatorController.changeLayout.call(me.itemNavigatorController);
	},
	onSortChange:function(sort){
		var me=this;
		me.itemNavigatorController.sortChange.call(me.itemNavigatorController,sort)
	},
	onSelectionChange:function(selections){
		var me=this;
		me.itemNavigatorController.issueSelectionChange.call(me.itemNavigatorController,selections);
	},
	onItemContextMenu:function(data,event,grid,index,record){
		var me=this;
		var workItemID=data.workItemID;
		if(workItemID&&workItemID!==-1){
			var popupMenu=me.createPopup.call(me,data,grid,index,record);
			if(popupMenu){
				popupMenu.showAt(event.getXY());
				me.listViewPlugin.selectItem(workItemID);
			}
		}
	},
	onItemDblClick:function(data,animateTarget){
		var me=this;
		if(me.listViewPlugin.$className !== 'com.trackplus.itemNavigator.GanttViewPlugin') {
			me.openEditDlg(data, animateTarget);
		}else {
			if(!me.listViewPlugin.isNewSelectedTask()) {
				if(me.listViewPlugin.ganttController.isChartContainsUnsavedItems()) {
					me.listViewPlugin.ganttController.showSaveDialogWarningIfChartContainsUnsavedItems(me, me.openEditDlg, null, [data, animateTarget]);
				}else {
					me.openEditDlg(data, animateTarget);
				}
			}
		}
	},
	openEditDlg:function(data,animateTarget){
		var me = this;
		var workItemID=data.workItemID;
		if(workItemID&&workItemID!==-1){
			var workItemIndex=data['workItemIndex'];
			var actionID=-2;//PRINT
			me.listViewPlugin.selectItem(workItemID);
			me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,actionID,null,workItemIndex/*,animateTarget*/);
		}
	},
	onTotalChange:function(totalCount,count){
		var me=this;
		me.itemNavigatorController.model.totalCount=totalCount;
		me.itemNavigatorController.model.count=count;
		me.itemNavigatorController.updateTotalCount();
	},
	onStartDragItems:function(workItems,selectedFieldIDs,extraParams){
		var me=this;
		var urlStr="possibleFieldOptions.action";
		if(CWHF.isNull(selectedFieldIDs)){
			selectedFieldIDs=new Array();
		}
		if(Ext.Array.indexOf(selectedFieldIDs,4)===-1){
			selectedFieldIDs.push(4);//STATE
		}
		if(me.itemNavigatorController.filterController.subFilterVisible===true){
			/*if(Ext.Array.indexOf(selectedFieldIDs,2)===-1){
				selectedFieldIDs.push(2);//ISSUETYPE
			}*/
			if(Ext.Array.indexOf(selectedFieldIDs,10)===-1){
				selectedFieldIDs.push(10);//PRIORITY
			}
		}
		var params={
			selectedItemIDs:workItems,
			selectedFieldIDs:selectedFieldIDs.join(",")
		};
		Ext.Ajax.request({
			disableCaching:true,
			url:urlStr,
			params:params,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				me.listViewPlugin.updatePossibleFieldOptions(jsonData,extraParams);
				me.itemNavigatorController.filterController.updatePossibleFieldOptions(jsonData);
			},
			failure: function(type, error){
			}
		});
	},
	onAfterDropItems:function(){
		var me=this;
		me.itemNavigatorController.filterController.onAfterDropItems();
	},
	refreshData:function(issues){
		var me=this;
		if(CWHF.isNull(me.listViewPlugin)){
			return null;
		}
		me.listViewPlugin.refreshData.call(me.listViewPlugin,issues);
	},
	setVisibleTools:function(b){
		var me=this;
		var toolPanel=me.settingsPanel;
		if(toolPanel){
			var el=toolPanel.getEl();
			var settingsHeight=me.settingsHeight;
			var gridEl=me.listView.getEl();
			var gridY=gridEl.getY();
			var gridHeight=gridEl.getHeight();
			if(b){
				gridEl.animate({
					top:settingsHeight,
					height:gridHeight-settingsHeight,
					duration:300,
					listeners:{
						'afteranimate':function(){
							toolPanel.setVisible(true);
							el.slideIn('t', {
								easing: 'easeOut',
								duration: 300,
								//remove: false,
								//useDisplay: false,
								listeners:{
									'afteranimate':function(){
										me.view.ownerCt.updateLayout();
									}
								}
							});
						}
					}
				});
			}else{
				el.slideOut('t', {
					easing: 'easeOut',
					duration: 300,
					listeners:{
						'afteranimate':function(){
							gridEl.animate({
								top:0,
								height:gridHeight+settingsHeight,
								duration:300,
								listeners:{
									'afteranimate':function(){
										toolPanel.setVisible(false);
										me.view.ownerCt.updateLayout();
									}
								}
							});
						}
					}
				});
			}
		}
	},
	//For Gantt
	addSaveButton: function(toolbarItemsArr) {
		var me = this;
		if(me.listViewPlugin){
			if(me.listViewPlugin.$className === 'com.trackplus.itemNavigator.GanttViewPlugin') {
				me.listViewPlugin.ganttController.addSaveButton();
			}
		}
    },
	//For Gantt
    addOrRemoveSaveButton: function(toolbarItems) {
    	var me = this;
    	if(me.listViewPlugin ){
			if(me.listViewPlugin.$className === 'com.trackplus.itemNavigator.GanttViewPlugin') {
				var items = borderLayout.getActiveToolbarList().items.items;
				var toolbar = borderLayout.getActiveToolbarList();
				for(var ind in items) {
					if(items[ind].itemId ) {
						if(items[ind].itemId === 'ganttSaveBtn') {
							toolbar.remove(items[ind]);
						}
					}
				}
				me.addSaveButton(toolbarItems);
			}else{
				var toolbar = borderLayout.getActiveToolbarList();
				var items = borderLayout.getActiveToolbarList().items.items;
				for(var ind in items) {
					if(items[ind].itemId ) {
						if(items[ind].itemId === 'ganttSaveBtn') {
							toolbar.remove(items[ind]);
						}
					}
				}
			}
		}
    },
	getSelectedIssues:function(){
		var me=this;
		return me.listViewPlugin.getSelectedIssues();
	},
	navigate:function(workItemID,workItemIndex,dir){
		var me=this;
		return me.listViewPlugin.navigate.call(me.listViewPlugin,workItemID,workItemIndex,dir);
	},
	selectItemByIndex:function(workItemIndex){
		var me=this;
		return me.listViewPlugin.selectItemByIndex.call(me.listViewPlugin,workItemIndex);
	},
	selectItem:function(workItemID){
		var me=this;
		if(me.listViewPlugin){
			return me.listViewPlugin.selectItem.call(me.listViewPlugin,workItemID);
		}
		return null;
	},
	deselectItem:function(workItemID){
		var me=this;
		return me.listViewPlugin.deselectItem.call(me.listViewPlugin,workItemID);
	},
	createPopup:function(rowData,grid,index,record){
		var me=this;
		if(me.popupMenu){
			me.popupMenu.destroy();
			me.popupMenu=null;
			delete me.popupMenu;
		}
		me.popupMenu = Ext.create('Ext.menu.Menu',{
			floating:true,
			items:me.getPopupMenuItems.call(me,rowData,grid,index,record),
			closeAction:'destroy'
		});
		return me.popupMenu;
	},
	getPopupMenuItems:function(rowData,grid,index,record){
		var me=this;
		var workItemID=rowData.workItemID;
		var workItemIndex=rowData.workItemIndex;
		var projectID=rowData.projectID;
		var issueTypeID=rowData.issueTypeID;
		var originatorID=rowData.originatorID;
		var parentID=rowData.parentID;
		var accessLevelFlag=rowData.accessLevelFlag;
		var items=[];
		var editable=rowData["editable"];
		var linkable=rowData["linkable"];
		var notEditableFields=rowData["notEditableFields"];
		var leaf = rowData["leaf"];
		var summaryItemsBehavior = true;
		if (me.model) {
			summaryItemsBehavior = me.model.summaryItemsBehavior;
		}
		var addExpense=(leaf || !summaryItemsBehavior)  && editable;
		if(addExpense && notEditableFields && notEditableFields.length>0){
			//public static final int MY_EXPENSE_COST = -1200;
			//public static final int MY_EXPENSE_TIME = -1201;
			var idx_MY_EXPENSE_COST=Ext.Array.indexOf(notEditableFields,-1200);
			var idx_MY_EXPENSE_TIME=Ext.Array.indexOf(notEditableFields,-1201);
			addExpense=(idx_MY_EXPENSE_COST===-1&&idx_MY_EXPENSE_TIME===-1);
		}
		if(editable){
			items.push({
				text: getText('common.btn.edit'),
				iconCls:'itemAction_edit16',
				handler: function(){
					me.taskEditHandler(workItemID, workItemIndex);
				}
			});
		}
		items.push({
			text: getText('item.action.viewInNewTab'),
			iconCls:'itemAction_viewAll16',
			handler: function(){
				var urlStr='printItem.action?key='+workItemID;
				window.open(urlStr,'printItem'+workItemID);
			}
		});
		items.push({
			text: getText('common.btn.copy'),
			iconCls:'itemAction_copy16',
			handler: function(){
				me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,-1,null,workItemIndex);
			}
		});
		if(editable){
			items.push({
				text: getText('common.btn.move'),
				iconCls:'itemAction_move16',
				handler:function(){
					me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,3,null,workItemIndex);
				}
			});
			items.push({
				text: getText('common.btn.changeStatus'),
				iconCls:'itemAction_changeStatus16',
				handler:function(){
					me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,5,null,workItemIndex);
				}
			});
		}
		items.push({
			text: getText('common.btn.addChild'),
			iconCls:'itemAction_addChild16',
			handler:function(){
				me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,4,null,workItemIndex,null,null,true);
			}
		});
		if(editable){
			items.push({
				text: getText('common.btn.chooseParent'),
				iconCls:'itemAction_parent16',
				handler:function(){
					me.itemNavigatorController.chooseParent.call(me.itemNavigatorController,rowData);
				}
			});
			if(parentID){
				items.push({
					text: getText('common.btn.removeParent'),
					iconCls:'itemAction_removeParent16',
					handler:function(){
						me.itemNavigatorController.executeAJAXItemAction.call(me.itemNavigatorController,'itemNavigator!removeParent.action?workItemID='+workItemID);
					}
				});
			}
		}
		if (editable && linkable) {
			items.push({
				text: getText('common.btn.addLinkedItem'),
				iconCls:'links16',
				handler:function(){
					/*addLinkFromContextMenu = {};
					addLinkFromContextMenu.projectID=rowData.projectID;
					addLinkFromContextMenu.issueTypeID=rowData.issueTypeID;*/
					addLinkFromContextMenu = true;
					me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,6,null,workItemIndex,null,null,true,addLinkFromContextMenu);
				}
			});
		}
		if(originatorID===com.trackplus.TrackplusConfig.userID){
			items.push({
				text: accessLevelFlag?getText('common.btn.unlock'):getText('common.btn.lock'),
				iconCls:'itemAction_lock16',
				handler:function(){
					me.executeAJAX('item!reverseAccessFlag.action?workItemID='+workItemID);
				}
			});
		}
		if(addExpense){
			items.push({
				text: getText('common.btn.addExpense'),
				iconCls:'cost16',
				handler:function(){
					me.addWorklog(workItemID,projectID,issueTypeID);
				}
			});
		}
		items.push({
			text: getText('common.btn.report'),
			iconCls:'itemAction_report16',
			handler:function(){
				//me.executeURL('reportConfig.action?fromIssueNavigator=true&workItemID='+workItemID);
				com.trackplus.admin.Report.executeReportFromIssueNavigator(workItemID);
			}
		});
		var pluginMenuItems=me.listViewPlugin.getPopupMenuItems.call(me.listViewPlugin,rowData,grid,index,record);
		if(pluginMenuItems){
			for(var i=0;i<pluginMenuItems.length;i++){
				items.push(pluginMenuItems[i]);
			}
		}
		return items;
	},
	taskEditHandler: function(workItemID, workItemIndex) {
		var me = this;
		if(me.listViewPlugin.$className !== 'com.trackplus.itemNavigator.GanttViewPlugin') {
			me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,2,null,workItemIndex);
		}else{
			if(!me.listViewPlugin.isNewSelectedTask()) {
				if(me.listViewPlugin.ganttController.isChartContainsUnsavedItems()) {
					me.listViewPlugin.ganttController.showSaveDialogWarningIfChartContainsUnsavedItems(me, me.taskEditHandler, null, [workItemID, workItemIndex]);
				}else {
					me.itemNavigatorController.executeItemAction.call(me.itemNavigatorController,workItemID,2,null,workItemIndex);
				}
			}
		}
	},
	addWorklog:function(workItemID,projectID,issueTypeID){
		var me=this;
		var worklogController=Ext.create('com.aurel.trackplus.itemDetail.WorklogController',{
			workItemID:workItemID,
			projectID:projectID,
			issueTypeID:issueTypeID,
			jsonData:{},
			refresh: me.itemNavigatorController.refresh,
			refreshScope:me.itemNavigatorController
		});
		worklogController.openWorklog.call(worklogController,getText("item.action.edit.title")+"&nbsp;"+workItemID+"&nbsp;"+getText("item.tabs.expense.editExpense.title.add"),null);
		/*worklogController.addModifyExpense.call(worklogController, me.itemNavigatorController,
				getText("item.action.edit.title")+"&nbsp;"+workItemID+"&nbsp;"+getText("item.tabs.expense.editExpense.title.add"),null);*/
	},
	executeAJAX:function(urlStr){
		var me=this;
		Ext.Ajax.request({
			url: urlStr,
			success: function(response){
				me.itemNavigatorController.refresh.call(me.itemNavigatorController);
			},
			failure:function(){
				alert("failure");
			}
		});
	},
	executeURL:function(urlStr){
		window.location.href=urlStr;
	}
});
Ext.define('com.trackplus.itemNavigator.CheckboxModel',{
	extend: 'Ext.selection.CheckboxModel',
	updateHeaderState: function() {
		var me = this,
			store = me.store,
			storeCount = store.getCount(),
			views = me.views,
			hdSelectStatus = false,
			selectedCount = 0,
			selected, len, i;
		var selectedGroups=0;
		var items = me.store.getRange();
		for(var i=0;i<items.length;i++){
			if(items[i].get('group')===true){
				selectedGroups++;
			}
		}
		if (!store.buffered && storeCount > 0) {
			selected = me.selected;
			hdSelectStatus = true;
			for (i = 0, len = selected.getCount(); i < len; ++i) {
				/*if (!me.storeHasSelected(selected.getAt(i))) {
				 break;
				 }*/
				++selectedCount;
			}
			hdSelectStatus = storeCount === selectedCount+ selectedGroups;
		}
		if (views && views.length) {
			me.toggleUiHeader(hdSelectStatus);
		}
	},
	deselectAll:function(){
		var me=this;
		//this.selectedGroups=0;
		me.callParent(arguments);
	},
	listeners:{
		beforeselect:function(selModel, record, index) {
			return record.get('group') !== true;
		},
		beforedeselect:function(selModel, record, index) {
			return record.get('group') !== true;
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.TreeDropZone',{
	extend: 'Ext.dd.DropZone',
	config:{
		view:null,
		isValidNode:null,
		isValidNodeScope:null
	},
	expandDelay : 600,
	constructor: function(config) {
		var me = this;
		Ext.apply(me, config);
		me.callParent([me.view.el]);
	},
	getTargetFromEvent: function(e) {
		var node = e.getTarget(this.view.getItemSelector()),
		mouseY, nodeList, testNode, i, len, box;
		if (!node) {
			mouseY = e.getY();
			for (i = 0, nodeList = this.view.getNodes(), len = nodeList.length; i < len; i++) {
				testNode = nodeList[i];
				box = Ext.fly(testNode).getBox();
				if (mouseY <= box.bottom) {
					return testNode;
				}
			}
		}
		return node;
	},
	expandNode : function(node) {
		var view = this.view;
		if (!node.isLeaf() && !node.isExpanded()) {
			view.expand(node);
			this.expandProcId = false;
		}
	},
	queueExpand : function(node) {
		this.expandProcId = Ext.Function.defer(this.expandNode, this.expandDelay, this, [node]);
	},
	fireViewEvent: function() {
		var me = this,
			result;
		me.lock();
		result = me.view.fireEvent.apply(me.view, arguments);
		me.unlock();
		return result;
	},
	invalidateDrop: function() {
		if (this.valid) {
			this.valid = false;
		}
		if(this.overRecord){
			var cmp=Ext.fly(this.overRecord);
			if(cmp) {
				cmp.removeCls('my-row-highlight-class');
			}
		}
	},
	onNodeEnter : function(target, dd, e, data){
		if(this.isValidDropPoint(target,  dd, e, data)) {
			Ext.fly(target).addCls('my-row-highlight-class');
		}
	},
	onNodeOut : function(target, dd, e, data){
		Ext.fly(target).removeCls('my-row-highlight-class');
	},
	onNodeOver : function(node, dragZone, e, data) {
		var me=this;
		var returnCls = this.dropNotAllowed;
		var targetNode = this.view.getRecord(node);
		this.cancelExpand();
		if (!this.expandProcId&&!targetNode.isLeaf() && !targetNode.isExpanded()) {
			this.queueExpand(targetNode);
		}
	if(this.isValidDropPoint(node,  dragZone, e, data)) {
			this.valid = true;
			this.overRecord = targetNode;
			returnCls = Ext.baseCSSPrefix +'dd-drop-ok';
		} else {
			this.valid = false;
		}
		this.currentCls = returnCls;
		return returnCls;
	},
	cancelExpand : function() {
		if (this.expandProcId) {
			clearTimeout(this.expandProcId);
			this.expandProcId = false;
		}
	},
	isValidDropPoint : function(node,  dragZone, e, data) {
		var me=this;
		if (!node || !data.item) {
			return false;
		}
		var view = this.view;
		var targetNode = view.getRecord(node);
		if(me.isValidNode&&(typeof me.isValidNode === 'function')){
			if (CWHF.isNull(this.isValidNodeScope)) {
				return me.isValidNode.call(me,targetNode);
			} else {
				return me.isValidNode.call(this.isValidNodeScope,targetNode);
			}
		}
		var canDrop=targetNode.data['canDrop'];
		if(canDrop){
			return canDrop===true;
		};
		return true;
	},
	onNodeDrop: function(node, dragZone, e, data) {
		var me = this,
			dropped = false,
			processDrop = function () {
				me.invalidateDrop();
				dropped = true;
				me.fireViewEvent('drop', node, data, me.overRecord);
			},
			performOperation = false;
		if (me.valid) {
			performOperation = me.fireViewEvent('beforedrop', node, data, me.overRecord, processDrop);
			if (performOperation !== false) {
				// If the processDrop function was called in the event handler, do not do it again.
				if (!dropped) {
					processDrop();
				}
			}
		}
		return performOperation;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.NavigableItem',{
	extend:'Ext.Base',
	itemDialogManager:null,
	usePosition:false,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		me.itemDialogManager=Ext.create('com.trackplus.itemNavigator.ItemDialogManager',{
			navigable:me,
			usePosition:me.usePosition
		});
	},
	/*abstract function*/
	navigate:function(workItemID,workItemIndex,dir){
	},
	selectItem:function(workItemID){
	},
	deselectItem:function(workItemID){
	},
	selectItemByIndex:function(workItemIndex){
	},
	deselectItemByIndex:function(workItemIndex){
	},
	itemChangeHandler:function(fields){
	},
	openItem:function(workItemID,actionID,workItemIndex,extraCfg){
		var me=this;
		var nextItem=me.navigate(workItemID,workItemIndex,'next',true);
		var prevItem=me.navigate(workItemID,workItemIndex,'prev',true);
		var navigateCtx={
			workItemID:workItemID,
			workItemIndex:workItemIndex,
			nextItem:nextItem,
			prevItem:prevItem
		};
		var itemActionCfg={
			workItemID:workItemID,
			actionID:CWHF.isNull(actionID)?-2:actionID,
			successHandler:me.successHandler,
			scope:me,
			modal:false,
			disabledNext:CWHF.isNull(nextItem),
			disabledPrev:CWHF.isNull(prevItem)
		};
		if(extraCfg){
			for(var x in extraCfg){
				itemActionCfg[x]=extraCfg[x];
			}
		}
		var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',itemActionCfg);
		me.itemDialogManager.openDialog(itemAction,navigateCtx);
	},
	containsFields:function(myFields,changedFields){
		var me=this;
		if(changedFields){
			for(var i=0;i<changedFields.length;i++){
				if(me.containsOneField(myFields,changedFields[i])){
					return true;
				}
			}
		}
		return false;
	},
	containsOneField:function(myFields,fieldID){
		var me=this;
		for(var i=0;i<myFields.length;i++){
			if(myFields[i].reportField===fieldID){
				return true;
			}
		}
		return false;
	}
});
Ext.define('com.trackplus.itemNavigator.GridNavigableItem',{
	extend:'com.trackplus.itemNavigator.NavigableItem',
	/*abstract function*/
	getGrid:function(){
		return this.grid;
	},
	getFieldNameItemID:function(){
		return 'objectID';
	},
	navigate:function(workItemID,workItemIndex,dir){
		var me=this;
		var grid=me.getGrid();
		var fieldNameItemID=me.getFieldNameItemID();
		if(CWHF.isNull(grid)){
			return null;
		}
		var store =grid.getStore();
		var idx=-1;
		if(workItemIndex>=0&&workItemIndex<store.getCount()){
			var r=store.getAt(workItemIndex);
			if(r.data[fieldNameItemID]===workItemID){
				idx=workItemIndex;
			}
		}
		if(idx===-1){
			idx=me.findIndex(fieldNameItemID,workItemID);
		}
		if(idx===-1){
			//the item is not present anymore use workItemIndex;
			idx=workItemIndex;
			if(dir==='next'){
				//keep this item as next
				idx--;
			}
		}
		if(dir==='next'){
			if(idx===store.getCount()-1){
				return null;
			}
			idx++;
		}else{
			if(idx===0){
				return null;
			}
			idx--;
		}
		var record=store.getAt(idx);
		return{
			workItemID:record.data[fieldNameItemID],
			workItemIndex:idx
		};
	},
	selectItem:function(workItemID){
		var me=this;
		var grid=me.getGrid();
		if(CWHF.isNull(grid)||CWHF.isNull(workItemID)){
			return null;
		}
		return me.selectItemGrid(grid,workItemID);
	},
	selectItemGrid:function(grid,workItemID){
		var me=this;
		var store =grid.getStore();
		var workItemIDs = Ext.Array.from(workItemID);
		var records=new Array();
		var fieldNameItemID=me.getFieldNameItemID();
		for(var i=0;i<workItemIDs.length;i++){
			var idx=me.findIndex(fieldNameItemID,workItemIDs[i]);
			if (idx) {
				grid.getSelectionModel().select(idx);
				records.push(store.getAt(idx));
			}
		}
		return records;
	},
	deselectItem:function(workItemID){
		var me=this;
		var grid=me.getGrid();
		if(CWHF.isNull(grid)||CWHF.isNull(workItemID)){
			return null;
		}
		me.deselectItemGrid(grid,workItemID);
	},
	deselectItemGrid:function(grid,workItemID){
		var me=this;
		var store =grid.getStore();
		var workItemIDs = Ext.Array.from(workItemID);
		var fieldNameItemID=me.getFieldNameItemID();
		for(var i=0;i<workItemIDs.length;i++){
			var idx=me.findIndex(fieldNameItemID,workItemIDs[i]);
			if (idx) {
				grid.getSelectionModel().deselect(idx);
			}
		}
	},
	selectItemByIndex:function(workItemIndex){
		var me=this;
		var grid=me.getGrid();
		if(CWHF.isNull(grid)||CWHF.isNull(workItemIndex)){
			return null;
		}
		return me.selectItemGridByIndex(grid,workItemIndex);
	},
	selectItemGridByIndex:function(grid,workItemIndex){
		var store =grid.getStore();
		var workItemIndexes = Ext.Array.from(workItemIndex);
		var records=new Array();
		for(var i=0;i<workItemIndexes.length;i++){
			var idx=workItemIndexes[i];
			if (idx>=0&&idx<store.getCount()) {
				grid.getSelectionModel().select(idx);
				records.push(store.getAt(idx));
			}
		}
		return records;
	},
	/*private functions*/
	findIndex:function(fieldNameItemID, workItemID){
		var me=this;
		var grid=me.getGrid();
		var store =grid.getStore();
		var r;
		for(var i=0;i<store.getCount();i++){
			r=store.getAt(i);
			if(r.data[fieldNameItemID]===workItemID){
				return i;
			}
		}
		return -1;
	}
});
Ext.define('com.trackplus.itemNavigator.TreeNavigableItem',{
	extend:'com.trackplus.itemNavigator.NavigableItem',
	/*abstract function*/
	getTreeGrid:function(){
		return null;
	},
	navigate:function(workItemID,workItemIndex,dir){
		var me=this;
		var treeGrid=me.getTreeGrid();
		if(treeGrid){
			var node=treeGrid.getStore().getNodeById(workItemID);
			var nodeToSelect=null;
			if (node) {
				if(dir==='next'){
					nodeToSelect=me.findNext(node,true);
				}else{
					nodeToSelect=me.findPrev(node,true);
				}
			}else{
				//item is not present anymore on lis, try to get node by index
				node = me.findNodeByWorkItemIndex(workItemIndex);
				if(node){
					if(dir==='next'){
						nodeToSelect=node;
					}else{
						nodeToSelect=me.findPrev(node,true);
					}
				}
			}
			if(nodeToSelect){
				return{
					workItemID:nodeToSelect.data['workItemID'],
					workItemIndex:nodeToSelect.data['workItemIndex']
				}
			}
			return null;
		}
	},
	selectItem:function(workItemID){
		var me=this;
		var treeGrid=me.getTreeGrid();
		if(CWHF.isNull(treeGrid)||CWHF.isNull(workItemID)){
			return null;
		}
		return me.selectItemInTree(treeGrid,workItemID);
	},
	selectItemInTree:function(treeGrid,workItemID){
		var me=this;
		var workItemIDs = Ext.Array.from(workItemID);
		var nodeArrays=new Array();
		for(var i=0;i<workItemIDs.length;i++){
			var node = treeGrid.getStore().getNodeById(workItemIDs[i]);
			if (node) {
				treeGrid.selectPath(node.getPath());
				nodeArrays.push(node.data);
			}
		}
		return nodeArrays;
	},
	deselectItem:function(workItemID){
		var me=this;
		var treeGrid=me.getTreeGrid();
		if(CWHF.isNull(treeGrid)||CWHF.isNull(workItemID)){
			return null
		}
		me.deselectItemInTree(treeGrid,workItemID);
	},
	deselectItemInTree:function(treeGrid,workItemID){
		var me=this;
		var workItemIDs = Ext.Array.from(workItemID);
		for(var i=0;i<workItemIDs.length;i++){
			var node = treeGrid.getStore().getNodeById(workItemIDs[i]);
			if (node) {
				treeGrid.getSelectionModel().deselect(node);
			}
		}
	},
	selectItemByIndex:function(workItemIndex){
		var me=this;
		var treeGrid=me.getTreeGrid();
		if(CWHF.isNull(treeGrid)||CWHF.isNull(workItemIndex)){
			return null;
		}
		return me.selectItemByIndexInTree(treeGrid,workItemIndex);
	},
	selectItemByIndexInTree:function(treeGrid,workItemIndex){
		var me=this;
		var workItemIndexes = Ext.Array.from(workItemIndex);
		var nodeArrays=new Array();
		for(var i=0;i<workItemIndexes.length;i++){
			var node = me.findNodeByWorkItemIndex(workItemIndexes[i]);
			if (node) {
				treeGrid.selectPath(node.getPath());
				nodeArrays.push(node.data);
			}
		}
		return nodeArrays;
	},
	/*protected functions*/
	onStoreRefresh:function(store){
		var me=this;
		var root=store.getRootNode();
		me.updateNodeChildrenIndex(root,0);
	},
	updateNodeChildrenIndex:function(node,idx){
		var me=this;
		var children=node.childNodes;
		if(children){
			for(var i=0;i<children.length;i++){
				var child=children[i];
				if(!child.data['group']===true){
					child.data['workItemIndex']=idx++;
				}
				idx=me.updateNodeChildrenIndex(child,idx);
			}
		}
		return idx;
	},
	/*private functions*/
	findPrev:function(node){
		var me=this;
		var nodeToSelect=null;
		var parentNode=node.parentNode;
		if(node.isFirst()){
			if(parentNode.isRoot()){
				nodeToSelect=null;
			}else{
				if(parentNode.data['workItemID']){
					nodeToSelect=parentNode;
				}else{
					nodeToSelect=me.findPrev(parentNode);
				}
			}
		}else{
			var myIndex=parentNode.indexOf(node);
			var prevSibling=parentNode.getChildAt(myIndex-1);
			if(prevSibling.data['workItemID']){
				nodeToSelect=prevSibling;
			}else{
				nodeToSelect=me.findPrev(prevSibling);
			}
		}
		return nodeToSelect;
	},
	findNext:function(node,includeChildren){
		var me=this;
		var nodeToSelect=null;
		if(node.hasChildNodes()&&includeChildren===true){
			nodeToSelect=node.getChildAt(0);
		}else{
			var parentNode=node.parentNode;
			if(node.isLast()){
				if(parentNode.isRoot()){
					nodeToSelect=null;
				}else{
					nodeToSelect=me.findNext(parentNode,false);
				}
			}else{
				var myIndex=parentNode.indexOf(node);
				var nextSibling=parentNode.getChildAt(myIndex+1);
				if(nextSibling.data['workItemID']){
					nodeToSelect=nextSibling;
				}else{
					nodeToSelect=me.findNext(nextSibling,true);
				}
			}
		}
		return nodeToSelect;
	},
	findNodeByWorkItemIndex:function(workItemIndex){
		var me=this;
		var selectedNode=null;
		var maxIndex=0;
		var maxNode=0;
		var treeGrid=me.getTreeGrid();
		if(treeGrid){
			var root=treeGrid.getStore().getRootNode();
			root.cascadeBy(function (node) {
				var idx=node.data['workItemIndex'];
				if(idx){
					if(idx>maxIndex){
						maxIndex=idx;
						maxNode=node;
					}
					if(idx===workItemIndex){
						selectedNode=node;
					}
				}
			});
			if(selectedNode){
				return selectedNode;
			}
			return maxNode;
		}
		return null;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.ItemDialogManager',{
	extend:'Ext.Base',
	config: {
		navigable:null,
		usePosition:false
	},
	allDialogs:new Array(),
	navigateContexts:new Array(),
	lastActiveDialog:null,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	openDialog:function(itemAction,navigateCtx){
		var me=this;
		if(me.allDialogs.length>0){
			var prevDialog;
			if(me.lastActiveDialog){
				prevDialog=me.lastActiveDialog;
			}else{
				prevDialog=me.allDialogs[me.allDialogs.length-1];
			}
			var prevPosition=prevDialog.dialog.getPosition();
			itemAction.position=[prevPosition[0]+25,prevPosition[1]+25];
		}
		itemAction.execute.call(itemAction);
		itemAction.addListener('activate',me.activateItemDialog,me);
		itemAction.addListener('deactivate',me.deactivateItemDialog,me);
		itemAction.addListener('close',me.closeItemDialog,me);
		itemAction.addListener('itemChange',me.itemChangeHandler,me);
		itemAction.addListener('clickOnChild',me.clickOnChildHandler,me);
		itemAction.addListener('clickOnLink',me.clickOnLinkHandler,me);
		itemAction.addListener('clickOnParent',me.clickOnParentdHandler,me);
		itemAction.addListener('navigateToItem',me.navigateToItemHandler,me);
		me.allDialogs.push(itemAction);
		me.navigateContexts.push(navigateCtx);
		me.lastActiveDialog=itemAction;
	},
	navigateToItemHandler:function(itemAction,direction){
		var me=this;
		var workItemID=itemAction.workItemID;
		var dialogIndex= Ext.Array.indexOf(me.allDialogs, itemAction);
		var navCtx=me.navigateContexts[dialogIndex];
		var nextItem=me.navigable.navigate.call(me.navigable,workItemID,navCtx.workItemIndex,direction);
		if(nextItem){
			var nextWorkItemID=nextItem.workItemID;
			var nextWorkItemIndex=nextItem.workItemIndex;
			if(me.usePosition){
				me.navigable.deselectItemByIndex.call(me.navigable,navCtx.workItemIndex);
			}else{
				me.navigable.deselectItem.call(me.navigable,itemAction.workItemID);
			}
			itemAction.workItemID=nextWorkItemID;
			var nextItem1=me.navigable.navigate.call(me.navigable,nextWorkItemID,nextWorkItemIndex,'next');
			var prevItem1=me.navigable.navigate.call(me.navigable,nextWorkItemID,nextWorkItemIndex,'prev');
			navCtx.workItemID=nextWorkItemID;
			navCtx.workItemIndex=nextWorkItemIndex;
			navCtx.nextItem=nextItem1;
			navCtx.prevItem=prevItem1;
			itemAction.disabledNext=(CWHF.isNull(nextItem1));
			itemAction.disabledPrev=(CWHF.isNull(prevItem1));
			itemAction.reExecute();
			if(me.usePosition){
				me.navigable.selectItemByIndex.call(me.navigable,nextWorkItemIndex);
			}else{
				me.navigable.selectItem.call(me.navigable,itemAction.workItemID);
			}
		}else{
			var msg="";
			if(direction==='next'){
				msg=getText('itemov.err.noNextAvailable');
				itemAction.setDisabledNextButton(true);
			}else{
				msg=getText('itemov.err.noPrevAvailable');
				itemAction.setDisabledPrevButton(true);
			}
			CWHF.showMsgError(msg);
		}
	},
	itemChangeHandler:function(fields){
		var me=this;
		if(me.navigable){
			me.navigable.itemChangeHandler.call(me.navigable,fields);
		}
	},
	clickOnChildHandler:function(workItemID){
		var me=this;
		if(me.navigable){
			me.navigable.openItem.call(me.navigable,workItemID);
		}
	},
	clickOnLinkHandler:function(workItemID){
		var me=this;
		if(me.navigable){
			me.navigable.openItem.call(me.navigable,workItemID);
		}
	},
	clickOnParentdHandler:function(parentID){
		var me=this;
		if(me.navigable){
			me.navigable.openItem.call(me.navigable,parentID);
		}
	},
	activateItemDialog:function(itemAction){
		var me=this;
		me.lastActiveDialog=itemAction;
		var workItemID=itemAction.workItemID;
		if(me.navigable){
			me.navigable.selectItem.call(me.navigable,workItemID);
		}
	},
	deactivateItemDialog:function(itemAction){
		var me=this;
		var workItemID=itemAction.workItemID;
		me.lastActiveDialog=null;
		/*if(me.navigable){
			me.navigable.deselectItem.call(me.navigable,workItemID);
		}*/
	},
	releaseItemLock: function(workItemID) {
		Ext.Ajax.request({
			url: "releaseItemLock.action",
			params:{
				workItemID:workItemID
			},
			success: function(response){
			},
			failure:function(result){
			}
		});
	},
	closeItemDialog:function(itemAction,options) {
		var me=this;
		var workItemID = itemAction.workItemID;
		var actionID = itemAction.actionID;
		if (workItemID && actionID) {
			var savedSuccessfully=false;
			if(options){
				savedSuccessfully=options.savedSuccessfully;
			}
			//alert("savedSuccessfully="+savedSuccessfully);
			//2:edit, 3:move, 5:change status
			if (savedSuccessfully===false && (actionID===2 || actionID===3 || actionID===5)) {
				//cancel or X button after opening the item with edit/move/status change form
				me.releaseItemLock(workItemID);
			}
		}
		if(me.lastActiveDialog===itemAction){
			me.lastActiveDialog=null;
		}
		var idx=Ext.Array.indexOf(me.allDialogs,itemAction);
		me.navigateContexts=Ext.Array.erase( me.navigateContexts, idx, 1);
		me.allDialogs=Ext.Array.remove(me.allDialogs,itemAction);
		/*if(me.navigable){
			me.navigable.deselectItem.call(me.navigable,itemAction.workItemID);
		}*/
	},
	findNextItem:function(workItemID,direction,keepPosition){
		var me=this;
		var nextItemID=null;
		if(me.navigable){
			nextItemID=me.navigable.navigate.call(me.navigable,workItemID,CWHF.isNull(direction)?'next':direction,keepPosition);
		}
		return nextItemID;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//View
Ext.define('com.trackplus.itemNavigator.FilterView',{
	extend:'Ext.tree.Panel',
	useArrows: true,
	autoScroll: true,
	rootVisible: false,
	border: false,
	cls:'westTreeNavigator',
	bodyBorder:false,
	//margins:Ext.isIE?'0 -4 0 0':'0 -5 0 0',
	width:200,
	frame: false,
	//collapsible:false,
	//title:'my title here',
	//iconCls:'queryView',
	//collapseMode:'mini',
	//collapsedCls:'westTreeNavigatorCollapsed',
	//split:true,
	listeners:{
		'staterestore':{
			fn:function(panel,state){
				var w=state.width;
				var appWidth=borderLayout.getWidth();
				if(w>appWidth+100){
					w=appWidth-100;
					if(w<0){
						w=50
					}
					panel.width=w;
				}
			}
		}
	},
	config: {
		model:null,
		filterController:null,
		queryContextID:null
	},
	initComponent: function(){
		var me=this;
		//me.title=" ";
		me.store = Ext.create('Ext.data.TreeStore', {
			fields: ['id','text','objectID','canDrop','verifyAllowDropAJAX','nodeType',
				'useFilter','filterViewID', 'maySaveFilterLayout','iconCls','icon','dropHandlerCls','cls'],
			root: {
				expanded: true,
				text:"",
				user:"",
				status:"",
				children:me.model.children
			},
			proxy:{
				type: 'ajax',
				url: 'itemNavigator!expandNode.action'
			}
		});
		me.callParent();
		me.initMyListeners();
	},
	initMyListeners:function(){
		var me=this;
		//me.addListener('beforecollapse',me.beforeCollapseWestNavigator,me);
		//me.addListener('beforeexpand',me.beforeExpandWestNavigator,me);
		me.view.addListener('afterrender',me.onTreeViewAfterRenderer,me);
		me.view.addListener('itemcontextmenu',me.onTreeNodeCtxMenu,me);
	},
	beforeCollapseWestNavigator:function(){
		var me=this;
		me.lastIconCls=me.iconCls;
		me.setIconCls(null);
	},
	beforeExpandWestNavigator:function(){
		var me=this;
		me.setIconCls(me.lastIconCls);
	},
	onTreeViewAfterRenderer:function(){
		var me=this;
		me.store.getRootNode().expandChildren();
		me.dropZone = Ext.create('com.trackplus.util.TreeDropZone', {
			view: me.view,
			ddGroup: "itemToCategory"
		});
	},
	/**
	 * Show the context menu
	 */
	onTreeNodeCtxMenu: function(tree, record, item, index, evtObj) {
		var me=this;
		evtObj.stopEvent();
		me.createCtxMenu(tree, record,evtObj);
		return false;
	},
	createCtxMenu: function(tree, record,evtObj) {
		var me=this;
		if (record) {
			var nodeType = record.data["nodeType"];
			if (nodeType) {
				switch (nodeType){
					case "2_8": {
						//project or release
						me.createProjectReleaseCtxMenu(tree, record,evtObj);
						break;
					}
					case "2_5":{
						//subscribed filter
						me.createFilterCtxMenu(tree, record, evtObj);
						/*var items = [];
						items.push({
							text:getText('common.btn.remove'),
							iconCls:'delete16',
							scope: this,
							handler:function(){
								this.removeFilter(record, tree);
							}
						});
						var contextMenu = new Ext.menu.Menu({
							items: items
						});
						contextMenu.showAt(evtObj.getXY());*/
						break;
					}
					case "2_7":{
						var entityID=record.data["objectID"];
						if(entityID===6){
							//trash
							var items = [];
							items.push({
								text:getText('common.btn.clear'),
								iconCls:'clear16',
								scope: this,
								handler:function(){
									this.clearTrashBasket(record, tree);
								}
							});
							var contextMenu = new Ext.menu.Menu({
								items: items
							});
							contextMenu.showAt(evtObj.getXY());
						}
						break;
					}
				}
			}
		}
		return contextMenu;
	},
	clearTrashBasket:function(){
		var me=this;
		var urlStr="itemNavigator!emptyTrashBasket.action";
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(response){
				borderLayout.setLoading(false);
				me.filterController.itemNavController.refresh.call(me.filterController.itemNavController,null,null,false);
			},
			failure:function(){
				borderLayout.setLoading(false);
			}
		});
	},
	createProjectReleaseCtxMenu:function(tree, record,evtObj) {
		var me=this;
		var entityID=record.data["objectID"];
		tree.setLoading(true);
		var urlStr="project!getProjectReleaseCtxMenu.action";
		Ext.Ajax.request({
			url: urlStr,
			params: {
				entityID:entityID
			},
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				var issueTypes=responseJson.data.issueTypes;
				var projectID=responseJson.data.projectID;
				var isProjectAdmin = responseJson.data.isProjectAdmin;
				var mightHaveRelease = responseJson.data.mightHaveRelease;
				var items = [];
				if (isProjectAdmin) {
					if (entityID<0) {
						//is a project
						var addSubprojectTitle = getText("common.lbl.add",getText("admin.project.lbl.subproject"));
						items.push({
							text: addSubprojectTitle,
							iconCls: "projectAdd",
							scope: this,
							handler: function(){
								me.addSubproject(projectID, addSubprojectTitle);
							}
						});
						var editProjectTitle = getText("common.lbl.edit",getText("admin.project.lbl.project"));
						items.push({
							text: editProjectTitle,
							iconCls: "projects-ticon",
							scope: this,
							handler: function(){
								me.editProject(projectID, editProjectTitle);
							}
						});
						var assignRolesTitle = getText("common.lbl.assign",getText("admin.customize.role.lbl.roles"));
						items.push({
							text: assignRolesTitle,
							iconCls: "roles-ticon",
							scope: this,
							handler: function(){
								me.assignRoles(projectID, assignRolesTitle);
							}
						});
					}
					var releaseID=null;
					if (mightHaveRelease) {
						var releaseLbl=getText('admin.project.release.lbl.main');
						items.push({
							text:getText('common.lbl.add',releaseLbl),
							iconCls:'releaseAdd',
							scope: this,
							handler:function(){
								me.addRelease(projectID,releaseID);
							}
						});
					}
					if (entityID>0) {
						//is release
						releaseID=entityID;
						items.push({
							text:getText('common.lbl.add',getText('admin.project.release.childPhase.general')),
							iconCls:'releaseAdd',
							scope: this,
							handler:function(){
								me.addChildRelease(projectID, releaseID);
							}
						});
						items.push({
							text:getText('common.lbl.edit',releaseLbl),
							iconCls:'releaseEdit',
							scope: this,
							handler:function(){
								me.editRelease(projectID, releaseID);
							}
						});
						items.push({
							text:getText('common.lbl.delete',releaseLbl),
							iconCls:'delete',
							scope: this,
							handler:function(){
								me.deleteRelease(projectID, releaseID);
							}
						});
					}
					items.push('-');
				}
				if (mightHaveRelease) {
					items.push({
						text:getText('common.btn.releaseNotes'),
						iconCls:'releaseNotes16',
						scope: this,
						handler:function(){
							me.releaseNotes(record, tree);
						}
					});
				}
				if(issueTypes&&issueTypes.length>0){
					items.push('-');
					for(var i=0;i<issueTypes.length;i++){
						var issueType=issueTypes[i];
						items.push({
							text:getText('common.lbl.add',issueType.label),
							icon:'optionIconStream.action?fieldID=-2&optionID='+issueType.id,
							scope:{
								issueTypeID:issueType.id,
								projectID:projectID,
								releaseID:entityID>0?entityID:null
							},
							handler:function(btn){
								borderLayout.borderLayoutController.createNewIssue.call(borderLayout.borderLayoutController,this.issueTypeID,this.projectID,this.releaseID);
							}
						});
					}
				}
				if (items.length>0) {
					var contextMenu = new Ext.menu.Menu({
						items: items
					});
					contextMenu.showAt(evtObj.getXY());
				}
				tree.setLoading(false);
			},
			failure:function(){
				tree.setLoading(false);
			}
		});
	},
	addSubproject:function(projectID, title){
		var me=this;
		var loadParams={
			add:true,
			addAsSubproject:true,
			projectID:projectID
		};
		var submitParams=loadParams;
		var projectConfig=Ext.create("com.trackplus.admin.project.ProjectConfig",{});
		projectConfig.addOrEditProject(loadParams,submitParams, title, me, me.reloadAll);
	},
	editProject:function(projectID, title) {
		var me=this;
		var loadParams={
			add:false,
			projectID:projectID
		};
		var submitParams=loadParams;
		var projectConfig=Ext.create("com.trackplus.admin.project.ProjectConfig",{rootID:projectID});
		projectConfig.addOrEditProject(loadParams,submitParams, title, me, me.reloadAll);
	},
	assignRoles:function(projectID, title) {
		var roleAssignment = Ext.create("com.trackplus.admin.project.RoleAssignment", {
            rootID : projectID,
            treeWidth : 200
        });
		var width = 1200;
		var height = 800;
		var windowParameters = {title:title,
			width:width,
			height:height,
			formPanel:roleAssignment.createCenterPanel(),
			cancelButtonText : getText("common.btn.done")
		};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	addRelease:function(projectID, releaseID){
		var me=this;
		var node=""+projectID;
		if(releaseID){
			node=node+"_"+releaseID;
		}
		var loadParams={
			add:true,
			addAsChild:false,
			node:node
		};
		var submitParams=loadParams;
		var releaseLbl=getText('admin.project.release.lbl.main');
		me.addOrEditRelease(loadParams,submitParams,getText("common.lbl.add",releaseLbl));
	},
	addChildRelease:function(projectID, releaseID){
		var me=this;
		var node=""+projectID;
		if(releaseID){
			node=node+"_"+releaseID;
		}
		var loadParams={
			add:true,
			addAsChild:true,
			node:node
		};
		var submitParams=loadParams;
		var releaseLbl=getText('admin.project.release.lbl.main');
		me.addOrEditRelease(loadParams,submitParams,getText("common.lbl.add",releaseLbl));
	},
	editRelease:function(projectID, releaseID){
		var me=this;
		var node=""+projectID;
		if(releaseID){
			node=node+"_"+releaseID;
		}
		var loadParams={
			add:false,
			addAsChild:false,
			node:node
		};
		var submitParams=loadParams;
		var releaseLbl=getText('admin.project.release.lbl.main');
		me.addOrEditRelease(loadParams,submitParams,getText("common.lbl.edit",releaseLbl));
	},
	addOrEditRelease:function(loadParams,submitParams,title){
		var labelWidth=120;
		var panelItems=com.trackplus.admin.project.Release.createEditPanelItems(labelWidth);
		var width = 600;
		var height = 400;
		var loadUrl =  "release!edit.action";
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = "release!save.action";
		var submit = {
			submitUrl:submitUrl,
			submitUrlParams:submitParams,
			submitButtonText:getText('common.btn.save'),
			refreshAfterSubmitHandler:this.reloadAll
		};
		var windowParameters = {title:title,
			width:width,
			height:height,
			load:load,
			submit:submit,
			items:panelItems,
			postDataProcess:com.trackplus.admin.project.Release.postDataLoadCombo
		};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	deleteRelease:function(projectID, releaseID){
		var me=this;
		var releaseLbl=getText('admin.project.release.lbl.main');
		Ext.MessageBox.confirm(getText("common.lbl.delete",releaseLbl),
			getText("common.lbl.removeWarning",releaseLbl),
			function(btn){
				if (btn==="no") {
					return false;
				} else {
					me.deleteSelected.call(me, projectID, releaseID);
				}
			}
		);
	},
	deleteSelected:function(projectID, releaseID){
		var me=this;
		var node=projectID+"_"+releaseID;
		var releaseLbl=getText('admin.project.release.lbl.main');
		Ext.Ajax.request({
			url: "release!delete.action",
			params: {
				node:node
			},
			disableCaching:true,
			scope: me,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success===true) {
					//delete done (no replacement were needed)
					me.reloadAll();
				} else {
					var errorCode = responseJson.errorCode;
					if (errorCode) {
						if (errorCode===1){//ERROR_CODE_NEED_REPLACE
							//render dialog for selecting the replacement
							var windowItems = [{xtype : 'label',itemId: 'replacementWarning'},
								CWHF.createSingleTreePicker("Replacement",
									"replacementID", [], null,
									{itemId:"replacementID",
										allowBlank:false,
										blankText: getText('common.err.replacementRequired',releaseLbl),
										labelWidth:150,
										margin:'5 0 0 0'
									})
							];
							var title = getText("common.lbl.delete",releaseLbl);
							var load = {
								loadUrl: 'release!renderReplace.action',
								loadUrlParams:{node: node}
							};
							var submit = {
								submitUrl:"release!replaceAndDelete.action",
								submitUrlParams:{node:node},
								submitButtonText:getText('common.btn.delete'),
								//deleting more users can be a lenghty operation
								timeout:300,
								refreshAfterSubmitHandler:me.reloadAll
								//refreshAfterSubmitHandler:me.refreshAfterDeleteAndRepleceRelease
								//refreshParametersBeforeSubmit:me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson)
							};
							var extraConfig={};
							var windowConfig = Ext.create('com.trackplus.util.WindowConfig',
								{postDataProcess:me.replaceOptionPostDataProcess, extraConfig:extraConfig});
							windowConfig.showWindow(me, title, 500, 200, load, submit, /*refresh,*/ windowItems);
						}
					} else {
						//no right to delete (for ex. with fake URL-Params)
						//var errorMessage=responseJson.errorMessage;
						//me.errorHandlerDelete(selectedRecords, errorCode, errorMessage);
						me.errorHandlerDelete(responseJson);
					}
				}
			},
			failure: function(response){
				com.trackplus.util.requestFailureHandler(response);
			},
			method:"POST"
		});
	},
	replaceOptionPostDataProcess: function(data, panel, extraConfig) {
		var replacementWarning = panel.getComponent('replacementWarning');
		var replacementWarningText = data['replacementWarning'];
		if (CWHF.isNull(replacementWarningText)) {
			var label = data['label'];
			replacementWarningText = getText("common.lbl.replacementWarning", this.getEntityLabel(extraConfig), label);
			replacementWarningText = replacementWarningText + getText("common.lbl.cancelDeleteAlert");
		}
		replacementWarning.setText(replacementWarningText, false);
		var replacementList = panel.getComponent('replacementID');
		replacementList.updateMyOptions(data["replacementTree"]);
		var replacementListLabel = data.replacementListLabel;
		if (CWHF.isNull(replacementListLabel)) {
			replacementListLabel =  this.getTitle('common.lbl.replacement', extraConfig);
		}
		replacementList.labelEl.dom.innerHTML = replacementListLabel;
	},
	reloadAll:function(){
		borderLayout.setLoading(true);
		window.location.href="itemNavigator.action";
	},
	releaseNotes: function(record, tree){
		var url='releaseNotes.action?project='+record.data["objectID"];
		window.open(url,"_blank");
	},
	createFilterCtxMenu:function(tree, record, evtObj) {
		var me=this;
		var filterID=record.data["objectID"];
		tree.setLoading(true);
		var urlStr="filterConfig!filterIsModifiable.action";
		Ext.Ajax.request({
			url: urlStr,
			params: {
				filterID:filterID
			},
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				var modifiable=responseJson.value;
				var items = [];
				var issueFilterLabel=getText("admin.customize.queryFilter.lbl.issueFilter");
				items.push({
					text:getText('common.lbl.add', issueFilterLabel),
					iconCls:"filterAdd",
					scope: this,
					handler:function(){
						me.addFilter(filterID);
					}
				});
				if (modifiable) {
					items.push({
						text:getText("common.lbl.edit", issueFilterLabel),
						iconCls:"filterEdit",
						scope: this,
						handler:function(){
							me.editFilter(filterID);
						}
					});
				}
				items.push({
					text:getText("common.lbl.remove", issueFilterLabel),
					iconCls:"delete",
					scope: this,
					handler:function(){
						me.removeFilter(tree, record, filterID);
					}
				});
				var contextMenu = new Ext.menu.Menu({
					items: items
				});
				contextMenu.showAt(evtObj.getXY());
				tree.setLoading(false);
			},
			failure:function(){
				tree.setLoading(false);
			}
		});
	},
	removeFilter: function(tree, record, filterID){
		Ext.Ajax.request({
			url: 'filtersInMenu!delete.action',
			params: {
				unassign:filterID
			},
			disableCaching:true,
			success: function(response){
				record.remove(true);
			}
		});
	},
	addFilter:function(filterID){
		var me=this;
		var issueFilterLabel=getText("admin.customize.queryFilter.lbl.issueFilter");
		me.addOrEditFilter(true, null, 1, getText("common.lbl.add",issueFilterLabel));
	},
	editFilter:function(filterID){
		var me=this;
		var issueFilterLabel=getText("admin.customize.queryFilter.lbl.issueFilter");
		me.addOrEditFilter(false, filterID, 1, getText("common.lbl.edit",issueFilterLabel));
	},
	addOrEditFilter:function(add, filterID, filterType, title) {
		var scope=Ext.create("com.trackplus.admin.customize.category.CategoryConfig",{
			rootID:"issueFilter"
		});
		scope.indexMax = 0;
		scope.instant = false;
		scope.renderPath = add;
		com.trackplus.admin.CategoryConfig.showAddEditFilter(scope, this, this.reloadAll, add, filterID, filterType, title);
	}
});
Ext.define('com.trackplus.itemNavigator.FilterController',{
	extend:'Ext.Base',
	config: {
		model:null,
		queryContext:null,
		skipEmptyNodeType:false,
		itemNavController:null,
		subFilterVisible:false
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	createView:function(){
		var me=this;
		if(CWHF.isNull(me.model)){
			me.view=null;
			return null;
		}
		var id=me.queryContext.queryType+"_"+me.queryContext.queryID;
		me.filterView=me.createTreeView(me.model['queryView'],me.subFilterVisible===true,id);
		var myTitle=getText('common.lbl.queries');
		if(me.subFilterVisible===true){
			me.subFilterView=me.createTreeView(me.model['subFilterView']);
			myTitle=myTitle+" > "+getText('common.lbl.subfilter');
		}else{
			me.subFilterView=null;
		}
		var filterItems=new Array();
		filterItems.push(me.filterView);
		if(me.subFilterView){
			filterItems.push(me.subFilterView);
		}
		me.toolPlus=Ext.create('Ext.panel.Tool',{
			type:'plus',
			hidden:(me.subFilterVisible===true),
			tooltip:getText('common.lbl.subfilter'),
			handler:function(){
				me.toolPlus.setVisible(false);
				me.toolMinus.setVisible(true);
				me.showHideSubFilter();
			}
		});
		me.toolMinus=Ext.create('Ext.panel.Tool',{
			type:'minus',
			tooltip:getText('common.lbl.subfilter.clear'),
			hidden:!(me.subFilterVisible===true),
			handler:function(){
				me.toolPlus.setVisible(true);
				me.toolMinus.setVisible(false);
				me.showHideSubFilter();
			}
		});
		var width=225;
		if(me.subFilterView){
			width=450;
		}
		me.view=Ext.create('Ext.panel.Panel',{
			region:'west',
			bodyBorder:false,
			border:false,
			//margin:Ext.isIE?'0 -4 0 0':'0 -6 0 0',
			width:width,
			minWidth:width,
			collapsible:true,
			title:myTitle,
			//iconCls:'queryView',
			//collapseMode:'mini',
			cls:'westTreeNavigator',
			collapsedCls:'westTreeNavigatorCollapsed',
			split:true,
			tools:[me.toolPlus,me.toolMinus],
			layout:{
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			defaults:{
				flex:1
			},
			items:filterItems
		});
		return me.view;
	},
	createTreeView:function(model,border,nodeID){
		var me=this;
		var myCls='westTreeNavigator';
		if(border===true){
			myCls=myCls+' westTreeNavigator-borderRight'
		}
		var treeView=Ext.create('com.trackplus.itemNavigator.FilterView',{
			flex:1,
			model:model,
			cls:myCls,
			filterController:this
		});
		if(nodeID){
			treeView.addListener('afterrender',function(){
				var record = treeView.getStore().getNodeById(nodeID);
				if(record){
					treeView.getSelectionModel().select(record);
					treeView.expandPath(record.getPath());
				}
				treeView.addListener('select',function(rowModel,record,index, eOpts ){
					me.filterByNode.call(me,rowModel,record,index, eOpts);
					return false;
				});
			});
		}else{
			treeView.addListener('select',function(rowModel,record,index, eOpts ){
				me.filterByNode.call(me,rowModel,record,index, eOpts);
				return false;
			});
		}
		treeView.getView().addListener('beforedrop',function(node,data, overModel){
			var canDrop=overModel.data.canDrop;
			if(!canDrop){
				return false;
			}
			/*var verifyAllowDropAJAX=overModel.data.verifyAllowDropAJAX;
			 if(verifyAllowDropAJAX===true){
			 me.dropOnNodeAjaxRequest.call(me,node,data, overModel, dropPosition,dropFunction,eOpts);
			 }else{
			 me.dropOnNode.call(me,node,data, overModel, dropPosition,dropFunction,eOpts);
			 }
			 return false;*/
			return true;
		});
		treeView.getView().addListener('drop',function(node,data, overModel, dropFunction,eOpts){
			me.dropOnNode.call(me,node,data, overModel,dropFunction,eOpts);
			return true;
		});
		treeView.store.on('beforeload',function( store, operation, eOpts){
			if(operation.node){
				var extraParams = me.getTreeExpandExtraParams.call(me,operation.node);
				if (extraParams) {
					treeView.store.proxy.extraParams = extraParams;
				}
			}
		});
		return treeView;
	},
	getTreeExpandExtraParams:function(node){
		var nodeObjectID=node.data.objectID;
		var nodeType=node.data.nodeType;
		return {
			nodeType:nodeType,
			nodeObjectID:nodeObjectID
		};
	},
	showHideSubFilter:function(){
		var me=this;
		me.subFilterVisible=!me.subFilterVisible;
		var myTitle=getText('common.lbl.queries');
		if(me.subFilterVisible===true){
			var cloneChildren=Ext.clone(me.model['subFilterView']);
			me.subFilterView=me.createTreeView(cloneChildren);
			me.view.getEl().fadeOut({
				opacity: 0.1, //can be any value between 0 and 1 (e.g. .5)
				easing: 'easeOut',
				duration: 250,
				remove: false,
				useDisplay: false,
				callback:function(){
					if(me.view.width<450){
						me.view.setWidth(450);
					}
					me.filterView.addCls('westTreeNavigator-borderRight');
					me.view.add(me.subFilterView);
					myTitle=myTitle+" > "+getText('common.lbl.subfilter');
					me.view.setTitle(myTitle);
					me.view.getEl().fadeIn({
						opacity: 1, //can be any value between 0 and 1 (e.g. .5)
						easing: 'easeOut',
						duration: 500,
						callback:function(){
							me.view.updateLayout();
						}
					});
				}
			});
		}else{
			var needToClear=me.isNeedToClear();
			me.view.getEl().fadeOut({
					opacity: 0.1, //can be any value between 0 and 1 (e.g. .5)
					easing: 'easeOut',
					duration: 250,
					remove: false,
					useDisplay: false,
					callback:function(){
						if(me.view.width>225){
							me.view.setWidth(225);
						}
						me.filterView.removeCls('westTreeNavigator-borderRight');
						me.view.remove(me.subFilterView,true);
						me.subFilterView=null;
						if(needToClear){
							me.itemNavController.clearSubfilter.call(me.itemNavController);
						}
						me.view.setTitle(myTitle);
						me.view.getEl().fadeIn({
							opacity: 1, //can be any value between 0 and 1 (e.g. .5)
							easing: 'easeOut',
							duration: 500,
							callback:function(){
								me.view.updateLayout();
							}
						});
					}
			});
		}
		//me.btnClearSubfilter.setVisible(me.subFilterVisible);
	/*Ext.Ajax.request({
			url: "itemNavigator!storeLastSelectedNavigator.action",
			params:{
				objectID:10
			}
		});*/
	},
	isNeedToClear:function(){
		var me=this;
		var needToClear=false;
		var selections=me.subFilterView.getSelectionModel().getSelection();
		if(selections&&selections.length>0){
			var nodeData=selections[0].data;
			var nodeObjectID=nodeData.objectID;
			var nodeType=nodeData.nodeType;
			if(nodeType&&nodeType!==''){
				needToClear=true;
			}
		}
		return needToClear;
	},
	clearSubFilter:function(){
		var me=this;
		if(me.isNeedToClear()){
			me.subFilterView.getSelectionModel().deselectAll();
			me.itemNavController.clearSubfilter.call(me.itemNavController);
		}
	},
	updatePossibleFieldOptions:function(jsonData){
		var me=this;
		//Status query
		var fieldID=4;
		var validDropTargetIds=jsonData['field'+fieldID];
		var partialDropTargetIds=jsonData['partialField'+fieldID];
		var statusNodeID="section_status";
		var node=me.filterView.getStore().getNodeById(statusNodeID);
		me.markValidDropNodes(node,validDropTargetIds,partialDropTargetIds);
		if(me.subFilterVisible===true){
			var fieldIDs=new Array();
			fieldIDs.push(4);//STATE
			//fieldIDs.push(2);//ISSUETYPE
			fieldIDs.push(10);//PRIORITY
			for(var i=0;i<fieldIDs.length;i++){
				fieldID=fieldIDs[i];
				validDropTargetIds=jsonData['field'+fieldID];
				partialDropTargetIds=jsonData['partialField'+fieldID];
				node=me.subFilterView.getStore().getNodeById("section_operation_ItemOperationSelect_"+fieldID);
				me.markValidDropNodes(node,validDropTargetIds,partialDropTargetIds);
			}
		}
	},
	markValidDropNodes:function(node,validDropTargetIds,partialDropTargetIds){
		var me=this;
		var children = node.childNodes;
		if (children ) {
			for (var i = 0; i < children.length; i++) {
				var child = children[i];
				var nodeID = child.data['id'];
				var id = parseInt(nodeID.substring(nodeID.lastIndexOf("_") + 1));
				var cls = child.get('cls');
				var valid = CWHF.isNull(validDropTargetIds) || Ext.Array.indexOf(validDropTargetIds, id) !== -1;
				var partialValid = partialDropTargetIds  && Ext.Array.indexOf(partialDropTargetIds, id) !== -1;
				if (valid) {
					child.set("cls", cls + " treeItem-dropOk");
					child.set('canDrop',true);
				}
				if (partialValid) {
					child.set("cls", cls + " treeItem-dropPartial");
					child.set('canDrop',true);
				}
				if (!valid && !partialValid) {
					child.set("cls", cls + " treeItem-dropDisabled");
					child.set('canDrop',false);
				}
			}
		}
	},
	clearMarkedNodes:function(node){
		var children=node.childNodes;
		if(children){
			for(var i=0;i<children.length;i++){
				var child=children[i];
				var cls=child.get('cls');
				if(cls){
					cls=cls.replace(" treeItem-dropOk","");
					cls=cls.replace(" treeItem-dropPartial","");
					cls=cls.replace(" treeItem-dropDisabled","");
					child.set("cls",cls);
				}
			}
		}
	},
	onAfterDropItems:function(){
		var me=this;
		//Status query
		var statusNodeID="section_status";
		var node=me.filterView.getStore().getNodeById(statusNodeID);
		me.clearMarkedNodes(node);
		if(me.subFilterVisible===true){
			var fieldIDs=new Array();
			fieldIDs.push(4);//STATE
			//fieldIDs.push(2);//ISSUETYPE
			fieldIDs.push(10);//PRIORITY
			for(var i=0;i<fieldIDs.length;i++){
				var fieldID=fieldIDs[i];
				node=me.subFilterView.getStore().getNodeById("section_operation_ItemOperationSelect_"+fieldID);
				me.clearMarkedNodes(node);
			}
		}
	},
	filterByNode:function(rowModel,record){
		var me=this;
		var nodeType=record.data.nodeType;
		if(me.skipEmptyNodeType===true&&(CWHF.isNull(nodeType)||nodeType==='')){
			return false;
		}
		me.itemNavController.filterByNodeType.call(me.itemNavController,record.data);
	},
	getSelectedItemIds:function(data){
		var workItems="";
		var workItemID=-1;
		for(var i=0;i<data.records.length;i++){
			var workItemIDStr=data.records[i].data['workItemID'];
			try {
				workItemID=parseInt(workItemIDStr);
			}catch(e){
				workItemID=-1;
			}
			if(!isNaN(workItemID)&&workItemID!==-1){
				workItems+=workItemID+",";
			}
		}
		return workItems;
	},
	dropOnNodeAjaxRequest:function(node,data, overModel, dropPosition,dropFunction,eOpts){
		var me=this;
		var workItems =me.getSelectedItemIds(data);
		if(workItems===""){
			return false;
		}
		var nodeObjectID=overModel.data.objectID;
		var nodeType=overModel.data.nodeType;
		var urlStr="itemNavigator!canDropOnNode.action";
		me.view.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				var canDrop=jsonData.data.canDrop;
				me.view.setLoading(false);
				if(canDrop){
					me.dropOnNode.call(me,node,data, overModel, dropPosition,dropFunction,eOpts);
				}
			},
			failure: function(){
				me.view.setLoading(false);
			},
			method:'POST',
			params:{
				workItems:workItems,
				nodeType:nodeType,
				nodeObjectID:nodeObjectID
			}
		});
	},
	dropOnNode:function(node,data, overModel){
		var me=this;
		var  workItems =me.getSelectedItemIds(data);
		if(workItems===""){
			return false;
		}
		var nodeObjectID=overModel.data.objectID;
		var nodeType=overModel.data.nodeType;
		var dropHandlerCls=overModel.data.dropHandlerCls;
		if(CWHF.isNull(dropHandlerCls)||dropHandlerCls===""){
			dropHandlerCls='com.trackplus.itemNavigator.DropHandler';
		}
		var workItemID=workItems[0];
		var workItemIndex=data.records[0].data['workItemIndex'];
		var dropHandler=Ext.create(dropHandlerCls,{
			workItemID:workItemID,
			workItemIndex:workItemIndex,
			workItems:workItems,
			nodeType:nodeType,
			nodeObjectID:nodeObjectID,
			itemNavController:me.itemNavController
		});
		dropHandler.execute.call(dropHandler);
	}
});
Ext.define('com.trackplus.itemNavigator.DropHandler',{
	extend:'Ext.Base',
	config: {
		workItemIndex:null,
		workItemID:null,
		workItems:null,
		nodeType:null,
		nodeObjectID:null,
		itemNavController:null
	},
	TYPE_COMMON:0,
	TYPE_MASS_OPERATION:1,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	execute:function(){
		var me=this;
		me.ajaxRequest.call(me,{
			workItems:me.workItems,
			nodeType:me.nodeType,
			nodeObjectID:me.nodeObjectID
		});
	},
	ajaxRequest:function(params){
		var me=this;
		var urlStr="itemNavigator!dropOnNode.action";
		me.itemNavController.view.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				me.itemNavController.view.setLoading(false);
				if(jsonData.success===true){
					me.itemNavController.refresh.call(me.itemNavController,null,null,false,function(){
						if(me.workItemIndex){
							me.itemNavController.issueListFacade.selectItemByIndex.call(me.itemNavController.issueListFacade,me.workItemIndex);
						}else{
							if(me.workItemID){
								me.itemNavController.issueListFacade.selectItem.call(me.itemNavController.issueListFacade,me.workItemID);
							}else{
								me.itemNavController.issueListFacade.selectItem.call(me.itemNavController.issueListFacade,me.workItems.split(","));
							}
						}
					});
				}else{
					me.handleError.call(me,jsonData,params);
				}
			},
			failure: function(){
				me.itemNavController.view.setLoading(false);
			},
			method:'POST',
			params:params
		});
	},
	confirmationSubmitHandler:function(params){
		var me=this;
		if(CWHF.isNull(params)){
			params={};
		}
		params['params.confirmSave']='true';
		me.ajaxRequest.call(me,params);
	},
	handleError:function(jsonData,params){
		var me=this;
		var type=jsonData.type;
		switch (type){
			case me.TYPE_COMMON:{
				var title=getText("common.err.failure");
				if(jsonData.title){
					title=jsonData.title;
				}
				Ext.MessageBox.show({
					title: title,
					msg:jsonData.errorMessage,
					buttons: Ext.MessageBox.OK,
					icon: Ext.MessageBox.WARNING
				});
				break;
			}
			case me.TYPE_MASS_OPERATION:{
				var massEx=jsonData.massOperation;
				var errorCode=massEx.errorCode;
				if(errorCode&&errorCode===4){
					var title="Error";
					if(massEx.title){
						title=massEx.title;
					}
					Ext.MessageBox.confirm(title,
						massEx.errorMessage,
						function(btn){
							if (btn==="no") {
								return false;
							} else {
								me.confirmationSubmitHandler.call(me,params);
							}
						});
				}else{
					var title="Error";
					if(massEx.title){
						title=massEx.title;
					}
					Ext.MessageBox.show({
						title: title,
						msg:massEx.errorMessage,
						buttons: Ext.MessageBox.OK,
						icon: Ext.MessageBox.WARNING
					});
				}
				break;
			}
		}
	}
});
Ext.define('com.trackplus.itemNavigator.PopupDropHandler',{
	extend:'com.trackplus.itemNavigator.DropHandler',
	config:{
		width:600,
		height:400,
		title:'',
		layout:'fit',
		iconCls:null,
		autoScroll:false
	},
	execute:function(){
		var me=this;
		me.formPanel=me.createFormPanel();
		if(CWHF.isNull(me.formPanel)){
			me.ajaxRequest.call(me,{
				workItems:me.workItems,
				nodeType:me.nodeType,
				nodeObjectID:me.nodeObjectID
			});
			return;
		}
		me.openDialog();
	},
	openDialog:function(){
		var me=this;
		if(me.modalDialog){
			me.modalDialog.destroy();
		}
		if(CWHF.isNull(me.width)){
			me.width=600;
		}
		if(CWHF.isNull(me.height)){
			me.height=400;
		}
		if(CWHF.isNull(me.autoScroll)){
			me.autoScroll=false;
		}
		me.modalDialog = new Ext.Window({
			layout	  : me.layout,
			width	   :me.width ,
			height	  : me.height,
			iconCls	 : me.iconCls,
			closeAction :'destroy',
			plain	   : true,
			bodyBorder  : false,
			bodyStyle:{border:'none'},
			title		:me.title,
			modal	   :true,
			items	   :[me.formPanel],
			autoScroll  :me.autoScroll,
			buttons: [
				{text: getText('common.btn.ok'),
					handler  : function(){
						me.okHandler.call(me);
					}
				}/*,{text :getText('common.btn.reset'),
					handler  : function(){
						me.formPanel.getForm().reset();
					}
				}*/,{text : getText('common.btn.close'),
					handler  : function(){
						me.modalDialog.destroy();
					}
				}
			]
		});
		me.modalDialog.show();
	},
	okHandler:function(){
		var me=this;
		var urlStr="itemNavigator!dropOnNode.action";
		var params={
			workItems:me.workItems,
			nodeType:me.nodeType,
			nodeObjectID:me.nodeObjectID
		};
		me.formPanel.getForm().submit({
			url:urlStr,
			params:params,
			scope: me,
			success: function(form, action) {
				var result = action.result;
				if (result.success) {
					me.modalDialog.destroy();
					me.itemNavController.refresh.call(me.itemNavController);
					/*me.itemNavController.refresh.call(me.itemNavController,
						me.itemNavController.nodeType,me.itemNavController.nodeObjectID);*/
				}else {
					me.handleError.call(me,action.result,params);
				}
			},
			failure: function(form, action) {
				me.handleError.call(me,action.result,params);
			}
		});
	},
	createFormPanel:function(){
		var me=this;
		return Ext.create('Ext.form.Panel',{
			items:me.createFormItems()
		});
	},
	createFormItems:function(){
		return [];
	}
});
Ext.define('com.trackplus.itemNavigator.BasketDropHandler',{
	extend:'com.trackplus.itemNavigator.PopupDropHandler',
	width:450,
	height:250,
	layout:'fit',
	iconCls:null,
	autoScroll:false,
	title:getText("itemov.basketOperation.delegate.title"),
	createFormPanel:function(){
		var me=this;
		switch(me.nodeObjectID){
			case 4:{
				//CALENDAR
				me.width=380;
				me.height=100;
				me.title=getText("itemov.basketOperation.calendar.title");
				return Ext.create('Ext.form.Panel',{
					layout:{
						type:'hbox'
					},
					bodyStyle:{
						padding:'5px'
					},
					items:me.createFormItemsCalendar()
				});
			}
			case 5:{
				//DELEGATED
				return Ext.create('Ext.form.Panel',{
					bodyStyle:{
						padding:'5px'
					},
					items:me.createFormItems()
				});
			}
		}
		return null;
	},
	createFormItemsCalendar:function() {
		return [CWHF.createDateTimeField("itemov.basketOperation.calendar.date", "params.date", "params.time", {submitFormat:null,width:100}, {width:80, increment:30}, {labelWidth:150})];
	},
	createFormItems:function(){
		var me=this;
		var store = Ext.create('Ext.data.Store', {
			fields: ['id', 'label'],
			proxy: {
				type: 'ajax',
				url:'itemNavigator!getResponsibles.action?workItems='+me.workItems,
				reader: {
					type: 'json'
				}
			}
		});
		var cmbPerson=Ext.create('Ext.form.field.ComboBox',{
			fieldLabel: getText("admin.customize.automail.trigger.lbl.responsible"),
			labelAlign:'right',
			store: store,
			displayField: 'label',
			valueField: 'id',
			labelWidth:100,
			width:250,
			name:'params.responsible'
		});
		var dateTimePicker = CWHF.createDateTimeField("itemov.basketOperation.delegate.date", "params.date", "params.time", {submitFormat:null,width:100}, {width:80, increment:30}, {labelWidth:100});
		var txtComment=Ext.create('Ext.form.field.TextArea',{
			fieldLabel: getText('common.history.lbl.comment'),
			labelAlign:'right',
			name:'params.comment',
			minWidth:25,
			labelWidth:100,
			anchor: '100% -50'
		});
		return [cmbPerson,dateTimePicker,txtComment];
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.SimpleTreeGridViewPlugin',{
	extend: 'com.trackplus.itemNavigator.IssueListViewPlugin',
	mixins:{
		navigable:'com.trackplus.itemNavigator.TreeNavigableItem'
	},
	view:null,
	includeLongFields:false,
	useArrows:false,
	lines:true,
	disableSort:false,
	treeColumnID:null,
	useSelectionModel:false,
	useTree:true,
	constructor: function(config){
		this.callParent(arguments);
		this.mixins.navigable.constructor.call(this);
	},
	refreshData:function(data){
		var me=this;
		if(me.view){
			var rootNode=me.view.getStore().getRootNode();
			rootNode.removeAll();
			if(data&&data.length>0){
				rootNode.appendChild(data);
				me.view.getStore().sort();
			}
		}
	},
	createView:function(){
		var me=this;
		me.queryFieldCSS=me.model.queryFieldCSS;
		me.cellInlineCtr = Ext.create('com.trackplus.itemNavigator.CellInlineEditController',{
			navigator: me,
	    	isPrintItemEditable: me.model.isPrintItemEditable
		});
		me.view=Ext.create('Ext.tree.Panel',{
			margins: '0 0 0 0',
			region:'center',
			border:false,
			bodyBorder:false,
			columnLines :true,
			rowLines:true,
			lines :me.lines,
			rootVisible: false,
			useArrows: me.useArrows,
			cls:'simpleGridView gridNoBorder',
			plugins: [{
		        ptype: 'cellediting',
		        clicksToEdit: 1
		    }],
			viewConfig: {
				stripeRows: true,
				plugins:me.getTreeViewPlugins(),
				getRowClass: function (record, rowIndex, rp, ds) {
            	    return me.getRowClass.call(me,record, rowIndex, rp, ds);
            	}
			},
			store:me.createStore(),
			columns:me.createColumnModel(),
			selModel:me.createSelModel(),
			features:me.createFeatures.call(me)
		});
		me.initMyListeners();
		me.cellInlineCtr.setGrid(me.view);
        me.cellInlineCtr.initListeners();
        return me.view;
	},
	destroyView:function(){
		var me=this;
		me.view=null;
		delete me.view;
	},
	getTreeViewPlugins:function(){
		return [{
			ddGroup: 'itemToCategory',
			ptype: 'gridviewdragdrop',
			enableDrop: false
		}];
	},
	getSelectedIssues:function(){
		var me=this;
		var issueIds=[];
		if(me.model.layout.bulkEdit){
			var selections=me.view.getSelectionModel().getSelection();
			if(selections&&selections.length>0){
				for(var i=0;i<selections.length;i++){
					issueIds.push(selections[i].data.workItemID);
				}
			}
		}
		return issueIds;
	},
	getTreeGrid:function(){
		return this.view;
	},
	selectItemByIndex:function(workItemIndex){
		var me=this;
		return me.selectItemByIndexInTree(me.view,workItemIndex);
	},
	selectItem:function(workItemID){
		var me=this;
		return me.selectItemInTree(me.view,workItemID);
	},
	deselectItem:function(workItemID){
		var me=this;
		return me.deselectItemInTree(me.view,workItemID);
	},
	initMyListeners:function(){
		var me=this;
		//fix ExtJS BUG: click on row in grid with scroll will focus first row
		me.view.on('boxready', function (thisGrid) {
			thisGrid.view.focus = Ext.emptyFn;
		});
		me.view.addListener('itemcontextmenu',me.onGridItemContextMenu,me);
		me.view.addListener('celldblclick',me.onGridItemDblClick,me);
		me.view.addListener('afterrender',me.onGridAfterRenderer,me);
		me.view.addListener('columnresize',me.columnResizeHandler,me);
		me.view.addListener('columnmove',me.columnMoveHandler,me);
		me.view.addListener('sortchange',me.sortChangeHandler,me);
		me.view.addListener('afteritemexpand',me.afterItemExpandHandler,me);
		me.view.addListener('afteritemcollapse',me.afterItemCollapseHandler,me);
		//me.addListener('columnhide',me.columnHideHandler,me);
		//me.addListener('columnshow',me.columnShowHandler,me);
		me.view.getSelectionModel().addListener('selectionchange',me.onGridSelectionChange,me);
	},
	onGridSelectionChange: function(sm, selections) {
		var me = this;
		if(me.model.layout.bulkEdit){
			me.fireEvent.call(me,'selectionchange',selections);
		}
		if(me.cellInlineCtr ) {
			me.cellInlineCtr.onGridSelectionChnage(sm, selections);
		}
	},
	onGridAfterRenderer:function(){
		var me=this;
		var rowExpandAllTrgEl=Ext.get('rowExpandAllTrg');
		if(rowExpandAllTrgEl){
			rowExpandAllTrgEl.addListener('click',me.rowExpandAll,me);
		}
		var rowCollapseAllTrgEl=Ext.get('rowCollapseAllTrg');
		if(rowCollapseAllTrgEl){
			rowCollapseAllTrgEl.addListener('click',me.rowCollapseAll,me);
		}
		var dragZone=this.view.view.plugins[0].dragZone;
		if(dragZone){
			dragZone.onStartDrag=function(x,y){
				var records=this.dragData.records;
				var workItems=me.getSelectedItemIds(records);
				me.fireEvent('startDragItems',workItems);
				return true;
			};
			dragZone.afterDragDrop=function(){
				me.fireEvent('afterDropItems');
			};
			dragZone.afterInvalidDrop=function(){
				me.fireEvent('afterDropItems');
			};
		}
	},
	getSelectedItemIds:function(records){
		var workItems="";
		var workItemID=-1;
		for(var i=0;i<records.length;i++){
			var workItemIDStr=records[i].data['workItemID'];
			try {
				workItemID=parseInt(workItemIDStr);
			}catch(e){
				workItemID=-1;
			}
			if(!isNaN(workItemID)&&workItemID!==-1){
				workItems+=workItemID+",";
			}
		}
		return workItems;
	},
	onGridItemContextMenu:function(gridView,record,item,index, event,opts){
		var me=this;
		event.stopEvent();
		me.fireEvent('itemcontextmenu',record.data,event,me.view,index,record);
		return false;
	},
	onGridItemDblClick:function(view, td,cellIndex,record, tr, rowIndex,e){
		var me=this;
		e.stopEvent();
		if(me.model.layout.bulkEdit===true&&cellIndex===0){
			return false;
		}
		me.fireEvent.call(me,'itemdblclick',record.data,td);
		return false;
	},
	invalidExpandCollapse:false,
	expandCollapseItem:function(node,expanded){
		var me=this;
		var id=node.data.id;
		if((id+'').indexOf('g')!==-1){
			//group
			me.expandGroup(id.substring(1),expanded);
		}else{
			//item
			me.expandItem(id,expanded);
		}
	},
	expandGroup:function(groupID,expanded){
		Ext.Ajax.request({
			url: 'reportExpand!expandGroup.action',
			params:{
				expanded:expanded,
				groupID:groupID
			}
		});
	},
	expandItem:function(workItemID,expanded){
		Ext.Ajax.request({
			url: 'reportExpand!expandReportBean.action',
			params:{
				expanded:expanded,
				workItemID:workItemID
			}
		});
	},
	afterItemExpandHandler:function(node, index, item){
		var me=this;
		if(me.invalidExpandCollapse===true){
			return;
		}
		me.expandCollapseItem(node,true);
	},
	afterItemCollapseHandler:function(node, index, item, eOpts){
		var me=this;
		if(me.invalidExpandCollapse===true){
			return;
		}
		me.expandCollapseItem(node,false);
	},
	validateExpandCollapse:function(node){
		var me=this;
		Ext.Function.defer(function(){
			me.invalidExpandCollapse=false;
		}, 3000, me);
	},
	rowExpandAll:function(e){
		var me=this;
		e.stopEvent();
		me.invalidExpandCollapse=true;
		//me.view.removeListener('beforeitemexpand',me.beforeItemExpandHandler,me);
		//me.view.removeListener('beforeitemcollapse',me.beforeItemCollapseHandler,me);
		me.view.expandAll(me.validateExpandCollapse,me);
		Ext.Ajax.request({
			url: "reportExpand!expandAll.action"
		});
		return false;
	},
	rowCollapseAll:function(e){
		var me=this;
		e.stopEvent();
		me.invalidExpandCollapse=true;
		me.view.collapseAll(me.validateExpandCollapse,me);
		Ext.Ajax.request({
			url: "reportExpand!collapseAll.action"
		});
		return false;
	},
	columnResizeHandler:function(ct,column,width){
		var me=this;
		var urlStr="layoutColumns!resizeColumn.action";
		var layoutID=column.itemId.substring(2);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				me.fireEvent.call(me,'layoutchange');
			},
			failure: function(){
			},
			method:'POST',
			params:{
				layoutID:layoutID,
				fieldID: column.fieldID,
				width:width,
				filterType:me.model.queryContext.queryType,
				filterID:me.model.queryContext.queryID
			}
		});
	},
	sortChangeHandler:function(ct,column,direction){
		var me=this;
		var sortField = column.dataIndex.substring(1);
		//false = ascending, true = descending
		var sortOrder = (direction==='DESC');
		me.model.layout.sortField=sortField;
		me.model.layout.sortOrder=sortOrder;
		me.model.layout.sortWithSO=column.sortWithSO;
		if (me.model.queryContext) {
			filterType = me.model.queryContext.queryType;
			filterID = me.model.queryContext.queryID;
		}
		me.fireEvent.call(me,'sortchange',{
			sortField:sortField,
			sortOrder:sortOrder,
			sortWithSO:column.sortWithSO
		});
		Ext.Ajax.request({
			url: 'layoutSorting.action',
			disableCaching:true,
			params:{
				sortField:sortField,
				sortOrder:sortOrder,
				filterType: filterType,
				filterID: filterID
			}
		});
	},
	createFeatures:function(){
		var me=this;
		var features= [];
		/*features.push(Ext.create('com.trackplus.itemNavigator.GroupFeature',{
			treeColumnID:me.treeColumnID,
			useSelectionModel:me.useSelectionModel
		}));*/
		return features;
	},
	getSorters:function(){
		var me=this;
		var sorters=null;
		if(me.model.layout.sortField){
			var sortField="f"+me.model.layout.sortField;
			var sortDirection;
			if(me.model.layout.sortOrder===true){
				sortDirection='DESC';
			}else{
				sortDirection='ASC';
			}
			sorters=[];
			if(me.model.layout.sortWithSO===true){
				sorters.push({
					property:sortField,
					direction :sortDirection,
					sorterFn:function(o1,o2){
						var me = this;
						var v1 = me.getRoot(o1)['f_so'+me.property.substring(1)];
						var v2 = me.getRoot(o2)['f_so'+me.property.substring(1)];
						var r= v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
					}
				});
			}else{
				sorters.push({
					property:sortField,
					direction :sortDirection
				});
			}
		}
		return sorters;
	},
	createStore:function(){
		var me=this;
		var fields=me.createFields();
		var store=Ext.create('Ext.data.TreeStore', {
			fields:fields,
			autoLoad: false,
			//sorters:me.getSorters(),
			root: {
				expanded: true,
				text:"",
				children:me.model.issues
			}
		});
		store.addListener("refresh",me.onStoreRefresh,me);
		return store;
	},
	findNodeByWorkItemIndex:function(workItemIndex){
		var me=this;
		var selectedNode=null;
		var maxIndex=0;
		var maxNode=0;
		var root=me.view.getStore().getRootNode();
		root.cascadeBy(function (node) {
			var idx=node.data['workItemIndex'];
			if(idx){
				if(idx>maxIndex){
					maxIndex=idx;
					maxNode=node;
				}
				if(idx===workItemIndex){
					selectedNode=node;
				}
			}
		});
		if(selectedNode){
			return selectedNode;
		}
		return maxNode;
	},
	getLayoutData:function(columnID){
	},
	createColumnModel:function(){
		var me=this;
		var shortFields=me.model.layout.shortFields;
		var columnModel=new Array(0);
		var layoutData;
		if(me.model.layout.indexNumber===true){
			var count=me.model.totalCount;
			var size=0;
			if(CWHF.isNull(count)||count===0){
				size=21;
			}else{
				size=(count+"").length*5+17;
			}
			columnModel.push({
				draggable :false,
				menuDisabled:true,
				width:size,
				dataIndex:'workItemIndex',
				sortable:false,
				align:'right',
				tdCls:'simpleTreeGridCell',
				resizable:false
			});
		}
		for(var i=0;i<shortFields.length;i++){
			layoutData=shortFields[i];
			var sortable= !me.disableSort;//&&layoutData.sortable;
			var col=me.createColumn(i,layoutData,sortable,me.useTree);
			if(i>0){
				me.cellInlineCtr.setColumnEditor(shortFields[i], col);
				var uniformizedFieldType = me.cellInlineCtr.getUniformizedFieldType(layoutData.extJsRendererClass);
				if (uniformizedFieldType ) {
					var renderer = me.cellInlineCtr.getRendererForSpecificColumns(uniformizedFieldType);
					if (renderer) {
						col.renderer = renderer;
					}
				}
			}
			columnModel.push(col);
		}
		return columnModel;
	},
	dataChangeSuccess:function(opts){
		var me = this;
		me.cellInlineCtr.dataChangeSuccess();
	}
});
function openAttachments(workItemID,attachmentIds){
	var me=this;
	var selections=attachmentIds.split(";");
	for(var i=0;i<selections.length;i++){
		var attachID=selections[i];
		var attachmentURI='downloadAttachment.action?workItemID='+workItemID+'&attachKey='+attachID;
		if(i===0){
			window.open(attachmentURI,'attachmentWindow');
		}else{
			window.open(attachmentURI);
		}
	}
}

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.FlatGridViewPlugin',{
	extend: 'com.trackplus.itemNavigator.IssueListViewPlugin',
	mixins:{
		navigable:'com.trackplus.itemNavigator.GridNavigableItem'
	},
	plainGrid:true,
	view:null,
	includeLongFields:true,
	disableSort:false,
	treeColumnID:null,
	useSelectionModel:false,
	useTree:true,
	paginate:false,
	pageSize:10,
	cellInlineCtr:null,
	constructor: function(config){
		var me=this;
		this.callParent(arguments);
		this.mixins.navigable.constructor.call(this);
		me.paginate=me.model.listViewData.paginate;
		me.pageSize=me.model.listViewData.pageSize;
	},
	refreshData:function(data){
		var me=this;
		if(me.view){
			me.view.getStore().loadData(data);
		}
	},
	createFields:function(){
		var me=this;
		var fields=me.callParent();
		var longFields=me.model.layout.longFields;
		if(longFields){
			for(var i=0;i<longFields.length;i++){
				fields.push({name:'f'+longFields[i].reportField});
			}
		}
		fields.push({
			name : 'leaf'
		});
		return fields;
	},
	getSettingsToolbarItems:function(btnGroup,btnChooseColumns){
		var me=this;
		var items =me.callParent(arguments);
		var paginateLbl=getText('itemov.lbl.paginate');
		me.checkPaginate=Ext.create('Ext.form.field.Checkbox',{
			boxLabel:paginateLbl ,
			overflowText :paginateLbl,
			tooltip :getText('itemov.lbl.paginate.tt'),
			inputValue : true,
			checked:me.paginate
		});
		me.checkPaginate.addListener('change',me.changePaginate,me);
		items.push(me.checkPaginate);
		return items;
	},
	changePaginate:function(){
		var me=this;
		me.view.setLoading(true);
		me.paginate=me.checkPaginate.getValue();
		Ext.Ajax.request({
			url: "userPreferences.action?property=itemNavigatorPaginate&value="+me.paginate,
			disableCaching:true,
			success: function(data){
				me.view.setLoading(false);
				me.fireEvent.call(me,'datachange');
			},
			failure: function(type, error){
			}
		});
	},
	changePageSize:function(field, e){
		if (e.getKey() === e.ENTER) {
			var me = this;
			me.view.setLoading(true);
			me.pageSize = me.txtPageSize.getValue();
			Ext.Ajax.request({
				url: "userPreferences.action?property=itemNavigatorPageSize&value=" + me.pageSize,
				disableCaching: true,
				success: function (data) {
					me.view.setLoading(false);
					me.fireEvent.call(me, 'datachange');
				},
				failure: function (type, error) {
				}
			});
		}
	},
	createView:function(){
		var me=this;
		me.cellInlineCtr = Ext.create('com.trackplus.itemNavigator.CellInlineEditController',{
			navigator: me,
	    	isPrintItemEditable: me.model.isPrintItemEditable
		});
		me.queryFieldCSS=me.model.queryFieldCSS;
		var store=me.createStore();
		var pluginExpanded = true;
		var cfg={
			margins: '0 0 0 0',
			region:'center',
			border:false,
			bodyBorder:false,
			columnLines :true,
			rowLines:true,
			cls:'simpleGridView gridNoBorder',
			plugins: [{
		        ptype: 'cellediting',
		        clicksToEdit: 1
		    }],
			viewConfig: {
				stripeRows: true,
				selectionModel: {
					type: 'rowmodel'
				},
				plugins:me.getTreeViewPlugins(),
				getRowClass: function (record, rowIndex, rp, ds) {
					return me.getRowClass.call(me,record, rowIndex, rp, ds);
				}
			},
			store:store,
			columns:me.createColumnModel(),
			selModel:me.createSelModel(),
			features:me.createFeatures.call(me)
		};
		if(me.paginate===true){
			me.txtPageSize=Ext.create('Ext.form.field.Number',{
				name: 'pageSize',
				fieldLabel: getText('itemov.lbl.pageSize'),
				labelAlign:'right',
				value: me.pageSize,
				maxValue: 10000,
				minValue: 10,
				allowDecimals:false,
				width:175
			});
			me.txtPageSize.addListener('specialkey',me.changePageSize,me);
			cfg.tbar=Ext.create('Ext.PagingToolbar', {
				itemId:'paginateToolbar',
				store: store,
				displayInfo: true,
				afterPageText:getText('itemov.lbl.paginate.afterPageText'),
				beforePageText:getText('itemov.lbl.paginate.beforePageText'),
				displayMsg: getText('itemov.lbl.paginate.displayMsg'),
				emptyMsg: getText('itemov.lbl.paginate.emptyMsg'),
				items:['-', me.txtPageSize]
			});
		}
		me.view=Ext.create('Ext.grid.Panel',cfg);
		me.initMyListeners();
	    me.cellInlineCtr.setGrid(me.view);
        me.cellInlineCtr.initListeners();
		return me.view;
	},
	destroyView:function(){
		var me=this;
		me.view=null;
		delete me.view;
	},
	getTreeViewPlugins:function(){
		return [{
			ddGroup: 'itemToCategory',
			ptype: 'gridviewdragdrop',
			enableDrop: false
		}];
	},
	getSelectedIssues:function(){
		var me=this;
		var issueIds=[];
		if(me.model.layout.bulkEdit){
			var selections=me.view.getSelectionModel().getSelection();
			if(selections&&selections.length>0){
				for(var i=0;i<selections.length;i++){
					issueIds.push(selections[i].data.workItemID);
				}
			}
		}
		return issueIds;
	},
	getGrid:function(){
		return this.view;
	},
	getFieldNameItemID:function(){
		return 'workItemID';
	},
	selectItemByIndex:function(workItemIndex){
		var me=this;
		return me.selectItemGridByIndex(me.view,workItemIndex);
	},
	selectItem:function(workItemID){
		var me=this;
		var grid=me.getGrid();
		if(CWHF.isNull(grid)||CWHF.isNull(workItemID)){
			return null;
		}
		return me.selectItemGrid(grid,workItemID);
	},
	deselectItem:function(workItemID){
		var me=this;
		var grid=me.getGrid();
		if(CWHF.isNull(grid)||CWHF.isNull(workItemID)){
			return null;
		}
		me.deselectItemGrid(grid,workItemID);
	},
	initMyListeners:function(){
		var me=this;
		//fix ExtJS BUG: click on row in grid with scroll will focus first row
		me.view.on('boxready', function (thisGrid) {
			thisGrid.view.focus = Ext.emptyFn;
		});
		me.view.addListener('itemcontextmenu',me.onGridItemContextMenu,me);
		me.view.addListener('celldblclick',me.onGridItemDblClick,me);
		me.view.addListener('afterrender',me.onGridAfterRenderer,me);
		me.view.addListener('columnresize',me.columnResizeHandler,me);
		me.view.addListener('columnmove',me.columnMoveHandler,me);
		me.view.addListener('sortchange',me.sortChangeHandler,me);
		//me.view.addListener('afteritemexpand',me.afterItemExpandHandler,me);
		//me.view.addListener('afteritemcollapse',me.afterItemCollapseHandler,me);
		//me.addListener('columnhide',me.columnHideHandler,me);
		//me.addListener('columnshow',me.columnShowHandler,me);
		me.view.getSelectionModel().addListener('selectionchange',me.onGridSelectionChange,me);
	},
	onGridSelectionChange: function(sm, selections) {
		var me = this;
		if(me.model.layout.bulkEdit){
//			me.callParent(sm, selections);
			me.fireEvent.call(me,'selectionchange',selections);
		}
		if(me.cellInlineCtr ) {
			me.cellInlineCtr.onGridSelectionChnage(sm, selections);
		}
	},
	onGridAfterRenderer:function(){
		var me=this;
		var rowExpandAllTrgEl=Ext.get('rowExpandAllTrg');
		if(rowExpandAllTrgEl){
			rowExpandAllTrgEl.addListener('click',me.rowExpandAll,me);
		}
		var rowCollapseAllTrgEl=Ext.get('rowCollapseAllTrg');
		if(rowCollapseAllTrgEl){
			rowCollapseAllTrgEl.addListener('click',me.rowCollapseAll,me);
		}
		var dragZone=this.view.view.plugins[0].dragZone;
		if(dragZone){
			dragZone.onStartDrag=function(x,y){
				var records=this.dragData.records;
				var workItems=me.getSelectedItemIds(records);
				me.fireEvent('startDragItems',workItems);
				return true;
			};
			dragZone.afterDragDrop=function(){
				me.fireEvent('afterDropItems');
			};
			dragZone.afterInvalidDrop=function(){
				me.fireEvent('afterDropItems');
			};
		}
	},
	getSelectedItemIds:function(records){
		var workItems="";
		var workItemID=-1;
		for(var i=0;i<records.length;i++){
			var workItemIDStr=records[i].data['workItemID'];
			try {
				workItemID=parseInt(workItemIDStr);
			}catch(e){
				workItemID=-1;
			}
			if(!isNaN(workItemID)&&workItemID!==-1){
				workItems+=workItemID+",";
			}
		}
		return workItems;
	},
	onGridItemContextMenu:function(gridView,record,item,index, event,opts){
		var me=this;
		event.stopEvent();
		me.fireEvent('itemcontextmenu',record.data,event,me.view,index,record);
		return false;
	},
	onGridItemDblClick:function(view, td,cellIndex,record, tr, rowIndex,e){
		var me=this;
		e.stopEvent();
		if(me.model.layout.bulkEdit===true&&cellIndex===0){
			return false;
		}
		me.fireEvent.call(me,'itemdblclick',record.data,td);
		return false;
	},
	invalidExpandCollapse:false,
	columnResizeHandler:function(ct,column,width){
		var me=this;
		var urlStr="layoutColumns!resizeColumn.action";
		var layoutID=column.itemId.substring(2);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				me.fireEvent.call(me,'layoutchange');
			},
			failure: function(){
			},
			method:'POST',
			params:{
				layoutID:layoutID,
				fieldID: column.fieldID,
				width:width,
				filterType:me.model.queryContext.queryType,
				filterID:me.model.queryContext.queryID
			}
		});
	},
	sortChangeHandler:function(ct,column,direction){
		var me=this;
		var sortField = column.dataIndex.substring(1);
		//false = ascending, true = descending
		var sortOrder = (direction==='DESC');
		me.model.layout.sortField=sortField;
		me.model.layout.sortOrder=sortOrder;
		me.model.layout.sortWithSO=column.sortWithSO;
		var filterType = null;
		var filterID = null;
		if (me.model.queryContext) {
			filterType = me.model.queryContext.queryType;
			filterID = me.model.queryContext.queryID;
		}
		me.fireEvent.call(me,'sortchange',{
			sortField:sortField,
			sortOrder:sortOrder,
			sortWithSO:column.sortWithSO
		});
		Ext.Ajax.request({
			url: 'layoutSorting.action',
			disableCaching:true,
			params:{
				sortField:sortField,
				sortOrder:sortOrder,
				filterType: filterType,
				filterID: filterID
			},
			success:function(){
				if(me.paginate===true) {
					me.view.getDockedComponent('paginateToolbar').moveFirst();
				}
			}
		});
	},
	createFeatures:function(){
		var me=this;
		var features=new Array();
		if(me.model.layout.longFields&&me.model.layout.longFields.length>0){
			features.push(me.createRowBodyFeature());
		}
		//features.push({ftype: 'rowwrap'});
		return features;
	},
	createRowBodyFeature:function(){
		var me=this;
		return Ext.create('com.trackplus.itemNavigator.RowBody',{
			model:me.model
		});
	},
	getSorters:function(){
		var me=this;
		var sorters=null;
		return null;
		if(me.model.layout.sortField){
			var sortField="f"+me.model.layout.sortField;
			var sortDirection;
			if(me.model.layout.sortOrder===true){
				sortDirection='DESC';
			}else{
				sortDirection='ASC';
			}
			sorters=[];
			if(me.model.layout.sortWithSO===true){
				sorters.push({
					property:sortField,
					direction :sortDirection,
					sorterFn:function(o1,o2){
						var me = this;
						var v1 = me.getRoot(o1)['f_so'+me.property.substring(1)];
						var v2 = me.getRoot(o2)['f_so'+me.property.substring(1)];
						var r= v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
					}
				});
			}else{
				sorters.push({
					property:sortField,
					direction :sortDirection
				});
			}
		}
		return sorters;
	},
	createStore:function(){
		var me=this;
		var fields=me.createFields();
		var cfg={
			fields:fields,
			pageSize: me.pageSize,
			autoLoad: true/*,
			sorters:me.getSorters()*/
		};
		if(me.paginate===true){
			cfg.proxy={
				type: 'ajax',
				url: 'itemNavigator!navigate.action',
				reader:Ext.create('com.trackplus.itemNavigator.FlatGridReader',{
					rootProperty: 'issues',
					totalProperty: 'totalCount',
					flatGridViewPlugin:me
				}),
				simpleSortMode: true
			};
		}else{
			cfg.data=me.model.issues;
		}
		var store=Ext.create('Ext.data.Store',cfg);
		if(me.paginate===true){
			store.addListener('beforeload',me.beforeLoadPage,me);
		}
		//store.addListener("refresh",me.onStoreRefresh,me);
		return store;
	},
	beforeLoadPage:function(){
		var me=this;
		me.view.store.getProxy().extraParams = {
			queryContextID:me.model.queryContext.id,
			nodeType:me.model.nodeType,
			nodeObjectID:me.model.nodeObjectID
		};
	},
	getLayoutData:function(columnID){
	},
	createColumnModel:function(){
		var me=this;
		var shortFields=me.model.layout.shortFields;
		var columnModel=new Array(0);
		var layoutData;
		if(me.model.layout.indexNumber===true){
			var count=me.model.totalCount;
			var size=0;
			if(CWHF.isNull(count)||count===0){
				size=21;
			}else{
				size=(count+"").length*5+17;
			}
			columnModel.push({
				draggable :false,
				menuDisabled:true,
				width:size,
				dataIndex:'workItemIndex',
				sortable:false,
				align:'right',
				tdCls:'simpleTreeGridCell',
				resizable:false
			});
		}
		for(var i=0;i<shortFields.length;i++){
			layoutData=shortFields[i];
			var sortable= !me.disableSort;//&&layoutData.sortable;
			var col=me.createColumn(i,layoutData,sortable,false);
			me.cellInlineCtr.setColumnEditor(shortFields[i], col);
			var uniformizedFieldType = me.cellInlineCtr.getUniformizedFieldType(layoutData.extJsRendererClass);
			if(uniformizedFieldType ) {
				var renderer = me.cellInlineCtr.getRendererForSpecificColumns(uniformizedFieldType);
				if(renderer ) {
					col.renderer = renderer;
				}
		    }
			columnModel.push(col);
		}
		return columnModel;
	},
	dataChangeSuccess:function(opts){
		var me = this;
		me.cellInlineCtr.dataChangeSuccess();
	}
});
Ext.define('com.trackplus.itemNavigator.FlatGridReader',{
	extend: 'Ext.data.reader.Json',
	config:{
		flatGridViewPlugin:null
	},
	readRecords: function(data) {
		var me = this;
		var totalCount=data.totalCount;
		var count=data.count;
		me.getFlatGridViewPlugin().fireEvent('totalChange',totalCount,count);
		return me.callParent(arguments);
	}
});
Ext.define('com.trackplus.itemNavigator.RowBody',{
	extend: 'Ext.grid.feature.RowBody',
	config:{
		model:{}
	},
	init:function(grid){
		var me = this;
		me.extraRowTpl=[
			'{%',
			'values.view.rowBodyFeature.setupRowData(values.record, values.recordIndex, values);',
			'this.nextTpl.applyOut(values, out, parent);',
			'%}',
				'<tr class="' + Ext.baseCSSPrefix + 'grid-rowbody-tr {rowBodyCls}">',
			me.model.layout.bulkEdit?'<tpl if="emptyCellClass === \'\'" ><td class="x-grid-cell-special"></td><tpl else><td class="x-grid-cell-special" style="border-top-width:1px;"></td></tpl> ':'',
			me.model.layout.indexNumber?'<td class="simpleTreeGridRowBodyEmptyCell {emptyCellClass}"></td>':'',
			'<td class="simpleTreeGridRowBodyEmptyCell {emptyCellClass}"></td>',
				'<td class="' + Ext.baseCSSPrefix + 'grid-cell-rowbody' + '" colspan="{rowBodyColspan}">',
				'<div class="ulist ' + Ext.baseCSSPrefix + 'grid-rowbody' + ' {rowBodyDivCls}">{rowBody}</div>',
			'</td>',
			'</tr>', {
				priority: 100,
				syncRowHeights: function(firstRow, secondRow) {
					var owner = this.owner,
						firstRowBody = Ext.fly(firstRow).down(owner.eventSelector, true),
						secondRowBody,
						firstHeight, secondHeight;
					// Sync the heights of row body elements in each row if they need it.
					if (firstRowBody && (secondRowBody = Ext.fly(secondRow).down(owner.eventSelector, true))) {
						if ((firstHeight = firstRowBody.offsetHeight) > (secondHeight = secondRowBody.offsetHeight)) {
							Ext.fly(secondRowBody).setHeight(firstHeight);
						}
						else if (secondHeight > firstHeight) {
							Ext.fly(firstRowBody).setHeight(secondHeight);
						}
					}
				},
				syncContent: function(destRow, sourceRow) {
					var owner = this.owner,
						destRowBody = Ext.fly(destRow).down(owner.eventSelector, true),
						sourceRowBody;
					// Sync the heights of row body elements in each row if they need it.
					if (destRowBody && (sourceRowBody = Ext.fly(sourceRow).down(owner.eventSelector, true))) {
						Ext.fly(destRowBody).syncContent(sourceRowBody);
					}
				}
			}
		];
		me.callParent(arguments);
	},
	getAdditionalData: function(data, idx, record, orig) {
		var me=this;
		var headerCt = this.view.headerCt;
		var colspan = headerCt.getColumnCount()-1;
		if(me.model.layout.bulkEdit){
			colspan=colspan-1;
		}
		if(me.model.layout.indexNumber){
			colspan=colspan-1;
		}
		if(data['group']===true){//grouping
			return null;
		}
		var rowBody='';
		var rowBodyContent='';
		var emptyCellClass='';
		if(me.model.layout.longFields&&me.model.layout.longFields.length>0){
			rowBody='<div class="simpleTreeGridRowBody">';
			var longField;
			for(var i=0;i<me.model.layout.longFields.length;i++){
				longField=me.model.layout.longFields[i];
				var longFieldID=longField.reportField;
				var longFieldLabel=longField.label;
				var longFieldValue=data["f"+longFieldID];
				switch(longFieldID){
					case -1005:{
						//history
						var history=data['f'+longFieldID];
						if(history&&history.length>0){
							rowBodyContent+=me.createHistoryTemplate.call(me,data, idx, record,orig,longFieldLabel,history);
						}
						break;
					}
					case 23:{
						//comment
						var comments=data['f'+longFieldID];
						if(comments&&comments.length>0){
							rowBodyContent+=me.createCommentsTemplate.call(me,data, idx, record,orig,longFieldLabel,comments);
						}
						break;
					}
					case -1008:{
						//cost
						var costs=data['f'+longFieldID];
						if(costs&&costs.length>0){
							rowBodyContent+=me.createCostsTemplate.call(me,data, idx, record,orig,longFieldLabel,costs);
						}
						break;
					}
					case -1007://budgetHistory
					case -1011:{
						//PLAN_HISTORY_LIST = -1011
						var budgetHistory=data['f'+longFieldID];
						if(budgetHistory&&budgetHistory.length>0){
							rowBodyContent+=me.createBudgetHistoryTemplate.call(me,data, idx, record,orig,longFieldLabel,budgetHistory);
							//longFieldValue="someething here";
							//rowBodyContent+=me.createLongFieldTemplate.call(me,data, idx, record, orig,longFieldID,longFieldLabel,longFieldValue);
						}
						break;
					}
					default:{
						if(longFieldValue&&longFieldValue!==''){
							rowBodyContent+=me.createLongFieldTemplate.call(me,data, idx, record, orig,longFieldID,longFieldLabel,longFieldValue);
						}
					}
				}
			}
			hasContent=rowBodyContent!=='';
			if(hasContent){
				emptyCellClass='simpleTreeGridRowBodyEmptyCell-bodyContent';
			}
			rowBody+=rowBodyContent;
			rowBody+='</div>';
		}
		return {
			rowBody: rowBody,
			rowBodyCls: this.rowBodyCls,
			rowBodyColspan: colspan,
			emptyCellClass:emptyCellClass
		};
	},
	createLongFieldTemplate:function(data, idx, record, orig,longFieldID,lonFieldLabel,longFieldValue){
		var me=this;
		if(CWHF.isNull(me.longFieldTpl)){
			me.initLongFieldTpl();
		}
		return me.longFieldTpl.applyTemplate({lonFieldLabel: lonFieldLabel, longFieldValue:longFieldValue});
	},
	initLongFieldTpl:function(){
		var me=this;
		var str='<table class="reportHistory" border="0" cellPadding="0" cellSpacing="0">';
		str+='<tr class="reportHistoryRow"><td class="reportHistoryCellLabel">{lonFieldLabel}</td></tr>';
		str+='<tr class="reportHistoryRowLast"><td class="reportHistoryCellLongField">{longFieldValue}</td></tr>';
		str+='</table>';
		me.longFieldTpl = new Ext.Template(str);
		me.longFieldTpl.compile()
	},
	createCommentsTemplate:function(data, idx, record, orig,longFieldLabel,comments){
		var me=this;
		if(CWHF.isNull(me.commentsTpl)){
			me.initCommentsTpl();
		}
		return me.commentsTpl.applyTemplate({longFieldLabel:longFieldLabel,comments: comments});
	},
	initCommentsTpl:function(){
		var me=this;
		var str=[
			'<table class="reportHistory" border="0" cellPadding="0" cellSpacing="0">',
			'<tr style="height: 0px">',
			'<th width="130px"></th>',
			'<th width="200px"></th>',
			'<th width="100%"></th>',
			'</tr>',
			'<tr class="reportHistoryRow"><td class="reportHistoryCellLabel" colspan="3">{longFieldLabel}</td></tr>',
			'<tr class="reportHistoryRow">',
				'<td class="reportHistoryCellHeader">'+getText('common.history.lbl.lastEdit')+'</td>',
				'<td class="reportHistoryCellHeader">'+getText('common.history.lbl.changedBy')+'</td>',
				'<td class="reportHistoryCellHeader">'+getText('common.history.lbl.comment')+'</td>',
			'</tr>',
			'<tpl for="comments">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{date}</div></td>',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{author}</div></td>',
			'<td class="reportHistoryCellLast longFieldCell"><div style="width:auto;overflow:hidden;">{comment}</div></td>',
			'</tr>',
			'</tpl>',
			'</table>'
		];
		me.commentsTpl = new Ext.XTemplate(str);
		me.commentsTpl.compile()
	},
	createHistoryTemplate:function(data, idx, record, orig,longFieldLabel,history){
		var me=this;
		if(CWHF.isNull(me.historyTpl)){
			me.initHistoryTpl();
		}
		return me.historyTpl.applyTemplate({longFieldLabel:longFieldLabel,history: history});
	},
	initHistoryTpl:function(){
		var me=this;
		var str=[
			'<table class="reportHistory" border="0" cellPadding="0" cellSpacing="0">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCellLabel" colspan="4">{longFieldLabel}</td>',
			'</tr>',
			'<tr class="reportHistoryRow">',
				'<td class="reportHistoryCellHeader" width="100px">'+getText('common.history.lbl.lastEdit')+'</td>',
				'<td class="reportHistoryCellHeader" width="20%">'+getText('common.history.lbl.changedBy')+'</td>',
				'<td class="reportHistoryCellHeader" width="40%">'+getText('common.history.lbl.newValue')+'</td>',
				'<td class="reportHistoryCellHeader" width="40%">'+getText('common.history.lbl.oldValue')+'</td>',
			'</tr>',
			'<tpl for="history">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{date}</div></td>',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{author}</div></td>',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{newValues}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{oldValues}</div></td>',
			'</tr>',
			'</tpl>',
			'</table>'
		];
		me.historyTpl = new Ext.XTemplate(str);
		me.historyTpl.compile()
	},
	createCostsTemplate:function(data, idx, record, orig,longFieldLabel,costs){
		var me=this;
		if(CWHF.isNull(me.costsTpl)){
			me.initCostsTpl();
		}
		return me.costsTpl.applyTemplate({longFieldLabel:longFieldLabel,costs: costs});
	},
	initCostsTpl:function(){
		var me=this;
		var str=[
			'<table class="reportHistory" border="0" cellPadding="0" cellSpacing="0">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCellLabel" colspan="5">{longFieldLabel}</td>',
			'</tr>',
			'<tr class="reportHistoryRow">',
				'<td class="reportHistoryCellHeader" width="100px">'+getText('common.history.lbl.lastEdit')+'</td>',
				'<td class="reportHistoryCellHeader" width="20%">'+getText('common.history.lbl.changedBy')+'</td>',
				'<td class="reportHistoryCellHeader" width="50%">'+getText('common.history.lbl.subject')+'</td>',
				'<td class="reportHistoryCellHeader" width="10%">'+getText('item.tabs.expense.editExpense.lbl.effort')+'</td>',
				'<td class="reportHistoryCellHeader" width="10%">'+getText('common.lbl.cost')+'</td>',
			'</tr>',
			'<tpl for="costs">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{date}</div></td>',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{author}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{subject}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{work}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{cost}</div></td>',
			'</tr>',
			'</tpl>',
			'</table>'
		];
		me.costsTpl = new Ext.XTemplate(str);
		me.costsTpl.compile();
	},
	createBudgetHistoryTemplate:function(data, idx, record, orig,longFieldLabel,costs){
		var me=this;
		if(CWHF.isNull(me.budgetHistoryTpl)){
			me.initBudgetHistoryTpl();
		}
		return me.budgetHistoryTpl.applyTemplate({longFieldLabel:longFieldLabel,costs: costs});
	},
	initBudgetHistoryTpl:function(){
		var me=this;
		var str=[
			'<table class="reportHistory" border="0" cellPadding="0" cellSpacing="0">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCellLabel" colspan="4">{longFieldLabel}</td>',
			'</tr>',
			'<tr class="reportHistoryRow">',
				'<td class="reportHistoryCellHeader" width="100px">'+getText('common.history.lbl.lastEdit')+'</td>',
				'<td class="reportHistoryCellHeader" width="20%">'+getText('common.history.lbl.changedBy')+'</td>',
				'<td class="reportHistoryCellHeader" width="40%">'+getText('item.tabs.expense.editExpense.lbl.effort')+'</td>',
				'<td class="reportHistoryCellHeader" width="40%">'+getText('common.lbl.cost')+'</td>',
			'</tr>',
			'<tpl for="costs">',
			'<tr class="reportHistoryRow">',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{date}</div></td>',
			'<td class="reportHistoryCell"><div style="width:auto;overflow:hidden;">{author}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{work}</div></td>',
			'<td class="reportHistoryCellLast"><div style="width:auto;overflow:hidden;">{cost}</div></td>',
			'</tr>',
			'</tpl>',
			'</table>'
		];
		me.budgetHistoryTpl = new Ext.XTemplate(str);
		me.budgetHistoryTpl.compile();
	}
});
function openAttachments(workItemID,attachmentIds){
	var me=this;
	var selections=attachmentIds.split(";");
	for(var i=0;i<selections.length;i++){
		var attachID=selections[i];
		var attachmentURI='downloadAttachment.action?workItemID='+workItemID+'&attachKey='+attachID;
		if(i===0){
			window.open(attachmentURI,'attachmentWindow');
		}else{
			window.open(attachmentURI);
		}
	}
}

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.CellInlineEditController',{
	extend:'Ext.Base',
	 mixins: {
		 field: 'Ext.form.field.Field'
	 },
	config: {
		navigator: null,
		grid: null,
		gantt: null,
	    //if Enable inline edit is enabled (My Settings => Other
	    //settings) then the cells are editable inline, otherwise NO.
		isPrintItemEditable: null
	},
	isNew: false,
	editOrCreateInProgress: false,
	row: null, //edited row or in case of creating new item the above row
	actualEditedOrCreatedRow: null,
	actualEditedOrCreatedRecord: null,
	warningDisplayed: false,
	SYSTEM_FIELDS: {
		SYNOPSIS: 17,
		RESPONSIBLE: 6,
		STATE_FIELD_ID: 4,
		STARTDATE: 19,
		ENDDATE: 20,
		DURATION: 33,
		TOP_DOWN_STARTDATE: 29,
		TOP_DOWN_ENDDATE: 30,
		TOP_DOWN_DURATION: 34
	},
	UNIFORMIZED_FIELD_TYPES: {
		singleSelect: 'SINGLE_SELECT',
		datePicker: 'DATE_PICKER',
		simpleTextField: 'SIMPLE_TEXT_FIELD',
		checkBox: "CHECK_BOX",
		numberEditor: "NUMBER_EDITOR"
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initConfig(config);
	},
	initListeners: function() {
		var me = this;
		if(me.getIsPrintItemEditable()) {
			me.getGrid().addListener('edit', me.onGridEdit, me);
			me.getGrid().addListener('beforeedit', me.onGridBeforeEdit, me);
			me.getGrid().addListener('render', me.onReadyHandler, me);
			me.getGrid().addListener('validateedit', me.validateedit, me);
		}
	},
	validateedit: function(editor, e) {
		var me = this;
		if(CWHF.isNull(e.value)) {
			e.cancel = true;
		}
		if(me.getUniformizedFieldType(e.column.extJsRendererClass) === me.UNIFORMIZED_FIELD_TYPES.checkBox) {
			var convertedOriginalValue = me.convertCheckboxValueToBoolean(e.originalValue);
			var convertedValue = me.convertCheckboxValueToBoolean(e.value);
			if(convertedOriginalValue === convertedValue) {
				e.cancel = true;
			}
		}
	},
	convertCheckboxValueToBoolean: function(val) {
		if(typeof(val) === "boolean"){
			return val;
		}
		if(val === "true") {
			return true;
		}
		if(val === "false") {
			return false;
		}
		if(val === getText('common.boolean.N')) {
			return false;
		}
		if(val === getText('common.boolean.Y')) {
			return true;
		}
		return null;
	},
	initGanttSpecificListener: function() {
		var me = this;
		if(me.getIsPrintItemEditable()) {
			me.getGantt().addListener('selectionchange', me.onGridSelectionChnage, me);
		}
	},
	onReadyHandler: function() {
		var me = this;
		if(me.getIsPrintItemEditable()) {
			Ext.getBody().addKeyMap({
			    eventName: "keydown",
			    binding: [{
			    	key: [Ext.event.Event.NUM_PLUS, 171, 61],
			        ctrl: true,
			        fn:  me.addNewRow,
			        scope: me
			    },{
			    	key: [83],
			        ctrl: true,
			        fn:  me.saveShortcutHandler,
			        scope: me
			    },{
			    	key: [90],
			        ctrl: true,
			        fn:  me.undoEditOrCreate,
			        scope: me
			    },{
			    	key: [Ext.event.Event.NUM_MINUS],
			        ctrl: true,
			        fn:  me.removeRowFromGrid,
			        scope: me
			    }]
			});
			borderLayout.onPageMouseDown = function(event) {
				if(!me.clickIsOutOfGrid(event)) {
					return true;
				}
				var modifiedRecords = me.getGrid().store.getModifiedRecords();
				if(!me.warningDisplayed && me.editOrCreateInProgress && modifiedRecords.length > 0) {//me.isRowEditedt()) {
					event.stopEvent();
					Ext.MessageBox.show({
						title:getText('common.warning'),
						msg: getText('item.action.leavingInlineEdit'),
						buttons: Ext.MessageBox.YESNO,
						fn: function(btn){
							if(btn==="yes"){
								me.prepareDataAdnSave();
							}
							if(btn==="no"){
								me.getNavigator().fireEvent.call(me.getNavigator(),'datachange');
								me.reInitializeDataAfterEditOrCreate();
							}
						},
						icon: Ext.MessageBox.QUESTION
					});
					me.warningDisplayed = false;
					me.getGrid().getSelectionModel().select(me.actualEditedOrCreatedRecord);
				}else {
					return true;
				}
			};
		}
	},
	clickIsOutOfGrid: function(event) {
		var me = this;
		var isOut = true;
		clickX = event.getX();
		clickY = event.getY();
		var gridX = me.getGrid().getX();
//		var gridY = me.getGrid().getY();
		var toolbarY = borderLayout.getActiveToolbarList().getY();
		if(clickX > gridX && clickY > toolbarY) {
			isOut = false;
		}
		return isOut;
	},
	onGridSelectionChnage: function(view, selected, opts) {
		var me = this;
		me.prepareDataAdnSave();
	},
	saveShortcutHandler: function(keyCode, event) {
		event.stopEvent();
		var me = this;
		me.prepareDataAdnSave();
	},
	prepareDataAdnSave: function() {
		var me = this;
		//if not from Gantt we save the changes otherwise the Gantt will handle saving.
		if(CWHF.isNull(me.getGantt())) {
			var params = new Object();
			if(me.row  && me.isRowEditedt()) {
				var workItemIDAbove = null;
				if(me.isNew) {
					workItemIDAbove = me.workItemIDAbove;
				}
				me.saveData(params, workItemIDAbove);
			}
		}
	},
	onGridEdit: function(editor, ctx, e) {
		var me = this;
		if(CWHF.isNull(me.row)) {
			me.row = me.getGridSelectedRow();
		}
		if(CWHF.isNull(me.actualEditedOrCreatedRow)) {
			me.actualEditedOrCreatedRow = me.getGridSelectedRow();
		}
	},
	getGridSelectedRow: function() {
		var me = this;
		var selectedData = me.getGrid().getSelectionModel().getSelection();
		var row = selectedData[0].getData();
		return row;
	},
	onGridBeforeEdit: function(editor, ctx, e) {
		var me = this;
		if(!me.isEditable(ctx)) {
			return false;
		}
		me.actualEditedOrCreatedRecord = ctx.record;
		me.editOrCreateInProgress = true;
		if(!me.isNew){
			var editableValue = ctx.record.data.editable;
			if(!editableValue) {
				return false;
			}
		}
		var editorComponent = ctx.column.field;
		var uniformizedFieldType = me.getUniformizedFieldType(ctx.column.extJsRendererClass);
		switch(uniformizedFieldType) {
		    case me.UNIFORMIZED_FIELD_TYPES.singleSelect:
		    	me.loadFieldValue(editorComponent, ctx.record.data.workItemID, ctx.record.data.projectID, ctx.record.data.issueTypeID, ctx.column.fieldID, me.UNIFORMIZED_FIELD_TYPES.singleSelect, 'itemNavigator!loadComboDataByFieldID.action');
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.checkBox:
//		    	me.loadFieldValue(editorComponent, ctx.record.data.workItemID, ctx.record.data.projectID, ctx.record.data.issueTypeID, ctx.column.fieldID, me.UNIFORMIZED_FIELD_TYPES.checkBox, 'itemNavigator!loadFieldValue.action');
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.simpleTextField:
		    	if(me.isNew) {
		    		editorComponent.margin = '0 0 0 0';
		    	}
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.numberEditor:
		    	break;
		    default:
		    	break;
		}
	},
	isEditable: function(ctx) {
		var me = this;
//		Ext.defer(me.doInitAfterEverythingLoadedAndRendered, 150, me);
		if(ctx.record.data.leaf) {
			return true;
		}else {
			if(ctx.field === 'f' + me.SYSTEM_FIELDS.STARTDATE || ctx.field === 'f' + me.SYSTEM_FIELDS.ENDDATE ||
					ctx.field === 'f' + me.SYSTEM_FIELDS.DURATION ||
				ctx.field === 'f' + me.SYSTEM_FIELDS.TOP_DOWN_STARTDATE || ctx.field === 'f' + me.SYSTEM_FIELDS.TOP_DOWN_ENDDATE ||
					ctx.field === 'f' + me.SYSTEM_FIELDS.TOP_DOWN_DURATION) {
				return false;
			}else {
				return true;
			}
		}
	},
	getShortField: function(fieldID) {
	},
	setColumnEditor: function(shortField, column) {
		var me = this;
		if(me.getIsPrintItemEditable()) {
//			var editor = new Object();
//			editor.allowBlank = false;
//			editor.selectOnFocus = true;
			column.extJsRendererClass = shortField.extJsRendererClass;
			me.setCellRenderer(shortField. extJsRendererClass, column, shortField);
		}
	},
	createContext: function() {
		var me = this;
		var params = new Object();
		params.actionID = 1;
		params.fromAjax	= true;
		params['params.projectID'] = me.row.projectID;
		params['params.issueTypeID'] = me.row.issueTypeID;
		params.parentID = '';
		params.synopsis = '';
		params.workItemID = '';
		Ext.Ajax.request({
			url: "item!next.action",
			disableCaching:true,
			success: function(response){
			},
			failure: function(){
			},
			method:'POST',
			params: params
		});
	},
	saveData: function(params, workItemIDAbove) {
		var me = this;
		var modifiedRecords = me.getGrid().store.getModifiedRecords();
		if(modifiedRecords.length > 0) {
			var firstRecord = modifiedRecords[0];
			var changedFields = firstRecord.getChanges();
			for(var ind in changedFields) {
				var fieldValue = changedFields[ind];
				if (ind && ind.charAt(0) === 'f') {
					params['fieldValues.' + ind] = fieldValue;
				}
			}
			params.projectID = me.row.projectID;
			params.issueTypeID = me.row.issueTypeID;
			if(workItemIDAbove ) {
				params.workItemIDAbove = workItemIDAbove;
			}
			if(me.isNew) {
				params.actionID = "1";
				actionIDValue = 1;
				params.workItemID = "";
			}else {
				params.actionID = "2";
				params.workItemID = me.row.workItemID;
			}
			params.inlineEditInNavigator = true;
			params.fromAjax	= true;
			Ext.Ajax.request({
				url: "itemSave.action",
				disableCaching:true,
				success: function(response){
					var responseJSON = Ext.decode(response.responseText);
					if(responseJSON.success) {
						borderLayout.workItemIDToSelectAfterReload = responseJSON.data.workItemID;
						me.reInitializeDataAfterEditOrCreate();
						if(me.getGantt() ) {
							var changedRow = me.getGrid().store.getById(responseJSON.data.workItemID);
							changedRow.commit();
						}else {
							me.getNavigator().fireEvent.call(me.getNavigator(),'datachange');
						}
					}else {
						var data = responseJSON.data;
						var errors = data.errors;
						var errorMessage = '';
						Ext.Array.forEach(errors, function (error) {
					    	errorMessage += error.label;
		                }, me);
						CWHF.showMsgError(errorMessage);
					}
				},
				failure: function(){
					me.reInitializeDataAfterEditOrCreate();
				},
				method:'POST',
				params: params
			});
		}
	},
	isRowEditedt: function() {
		var me = this;
		return me.editOrCreateInProgress;
	},
	dateColumnRenderer: function(value) {
		if(value.length > 0) {
			var date = Ext.Date.parse(value, com.trackplus.TrackplusConfig.DateFormat);
			if(!Ext.isDefined(date)) {
				date = new Date(value);
			}
			var formatted = Ext.Date.format(date, com.trackplus.TrackplusConfig.DateFormat);
			return formatted;
		}
		return value;
	},
	setCellRenderer: function(extJsRendererClass, column, shortField) {
		var me = this;
		var uniformizedFieldType = me.getUniformizedFieldType(extJsRendererClass);
		switch(uniformizedFieldType) {
		    case me.UNIFORMIZED_FIELD_TYPES.simpleTextField:
		        me.createTextFieldEditor(column);
		        break;
		    case me.UNIFORMIZED_FIELD_TYPES.singleSelect:
		    	me.createComboEditor(column);
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.datePicker:
		    	me.createDateEditor(column, extJsRendererClass);
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.checkBox:
		    	me.createCheckBox(column, shortField);
		    	break;
		    case me.UNIFORMIZED_FIELD_TYPES.numberEditor:
		    	me.createNumberEditor(column, shortField, extJsRendererClass);
		    	break;
		    default:
		        editor = null;
		}
	},
	getUniformizedFieldType: function(extJsRendererClass) {
		var me = this;
		switch(extJsRendererClass) {
		    case "com.aurel.trackplus.field.SynopsisTypeRenderer":
		        return me.UNIFORMIZED_FIELD_TYPES.simpleTextField;
		        break;
		    case "com.aurel.trackplus.field.PersonPickerRenderer":
		    case "com.aurel.trackplus.field.StateRenderer":
		    case "com.aurel.trackplus.field.PriorityRenderer":
		    case "com.aurel.trackplus.field.SelectTypeRenderer":
		    	return me.UNIFORMIZED_FIELD_TYPES.singleSelect;
		    	break;
		    case "com.aurel.trackplus.field.DateTypeRenderer":
		    case "com.aurel.trackplus.field.StartDateRenderer":
		    case "com.aurel.trackplus.field.EndDateRenderer":
		    case "com.aurel.trackplus.field.StartDateTargetRenderer":
		    case "com.aurel.trackplus.field.EndDateTargetRenderer":
		    	return me.UNIFORMIZED_FIELD_TYPES.datePicker;
		    	break;
		    case "com.aurel.trackplus.field.CheckBoxTypRenderer":
		    	return me.UNIFORMIZED_FIELD_TYPES.checkBox;
		    case "com.aurel.trackplus.field.DurationRenderer":
		    case "com.aurel.trackplus.field.TargetDurationRenderer":
		    	return me.UNIFORMIZED_FIELD_TYPES.numberEditor;
		    default:
		        return null;
		}
	},
	createTextFieldEditor: function(column) {
		var me = this;
		var editor = Ext.create('Ext.form.field.Text', {
		    listeners: {
		    	change: function(component, newValue, oldValue, eOpts) {
		    	}
		    }
		});
		column.editor = editor;
	},
	createComboEditor: function(column) {
		var me = this;
		var fields = [];
		fields.push({name : 'label',type : 'string'});
		fields.push({name : 'id', type : 'number'});
		var combo = Ext.create('Ext.form.ComboBox', {
			fields: fields,
		    displayField: 'label',
		    valueField: 'id',
		    listeners: {
		    	select: function(combo, records) {
		    	}
		    }
	    });
		column.editor = combo;
	},
	createDateEditor: function(column, originalFieldType) {
		var me = this;
		var editor = Ext.create('Ext.form.field.Date', {
			format: com.trackplus.TrackplusConfig.DateFormat,
			listeners: {
				change: function(component, newValue, oldValue, eOpts) {
					var rowItem = me.getGrid().getSelectionModel().getSelection()[0];
					rowItem.set('f' + component.column.fieldID, newValue);
		    		if(CWHF.isNull(me.getGantt())) {
		    			me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
		    		}else {
    					var task = me.getGrid().store.getById(rowItem.data.Id);
    					if(!me.getNavigator().isShowBaseline()) {
			    			if(this.originalFieldType === 'com.aurel.trackplus.field.StartDateRenderer') {
			    				task.setStartDate(newValue);
			    			}
			    			if(this.originalFieldType === 'com.aurel.trackplus.field.EndDateRenderer') {
			    				task.setEndDate(newValue);
			    			}
			    			if(this.originalFieldType === 'com.aurel.trackplus.field.StartDateTargetRenderer' ||
			    					this.originalFieldType === 'com.aurel.trackplus.field.EndDateTargetRenderer') {
			    				me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
			    			}
    					}else {
    						if(this.originalFieldType === 'com.aurel.trackplus.field.StartDateTargetRenderer') {
    							task.setStartDate(newValue);
    						}
    						if(this.originalFieldType === 'com.aurel.trackplus.field.EndDateTargetRenderer') {
    							task.setEndDate(newValue);
    						}
    						if(this.originalFieldType === 'com.aurel.trackplus.field.StartDateRenderer' ||
    								this.originalFieldType === 'com.aurel.trackplus.field.EndDateRenderer') {
			    				me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
			    			}
    					}
		    		}
		    		me.clearDirtyMarkerFromGroupValues();
				}
			},
			 getValue: function(){
				 if(me.getGantt() ) {
					 if(me.fieldIsTargetOrNormalStartEnd(this.originalFieldType)) {
						 return this.value;
					 }else {
						 return Ext.util.Format.date(this.value, com.trackplus.TrackplusConfig.DateFormat);
					 }
				 }else {
					 var date = this.value;
					 if(date  && date !== "") {
						return Ext.util.Format.date(date, com.trackplus.TrackplusConfig.DateFormat);
					 }else {
						 return this.value;
					 }
				 }
			 }
		});
		editor.originalFieldType = originalFieldType;
		column.format = com.trackplus.TrackplusConfig.DateFormat;
		column.renderer = me.dateColumnRenderer;
		column.editor = editor;
	},
	/*
	 * This method removes all red markers from group items
	 */
	clearDirtyMarkerFromGroupValues: function() {
		var me = this;
		if(me.getGantt()) {
			var store = me.getGantt().getTaskStore();
			var rootNode = store.getRootNode();
			me.parseGridItemsAndClearDirtyMarkerFromGroupItems(rootNode);
		}
	},
	/*
	 * This method parses tasks if a group item is dirty then removes red marker.
	 */
	parseGridItemsAndClearDirtyMarkerFromGroupItems: function(rootItem) {
		var me = this;
		if(rootItem.data.group ) {
			rootItem.commit();
		}
		if(rootItem.childNodes.length !== 0) {
			for(var ind in rootItem.childNodes) {
				var child = rootItem.childNodes[ind];
				if(child.length !== 0) {
					me.parseGridItemsAndClearDirtyMarkerFromGroupItems(child);
				}
			}
		}
	},
	fieldIsTargetOrNormalStartEnd: function(originalFieldType) {
		var me = this;
		if(originalFieldType === 'com.aurel.trackplus.field.StartDateRenderer' || originalFieldType === 'com.aurel.trackplus.field.EndDateRenderer' ||
				originalFieldType === 'com.aurel.trackplus.field.StartDateTargetRenderer' || originalFieldType === 'com.aurel.trackplus.field.EndDateTargetRenderer') {
			return true;
		}else {
			return false;
		}
	},
	createCheckBox: function(column, shortField) {
		var me = this;
		var editor = Ext.create('Ext.form.field.Checkbox', {
			boxLabel: shortField.label,
		    listeners: {
		    	change: function(component, newValue, oldValue, eOpts) {
		    		if(component.column ) {
		    		}
		    	}
			},
			setValue: function(val) {
				if(typeof(val) === "boolean"){
					this.setRawValue(val);
				}else {
					if(val === getText('common.boolean.Y')) {
						this.setRawValue(true);
					}else {
						this.setRawValue(false);
					}
				}
			},
			getValue: function() {
				return this.getRawValue();
			}
		});
		column.editor = editor;
	},
	createNumberEditor: function(column, shortField, originalFieldType) {
		var me = this;
		var editor = Ext.create('Ext.form.field.Number', {
			boxLabel: shortField.label,
			value: 0,
		    listeners: {
		    	change: function(component, newValue, oldValue, eOpts) {
		    		if(component.column ) {
    					var rowItem = me.getGrid().getSelectionModel().getSelection()[0];
		    			if(me.getGantt()  ) {
		    				if(!me.getNavigator().isShowBaseline()) {
		    					if(component.originalFieldType === 'com.aurel.trackplus.field.DurationRenderer') {
		    						var task = me.getGrid().store.getById(rowItem.data.Id);
		    						task.setDuration(newValue);
		    					}
		    					if(component.originalFieldType === 'com.aurel.trackplus.field.TargetDurationRenderer') {
			    					me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
		    					}
		    				}else {
		    					if(component.originalFieldType === 'com.aurel.trackplus.field.TargetDurationRenderer') {
		    						var task = me.getGrid().store.getById(rowItem.data.Id);
		    						task.setDuration(newValue);
		    					}
		    					if(component.originalFieldType === 'com.aurel.trackplus.field.DurationRenderer') {
		    						me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
		    					}
		    				}
		    			}else {
		    				if(component.originalFieldType === 'com.aurel.trackplus.field.DurationRenderer' ||
		    						component.originalFieldType === 'com.aurel.trackplus.field.TargetDurationRenderer') {
		    					me.refreshDependentFields(component, rowItem.data, oldValue, newValue);
		    				}
		    			}
		    		}
		    	}
			},
			getValue : function() {
				var num = parseInt(this.value) || '';
				return num;
			}
		});
		editor.originalFieldType = originalFieldType;
		column.editor = editor;
	},
	loadFieldValue: function(component, workItemID, projectID, issueTypeID, fieldID, fieldType, url) {
		var me = this;
		params = new Object();
		params.workItemID = workItemID;
		params.fieldID = fieldID;
		params.projectID = projectID;
		params.issueTypeID = issueTypeID;
		Ext.Ajax.request({
			url: url,
			disableCaching:true,
			success: function(response){
				responseJSON = Ext.decode(response.responseText);
				if(me.UNIFORMIZED_FIELD_TYPES.singleSelect === fieldType) {
					var storeData = responseJSON.storeData;
					var myStore = Ext.create('Ext.data.Store', {
						fields: ['id', 'label'],
						data: storeData
					});
					component.bindStore(myStore);
				}
			},
			failure: function(){
			},
			method:'POST',
			params: params
		});
	},
	checkUserCreateRight: function() {
		var me = this;
		var selectedData = me.getGrid().getSelectionModel().getSelection();
		if(selectedData.length > 0) {
			var selection = selectedData[0];
			me.row = selection.getData();
			var projectID = me.row.projectID;
			var issueTypeID = me.row.issueTypeID;
			var params = new Object();
			params.projectID = projectID;
			params.issueTypeID = issueTypeID;
			Ext.Ajax.request({
				url: "item!checkUserRightForCreatingNewItem.action",
				disableCaching:true,
				success: function(response){
					var responseJSON = Ext.decode(response.responseText);
					var userCanCreateNewItem = responseJSON.userCanCreateNewItem;
					if(userCanCreateNewItem) {
						me.handleCreatingNewItem();
					}else {
						CWHF.showMsgError(getText('item.err.createNotAllowed'));
						me.reInitializeDataAfterEditOrCreate();
					}
				},
				failure: function(){
				},
				method:'POST',
				params: params
			});
		}
	},
	reInitializeDataAfterEditOrCreate: function() {
		var me = this;
		me.isNew = false;
		me.row = null;
		me.editOrCreateInProgress = false;
	},
	handleCreatingNewItem: function() {
		var me = this;
		var selectedData = me.getGrid().getSelectionModel().getSelection();
		if(selectedData.length > 0) {
			var selection = selectedData[0];
			me.row = selection.getData();
			me.isNew = true;
			var taskTypeName = me.row.f2;
			var workspaceName = me.row.f1;
			var newTask = new Object();
			newTask.leaf = true;
			newTask.cls = 'item-calendarStartDateMissing';
			newTask.f2 = taskTypeName;
			newTask.f1 = workspaceName;
			newTask.f17 = "";
			var tmpID = Math.floor((Math.random() * 10) + 1000) * -1;
			newTask.Id = tmpID;
			newTask.workItemID = null;
			newTask.projectID = me.row.projectID;
			newTask.issueTypeID = me.row.issueTypeID;
			newTask.linkable = me.row.linkable;
			newTask.editable = me.row.editable;
			newTask.workItemIDAbove = me.row.workItemID;
			me.workItemIDAbove =  me.row.workItemID;
			switch(me.getNavigator().$className) {
			    case 'com.trackplus.itemNavigator.SimpleTreeGridViewPlugin':
			    case 'com.trackplus.itemNavigator.WBSViewPlugin':
			    case 'com.trackplus.itemNavigator.GanttViewPlugin':
			    	me.selectNewlyAddedRowTree(selection, newTask);
			    	break;
			    case 'com.trackplus.itemNavigator.FlatGridViewPlugin':
			    	me.selectNewlyAddedRowFlat(selection, newTask);
			    	break;
			    default:
			    	break;
			}
			if(CWHF.isNull(me.getGantt())) {
				me.createContext();
			}
			me.editOrCreateInProgress = true;
			me.recalculateGridItemIndex();
			selectedData = me.getGrid().getSelectionModel().getSelection();
			if(selectedData.length > 0) {
				var selection = selectedData[0];
				selection.set('f17', getText('itemov.ganttView.newlyCreatedItemDummyTitle'));
			}
		}
	},
	addNewRow: function(keyCode, event) {
		var me = this;
		event.stopEvent();
		me.reInitializeDataAfterEditOrCreate();
		me.checkUserCreateRight();
	},
	selectNewlyAddedRowTree: function(selection, newTask) {
		var me = this;
		var parentNode = selection.parentNode;
		var rowIndex = parentNode.indexOf(selection);
		rowIndex++;
		me.actualEditedOrCreatedRecord = parentNode.insertChild(rowIndex, newTask);
		me.getGrid().getSelectionModel().select(me.actualEditedOrCreatedRecord);
	},
	selectNewlyAddedRowFlat: function(selection, newTask) {
		var me = this;
		var rowIndex = me.getGrid().store.indexOf(selection);
		rowIndex++;
		me.actualEditedOrCreatedRecord = me.getGrid().store.insert(rowIndex, newTask);
		me.getGrid().getSelectionModel().select(me.actualEditedOrCreatedRecord);
	},
	dataChangeSuccess: function() {
		var me = this;
		var id = borderLayout.workItemIDToSelectAfterReload;
		var recordToSelect = me.getGrid().store.getById(id);
		me.getGrid().getSelectionModel().select(recordToSelect);
	},
	undoEditOrCreate: function() {
		var me = this;
		me.getNavigator().fireEvent.call(me.getNavigator(),'datachange');
	},
	removeRowFromGrid: function(keyCode, event) {
		var me = this;
		event.stopEvent();
		if(CWHF.isNull(me.getGantt())) {
			if(!me.isNew) {
				var selectedData = me.getGrid().getSelectionModel().getSelection();
				if(selectedData.length > 0) {
					var selection = selectedData[0];
					var workItemID = selection.getData().workItemID;
					me.closeItemAjax(workItemID);
				}
			}
		}else {
			var selectedData = me.getGrid().getSelectionModel().getSelection();
			if(selectedData.length > 0) {
				var selection = selectedData[0];
				var isNew = false;
				if(selection.data.Id < 0) {
					isNew = true;
				}
				if(isNew) {
					me.getGantt().getTaskStore().remove(selection);
					me.recalculateGridItemIndex();
				}else {
					var workItemID = selection.getData().workItemID;
					me.closeItemAjax(workItemID);
				}
			}
		}
	},
	handleRemoveFromGantt: function() {
		var me = this;
		var selectedData = me.getGrid().getSelectionModel().getSelection();
		if(selectedData.length > 0) {
			var selection = selectedData[0];
			var isNew = false;
			if(selection.data.Id < 0) {
				isNew = true;
			}
			if(isNew) {
				me.getGantt().getTaskStore().remove(selection);
				me.recalculateGridItemIndex();
			}else {
				var workItemID = selection.getData().workItemID;
				me.closeItemAjax(workItemID);
			}
		}
	},
	closeItemAjax: function(workItemID) {
		var me = this;
		var params = {};
		params.workItemID = workItemID;
		Ext.Ajax.request({
			url: "itemNavigator!closeWorkItem.action",
			disableCaching:true,
			success: function(response){
				var responseJSON = Ext.decode(response.responseText);
				if(responseJSON.success) {
					CWHF.showMsgInfo(getText('item.action.stateChangeToClosed', workItemID));
					if(CWHF.isNull(me.getGantt())) {
						me.getNavigator().fireEvent.call(me.getNavigator(),'datachange');
					}else {
						var task = me.getGrid().store.getById(workItemID);
						task.data['f' + me.SYSTEM_FIELDS.STATE_FIELD_ID] = responseJSON.closedStateName;
						me.getGrid().getView().refresh();
					}
				}else {
					var data = responseJSON.data;
					var errors = data.errors;
					var errorMessage = '';
					Ext.Array.forEach(errors, function (error) {
				    	errorMessage += error.label;
	                }, me);
					CWHF.showMsgError(errorMessage);
				}
			},
			failure: function(){
			},
			method:'POST',
			params: params
		});
	},
	recalculateGridItemIndex: function() {
		var me = this;
		if(me.getGantt() ) {
			var store = me.getGantt().getTaskStore();
			var rootNode = store.getRootNode();
			me.workItemIndex = 0;
			me.parseGridItemsAndResetIndex(rootNode);
			me.getGrid().getView().refresh();
		}
	},
	parseGridItemsAndResetIndex: function(rootItem) {
		var me = this;
		var isProject = false;
		if(rootItem.data.group ) {
			isProject = rootItem.data.group;
		}
		if(!isProject && rootItem.data.Id !== 'root') {
			rootItem.data.workItemIndex = me.workItemIndex;
			me.workItemIndex++;
		}
		if(rootItem.childNodes.length !== 0) {
			for(var ind in rootItem.childNodes) {
				var child = rootItem.childNodes[ind];
				if(child.length !== 0) {
					me.parseGridItemsAndResetIndex(child);
				}
			}
		}
	},
    getRendererForSpecificColumns: function(uniformizedFieldType, columnNr) {
		var me = this;
		var renderer = null;
	    if(uniformizedFieldType === me.UNIFORMIZED_FIELD_TYPES.datePicker) {
	    	renderer = function (value, metaData, record, row, col, store, gridView) {
	    		var isProject = false;
    			if(record.data.group ) {
    				isProject = record.data.group;
    			}
    			if(!isProject) {
		    		var dateObj = null;
		    		if(value instanceof Date) {
		    			dateObj = new Date(value.getTime());
		    		}else {
		    			dateObj = Ext.Date.parse(value, com.trackplus.TrackplusConfig.DateFormat);
		    		}
		    		if(dateObj ) {
		    			if(!isProject) {
		    				return Ext.util.Format.date(dateObj, com.trackplus.TrackplusConfig.DateFormat);
		    			}
		    		}
    			}else {
	    			if(columnNr === 0 ) {
	    				return record.data['Name'];
	    			}else {
	    				return "";
	    			}
	    		}
	    	};
	    }
	    if(uniformizedFieldType === me.UNIFORMIZED_FIELD_TYPES.singleSelect) {
	    	renderer = function (val, metaData, record, row, col, store, gridView) {
    			var combo = metaData.column.getEditor();
    			if(val && combo && combo.store && combo.displayField){
    				var valueFieldInt = parseInt(val);
    				var index = combo.store.findExact(combo.valueField, valueFieldInt);
    				if(index >= 0){
    					return combo.store.getAt(index).get(combo.displayField);
    				}
    			}
    			return val;
	    	};
	    }
	    if(uniformizedFieldType === me.UNIFORMIZED_FIELD_TYPES.checkBox) {
	    	renderer= function (val, metaData, record, row, col, store, gridView) {
	    		var isProject = false;
    			if(record.data.group ) {
    				isProject = record.data.group;
    			}
    			if(!isProject) {
    				if(typeof(val) === "boolean"){
    					if(val) {
    						return getText('common.boolean.Y');
    					}else {
    						return getText('common.boolean.N');
    					}
    				}else {
    					if(val === "true") {
    						return getText('common.boolean.Y');
    					}
    					if(val === "false") {
    						return getText('common.boolean.N');
    					}
    					if(val === "") {
    						return getText('common.boolean.N');
    					}
    					return val;
    				}
    			}else {
    				return '';
    			}
	    	};
	    }
	    if(uniformizedFieldType === me.UNIFORMIZED_FIELD_TYPES.numberEditor) {
	    	renderer = function (value, metaData, record, row, col, store, gridView) {
	    		var isProject = false;
	    		if(record.data.group ) {
	    			isProject = record.data.group;
	    		}
	    		if(!isProject) {
	    			return value;
	    		}
	    		return '';
	    	};
	    }
	    return renderer;
	},
	/************** HELPRE methods for updating dependents fields **************/
	refreshDependentFields: function(renderer, model, oldValue, newValue) {
		var me = this;
		var fieldID = renderer.column.fieldID;
		var fieldFullID = 'f' + fieldID;
		var originalFieldType = renderer.originalFieldType;
		var rendererClassInstance = null;
		var convertedOldValue = oldValue;
		var convertedNewValue = newValue;
		switch(originalFieldType) {
		    case 'com.aurel.trackplus.field.StartDateRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.StartDateRenderer', {});
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.DURATION;
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.ENDDATE;
		    	if(CWHF.isNull(me.getGantt())) {
		    		convertedOldValue = Ext.Date.parse(oldValue, com.trackplus.TrackplusConfig.DateFormat);
		    		convertedNewValue = Ext.Date.parse(newValue, com.trackplus.TrackplusConfig.DateFormat);
		    	}
		    	break;
		    case 'com.aurel.trackplus.field.EndDateRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.EndDateRenderer', {});
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.DURATION;
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.ENDDATE;
		    	if(CWHF.isNull(me.getGantt())) {
		    		convertedOldValue = Ext.Date.parse(oldValue, com.trackplus.TrackplusConfig.DateFormat);
		    		convertedNewValue = Ext.Date.parse(newValue, com.trackplus.TrackplusConfig.DateFormat);
		    	}
		    	break;
		    case 'com.aurel.trackplus.field.StartDateTargetRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.StartDateTargetRenderer', {});
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_ENDDATE;
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.TOP_DOWN_DURATION;
		    	if(CWHF.isNull(me.getGantt())) {
		    		convertedOldValue = Ext.Date.parse(oldValue, com.trackplus.TrackplusConfig.DateFormat);
		    		convertedNewValue = Ext.Date.parse(newValue, com.trackplus.TrackplusConfig.DateFormat);
		    	}
		    	break;
		    case 'com.aurel.trackplus.field.EndDateTargetRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.EndDateTargetRenderer', {});
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_ENDDATE;
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.TOP_DOWN_DURATION;
		    	if(CWHF.isNull(me.getGantt())) {
		    		convertedOldValue = Ext.Date.parse(oldValue, com.trackplus.TrackplusConfig.DateFormat);
		    		convertedNewValue = Ext.Date.parse(newValue, com.trackplus.TrackplusConfig.DateFormat);
		    	}
		    	break;
		    case 'com.aurel.trackplus.field.DurationRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.DurationRenderer', {});
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.DURATION;
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.ENDDATE;
		    	break;
		    case 'com.aurel.trackplus.field.TargetDurationRenderer':
		    	rendererClassInstance =  Ext.create('com.aurel.trackplus.field.TargetDurationRenderer', {});
		    	renderer.durationFieldID = me.SYSTEM_FIELDS.TOP_DOWN_DURATION;
		    	renderer.startDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_STARTDATE;
		    	renderer.endDateFieldID = me.SYSTEM_FIELDS.TOP_DOWN_ENDDATE;
		    	break;
		    default:
		    	return;
		}
		var fieldValues = {};
		fieldValues[fieldFullID] = convertedNewValue;
		var oldFieldValues = {};
		oldFieldValues[fieldFullID] = convertedOldValue;
		var isFromGantt = false;
		if(me.getGantt() ) {
			isFromGantt = true;
		}
		rendererClassInstance.refreshDependentFields.call(me, fieldID, fieldValues, oldFieldValues, renderer, model, isFromGantt);
	},
	updateField: function(fieldID, fieldValue, fieldDisplayValue, fieldValues) {
		var me=this;
		if(fieldValue ) {
			var fieldName = "f" + fieldID;
			var rowItem = me.getGrid().getSelectionModel().getSelection()[0];
			var convertedFieldValue = fieldValue;
			if(me.getGantt() ) {
				if(fieldID === me.SYSTEM_FIELDS.STARTDATE || fieldID === me.SYSTEM_FIELDS.ENDDATE ||
						fieldID === me.SYSTEM_FIELDS.TOP_DOWN_STARTDATE || fieldID === me.SYSTEM_FIELDS.TOP_DOWN_ENDDATE) {
					convertedFieldValue = Ext.Date.parse(fieldValue, com.trackplus.TrackplusConfig.DateFormat);
				}
			}
			rowItem.set(fieldName, convertedFieldValue);
			me.getGrid().getView().refresh();
		}
	},
	addWeekdays: function(date, weekdays, add) {
		var me=this;
		var i = 0;
	    var oneDay = 1;
	    if (!add) {
	    	oneDay = -1;
	    }
	    while (i < weekdays) {
	    	date.setDate(date.getDate() + oneDay);
	        var day = date.getDay();
	        if (day > 0 && day < 6) {
	            i++;
	        }
	    }
	    return Ext.Date.format(date, com.trackplus.TrackplusConfig.DateFormat);
	},
	parseDate: function(dateStr, nowIfNull) {
		if (CWHF.isNull(dateStr) || dateStr.length===0) {
			if (nowIfNull) {
				return new Date();
			} else {
				return null;
			}
		} else {
			var retValue = Ext.Date.parse(dateStr, com.trackplus.TrackplusConfig.DateFormat);
			return retValue;
		}
	},
	getDurationBetweenDates: function(startDateStr, endDate) {
		var me=this;
		var startDate = me.parseDate(startDateStr, false);
		if (CWHF.isNull(startDate) || CWHF.isNull(endDate)) {
			return null;
		}
		var i=0;
		while (startDate<endDate) {
			startDate.setDate(startDate.getDate() + 1);
			var day = startDate.getDay();
	        if (day > 0 && day < 6) {
	            i++;
	        } else {
	        	//end date explicitly set on Saturday or Sunday: take this week end day(s) as working day
	        	if (startDate>=endDate) {
	        		if (day===6) {
	        			//add one day for task ending on Saturday
	        			i++;
	        		} else {
	        			//add two days for task ending on Sunday
	        			i = i+2;
	        		}
	        	}
	        }
		}
		return i;
	},
	getDateFromModel: function(model, fieldID, isFromGantt) {
		var me = this;
		var date = null;
		date = model[fieldID];
		if(isFromGantt) {
			date = Ext.util.Format.date(date, com.trackplus.TrackplusConfig.DateFormat);
		}
		return date;
	}
	/************** ENDS OF HELPRE methods for updating dependents fields **************/
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.LiteGridViewPlugin',{
	extend: 'com.trackplus.itemNavigator.SimpleTreeGridViewPlugin',
	initMyListeners:function(){
		var me=this;
		//fix ExtJS BUG: click on row in grid with scroll will focus first row
		me.view.on('boxready', function (thisGrid) {
			thisGrid.view.focus = Ext.emptyFn;
		});
		me.view.addListener('celldblclick',me.onLiteGridItemDblClick,me);
	},
	onLiteGridItemDblClick:function(view, td,cellIndex,record, tr, rowIndex,e){
		var me=this;
		e.stopEvent();
		if(me.model.layout.bulkEdit===true&&cellIndex===0){
			return false;
		}
		var workItemID=record.data['workItemID'];
		me.openItem(workItemID);
		return false;
	},
	openItem:function(workItemID){
		var me=this;
		var actionID=-2;//PRINT
		var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',{
			workItemID:workItemID,
			actionID:actionID,
			parentID:null,
			successHandler:me.itemActionSuccessHandler,
			scope:me,
			modal:false,
			navigatorHandler:me.navigatorHandler,
			navigatorScope:me
		});
		itemAction.execute.call(itemAction);
		itemAction.addListener('navigateToItem',me.navigateToItemHandler,me);
	},
	navigateToItemHandler:function(action,nextWorkItemID,position){
		var me=this;
		me.openItem(nextWorkItemID);
	},
	itemActionSuccessHandler:function(){
	},
	navigatorHandler:function(workItemID,dir,keepPosition){
		var me=this;
		return me.navigateToItem(workItemID,dir,keepPosition);
	},
	getTreeViewPlugins:function(){
		return null
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.WBSViewPlugin',{
	extend: 'com.trackplus.itemNavigator.SimpleTreeGridViewPlugin',
	disableSort:true,
	WBS_SORT_ASCENDING:true,
	getTreeViewPlugins:function(){
		return [{
			ptype: 'gridviewdragdrop',
			dragText: getText('itemov.wbsView.lbl.dragText'),
			dragGroup: 'itemToCategory',
			dropGroup: 'itemToCategory',
			enableDrop: true
		}];
	},
	initMyListeners:function(){
		var me=this;
		me.callParent();
		me.view.getView().addListener('beforedrop',me.onGridBeforeDrop,me);
	},
	createFields:function(){
		var me=this;
		var fields=me.callParent();
		fields.push({name:'wbs'});
		return fields;
	},
	getSorters:function(){
		var me=this;
		var sortField="wbs";
		//var sortField = "f_so27";
		var sortDirection;
		if(me.WBS_SORT_ASCENDING===true){
			sortDirection='ASC'
		}else{
			sortDirection='DESC'
		}
		return [{
			property:sortField,
			direction :sortDirection
		}];
	},
	createStore:function(){
		var me=this;
		var store=me.callParent(arguments);
		store.sort();
		return store;
	},
	expandGroup:function(groupID,expanded){
		Ext.Ajax.request({
			url: 'reportExpand!expandGroupWBS.action',
			params:{
				expanded:expanded,
				groupID:groupID
			}
		});
	},
	onGridBeforeDrop:function(node,data, overModel, dropPosition){
		var me=this;
		var targetProjectID=overModel.data.projectID;
		var validWorkItems=[];
		var otherProjectItems=[];
		for(var i=0;i<data.records.length;i++){
			var record=data.records[i];
			if(record.data['group']===true){
				continue;
			}
			var sourceProjectID=record.data['projectID'];
			if(sourceProjectID!==targetProjectID){
				otherProjectItems.push(record);
			}else{
				validWorkItems.push(record);
			}
		}
		if(validWorkItems.length===0){
			var msg=getText('itemov.wbsView.err.notTheSameProject');
			Ext.MessageBox.show({
				title: '',
				msg: msg,
				width: 200,
				buttons: Ext.MessageBox.OK,
				icon:Ext.MessageBox.ERROR
			});
			return false;
		}
		while(data.records.length>0){
			data.records.pop();
		}
		me.view.setLoading(true);
		var workItems='';
		for(i=0;i<validWorkItems.length;i++){
			data.records.unshift(validWorkItems[i]);
			workItems+=validWorkItems[i].data['workItemID'];
			if(i<validWorkItems.length-1){
				workItems+=",";
			}
		}
		var before=(dropPosition==="before");
		if(me.WBS_SORT_ASCENDING===false){
			before=!before;
		}
		var params={
			workItems:workItems,
			targetWorkItemID:overModel.data['workItemID'],
			before:before
		};
		Ext.Ajax.request({
			url: "itemNavigator!changeWBS.action",
			disableCaching:true,
			success: function(){
				me.view.setLoading(false);
				me.fireEvent.call(me,'datachange');
			},
			failure: function(){
				me.view.setLoading(false);
				alert("failure");
			},
			method:'POST',
			params:params
		});
		return true;
	},
	getPopupMenuItems:function(rowData,grid,index,record){
		var me=this;
		var items=[];
		if (rowData.editable) {
			items.push({
					text: getText('common.btn.indent'),
					iconCls:'itemAction_indent16',
					handler:function(){
						me.indent.call(me,rowData,grid,index,record);
					}
			});
			items.push({
				text: getText('common.btn.outdent'),
				iconCls:'itemAction_outdent16',
				handler:function(){
					me.outdent.call(me,rowData,grid,index,record);
				}
			});
		}
		return items;
	},
	indent:function(rowData,grid,index,record){
		var me=this;
		var parentNode=record.parentNode;
		var recordIndex=parentNode.indexOf(record);
		if(recordIndex===0){
			alert(getText('itemov.wbsView.err.noIndentPossible'));
			return false;
		}
		grid.setLoading(true);
		var supNode=parentNode.getChildAt(recordIndex-1);
		var params={
			nodeType:me.itemNavigatorController.nodeType,
			nodeObjectID:me.itemNavigatorController.nodeObjectID,
			descriptorID:me.itemNavigatorController.selectedIssueViewDescriptor.id,
			queryType:me.itemNavigatorController.model.queryType,
			queryID:me.itemNavigatorController.model.queryID,
			workItemID:record.data['workItemID'],
			targetWorkItemID:supNode.data['workItemID']
		};
		Ext.Ajax.request({
			url: "itemNavigator!indent.action",
			disableCaching:true,
			success: function(response){
				grid.setLoading(false);
				var resp = Ext.decode(response.responseText);
	        	if (resp.success==false) {
	        		com.trackplus.util.showError(resp);
	        	} else {
					parentNode.removeChild(record);
					supNode.data['leaf']=false;
					supNode.appendChild(record);
					supNode.expand();
					me.fireEvent.call(me,'datachange');
	        	}
			},
			failure: function(response){
				grid.setLoading(false);
				com.trackplus.util.showError(response);
			},
			method:'POST',
			params:params
		});
	},
	outdent:function(rowData,grid,index,record){
		var me=this;
		var parentNode=record.parentNode;
		var rootNode=grid.store.getRootNode();
		if(parentNode===rootNode){
			CWHF.showMsgError(getText("itemov.wbsView.err.noOutdentPossible"));
			return false;
		}
		var parentIsGroup=parentNode.data['group'];
		if(parentIsGroup===true){
			CWHF.showMsgError(getText("itemov.wbsView.err.noOutdentPossible"));
			return false;
		}
		grid.setLoading(true);
		var params={
			nodeType:me.itemNavigatorController.nodeType,
			nodeObjectID:me.itemNavigatorController.nodeObjectID,
			descriptorID:me.itemNavigatorController.selectedIssueViewDescriptor.id,
			queryContextID:me.itemNavigatorController.model.queryContext.id,
			workItemID:record.data['workItemID']
		};
		Ext.Ajax.request({
			url: "itemNavigator!outdent.action",
			disableCaching:true,
			success: function(){
				var grandParent=parentNode.parentNode;
				var recordIndex=grandParent.indexOf(parentNode);
				grandParent.insertChild(recordIndex+1,record);
				if(!parentNode.hasChildNodes()){
					parentNode.data['leaf']=false;
				}
				grid.setLoading(false);
				me.fireEvent.call(me,'datachange');
			},
			failure: function(){
				grid.setLoading(false);
				alert("failure");
			},
			method:'POST',
			params:params
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.CardViewPlugin',{
	extend: 'com.trackplus.itemNavigator.IssueListViewPlugin',
	fieldGroup:null,
	northPanel:null,
	selectedGroups:null,
	fieldGroupLabel:null,
	queryFieldCSS:null,
	mySelectedIdx:0,
	selectedCardDataView:null,
	refreshData: function(data){
		alert("refresh data");
	},
	dataChangeSuccess:function(opts){
	},
	createSettingsPanel:function(){
		var me=this;
		me.initNorthPanel();
		me.multipleSelect.setValue(me.selectedGroups);
		return me.northPanel;
	},
	getSettingsHeight:function(){
		return 32;
	},
	/**
	 * @cfg {Function} createView
	 *
	 */
	createView:function(){
		var me=this;
		if(CWHF.isNull(me.view)){
			me.centerPanel=Ext.create('Ext.panel.Panel',{
				region:'center',
				layout: {
					type: 'hbox',
					padding:'2',
					align:'stretch'
				},
				border:false,
				defaults:{
					margins:'0 2 0 0'
				},
				bodyBorder:false,
				autoScroll:true
			});
			me.view=me.centerPanel;
			/*me.view=Ext.create('Ext.panel.Panel',{
				layout:'border',
				border:false,
				bodyBorder:false,
				items:[me.northPanel,me.centerPanel]
			});*/
			me.refreshCards();
		}
		return me.view;
	},
	initNorthPanel:function(){
		var me=this;
		var items=new Array();
		var options=me.model.listViewData.groupBy.options;
		me.cmbGroupBy=Ext.create('Ext.form.field.ComboBox',{
			fieldLabel:getText('itemov.cardView.column'),
			name:'groupBy',
			store: Ext.create('Ext.data.Store', {
				data	:(CWHF.isNull(options)?[]:options),
				fields	: [{name:'id', type:'int'}, {name:'label', type:'string'}],
				autoLoad: false
			}),
			border:false,
			bodyBorder:false,
			displayField: 'label',
			valueField: 'id',
			queryMode: 'local',
			value:me.model.listViewData.groupBy.id,
			width:250,
			labelAlign:'right',
			margin: '5 5 5 5'
		});
		me.cmbGroupBy.addListener('change',me.changeGroupBy,me);
		items.push(me.cmbGroupBy);
		items.push(me.createAddGroupPanel());
		var optionsSortBy=me.model.listViewData.sortBy.options;
		me.cmbSortBy=Ext.create('Ext.form.ComboBox',{
			name:'sortBy',
			store: Ext.create('Ext.data.Store', {
				data	:(CWHF.isNull(optionsSortBy)?[]:optionsSortBy),
				fields	: [{name:'id', type:'int'}, {name:'label', type:'string'},{name:'selected',type:'boolean'}],
				autoLoad: false
			}),
			border:false,
			bodyBorder:false,
			displayField: 'label',
			valueField: 'id',
			queryMode: 'local',
			value:me.model.listViewData.sortBy.sortField,
			width:195
		});
		me.cmbSortBy.addListener('change',me.changeSortBy,me);
		var sortOrder=me.model.listViewData.sortBy.sortOrder;
		me.radioAsc=Ext.create('Ext.form.field.Radio',{
			name:'sortOrder',
			inputValue: true,
			boxLabel:getText('itemov.lbl.groupBy.ascending'),
			checked:!sortOrder,
			margin: '0 0 0 5'
		});
		me.radioAsc.addListener('change',me.changeSortBy,me);
		me.radioDsc=Ext.create('Ext.form.field.Radio',{
			name:'sortOrder',
			inputValue: true,
			boxLabel:getText('itemov.lbl.groupBy.descending'),
			checked:sortOrder,
			margin: '0 0 0 5'
		});
		items.push({
			xtype: 'fieldcontainer',
			margin: '5 5 5 5',
			fieldLabel:getText('itemov.lbl.sortBy'),
			labelAlign:'right',
			labelWidth: 100,
			layout: 'hbox',
			items:[me.cmbSortBy,me.radioAsc,me.radioDsc]
		});
		if(me.model.isFilterView===true&&me.model.maySaveFilterLayout){
			var btnSaveAsFilterLayout=Ext.create("Ext.button.Button",{
				text:getText('itemov.btn.saveAsFilterLayout'),
				overflowText:getText('itemov.btn.saveAsFilterLayout'),
				tooltip:getText('itemov.btn.saveAsFilterLayout'),
				iconCls: me.descriptor.iconCls,
				margin:'5 5 5 10',
				handler:function(){
					me.saveAsCardFilterLayout.call(me);
				}
			});
			items.push(btnSaveAsFilterLayout);
		}
		me.northPanel=Ext.create('Ext.panel.Panel',{
			region:'north',
			layout: {
				type: 'column'
			},
			border:false,
			bodyBorder:false,
			//hidden:!me.settingsVisible,
			items:items
		});
	},
	saveAsCardFilterLayout:function(){
		var me=this;
		var urlStr="itemNavigator!saveAsFilterLayout.action";
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			params:{
				queryType:me.model.queryContext.queryType,
				queryID:me.model.queryContext.queryID
			},
			disableCaching:true,
			success: function(result){
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('itemov.msg.saveAsFilterLayoutSuccess'));
			},
			failure: function(){
				borderLayout.setLoading(false);
				CWHF.showMsgError('Failure');
			},
			method:'POST'
		});
	},
	navigate:function(workItemID,workItemIndex,dir,keepPosition){
		var me=this;
		if(CWHF.isNull(me.selectedCardDataView)){
			return null;
		}
		var store =me.selectedCardDataView.getStore();
		if(dir==='next'){
			if(me.mySelectedIdx===store.getCount()-1){
				return null;
			}
			me.mySelectedIdx++;
		}else{
			if(me.mySelectedIdx===0){
				return null;
			}
			me.mySelectedIdx--;
		}
		var record=store.getAt(me.mySelectedIdx);
		if(keepPosition){
			if(dir==='next'){
				me.mySelectedIdx--;
			}else{
				me.mySelectedIdx++;
			}
		}else{
			var selModel=me.selectedCardDataView.getSelectionModel();
			selModel.deselectAll();
			selModel.select(me.mySelectedIdx);
		}
		return{
			workItemID:record.data['workItemID'],
			workItemIndex:me.mySelectedIdx
		};
	},
	changeGroupBy:function(){
		var me=this;
		var fieldGroup=me.cmbGroupBy.getValue();
		me.view.setLoading(true);
		var urlStr="cardView!changeGroupBy.action";
		Ext.Ajax.request({
			params:{
				fieldGroup:fieldGroup,
				queryType:me.model.queryContext.queryType,
				queryID:me.model.queryContext.queryID
			},
			url: urlStr,
			disableCaching:true,
			success: function(data){
				me.view.setLoading(false);
				me.fireEvent.call(me,'datachange');
			},
			failure: function(type, error){
			}
		});
	},
	changeSortBy:function(){
		var me=this;
		var fieldGroup=me.cmbGroupBy.getValue();
		var sortField=me.cmbSortBy.getValue();
		var sortOrder=me.radioAsc.getSubmitValue()!==true;
		me.model.layout.sortField=sortField;
		me.model.layout.sortOrder=sortOrder;
		if(sortField){
			me.model.layout.sortWithSO=me.cmbSortBy.getStore().findRecord('id', sortField).data['selected'];
		}
		me.view.setLoading(true);
		var urlStr="cardView!changeSortBy.action";
		Ext.Ajax.request({
			disableCaching:true,
			url:urlStr,
			params:{
				sortField:sortField,
				sortOrder:sortOrder,
				fieldGroup:fieldGroup,
				queryType:me.model.queryContext.queryType,
				queryID:me.model.queryContext.queryID
			},
			success: function(data){
				me.view.setLoading(false);
				me.fireEvent.call(me,'datachange');
			},
			failure: function(type, error){
			}
		});
	},
	findIssuesByGroup:function(groupID){
		var me=this;
		var issues=me.model.issues;
		if(issues&&issues.length>0){
			for(var i=0;i<issues.length;i++){
				var group=issues[i];
				var idx=group.id.lastIndexOf("_");
				var id=group.id.substring(idx+1);
				if(id===groupID+""){
					return me.collectIssues(group.children);
				}
			}
		}
		return null;
	},
	collectIssues:function(issues){
		var me=this;
		if(CWHF.isNull(issues)||issues.length===0){
			return null;
		}
		var allIssues=new Array();
		for(var i=0;i<issues.length;i++){
			var anIssue=issues[i];
			allIssues.push(anIssue);
			var children=me.collectIssues(anIssue.children);
			if(children){
				allIssues=Ext.Array.merge(allIssues,children);
			}
		}
		return allIssues;
	},
	addAllGroups:function(){
		var me=this;
		var allGroups=me.model.listViewData.groups;
		me.selectedGroups=new Array();
		for(var i=0;i<allGroups.length;i++){
			var g=allGroups[i];
			me.selectedGroups.push(g.id);
		}
	},
	refreshCards:function(){
		var me=this;
		me.centerPanel.removeAll(true);
		var groups=new Array();
		me.queryFieldCSS=me.model.queryFieldCSS;
		var allGroups=me.model.listViewData.groups;
		me.fieldGroup=me.model.listViewData.groupBy.id;
		me.selectedGroups=me.model.listViewData.selectedGroups;
		me.fieldGroupLabel=me.model.listViewData.groupBy.labe;
		var addAllGroup=false;
		if(CWHF.isNull(me.selectedGroups)||me.selectedGroups.length===0){
			addAllGroup=true;
			me.selectedGroups=new Array();
		}
		for(var i=0;i<allGroups.length;i++){
			var g=allGroups[i];
			var number=0;
			var issuesInGroup=me.findIssuesByGroup(g.id);
			if(issuesInGroup){
				number=issuesInGroup.length;
			}
			groups.push({id:g.id,label: g.label,number:number,issues:issuesInGroup,width: g.width});
			if(addAllGroup){
				me.selectedGroups.push(g.id);
			}
		}
		me.allGroups=groups;
		var myItems=new Array();
		if(me.selectedGroups){
			for(var i=0;i<me.selectedGroups.length;i++){
				var g=me.findGroup(me.selectedGroups[i]);
				if(g){
					myItems.push(me.createGroupView(g));
				}
			}
		}
		me.centerPanel.add(myItems);
		me.centerPanel.updateLayout();
	},
	createSortFunction:function(){
		var me=this;
		var sorters=null;
		if(me.model.layout.sortField){
			var sortField;
			var sortDirection=1;
			if(me.model.layout.sortOrder===true){
				sortDirection=-1;
			}else{
				sortDirection=1;
			}
			if(me.model.layout.sortWithSO===true){
				sortField="f_so"+me.model.layout.sortField;
			}else{
				sortField="f"+me.model.layout.sortField;
			}
			return function(o1,o2){
				var me = this;
				var v1 = o1[sortField];
				var v2 = o2[sortField];
				var r= v1 > v2 ? 1 : (v1 < v2 ? -1 : 0);
				return r*sortDirection;
			};
		}
		return null;
	},
	findLabelField:function(fieldID){
		var me=this;
		var shortFields=me.model.layout.shortFields;
		if(CWHF.isNull(shortFields)){
			return null;
		}
		for(var i=0;i<shortFields.length;i++){
			if(shortFields[i].reportField===fieldID){
				return shortFields[i].label;
			}
		}
		return null;
	},
	renderIconHtml:function(fieldID, value){
		var htmlStr;
		switch (fieldID){
			case 5://manager
			case 6://responsible
			case 13:{//originator
				var icon='personAvatar.action?personID='+value;
				htmlStr='<img src="'+icon+'" height="50" width="50"/>';
				break;
			}
			default:{
				var icon='optionIconStream.action?fieldID=-'+fieldID+'&optionID='+value;
				htmlStr='<img src="'+icon+'" height="16"/>';
			}
		}
		return htmlStr;
	},
	createGroupView:function(group){
		var me=this;
		var cardElements=new Array();
		var issues=group.issues;
		var fields=me.createFields();
		var sortFn=me.createSortFunction();
		if(sortFn&&issues){
			issues=Ext.Array.sort(issues,sortFn);
		}
		var store=Ext.create('Ext.data.Store', {
			fields:fields,
			data:CWHF.isNull(issues)?[]:issues
		});
		if(CWHF.isNull(me.cardTpl)){
			me.initCardTpl();
		}
		var cardDataView=Ext.create('Ext.view.View', {
			store: store,
			tpl: me.cardTpl,
			multiSelect: true,
			trackOver: true,
			overItemCls: 'x-item-over',
			itemSelector: 'div.cardElementBase',
			emptyText: getText("itemov.cardView.emptyScrumCard"),
			prepareData: function(data) {
				var issue=data[i];
				var itemID=data['f12'];
				var workItemID=data['workItemID'];
				var responsible=data['f6'];
				var synopsis=data['f17'];
				var description=data['f21'];
				var editable=data['editable'];
				var cardCls='cardElementBase cardElement';
				var clsIndicator='cardElementIndicator';
				if(me.queryFieldCSS&&data['queryFieldCSS']){
					clsIndicator+=' queryFieldCSS rowCls_'+me.queryFieldCSS+"_"+ data['queryFieldCSS'];
				}
				if(editable===false){
					cardCls='cardElementBase cardElement-readOnly';
				}
				var screenFields=me.model.listViewData.panel.fields;
				var screenFieldData;
				var displayValue;
				var screenFieldsHTML=new Array();
				for(var i=0;i<screenFields.length;i++){
					screenFieldsHTML[i]=new Array();
					for(var j=0;j<screenFields[i].length;j++){
						screenFieldData=screenFields[i][j];
						if(screenFieldData){
							screenFieldsHTML[i][j]=new Object();
							screenFieldsHTML[i][j]['empty']=screenFieldData.empty;
						}
						if(screenFieldData&&screenFieldData.empty===false){
							var iconRendering=screenFieldData.iconRendering?screenFieldData.iconRendering:0;
							switch (iconRendering){
								case 0:{
									//label
									displayValue=data['f'+screenFieldData.fieldID];
									break;
								}
								case 1:{
									//icon
									displayValue=me.renderIconHtml(screenFieldData.fieldID,data['f-'+screenFieldData.fieldID]);
									break;
								}
								case 2:{
									//both
									displayValue=me.renderIconHtml(screenFieldData.fieldID,data['f-'+screenFieldData.fieldID])+ '&nbsp;'+data['f'+screenFieldData.fieldID];
									break;
								}
							}
							if(screenFieldData.hideLabel===false){
								var label=me.findLabelField(screenFieldData.fieldID);
								displayValue=label+": "+displayValue;
							}
							screenFieldsHTML[i][j]['displayValue']=displayValue;
							screenFieldsHTML[i][j]['rowSpan']=screenFieldData.rowSpan;
							screenFieldsHTML[i][j]['colSpan']=screenFieldData.colSpan;
							screenFieldsHTML[i][j]['valueHAlign']=screenFieldData.valueHAlign;
							screenFieldsHTML[i][j]['valueVAlign']=screenFieldData.valueVAlign;
						}
					}
				}
				Ext.apply(data,{
					description:description,
					cardCls:cardCls,
					clsIndicator:clsIndicator,
					fields:screenFieldsHTML,
					colsNo:me.model.listViewData.panel.colsNo,
					rowsNo:me.model.listViewData.panel.rowsNo,
					parentGroup:group.id,workItemID:workItemID,itemID:itemID,responsible:responsible,synopsis:synopsis
				});
				return data;
			}
		});
		cardDataView.addListener('itemcontextmenu',me.onGridItemContextMenu,me);
		cardDataView.addListener('itemdblclick',me.onGridItemDblClick,me);
		cardDataView.addListener('itemclick',me.onItemClick,me);
		cardDataView.getSelectionModel().addListener('selectionchange',me.onGridSelectionChange,me);
		cardElements.push(cardDataView);
		var panelGroup=Ext.create('com.trackplus.itemNavigator.GroupView',{
			group:group,
			width:group.width,
			items:cardElements
		});
		panelGroup.addListener('closeGroup',me.removeGroup,me);
		panelGroup.addListener('afterrender',function(c){
			Ext.create('Ext.resizer.Resizer', {
				target: panelGroup,
				handles: 'e',
				minWidth: 200,
				maxWidth: 800,
				listeners:{
					'resize':function(cmp, width, height, e, eOpts ){
						me.groupResizeHandler(panelGroup,me.model.listViewData.fieldGroup,group.id,width);
					}
				}
			});
			var dragZone=new Ext.view.DragZone({
				view: cardDataView,
				ddGroup: 'itemToCategory',
				dragText: '{0} selected row{1}',
				onStartDrag:function(x,y){
					me.validDropTargetIds=null;
					me.partialDropTargetIds=null;
					var records=this.dragData.records;
					var workItems=me.getSelectedItemIds(records);
					var fieldGroup=me.cmbGroupBy.getValue();
					var selectedFieldIDs=new Array();
					selectedFieldIDs.push(fieldGroup);
					me.fireEvent('startDragItems',workItems,selectedFieldIDs,group);
					return true;
				},
				afterDragDrop:function(){
					me.removeAllValidMarkers();
					me.fireEvent('afterDropItems');
				},
				afterInvalidDrop:function(){
					me.removeAllValidMarkers();
					me.fireEvent('afterDropItems');
				}
			});
			var dragSource = new Ext.dd.DragSource(panelGroup.getHeader().getEl(), {
				dragData:{'group': group},
				ddGroup:"itemToCategory",
				onStartDrag:function(){
					var clone = "<div>"+group.label+"</div>";
					clone.id = Ext.id(); // prevent duplicate ids
					this.proxy.update(clone);
					panelGroup.addCls('cardGropDragSource');
				},
				afterDragDrop:function( target, e, id ){
					panelGroup.removeCls('cardGropDragSource');
				},
				afterInvalidDrop:function(){
					panelGroup.removeCls('cardGropDragSource');
				}
			});
			var dropTarget = new Ext.dd.DropTarget(c.getEl(), {
				ddGroup	: 'itemToCategory',
				notifyOver : function(ddSource, e, data) {
					if(data.group){
						if(data.group.id!==group.id){
							return this.dropAllowed;
						}else{
							return false;
						}
					}
					if(!me.checkValidDropTarget(me,data,group)){
						return false;
					}
					return this.dropAllowed
				},
				notifyEnter : function(ddSource, e, data) {
					if(data.group){
						if(data.group.id===group.id){
							return false;
						}
					}else{
						if(!me.checkValidDropTarget(me,data,group)){
							return false;
						}
					}
					if(data.group){
						var idxSource=me.getGroupViewIndex(data.group);
						var idxTarget=me.getGroupViewIndex(group);
						if(idxSource>idxTarget){
							panelGroup.addCls("cardGroupPanel-dragOver-left");
						}else{
							panelGroup.addCls("cardGroupPanel-dragOver-right");
						}
					}else{
						panelGroup.addCls("cardGroupPanel-dragOver");
					}
					return this.dropAllowed
				},
				notifyOut: function(ddSource, e, data) {
					panelGroup.removeCls("cardGroupPanel-dragOver");
					panelGroup.removeCls("cardGroupPanel-dragOver-left");
					panelGroup.removeCls("cardGroupPanel-dragOver-right");
				},
				notifyDrop  : function(ddSource, e, data){
					panelGroup.removeCls("cardGroupPanel-dragOver");
					panelGroup.removeCls("cardGroupPanel-dragOver-left");
					panelGroup.removeCls("cardGroupPanel-dragOver-right");
					if(data.group){
						if(group.id===data.group.id){
							return false;
						}
						var before=false;
						me.changeGroupOrder(data.group,group,before);
					}else{
						if(!me.checkValidDropTarget(me,data,group)){
							return false;
						}
						Ext.defer(me.changeWorkItems, 100, me,[group,data.records]);
					}
					return true;
				}
			});
		});
		return panelGroup
	},
	checkValidDropTarget:function(me,data,group){
		var records=data.records;
		if(records&&records.length>0){
			var r=records[0];
			if(r.data['parentGroup']===group.id){
				return false;
			}
			var valid=CWHF.isNull(me.validDropTargetIds)||Ext.Array.indexOf(me.validDropTargetIds,group.id)!==-1;
			var partialValid=me.partialDropTargetIds&&Ext.Array.indexOf(me.partialDropTargetIds,group.id)!==-1;
			if(valid||partialValid){
				return true;
			}else{
				return false;
			}
		}
		return true;
	},
	updatePossibleFieldOptions:function(jsonData,group){
		var me=this;
		var fieldGroup=me.cmbGroupBy.getValue();
		var validDropTargetIds=jsonData['field'+fieldGroup];
		var partialDropTargetIds=jsonData['partialField'+fieldGroup];
		me.validDropTargetIds=validDropTargetIds;
		me.partialDropTargetIds=partialDropTargetIds;
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var id=groupView.getGroup().id;
			if(id!==group.id){
				if(CWHF.isNull(validDropTargetIds)||Ext.Array.indexOf(validDropTargetIds,id)!==-1){
					groupView.addCls("cardGroupPanel-dropTargetOk");
				}
				if(partialDropTargetIds&&Ext.Array.indexOf(partialDropTargetIds,id)!==-1){
					groupView.addCls("cardGroupPanel-dropTargetPartial");
				}
			}
		}
	},
	removeAllValidMarkers:function(){
		var me=this;
		me.validDropTargetIds=null;
		me.partialDropTargetIds=null;
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			groupView.removeCls("cardGroupPanel-dropTargetOk");
			groupView.removeCls("cardGroupPanel-dropTargetPartial");
		}
	},
	myTip:null,
	isDblClick:false,
	onItemClick:function(view, record, item, index, e, eOpts){
		var me=this;
		me.isDblClick=false;
		if(CWHF.isNull(me.myTip)){
			me.myTip = Ext.create('Ext.tip.ToolTip', {
				autoHide : true,
				dismissDelay:0,
				anchor: 'top'
			});
		}
		var description=record.data['f21'];
		if(description&&description!==''){
			me.myTip.update('<div class="ulist">'+description+'</div>');
			Ext.defer(function(){
				if(me.isDblClick){
					return true;
				}
				me.myTip.showAt(e.getXY());
			}, 300);
		}
	},
	onGridItemContextMenu:function(gridView,record,item,index, event,opts){
		var me=this;
		event.stopEvent();
		me.fireEvent('itemcontextmenu',record.data,event,me.view,index,record);
		return false;
	},
	onGridItemDblClick:function(view, record, item, index, e, eOpts){
		var me=this;
		me.isDblClick=true;
		e.stopEvent();
		me.mySelectedIdx=index;
		me.selectedCardDataView=view;
		me.fireEvent.call(me,'itemdblclick',record.data,item);
		return false;
	},
	onGridSelectionChange:function(sm, sel){
		var me=this;
		var allSelections=new Array();
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var selections=groupView.items.get(0).getSelectionModel().getSelection();
			if(selections&&selections.length>0){
				allSelections=Ext.Array.merge(allSelections,selections);
			}
		}
		me.fireEvent.call(me,'selectionchange',allSelections);
		return false;
	},
	createAddGroupPanel:function(){
		var me=this;
		me.fieldGroupLabel=me.model.listViewData.groupBy.label;
		var allGroups=me.model.listViewData.groups;
		var data=new Array();
		for(var i=0;i<allGroups.length;i++){
			var g=allGroups[i];
			data.push({
				id: g.id,
				label: g.label
			});
		}
		var fieldID=me.model.listViewData.groupBy.id;
		var iconUrlPrefix=null;
		if(fieldID===5||fieldID===6){
			iconUrlPrefix=null;
		}else{
			iconUrlPrefix='optionIconStream.action?fieldID=-'+fieldID+'&optionID=';
		}
		me.multipleSelect= Ext.create('com.trackplus.util.MultipleSelectPicker',{
			options:data,
			width:300,
			margin:'5 5 5 5',
			name:'selectedGroups',
			localizedLabel:me.fieldGroupLabel,
			maxSelectionCount:me.model.listViewData.maxSelectionCount,
			iconUrlPrefix:iconUrlPrefix
		});
		me.multipleSelect.addListener('change',me.multipleSelectChange,me);
		return me.multipleSelect;
	},
	multipleSelectChange:function(comp, newValue,oldValue){
		var me=this;
		if(CWHF.isNull(newValue)||newValue.length===0){
			me.centerPanel.removeAll(true);
			me.selectedGroups=null;
			return true;
		}
		me.selectedGroups=new Array();
		//remove groups
		var groupsAlreadyPressent=new Array();
		var groupViewToRemove=new Array();
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var id=groupView.getGroup().id;
			if(Ext.Array.indexOf(newValue,id)!==-1){
				groupsAlreadyPressent.push(id);
				me.selectedGroups.push(id);
			}else{
				groupViewToRemove.push(groupView);
			}
		}
		for(var i=0;i<groupViewToRemove.length;i++){
			me.centerPanel.remove(groupViewToRemove[i]);
		}
		var groupToAdd=new Array();
		for(var i=0;i<newValue.length;i++){
			var id=newValue[i];
			if(Ext.Array.indexOf(groupsAlreadyPressent,id)!==-1){
				continue;
			}
			me.selectedGroups.push(id);
			groupToAdd.push(me.findGroup(id));
		}
		for(var i=0;i<groupToAdd.length;i++){
			me.centerPanel.add(me.createGroupView(groupToAdd[i]));
		}
		me.centerPanel.updateLayout();
		me.changeSelectedGroups();
		return true;
	},
	changeSelectedGroups:function(){
		var me=this;
		var cardViewGroupFilter="";
		if(me.selectedGroups){
			cardViewGroupFilter=me.selectedGroups.join();
		}
		var fieldGroup=me.cmbGroupBy.getValue();
		var urlStr="cardView!cardFieldOptionsChange.action";
		Ext.Ajax.request({
			disableCaching:true,
			url:urlStr,
			params:{
				cardViewGroupFilter:cardViewGroupFilter,
				fieldGroup:fieldGroup,
				queryType:me.model.queryContext.queryType,
				queryID:me.model.queryContext.queryID
			},
			success: function(data){
			},
			failure: function(type, error){
			}
		});
	},
	findGroup:function(id){
		var me=this;
		var allGroups=me.allGroups;
		for(var i=0;i<allGroups.length;i++){
			if(allGroups[i].id===id){
				return allGroups[i];
			}
		}
	},
	getGroupViewIndex:function(group){
		var me=this;
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var id=groupView.getGroup().id;
			if(group.id===id){
				return i;
			}
		}
		return -1;
	},
	removeGroup:function(groupView){
		var me=this;
		var group=groupView.getGroup();
		me.centerPanel.remove(groupView,true);
		if(CWHF.isNull(me.selectedGroups)){
			me.addAllGroups();
		}
		me.selectedGroups=Ext.Array.remove(me.selectedGroups,group.id);
		me.multipleSelect.setValue(me.selectedGroups,true);
	},
	getSelectedItemIds:function(records){
		var workItems="";
		var workItemID=-1;
		for(var i=0;i<records.length;i++){
			var workItemIDStr=records[i].data['workItemID'];
			try {
				workItemID=parseInt(workItemIDStr);
			}catch(e){
				workItemID=-1;
			}
			if(!isNaN(workItemID)&&workItemID!==-1){
				workItems+=workItemID+",";
			}
		}
		return workItems;
	},
	changeWorkItems:function(group,records){
		var me=this;
		var workItems=me.getSelectedItemIds(records);
		me.view.setLoading(true);
		var params={
			workItems:workItems,
			fieldID:me.fieldGroup,
			value:group.id
		};
		me.ajaxRequest(params);
	},
	changeGroupOrder:function(sourceGroup,targetGroup,before){
		var me=this;
		var groupViewSource=null;
		var idxSource;
		var idxTarget;
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var id=groupView.getGroup().id;
			if(id===sourceGroup.id){
				groupViewSource=groupView;
				idxSource=i;
			}
			if(id===targetGroup.id){
				idxTarget=i;
			}
		}
		me.centerPanel.remove(idxSource,false);
		me.centerPanel.insert(idxTarget,groupViewSource);
		me.selectedGroups=new Array();
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var id=groupView.getGroup().id;
			me.selectedGroups.push(id);
		}
		me.multipleSelect.setValue(me.selectedGroups,true);
		me.changeSelectedGroups();
	},
	ajaxRequest:function(params){
		var me=this;
		var urlStr="itemNavigator!changeOneField.action";
		Ext.Ajax.request({
			url: urlStr,
			success: function(result){
				me.view.setLoading(false);
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===true){
					me.fireEvent.call(me,'datachange');
				}else{
					me.handleError(jsonData,params);
				}
			},
			params:params
		});
	},
	onCardItemDblClick:function(e, t, eOpts){
		var me=this;
		me.fireEvent.call(me,'itemdblclick',eOpts.item,t);
	},
	onCardItemContextMenu:function(e, t, eOpts){
		var me=this;
		e.stopEvent();
		me.fireEvent('itemcontextmenu',eOpts.item,e,me.view);
		return false;
	},
	initCardTpl:function(){
		var me=this;
		var panel=me.model.listViewData.panel;
		var tmpl=new Array();
		tmpl.push('<tpl for=".">');
		tmpl.push('<div class="{cardCls}">');
		tmpl.push('<table style="width:100%;height:100%" border="0" cellspacing="0" cellpadding="0">');
		tmpl.push('<tr><td rowspan="{rowsNo+1}" width="7" class="{clsIndicator}">&nbsp;</td><td colspan="{colsNo}"></td></tr>');
		tmpl.push('<tpl for="fields">');
		tmpl.push('<TR>');
		tmpl.push('<tpl for=".">');
		tmpl.push('<tpl if=".">');
		tmpl.push('<tpl if="!empty">');
		tmpl.push('<td class="cardField valueVerticalAlign-{valueVAlign} valueAlign-{valueHAlign}" colspan="{colSpan}" rowspan="{rowSpan}" >');
		tmpl.push('{displayValue}');
		tmpl.push('</td>');
		tmpl.push('</tpl>');//if field not empty
		tmpl.push('<tpl if="empty">');
		tmpl.push('<td>&nbsp;</td>');
		tmpl.push('</tpl>');//if field is empty
		tmpl.push('</tpl>');//if fieldWrapper not null
		tmpl.push('</tpl>');//for
		tmpl.push('</tr>');
		tmpl.push('</tpl>');
		tmpl.push('</table>')
		tmpl.push('</div>')
		tmpl.push('</tpl>');
		me.cardTpl = new Ext.XTemplate(tmpl);
		me.cardTpl.compile()
	},
	destroyView:function(){
	},
	/**
	 * @cfg {Function} getSelectedIssues
	 *
	 */
	getSelectedIssues:function(){
		var me=this;
		var selections=new Array();
		for(var i=0;i<me.centerPanel.items.getCount();i++){
			var groupView=me.centerPanel.items.getAt(i);
			var sel=groupView.items.get(0).getSelectionModel().getSelection();
			if(sel&&sel.length>0){
				selections=Ext.Array.merge(selections,sel);
			}
		}
		var issueIds=[];
		for(var i=0;i<selections.length;i++){
			issueIds.push(selections[i].data.workItemID);
		}
		return issueIds;
	},
	selectItemByIndex:function(workItemIndex){
	},
	selectItem:function(workItemID,isArray){
	},
	deselectItem:function(workItemID,isArray){
	},
	TYPE_COMMON:0,
	TYPE_MASS_OPERATION:1,
	handleError:function(jsonData,params){
		var me=this;
		var type=jsonData.type;
		switch (type){
			case me.TYPE_COMMON:{
				var title=getText("common.err.failure");
				if(jsonData.title){
					title=jsonData.title;
				}
				Ext.MessageBox.show({
					title: title,
					msg:jsonData.errorMessage,
					buttons: Ext.MessageBox.OK,
					icon: Ext.MessageBox.WARNING
				});
				break;
			}
			case me.TYPE_MASS_OPERATION:{
				var massEx=jsonData.massOperation;
				var errorCode=massEx.errorCode;
				if(errorCode&&errorCode===4){
					var title="Error";
					if(massEx.title){
						title=massEx.title;
					}
					Ext.MessageBox.confirm(title,
						massEx.errorMessage,
						function(btn){
							if (btn==="no") {
								return false;
							} else {
								me.confirmationSubmitHandler.call(me,params);
							}
						});
				}else{
					var title="Error";
					if(massEx.title){
						title=massEx.title;
					}
					Ext.MessageBox.show({
						title: title,
						msg:massEx.errorMessage,
						buttons: Ext.MessageBox.OK,
						icon: Ext.MessageBox.WARNING
					});
				}
				break;
			}
		}
	},
	confirmationSubmitHandler:function(params){
		var me=this;
		if(CWHF.isNull(params)){
			params={};
		}
		params['params.confirmSave']='true';
		me.ajaxRequest.call(me,params);
	},
	groupResizeHandler:function (panelGroup,fieldGroup,optionID,width){
		var me=this;
		var fieldGroup=me.cmbGroupBy.getValue();
		var urlStr="cardView!changeOptionWidth.action";
		Ext.Ajax.request({
			disableCaching:true,
			url:urlStr,
			params:{
				optionID:optionID,
				width:width,
				fieldGroup:fieldGroup,
				queryType:me.model.queryContext.queryType,
				queryID:me.model.queryContext.queryID
			},
			success: function(data){
			},
			failure: function(type, error){
			}
		});
	},
	getPopupMenuItems:function(rowData,grid,index,record){
		var me=this;
		var items=[];
		items.push('-');
		items.push({
			text: getText('itemov.cardView.configCardContent'),
			iconCls:'btnConfig16',
			handler:function(){
				me.configCardContent.call(me);
			}
		});
		return items;
	},
	configCardContent:function(){
		var me=this;
		var urlStr='cardScreenEdit.action?backAction=itemNavigator.action';
		window.location.href=urlStr;
	}
});
Ext.define('com.trackplus.itemNavigator.GroupView',{
	extend: 'Ext.panel.Panel',
	config:{
		group:{}
	},
	cls:'cardGroupPanel',
	frame:true,
	autoScroll:true,
	width:250,
	margin:'0 2 0 0',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		//me.addEvents('closeGroup');
	},
	initComponent: function(){
		var me=this;
		me.title= me.group.label+' ('+me.group.number+')';
		var tools=new Array();
		tools.push({
			type:'close',
			tooltip: 'Close',
			handler: function(event, toolEl, panel){
				me.fireEvent.call(me,'closeGroup',me);
			}
		});
		Ext.apply(this, {
			tools: tools
		});
		me.callParent();
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.ChooseColumns',{
	extend:'Ext.Base',
	config: {
		itemNavigatorController:null,
		filterType:null,
		filterID:null,
		includeLongFields:false
	},
	ccController:null,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		me.ccController=Ext.create('com.trackplus.itemNavigator.ChooseColumnsController',{
			itemNavigatorController:me.itemNavigatorController,
			filterType:me.filterType,
			filterID:me.filterID,
			includeLongFields:me.includeLongFields
		});
	},
	setIncludeLongFields:function(includeLongFields){
		this.includeLongFields=includeLongFields;
		this.ccController.includeLongFields=includeLongFields;
	},
	showDialog:function(){
		var me=this;
		me.ccController.showDialog.call(me.ccController);
	},
	destroyMe:function(){
	   var me=this;
		if(me.ccController){
			me.ccController.destroyMe.call(me.ccController);
			me.ccController=null;
		}
	}
});
Ext.define('com.trackplus.itemNavigator.ChooseColumnsController',{
	extend:'Ext.Base',
	config: {
		itemNavigatorController:null,
		filterType:null,
		filterID:null,
		includeLongFields:false
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	destroyMe:function(){
		var me=this;
		if(me.win){
			me.win.destroy();
		}
	},
	showDialog: function() {
		var width = 300;
		var height = 400;
		var loadParams = {filterType:this.filterType, filterID:this.filterID, includeLongFields:this.includeLongFields};
		var load = {loadUrl:"layoutColumns.action", loadUrlParams:loadParams};
		var submitParams = {filterType:this.filterType, filterID:this.filterID};
		var submit = {submitUrl:"layoutColumns!save.action",
					submitUrlParams:submitParams,
					refreshAfterSubmitHandler:this.reload, loading:true};
		var windowParameters = {title:getText("itemov.lbl.chooseColumns"),
			width:width,
			height:height,
			load:load, submit:submit,
			items:[],
			postDataProcess:this.createColumnItems,
			panelConfig:{
				bodyStyle:{
					padding:'0 0 0 10'
				}
			}
		};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	/**
	 * Refreshes a grid's store and selects a row by rowToSelect parameter if it is specified
	 * Called from selectAfterReload() (grid and tree refresh) and from simple grid CRUD
	 */
	reload: function() {
		this.itemNavigatorController.changeLayout.call(this.itemNavigatorController);
	},
	createColumnItems: function(data, panel){
		var me=this;
		var columnFieldList=data;
		var items=[];
		for(var i=0;i<columnFieldList.length;i++) {
			items.push(me.createColumnItem(columnFieldList[i]));
		}
		panel.add(items);
	},
	createColumnItem: function(columnField){
		if(columnField.fieldID<0){
			name='selectedColumnsMap.f_'+(columnField.fieldID*-1);
		}else{
			name='selectedColumnsMap.f'+columnField.fieldID;
		}
		return CWHF.createCheckbox(null, name,
				{value:columnField.used, boxLabel:columnField.label, margin: 5});
	}
	/*showDialog:function(){
		var me=this;
		borderLayout.setLoading(true);
		me.formPanel=Ext.create('Ext.form.Panel',{
			url:'itemNavigatorLayout!saveLayout.action',
			id:'chooseColumnsFormPanel',
			layout:'anchor',
			standardSubmit:false,
			bodyBorder:false,
			border    : false,
			autoScroll:true,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px 10px 5px 10px'
			}
		});
		if(me.win){
			me.win.destroy();
		}
		me.win = Ext.create('Ext.window.Window',{
			layout      : 'fit',
			width       : 300,
			height      : 400,
			closeAction :'destroy',
			plain       : true,
			title		 : getText('itemov.lbl.chooseColumns'),
			modal       : true,
			cls:'bottomButtonsDialog',
			bodyBorder:true,
			margin:'0 0 0 0',
			style:{
				padding:'5px 0px 0px 0px'
			},
			bodyPadding:'0px',
			autoScroll  : false,
			items       : [me.formPanel],
			buttons     : [
				{text:getText('common.btn.save') ,handler  :me.saveColumnsLayout,scope:me},
				{text:getText('common.btn.close'),handler  :function(){me.win.destroy();},scope:me}
			]
		});
		var urlStr='itemNavigatorLayout!loadAllColumns.action';
		Ext.Ajax.request({
			url: urlStr,
			params:{
				filterType:me.filterType,
				filterID:me.filterID,
				includeLongFields:me.includeLongFields
			},
			disableCaching:true,
			success: function(response){
				var jsonData=Ext.decode(response.responseText);
				var allColumns=jsonData.data;
				me.refresh.call(me,allColumns);
				borderLayout.setLoading(false);
				me.win.show();
			},
			failure: function(){
				borderLayout.setLoading(false);
				//alert("failure");
			}
		});
	},
	refresh:function(allColumns){
		var me=this;
		me.formPanel.removeAll();
		var items=[];
		var col;
		var name="";
		var idx=0;
		for(var i=0;i<allColumns.length;i++){
			col=allColumns[i];
			var longField=col.reportLayout.renderAsLong;
			if(longField===false&&(col.reportLayout.reportField===-1005||
				col.reportLayout.reportField===-1007||
				col.reportLayout.reportField===-1008||
				col.reportLayout.reportField===23)){
				longField=true;
			}
			if(col.reportLayout.reportField<0){
				name='selectedColumnsMap.f_'+(col.reportLayout.reportField*-1);
			}else{
				name='selectedColumnsMap.f'+col.reportLayout.reportField;
			}
			var hidden=false;
			if(me.includeLongFields===false){
				hidden=(longField===true);
			}
			if(!hidden){
				idx++;
			}
			var cls="";
			if(idx%2===1){
				cls='checkColumnOdd';
			}
			items.push({
				xtype:"checkboxfield",
				name:name,
				cls:cls,
				boxLabel:col.reportLayout.label,
				checked:col.used,
				inputValue:'true',
				value:col.used,
				hidden:hidden,
				anchor:'100%'
			});
		}
		me.formPanel.add(items);
		me.formPanel.updateLayout();
	},*/
	/*saveColumnsLayout:function() {
		var me=this;
		borderLayout.setLoading(true);
		me.formPanel.getForm().submit({
			params:{
				filterType:me.filterType,
				filterID:me.filterID
			},
			success: function(form, action) {
				me.win.destroy();
				borderLayout.setLoading(false);
				me.itemNavigatorController.changeLayout.call(me.itemNavigatorController);
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				alert("failure");
			}
		});
	}*/
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.itemNavigator.Grouping",{
	extend:"Ext.Base",
	config: {
		filterType: null,
		filterID: null,
		itemNavigatorController: null
	},
	constructor : function(cfg) {
		var config = cfg || {};
		this.initialConfig = config;
		Ext.apply(this, config);
		this.initConfig(config);
	},
	showDialog: function() {
		var width = 350;
		var height = 460;
		var loadParams = {filterType:this.filterType, filterID:this.filterID};
		var load = {loadUrl:"layoutGrouping.action", loadUrlParams:loadParams};
		var submitParams = {filterType:this.filterType, filterID:this.filterID};
		var submit = {submitUrl:"layoutGrouping!save.action",
					submitUrlParams:submitParams,
					refreshAfterSubmitHandler:this.reload, loading:true};
		var windowParameters = {title:getText("itemov.lbl.groupBy"),
			width:width,
			height:height,
			load:load, submit:submit,
			items:[],
			postDataProcess:this.createGroupingItems,
			panelConfig:{
				bodyStyle:{
					padding:'0 0 0 10'
				}
			}
		};
		var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	/**
	 * Refreshes a grid's store and selects a row by rowToSelect parameter if it is specified
	 * Called from selectAfterReload() (grid and tree refresh) and from simple grid CRUD
	 */
	reload: function() {
		this.itemNavigatorController.changeLayout.call(this.itemNavigatorController);
	},
	createGroupingItems: function(data, panel){
		var me=this;
		var groupFields=data.selectedGroupFields;
		var groupFieldList=data.groupFieldList;
		var ascendingDescendingList=data.ascendingDescendingList;
		var expandCollapseList=data.expandCollapseList;
		var maxGroupingLevels=groupFields.length;
		var items=[];
		var activeSet = false;
		var previousActiveSet = true;
		for(var i=0;i<groupFields.length;i++) {
			activeSet = !CWHF.isNull(groupFields[i].fieldID);
			items.push(me.createGroupingItem(i, maxGroupingLevels, panel, groupFields[i], groupFieldList, ascendingDescendingList, expandCollapseList, activeSet, previousActiveSet));
			previousActiveSet = activeSet;
		}
		panel.add(items);
	},
	createGroupingItem: function(i, count, mainPanel, groupField, groupFieldList, ascendingDescendingList, expandCollapseList, activeSet, previousActiveSet){
		var me=this;
		var itemIDPrefix =  "groupFields"+i;
		var namePrefix="groupFields["+i+"].";
		var checkBox = CWHF.createCheckbox(null, "activated"+i,
				{itemId:"activated"+i,value:activeSet, disabled:!previousActiveSet, boxLabel:getText("itemov.lbl.groupBy.active")},
				{change: {fn: me.activate,
					scope:me, index:i, count:count, mainPanel: mainPanel}});
		var fieldCombo = CWHF.createCombo(null, namePrefix + "fieldID",
			{itemId:itemIDPrefix + "fieldID",value: groupField.fieldID, data:groupFieldList, disabled:!activeSet, anchor:'100%'});
		var orderRadioButtonItems = CWHF.getRadioButtonItems(ascendingDescendingList,
			namePrefix + "descending", "id", "label", groupField.descending, false, true);
		var orderRadioGroup = CWHF.getRadioGroup(null, null, orderRadioButtonItems, {itemId:itemIDPrefix + "descending",anchor:'100%', disabled:!activeSet});
		var expandingRadioButtonItems = CWHF.getRadioButtonItems(expandCollapseList,
			namePrefix + "collapsed", "id", "label", groupField.collapsed, false, true);
		var expandingRadioGroup = CWHF.getRadioGroup(null, null, expandingRadioButtonItems, {itemId:itemIDPrefix + "collapsed",anchor:'100%', disabled:!activeSet});
		return Ext.create("Ext.panel.Panel",{
			margin:'5 0 5 0',
			border:true,
			itemId: "panel" + i,
			bodyBorder:false,
			bodyStyle:{
				padding:'5px 5px 2px 10px'
			},
			anchor:'100%',
			layout:'column',
			items:[
				{
					xtype: 'fieldcontainer',
					border:false,
					fieldLabel: '<B>'+(i+1)+'</B>',
					labelSeparator:'.',
					labelWidth:15,
					width:90,
					items:[checkBox]
				},{
					columnWidth: 1,
					border:false,
					bodyBorder:false,
					layout:'anchor',
					items:[fieldCombo,
					       orderRadioGroup,
					       expandingRadioGroup]
				}
			]
		});
	},
	activate: function(checkboxField, newValue, oldValue, options) {
		var index = options.index;
		var count = options.count;
		var mainPanel = options.mainPanel;
		var indexPanel = mainPanel.getComponent("panel" + index);
		var itemIDPrefix =  "groupFields"+index;
		var checkBoxActivated = indexPanel.getComponent(0).getComponent("activated"+index);
		var activated = checkBoxActivated.getRawValue();
		var selectField = indexPanel.getComponent(1).getComponent(itemIDPrefix+"fieldID");
		selectField.setDisabled(!activated);
		var descending = indexPanel.getComponent(1).getComponent(itemIDPrefix+"descending");
		descending.setDisabled(!activated);
		var collapsed = indexPanel.getComponent(1).getComponent(itemIDPrefix+"collapsed");
		collapsed.setDisabled(!activated);
		if (index<count-1) {
			if (activated) {
				//activate the next grouping level's checkbox
				var nextIndex = index+1;
				var nextPanel = mainPanel.getComponent("panel" + nextIndex);
				var nextCheckBox = nextPanel.getComponent(0).getComponent("activated"+nextIndex);
				nextCheckBox.setDisabled(false);
			} else {
				for (var i=index+1;i<count;i++) {
					var nextPanel = mainPanel.getComponent("panel" + i);
					var nextIndexPrefix =  "groupFields"+i;
					var selectField = nextPanel.getComponent(1).getComponent(nextIndexPrefix+"fieldID");
					selectField.setDisabled(true);
					var descending = nextPanel.getComponent(1).getComponent(nextIndexPrefix+"descending");
					descending.setDisabled(true);
					var collapsed = nextPanel.getComponent(1).getComponent(nextIndexPrefix+"collapsed");
					collapsed.setDisabled(true);
					var nextCheckBoxActivated = nextPanel.getComponent(0).getComponent("activated"+i);
					nextCheckBoxActivated.setDisabled(true);
					nextCheckBoxActivated.setRawValue(false);
				}
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.itemNavigator.InstantFilter",{
	extend:"Ext.util.Observable",
	config: {
		filterName: null,
		filterType: null,
		filterID: null,
		queryContextID: null,
		viewID: null,
		fromSession:false
	},
	filterPanel: null,
	//add new selection field: instant should be true to not add $Paramater
	instant: true,
	indexMax: 0,
	constructor : function(cfg) {
		var config = cfg || {};
		this.initialConfig = config;
		this.events=[];
		//this.addEvents("applyFilter");
		//this.addEvents("cleanFilter");
		this.listeners = config.listeners;
		Ext.apply(this, config);
		this.initConfig(config);
		this.callParent(arguments);
	},
	/**
	 * Creates the filter panel
	 */
	createPanel: function() {
		var me=this;
		me.filterPanel=Ext.create("Ext.form.Panel",{
			border:false,
			bodyBorder:false,
			autoScroll:true,
			region:"center",
			dockedItems: me.getFilterToolbar(),
			style:{
				borderBottom:"1px solid #d0d0d0"
			}
		});
		return me.filterPanel;
	},
	/**
	 * Loads the filter panel with filter expressions
	 */
	loadFilter: function() {
		var me=this;
		var	 params = {};
		if (CWHF.isNull(this.filterID) || CWHF.isNull(this.filterType)) {
			params.add = true;
		} else {
			params.filterID = this.filterID;
			params.filterType = this.filterType;
			params.queryContextID = this.queryContextID;
		}
		params.fromSession=this.fromSession;
		me.filterPanel.setLoading(true);
		me.filterPanel.getForm().load({
			url : "filterConfig!edit.action",
			params: params,
			scope: me,
			success: function(form, action) {
				me.filterPanel.setLoading(false);
				var data = action.result.data;
				data.selectColumnCount = 4;
				var modifiable = data["modifiable"];
				//force the filter fields to be modifiable (save as is always possible)
				data["modifiable"] = true;
				var toolbars = me.filterPanel.getDockedItems('toolbar[dock="top"]');
				if (toolbars) {
					//if not modifiable disbale the save button
					toolbars[0].getComponent(2).setDisabled(!modifiable);
				}
				me.issueFilter = true;//to avoid rendering new/old value (used only for notification filter)
				com.trackplus.admin.Filter.postLoadProcessTreeFilter.call(me, data, me.filterPanel);
			},
			failure: function(form, action) {
				me.filterPanel.setLoading(false);
				/*Ext.MessageBox.show({
					title: this.failureTitle,
					msg: action.response.responseText,
					buttons: Ext.Msg.OK,
					icon: Ext.MessageBox.ERROR
				})*/
			}
		});
	},
	/**
	 * Initialize the filter toolbar
	 */
	getFilterToolbar: function() {
		return [{
			xtype: 'toolbar',
			dock: 'top',
			margin:'4 0 0 0',
			items: [this.getApplyFilterAction(), this.getCleanFilterAction(), this.getSaveFilterAction(), this.getSaveFilterAsAction()]
		}];
	},
	/**
	 * Creates the apply filter action
	 */
	getApplyFilterAction: function() {
		var actionConfig = {
				text: getText("common.btn.apply"),
				overflowText: getText("common.btn.applyFilter"),
				tooltip:getText("itemov.btn.applyFilter.tt"),
				iconCls: "filterExec",
				scope: this,
				handler: this.onApply
		};
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Creates the clean filter action
	 */
	getCleanFilterAction: function() {
		var actionConfig = {
				text: getText("common.btn.reset"),
				overflowText: getText("common.btn.reset"),
				tooltip:getText("itemov.btn.clearFilter.tt"),
				iconCls: "clear16",
				scope: this,
				handler: this.onClean
		};
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Creates the save action
	 */
	getSaveFilterAction: function() {
		var actionConfig = {
				text: getText("common.btn.save"),
				overflowText: getText("common.btn.save"),
				tooltip:getText("itemov.btn.saveFilter.tt"),
				iconCls: "save",
				disabled: true,
				scope: this,
				handler: this.onSave
		};
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Creates the save as action
	 */
	getSaveFilterAsAction: function() {
		var actionConfig = {
				text: getText("common.btn.saveAs"),
				overflowText: getText("common.btn.saveAs"),
				tooltip:getText("itemov.btn.saveAsFilter.tt"),
				iconCls: "save",
				scope: this,
				handler: this.onSaveAs
		};
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Applies the filter
	 */
	onApply: function() {
		var me=this;
		submitUrlParams = {instant:true, ajax:true, filterID:me.filterID, filterType:me.filterType};
		com.trackplus.admin.Filter.preSubmitProcessIssueFilter(submitUrlParams, me.filterPanel);
		me.filterPanel.setLoading(true);
		me.filterPanel.getForm().submit({
			url: "savedFilterExecute!applyInstant.action",
			params: submitUrlParams,
			method: "POST",
			scope: me,
			success: function(form, action) {
				me.filterPanel.setLoading(false);
				var result = action.result;
				if (result) {
					if (result.success) {
						me.fireEvent.call(me,"applyFilter",{
							filterType: me.filterType,
							filterID: me.filterID,
							queryContextID: me.queryContextID
						});
					} else {
						com.trackplus.util.showError(result);
					}
				}
			},
			failure: function(form, action) {
				me.filterPanel.setLoading(false);
				result = action.result;
				if (result) {
					var errorMessage = result.errorMessage;
					if (errorMessage) {
						//only error message, no errorCode
						com.trackplus.util.showError(result);
					} else {
						com.trackplus.util.submitFailureHandler(form, action);
					}
				}
			}
		});
	},
	/**
	 * Cleans the filter conditions
	 */
	onClean: function() {
		var me=this;
		var params = {clearFilter:true};
		if (CWHF.isNull(this.filterID) || CWHF.isNull(this.filterType)) {
			params.instant = true;
		} else {
			params.filterID = this.filterID;
			params.filterType = this.filterType;
			params.queryContextID = this.queryContextID;
		}
		me.filterPanel.setLoading(true);
		me.filterPanel.getForm().load({
			url : "filterConfig!edit.action",
			params: params,
			scope: me,
			success: function(form, action) {
				me.filterPanel.setLoading(false);
				var data = action.result.data;
				data.selectColumnCount = 7;
				//force to be modifiable
				data["modifiable"] = true;
				com.trackplus.admin.Filter.clearTreeFilter.call(me, me.filterPanel, data);
				me.fireEvent.call(me,"clearFilter",{
					filterType: me.filterType,
					filterID: me.filterID,
					queryContextID: me.queryContextID
				});
			},
			failure: function(form, action) {
				me.filterPanel.setLoading(false);
				/*Ext.MessageBox.show({
					title: this.failureTitle,
					msg: action.response.responseText,
					buttons: Ext.Msg.OK,
					icon: Ext.MessageBox.ERROR
				})*/
			}
		});
	},
	onSave: function() {
		var me=this;
		var params = {};
		if (CWHF.isNull(this.filterID) || CWHF.isNull(this.filterType)) {
			//params.instant = true;
			params.add = true;
		} else {
			params.filterID = this.filterID;
			params.filterType = this.filterType;
			params.queryContextID = this.queryContextID;
		}
		com.trackplus.admin.Filter.preSubmitProcessIssueFilter(params, me.filterPanel);
		me.filterPanel.setLoading(true);
		me.filterPanel.getForm().submit({
			url: "filterConfig!save.action",
			params: params,
			method: "POST",
			scope: me,
			success: function(form, action) {
				me.filterPanel.setLoading(false);
				var result = action.result;
				if (result) {
					if (result.success) {
						CWHF.showMsgInfo(getText("admin.customize.queryFilter.successSave"));
						//TODO reload content
					} else {
						CWHF.showMsgError(getText("admin.customize.queryFilter.errorSave"));
					}
				}
			},
			failure: function(form, action) {
				me.filterPanel.setLoading(false);
				result = action.result;
				if (result) {
					var errorMessage = result.errorMessage;
					if (errorMessage) {
						//only error message, no errorCode
						com.trackplus.util.showError(result);
					} else {
						com.trackplus.util.submitFailureHandler(form, action);
					}
				}
			}
		});
	},
	onSaveAs: function() {
		var nameAndPathPicker=Ext.create("com.trackplus.util.NameAndPathPicker",{
			title:getText("common.btn.saveAs"),
			loadUrl: "categoryPathPicker.action",
			loadParams:  {categoryType:"issueFilter", add: true},
			//pathTree: data,
			handler:this.saveWithNameAndPath,
			//validateHandler: this.validateHandler,
			scope:this
		});
		nameAndPathPicker.showDialog();
	},
	/*validateHandler: function(submit) {
	var me=this;
	var filled = me.formEdit.isValid();
	if (!filled) {
		return false;
	}
	var pathNodeID = me.formEdit.getComponent("path").getValue();
	var label = me.formEdit.getComponent("name").getValue();
	Ext.Ajax.request({
		url: 'filterConfig!isValidLabel.action',
		params: {node:pathNodeID, label:label},
		scope: this,
		disableCaching:true,
		success: function(response){
			this.handler(label, pathNodeID);
		},
		failure: function(result){
			Ext.MessageBox.alert(this.failureTitle, result.responseText)
		},
		method:"POST"
	})
},*/
	saveWithNameAndPath:function(window, name, parentID, includeInMenu) {
		var me = this;
		var submitParams = {node:parentID, label:name, includeInMenu:includeInMenu, add:true, viewID: me.viewID};
		me.filterPanel.getForm().submit({
			url: "filterConfig!save.action",
			params: submitParams,
			method: "POST",
			scope: this,
			success: function(form, action) {
				me.filterPanel.setLoading(false);
				var result = action.result;
				if (result) {
					if (result.success) {
						CWHF.showMsgInfo(getText("admin.customize.queryFilter.successSave"));
						window.close();
						//TODO reload content
					} else {
						CWHF.showMsgError(getText("admin.customize.queryFilter.errorSave"));
					}
				}
			},
			failure: function(form, action) {
				me.filterPanel.setLoading(false);
				result = action.result;
				if (result) {
					var errorMessage = result.errorMessage;
					if (errorMessage) {
						//only error message, no errorCode
						com.trackplus.util.showError(result);
					} else {
						com.trackplus.util.submitFailureHandler(form, action);
					}
				}
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.itemNavigator.MassOperationController",{
	extend:"Ext.Base",
	config: {
		copy: null,
		selectedIssueIDs: null
	},
	itemNavigatorController: null,
	constructor : function(cfg) {
		var config = cfg || {};
		this.initConfig(config);
	},
	getTitle: function() {
		if (this.getCopy()){
			return getText("common.btn.bulkCopy");
		}else{
			return getText("common.btn.bulkEdit");
		}
	},
	getSaveLabel: function() {
		if (this.getCopy()) {
			return getText("common.btn.copy");
		} else {
			return getText("common.btn.save");
		}
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	showDialog: function() {
		var width = 900;
		var height = 600;
		var loadParams = {selectedIssueIDs:this.getSelectedIssueIDs(), bulkCopy:this.getCopy()};
		var load = {loadUrl:"massOperationEdit.action", loadUrlParams:loadParams};
		var submitParams = {selectedIssueIDs:this.getSelectedIssueIDs(), bulkCopy:this.getCopy()};
		var submit = {
					submitUrl:"massOperationEdit!save.action",
					submitUrlParams:submitParams,
					submitButtonText:this.getSaveLabel(),
					refreshAfterSubmitHandler:this.reload, loading:true};
		var postDataProcess = this.postDataProcess;
		var windowParameters = {title:this.getTitle(),
			width:width,
			height:height,
			load:load, submit:submit,
			items:[],
			postDataProcess:postDataProcess,
            preSubmitProcess: this.preSubmitProcess,
			panelConfig:{
				bodyStyle:{
					padding:'0 0 0 10'
				}
			}
		};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
    preSubmitProcess: function(submitUrlParams, panel) {
        var massOperationExpressionPanels = panel.items;
        var startAt = 1;
        if (this.getCopy()) {
            startAt=2;
        }
        for ( var i=startAt;i<massOperationExpressionPanels.getCount();i++ ) {
            var expressionPanel = massOperationExpressionPanels.getAt(i);
            var numberOfItems = expressionPanel.items.getCount();
            var valueControl = expressionPanel.items.getAt(numberOfItems-1);
            if (valueControl && !valueControl.isDisabled() && valueControl.beforeSubmit) {
                valueControl.beforeSubmit.call(this);
            }
        }
        return submitUrlParams;
    },
	postDataProcess: function(data, panel) {
		this.populateFieldExpressions(this, panel, data);
	},
	/**
	 * Refreshes a grid's store and selects a row by rowToSelect parameter if it is specified
	 * Called from selectAfterReload() (grid and tree refresh) and from simple grid CRUD
	 */
	reload: function() {
		this.itemNavigatorController.refresh.call(this.itemNavigatorController);
	},
	populateFieldExpressions: function(scope, massOperationMainPanel, data) {
		if (massOperationMainPanel) {
			var massOperationPanels = [{
				xtype: 'component',
				cls:"infoBox_bottomBorder",
				border:true,
				html: getText("itemov.massOperation.lbl.numberOfSelectedIssues") + '&nbsp;'+data['numberOfSelectedIssues']
			}];
			if (this.getCopy()) {
				var labelWidth=175;
				var width=labelWidth+25;
				var enableCopyAttachments = true;//data['enableCopyAttachments'];
				var enableCopyChildren = true;//data['enableCopyChildren'];
				massOperationPanels.push({
					xtype:'panel',
					border:false,
					bodyBorde:false,
					anchor:'100%',
					margin:'5 5 5 5',
					//height:30,
					layout:'hbox',
					items:[
						CWHF.createCheckbox("itemov.massOperation.lbl.copyHistory", "deepCopy",{labelWidth:labelWidth,width:width}),
						CWHF.createCheckbox("itemov.massOperation.lbl.copyAttachments",
							"copyAttachments", {disabled:!enableCopyAttachments,labelWidth:labelWidth,width:width}),
						CWHF.createCheckbox("itemov.massOperation.lbl.copyChildren",
							"copyChildren", {disabled:!enableCopyChildren,labelWidth:labelWidth,width:width}),
						CWHF.createCheckbox("itemov.massOperation.lbl.copyWatchers",
							"copyWatchers", {labelWidth:labelWidth,width:width}, {change: {fn: this.changeCopyWatchers,
								scope:this}})
					]
				});
			}
			var massOperationExpressions = data['expressions'];
			if (massOperationExpressions) {
				for(var i=0;i<massOperationExpressions.length;i++){
					var expression=massOperationExpressions[i];
					var cls='massOperationPanel';
					if(i%2===1){
						cls="massOperationOddPanel";
					}
					var expressionPanel = this.createMassOperationExpression(scope,
							expression, massOperationMainPanel,cls);
					//massOperationMainPanel.add(expressionPanel);
					massOperationPanels.push(expressionPanel);
				}
				//add all panels at once
				massOperationMainPanel.add(massOperationPanels);
			}
		}
	},
	changeCopyWatchers: function(checkboxField, newValue, oldValue, options) {
		var consultedPanel = this.formEdit.getComponent("expressionPanel-1");
		if (consultedPanel) {
			var consultedCheckBox = consultedPanel.getComponent("selectedFieldItemIdpseudoField1");
			if (consultedCheckBox) {
				consultedCheckBox.setDisabled(newValue);
				if (newValue===true) {
					this.changeFieldSelection(consultedCheckBox, false, true, {panel:consultedPanel, field:"-1"})
				} else {
					this.changeFieldSelection(consultedCheckBox, consultedCheckBox.getValue(), false, {panel:consultedPanel, field:"-1"})
				}
			}
		}
		var informedPanel = this.formEdit.getComponent("expressionPanel-2");
		if (informedPanel) {
			var informedCheckBox = informedPanel.getComponent("selectedFieldItemIdpseudoField2");
			if (informedCheckBox) {
				informedCheckBox.setDisabled(newValue);
				if (newValue===true) {
					this.changeFieldSelection(informedCheckBox, false, true, {panel:informedPanel, field:"-2"})
				} else {
					this.changeFieldSelection(informedCheckBox, informedCheckBox.getValue(), false, {panel:informedPanel, field:"-2"})
				}
			}
		}
	},
	createMassOperationHeader: function() {
		return Ext.create("Ext.panel.Panel", {
			border:false,
			defaults: {margin:"4 4 0 0"},
			layout: {
				type:'hbox'
				},
			items: [{
				xtype: 'label',
				html: getText("itemov.massOperation.lbl.active"),
				width: 80
			}, {
				xtype: 'displayfield',
				fieldLabel: getText("itemov.massOperation.lbl.fieldName"),
				width:300,
				labelWidth:90,
				labelAlign:'right',
				value: getText("itemov.massOperation.lbl.action")
			}, {
				xtype: 'label',
				html: getText("itemov.massOperation.lbl.fieldValue"),
				width: 200
			}]
		});
	},
	/**
	 * Create a simple filter expression
	 */
	createMassOperationExpression: function(scope, bulkExpression, massOperationMainPanel,cls) {
		var expressionPanel = Ext.create("Ext.panel.Panel", {
			itemId: "expressionPanel" + bulkExpression["field"],
			border:false,
			bodyBorder:false,
			cls:cls,
			layout: {
				type:'hbox',
				pack: 'start',
				align: 'top'//'stretch'
			}
		});
		var fieldSelection = CWHF.createCheckbox(null, bulkExpression["fieldName"], {itemId:bulkExpression["fieldItemId"], margin:'0 0 0 5',width:24,border:true,cls:"massOperationCheck"},
				{change: {fn: this.changeFieldSelection,
					scope:this,
					panel:expressionPanel, field:bulkExpression["field"], massOperationMainPanel:massOperationMainPanel}});
		expressionPanel.add(fieldSelection);
		var disabled = true;
		var jsonConfig = bulkExpression["jsonConfig"];
		if (jsonConfig && jsonConfig.disabled) {
			disabled = jsonConfig.disabled;
		}
		var setterCombo = CWHF.createCombo(bulkExpression["fieldLabel"],
				bulkExpression["relationName"],
				{	itemId: bulkExpression["relationItemId"],
					disabled:disabled,
					width:350,
					data:bulkExpression["setterRelations"],
					value:bulkExpression["selectedRelation"],
					labelWidth:150,
					margin:'2 5 2 5',
					labelIsLocalized:true
				},
				{select: {fn: this.changeSetter, scope:scope,
					panel:expressionPanel, bulkExpression:bulkExpression}});
		expressionPanel.add(setterCombo);
		this.addValuePart(scope, bulkExpression.valueRenderer, bulkExpression.jsonConfig, bulkExpression, expressionPanel, false);
		return expressionPanel;
	},
	getComponentItemID: function(baseName, field) {
		if (field>0) {
			return baseName + "field" + field;
		} else {
			return baseName + "pseudoField" + Math.abs(field);
		}
	},
	changeFieldSelection: function(checkboxField, newValue, oldValue, options) {
		var projectIDs = null;
		var expressionPanel = options.panel;
		var field = options.field;
		var setterCombo = expressionPanel.getComponent(this.getComponentItemID("setterRelationItemId",field));
		if (setterCombo) {
			setterCombo.setDisabled(!newValue);
		}
		var valuePart = expressionPanel.getComponent(this.getComponentItemID("valueItemID",field));
		if (valuePart) {
			valuePart.setDisabled(!newValue);
		}
		if (field===1 || field===2) {
			var params = new Object();
			if (field===1) {
				params["projectRefresh"] = true;
				if (newValue) {
					//get the submit value not the visible label value
					params["projectID"] = valuePart.getSubmitValue();
				}
				this.refreshContext(expressionPanel, params, field/*, newValue*/);
			} else {
				if (field===2) {
					params["issueTypeRefresh"] = true;
					if (newValue) {
						params["issueTypeID"] = valuePart.getValue();
					}
					this.refreshContext(expressionPanel, params, field/*, false*/);
				}
			}
		}
		if (field===19 || field===20 || field===29 || field===30) {
			//disable opposite date
			var massOperationMainPanel = options.massOperationMainPanel;
			if (massOperationMainPanel) {
				var adjustValue = false;
				var datePanel = massOperationMainPanel.getComponent('expressionPanel' + field);
				if (datePanel) {
					var valuePart = expressionPanel.getComponent(this.getComponentItemID("valueItemID", field));
					if (valuePart) {
						adjustValue = valuePart.getAdjustCheckBoxValue();
						if (adjustValue) {
							var oppositeDateField = null;
							if (field===19) {
								oppositeDateField = 20;
							} else {
								if (field===20) {
									oppositeDateField = 19;
								} else {
									if (field===29) {
										oppositeDateField = 30;
									} else {
										if (field===30) {
											oppositeDateField = 29;
										}
									}
								}
							}
							var oppositeDatePanel = massOperationMainPanel.getComponent('expressionPanel' + oppositeDateField);
							if (oppositeDatePanel) {
								var oppositeFieldCheckBox = oppositeDatePanel.getComponent(this.getComponentItemID("selectedFieldItemId", oppositeDateField));
								if (oppositeFieldCheckBox) {
									var oppositeFieldCheckBoxDisabled = false;
									if (!newValue) {
										oppositeFieldCheckBoxDisabled = false;
									} else {
										oppositeFieldCheckBoxDisabled = adjustValue;
									}
									oppositeFieldCheckBox.setDisabled(oppositeFieldCheckBoxDisabled);
									var setterCombo = oppositeDatePanel.getComponent(this.getComponentItemID("setterRelationItemId", oppositeDateField));
									if (setterCombo) {
										setterCombo.setDisabled(oppositeFieldCheckBoxDisabled || !oppositeFieldCheckBox.getValue());
									}
									var valuePart = oppositeDatePanel.getComponent(this.getComponentItemID("valueItemID", oppositeDateField));
									if (valuePart) {
										valuePart.setDisabled(oppositeFieldCheckBoxDisabled || !oppositeFieldCheckBox.getValue());
									}
								}
							}
						}
					}
				}
			}
		}
	},
	refreshContext: function(expressionPanel, params, field) {
		var mainPanel = expressionPanel.ownerCt;
		if (field===1) {
			params["issueTypeID"] = this.getContextField(mainPanel, 2);
		} else {
			if (field===2) {
				params["projectID"] = this.getContextField(mainPanel, 1)
			}
		}
		params["selectedIssueIDs"] = this.getSelectedIssueIDs();
		mainPanel.setLoading(true);
		Ext.Ajax.request({
			url: "massOperationEdit.action",
			params: params,
			scope: this,
			disableCaching:true,
			success: function(response) {
				var responseJson = Ext.decode(response.responseText);
				massOperationExpressions = responseJson.data["expressions"];
				if (mainPanel) {
					mainPanel.setLoading(false);
					if (massOperationExpressions) {
						var projectPanel = mainPanel.getComponent("expressionPanel1");
						var projectFieldWasSelected = false;
						if (projectPanel) {
                             var fieldNameCheckbox = projectPanel.getComponent("selectedFieldItemIdfield1");
                             if (fieldNameCheckbox) {
                            	 projectFieldWasSelected = fieldNameCheckbox.getValue();
                             }
						}
						var releaseNoticedFound = false;
						var releaseScheduledFound = false;
						Ext.Array.forEach(massOperationExpressions, function(expression, ind) {
							var field = expression.field;
							if (field===8) {
								releaseNoticedFound = true;
							} else {
								if (field===9) {
									releaseScheduledFound = true;
								}
							}
							var disabled = expression.jsonConfig["disabled"];
							var expressionPanel = mainPanel.getComponent("expressionPanel" + field);
                            if (expressionPanel) {
                            	//the field existed before context refresh
                                var selectedFieldItemId = expression["fieldItemId"];
                            	var fieldNameCheckbox = expressionPanel.getComponent(selectedFieldItemId);
                            	if (fieldNameCheckbox) {
                            		if (this.isRelease(field)) {
                            			//for releases enforce the server side disabled
                            			fieldNameCheckbox.setDisabled(projectFieldWasSelected);
                            			//do not trigger listeners
                            			fieldNameCheckbox.setRawValue(!disabled);
                            			var setterRelationItemId = expression["relationItemId"];
    	                                var setterRelationCombo = expressionPanel.getComponent(setterRelationItemId);
    	                                if (setterRelationCombo) {
    	                                	setterRelationCombo.setDisabled(disabled);
    	                                }
                            		} else {
                            			//only the datasources should be refreshed for non release dependences (the field selections should not be modified after project change)  
                                    	//leave the field's previous disabled status
                            			disabled = !fieldNameCheckbox.getValue();
                            		}
                            	}
	                            var valueComponentItemId = expression.valueItemId;
                                var valueComponent = expressionPanel.getComponent(valueComponentItemId);
                                //var oldDisabled = null;
                                if (valueComponent) {
                                	//the value will not be removed from Ext.form.Basic only from the UI
                                    //workaround: set the fields to disabled to not to be submitted then remove the component
                                    valueComponent.setDisabled(true);
                                    expressionPanel.remove(valueComponent);
                                }
                                if (expression.valueRenderer) {
                                    this.addValuePart(this, expression.valueRenderer, expression.jsonConfig, expression, expressionPanel, true, disabled);
                                }
                            } else {
                            	//the field is new exists only in the new context (project)
                                var issueType = mainPanel.getComponent("expressionPanel2");
                                if (issueType) {
                                    var index = mainPanel.items.indexOf(issueType);
                                    if (index) {
                                    	if (field!==8 && field!==9) {
                                    		//releases before item type, other dependent lists after item type
                                    		index = index+1;
                                    	}
                                        mainPanel.insert(index, this.createMassOperationExpression(this, expression, mainPanel, null));
                                    } else {
                                        mainPanel.add(this.createMassOperationExpression(this, expression, mainPanel, null));
                                    }
                                } else {
                                    mainPanel.add(this.createMassOperationExpression(this, expression, mainPanel, null));
                                }
                                var expressionPanel = mainPanel.getComponent("expressionPanel" + field);
                                if (expressionPanel) {
                                    var selectedFieldItemId = expression["fieldItemId"];
                                    var fieldNameCheckbox = expressionPanel.getComponent(selectedFieldItemId);
                                    fieldNameCheckbox.setDisabled(projectFieldWasSelected);
                                    fieldNameCheckbox.setValue(!disabled);
                                }
                            }
						}, this);
						//remove the release fields if they are not defined in the new project
						if (!releaseNoticedFound) {
							var expressionPanel = mainPanel.getComponent("expressionPanel8");
							if (expressionPanel) {
								mainPanel.remove(expressionPanel);
							}
						}
						if (!releaseScheduledFound) {
							var expressionPanel = mainPanel.getComponent("expressionPanel9");
							if (expressionPanel) {
								mainPanel.remove(expressionPanel);
							}
						}
					}
				}
			},
			failure: function(result){
				mainPanel.setLoading(false);
				Ext.MessageBox.show({
					title: this.failureTitle,
					msg: result.responseText,
					buttons: Ext.Msg.OK,
					icon: Ext.MessageBox.WARNING
				})
			},
			method:"POST"
		});
	},
	getContextField: function(mainPanel, fieldID) {
		var fieldComponent = this.getFieldComponent(mainPanel, fieldID);
		if (fieldComponent && !fieldComponent.isDisabled()) {
			return fieldComponent.getValue();
		}
		return null;
	},
	getFieldComponent: function(mainPanel, fieldID) {
		var contextPanel = mainPanel.getComponent("expressionPanel" + fieldID);
		if (contextPanel) {
			return contextPanel.getComponent(this.getComponentItemID("valueItemID", fieldID));
		}
		return null;
	},
	isRelease: function(field) {
		 return field===8 || field===9
	},
	/**
	 * Reload the value part of a bulk expression after changing the setter
	 * or after changing any or the composite select part
	 */
	changeSetter: function(combo, records, options) {
		var fieldID = options.bulkExpression.field;
		var valueComponentItemId = options.bulkExpression.valueItemId;
		var valueComponent = options.panel.getComponent(valueComponentItemId);
		var value = null;
		if (valueComponent) {
			value = valueComponent.getFieldValueJson();
		}
		var relationID = combo.getValue();
		var params = value;
		if (CWHF.isNull(value)) {
			params = new Object();
		}
		params["fieldID"] = fieldID;
		params["relationID"] = relationID;
		params["issueTypeID"] = this.getContextField(combo.ownerCt.ownerCt, 2);
		params["projectID"] = this.getContextField(combo.ownerCt.ownerCt, 1);
		params["selectedIssueIDs"] = this.getSelectedIssueIDs();
		Ext.Ajax.request({
			url: "massOperationFieldSetterAction.action",
			params: params,
			scope: this,
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (valueComponent) {
					//the value will not be removed from Ext.form.Basic only from the UI
					//workaround: set the fields to disabled to not to be submitted then remove the component
					valueComponent.setDisabled(true);
					options.panel.remove(valueComponent, true);
				}
				if (responseJson.valueRenderer && responseJson.valueRenderer!=="") {
					options.bulkExpression.valueRenderer = responseJson.valueRenderer;
					this.addValuePart(this, responseJson.valueRenderer, responseJson.jsonConfig,
						options.bulkExpression, options.panel, false);
				}
			},
			failure: function(result){
				Ext.MessageBox.show({
					title: this.failureTitle,
					msg: result.responseText,
					buttons: Ext.Msg.OK,
					icon: Ext.MessageBox.WARNING
				})
			},
			method:"POST"
		});
	},
	/**
	 * Configures and adds the value part (the dynamic part) to the filter expressions by first rendering of
	 * simple or "in tree" field expressions and after changing the matcher or the field
	 */
	addValuePart: function(scope, valueRenderer, jsonConfig, bulkExpression, expressionPanel, contextRefresh, oldDisabled) {
		if (bulkExpression.valueRenderer && bulkExpression.valueRenderer!=="") {
			if (jsonConfig) {
				jsonConfig.scope=scope;
				jsonConfig.selectedIssueIDs = this.getSelectedIssueIDs();
				var valueControlConfig = {
						jsonData:jsonConfig,
						margin:'2 0 2 0',
						fieldID: bulkExpression.field,
						itemId: bulkExpression.valueItemId,
						relationItemId: bulkExpression.relationItemId
				};
				var valueControl = Ext.create(valueRenderer, valueControlConfig);
				if (!this.isRelease(bulkExpression.field) && contextRefresh) {
					//overwrite the server side disabled
					valueControl.setDisabled(oldDisabled);
				}
				valueControl.scope = scope;
				expressionPanel.add(valueControl);
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.issue.Link',{
	extend:'Ext.Base',
	config: {
        itemNavigatorController: null,
		workItemIDs: null,
		fromGantt: false,
		ganttController: null,
		dependencyType: null,
		crossProject: null
	},
	constructor: function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		me.initConfig(config);
	},
	/**
	 * Executes a report from issue navigator: first choose report then render configuration (if needed)
	 */
	addLinkFromIssueNavigator:function() {
		var me = this;
		var load = {loadUrl:"itemLink!editItemLink.action", loadUrlParams: {fromGantt:this.fromGantt}};
		var submitUrlParams = {workItemIDs: this.workItemIDs, fromGantt: this.fromGantt, crossProject: this.crossProject};
		var submit = null;
		if(me.ganttController ) {
			submit = {submitHandler: me.ganttSpecialSubmitHandler, refreshAfterSubmitHandler: this.refreshAfterSubmitOrCancelHandler, submitButtonText:getText('common.btn.save'), submitUrlParams:submitUrlParams};
		}else {
			submit = {specialSubmitFailHandler:this.submitFailHandler, refreshAfterSubmitHandler:this.refresh, submitUrl:"itemLink!saveLinkFromIssueNavigator.action", submitUrlParams:submitUrlParams,
					submitButtonText:getText('common.btn.save')};
		}
		var windowParameters = {title:getText("itemov.link.title"),
				width:600,
				height:300,
				load:load,
				submit: submit,
				items: this.getLinkPanelItems(),
//				isFormPanel:false,
				refreshAfterCancel: true,
				postDataProcess:this.postDataLoadCombos};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		this.windowConfig = windowConfig;
		windowConfig.showWindowByConfig(this);
	},
	refreshAfterSubmitOrCancelHandler:function() {
		var me = this;
		if(me.fromGantt === true) {
			me.ganttController.removeLastAddedDependency();
		}
	},
	refresh:function(scope, result, submit) {
		var me = this;
		if (this.itemNavigatorController) {
			this.itemNavigatorController.refresh.call(this.itemNavigatorController);
		}
	},
	loadFailHandler:function() {
		var me = this;
		if(me.fromGantt === true) {
			me.ganttController.removeLastAddedDependency();
		}
	},
	ganttSpecialSubmitHandler: function() {
		var me = this;
		var formValues = this.windowConfig.formPanel.getValues();
		var newLinkProperties = {};
		newLinkProperties.description = formValues.description;
		newLinkProperties.linkTypeWithDirection = formValues.linkTypeWithDirection;
		newLinkProperties.linkType = formValues["parametersMap['DependencyType']"];
		newLinkProperties.lag = formValues["parametersMap['Lag']"];
		newLinkProperties.lagUnit = formValues["parametersMap['Lagformat']"];
		me.ganttController.adjustNewlyCreatedLink(newLinkProperties);
		this.windowConfig.win.close();
	},
	submitFailHandler:function(result) {
		var me = this;
		if(me.fromGantt === true) {
			me.ganttController.removeLastAddedDependency();
		}
	},
	postDataLoadCombos: function(data, panel) {
		var linkTypeWithDirection = panel.getComponent("linkTypeWithDirection");
		if (linkTypeWithDirection) {
			linkTypeWithDirection.store.loadData(data["linkTypesList"]);
			linkTypeWithDirection.setValue(data["linkTypeWithDirection"]);
		}
        this.replaceSpecificPart(panel, data["linkTypeJSClass"], data["specificData"]);
        if(this.dependencyType ) {
        	var dependencyCombo = panel.getComponent("specificPart");
        	dependencyCombo.items.items[0].setValue(this.getDependencyComboValueFromGanttValue(this.dependencyType));
        	dependencyCombo.items.items[0].setReadOnly(true);
        }
        if(data.linkTypesList.length === 0) {
        	this.loadFailHandler();
        }
	},
	getDependencyComboValueFromGanttValue: function(type) {
		switch(type) {
			case 0:
				return 3;
				break;
			case 1:
				return 2;
				break;
			case 2:
				return 1;
				break;
			case 3:
				return 0;
				break;
			default:
				return 0;
		}
	},
	getLinkPanelItems:function(){
		var linkTypeCombo = CWHF.createCombo("itemov.link.type", "linkTypeWithDirection",
				{labelWidth:150, anchor:'100%', idType:"string", allowBlank:false}, {select:{fn:this.selectLinkType, scope:this}});
		var descriptionText = CWHF.createTextAreaField("item.tabs.itemLink.lbl.comment", "description",
				{height:125, anchor:'100%', labelWidth:150});
		return [linkTypeCombo, descriptionText];
	},
	selectLinkType: function(combo, records, options) {
		Ext.Ajax.request({
			url:"itemLink!getSpecificPart.action",
			params:{"linkTypeWithDirection":combo.getValue()},
			disableCaching:true,
			scope: this,
			success: function(response, opts){
				var responseJson = Ext.decode(response.responseText);
				this.replaceSpecificPart(combo.ownerCt, responseJson["linkTypeJSClass"], responseJson["specificData"]);
			},
			failure: function(response, opts) {
			},
			method:'POST'
		});
	},
	/**
	 * Add the field type specific configuration
	 */
	replaceSpecificPart: function(panel, specificLinkTypeClass, specificData) {
		var specificPart = panel.getComponent("specificPart");
		if (specificPart) {
            specificPart.setDisabled(true);
			panel.remove(specificPart, true);
		}
		if (specificLinkTypeClass) {
			var specificPart = Ext.create(specificLinkTypeClass,{
				margin:'0 5 5 0'
			});
			if (specificPart) {
				panel.insert(1, specificPart);
				specificData["labelWidth"] = 100;
				specificPart.onDataReady(specificData);
				panel.updateLayout();
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.itemNavigator.ItemNavigatorController',{
	extend:'Ext.Base',
	mixins:{
		navigable:'com.trackplus.itemNavigator.TreeNavigableItem'
	},
	config: {
		model:null,
		useLastQuery:true,
		baseAction:'itemNavigator',
		skipEmptyNodeType:false,
		nodeType:null,
		nodeObjectID:null,
		workItemID:null,
		actionID:null,
		settingsVisible:false,
		filterEditVisible:false
	},
	view:null,
	filterController:null,
	selectedIssueViewDescriptor:null,
	selectedIssueViewDescriptorStandard:null,
	issueListFacade:null,
	selectedExtraAction:null,
	subDialogForExcelWizard:null,
	//apply filter from navigator upper area
	fromSession: false,
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		this.mixins.navigable.constructor.call(this,config);
	},
	test:function() {
	},
	createView:function(){
		var me=this;
		me.selectedIssueViewDescriptor=me.findView(me.model.lastSelectedView);
		me.selectedIssueViewDescriptorStandard=me.findView(me.model.lastSelectedViewPerson);
		me.filterEditPanel=Ext.create('Ext.panel.Panel', {
			region:'north',
			margins: '0 0 0 0',
			border: false,
			bodyBorder:false,
			hidden:!me.filterEditVisible,
			split:true,
			stateful:true,
			stateId:'itemNavigator_filterEdit',
			height:200,
			layout:'fit'
		});
		me.issueViewPanel=Ext.create('Ext.panel.Panel',{
			region:'center',
			margins: '0 0 0 0',
			border: false,
			bodyBorder:false,
			layout:'fit'
		});
		me.view=Ext.create('Ext.panel.Panel',{
			region:'center',
			margins: '0 0 0 0',
			border: false,
			bodyBorder:false,
			baseCls:'itemNavigator',
			layout:'border',
			bodyStyle:{
				padding:'0px 0px 0px 0px'
			},
			items:[me.filterEditPanel,me.issueViewPanel]
		});
		//me.initIssueListViewToolbar();
		me.updateSelectedIssueListView(true);
		return me.view;
	},
	updateSelectedIssueListView:function(createView){
		var me=this;
		var queryContextID=me.model.queryContext.id;
		var filterType=me.model.queryContext.queryType;
		var filterID=me.model.queryContext.queryID;
		var filterName=me.model.queryContext.queryName;
		var viewID = me.selectedIssueViewDescriptor.id;
		if(CWHF.isNull(this.fromSession)||this.fromSession===false){
			if(me.useLastQuery) {
				var instantFilter = Ext.create("com.trackplus.itemNavigator.InstantFilter",
						{filterName: filterName,
						filterType: filterType,
						filterID:filterID,
						queryContextID:queryContextID,
						viewID:viewID,
						fromSession:this.fromSession});
				me.filterEditPanel.removeAll(true);
				me.filterEditPanel.add(instantFilter.createPanel());
				instantFilter.addListener("applyFilter",me.onApplyFilter,me);
				instantFilter.addListener("clearFilter",me.onClearFilter,me);
				instantFilter.loadFilter.call(instantFilter);
			}
		}
		if(me.model.tooManyItems){
			me.issueViewPanel.removeAll(true);
			var pan=Ext.create('Ext.Component',{
				html:getText('itemov.err.tooManyItems'),
				border:false,
				cls:'infoBox1'
			});
			me.issueViewPanel.add(pan);
			me.view.updateLayout ();
			return true;
		}
		if(createView===true||CWHF.isNull(me.issueListFacade)){
			me.createIssueListView();
		}else{
			me.issueListFacade.refreshData.call(me.issueListFacade,me.model.issues);
		}
	},
	createIssueListView:function(){
		var me=this;
		if(me.issueListFacade){
			me.issueListFacade.destroy.call(me.issueListFacade);
			me.issueListFacade=null;
			delete me.issueListFacade;
		}
		me.issueListFacade=Ext.create('com.trackplus.itemNavigator.IssueListViewFacade',{
			descriptor:me.selectedIssueViewDescriptor,
			model:me.model,
			queryContext:me.model.queryContext,
			itemNavigatorController:me
		});
		me.issueViewPanel.removeAll(true);
		var pan=me.issueListFacade.createView.call(me.issueListFacade,me.model,me.settingsVisible);
		me.issueViewPanel.add(pan);
		me.view.updateLayout ();
		if(pan.getEl()) {
			me.onReadyHandler();
		}else {
			pan.addListener('render',me.onReadyHandler,me);
		}
	},
	onApplyFilter:function(queryCtx){
		var me=this;
		var filterType=queryCtx.filterType;
		var filterID=queryCtx.filterID;
		this.fromSession=true;
		me.refresh(null,null,true,null);
	},
	onClearFilter:function(queryCtx){
		var me=this;
		var filterType=queryCtx.filterType;
		var filterID=queryCtx.filterID;
		this.fromSession=false;
	},
	/**
	 * This method initialize external drag drop functionality for
	 * all item navigator views.
	 */
	onReadyHandler: function() {
		var me = this;
		if(me.model.showDragDropInfoMsg) {
			CWHF.showMsgInfo(getText('itemov.lbl.dragDropInfoText'), false);
		}
		me.dragCounter = 0;
		var viewDrop=me.issueListFacade.view;
		var domEl=viewDrop.getEl().dom;
		me.highLightPanel = new Ext.Panel({
			width: 500,
			height: 500,
		    bodyCls:'itemNavigatorViewHighlightWhenDrag',
		    hidden: true
		  });
		viewDrop.insert(me.highLightPanel);
		domEl.addEventListener("dragenter", function(evt){
			evt.stopPropagation();
			evt.preventDefault();
			var mouseX=parseInt(evt.clientX);
			var mouseY=parseInt(evt.clientY);
			var winX=mouseX-150;
			if(winX<10){
				winX=10;
			}
			me.dragCounter++;
			if(!me.highLightPanel.isVisible()) {
				me.highLightPanel.setWidth(me.view.lastBox.width);
				me.highLightPanel.setHeight(me.view.lastBox.height);
				me.highLightPanel.setVisible(true);
			}
//			viewDrop.addCls("itemNavigatorViewHighlightWhenDrag");
		}, false);
		domEl.addEventListener("dragleave",  function(evt){
			evt.stopPropagation();
			me.dragCounter--;
			if (Ext.isChrome || Ext.isSafari || Ext.isIE) {
				if(me.dragCounter=== 0) {
					me.highLightPanel.setVisible(false);
				}
			}else {
				me.highLightPanel.setVisible(false);
			}
//			viewDrop.removeCls("itemNavigatorViewHighlightWhenDrag");
		}, false);
		domEl.addEventListener("dragover",  function(evt){
			evt.stopPropagation();
			evt.preventDefault();
//			me.highLightPanel.setVisible(true);
		}, false);
		domEl.addEventListener("drop",  function(evt){
			evt.stopPropagation();
			evt.preventDefault();
//			viewDrop.removeCls("itemNavigatorViewHighlightWhenDrag");
			me.highLightPanel.setVisible(false);
			var files = evt.dataTransfer.files;
			if(files.length === 1) {
				var importExcelWizard = Ext.create('com.trackplus.admin.action.ImportExcel');
				var importMsProjPopUpWiz = 	Ext.create('com.trackplus.admin.action.ImportMsProject', {projectID:null});
				var file = null;
				if(files  && files.length > 0){
					file = files[0];
				}
				if(importExcelWizard.validateFileExtension(file.name)) {
					importExcelWizard.createPopUpDialog(files, me);
				}
				if(importMsProjPopUpWiz.validateFileExtension(file.name)) {
					importMsProjPopUpWiz.createPopUpDialog(files);
				}
			}
		}, false);
	},
	createNavigator:function(){
		var me=this;
		me.filterController=Ext.create('com.trackplus.itemNavigator.FilterController',{
			model:me.model.navigator,
			queryContext:me.model.queryContext,
			skipEmptyNodeType:me.skipEmptyNodeType,
			lastSelectedNavigator:me.model.lastSelectedNavigator,
			itemNavController:me
		});
		return me.filterController.createView.call(me.filterController);
	},
	issueSelectionChange:function(selections){
		var btnMassEdit=Ext.getCmp("massEdit");
		var btnMassCopy=Ext.getCmp("massCopy");
		var btnAddLink=Ext.getCmp("addLink");
		btnMassEdit.setDisabled(CWHF.isNull(selections)||selections.length===0);
		btnMassCopy.setDisabled(CWHF.isNull(selections)||selections.length===0);
		btnAddLink.setDisabled(CWHF.isNull(selections)||selections.length<2);
	},
	showGroupByPopup:function(){
		var me = this;
		var groupingDialog = Ext.create("com.trackplus.itemNavigator.Grouping",{
			filterType:me.model.queryContext.queryType,
			filterID:me.model.queryContext.queryID,
			itemNavigatorController:me
		});
		groupingDialog.showDialog();
		/*var me=this;
		if(me.grouping){
			me.grouping.destroyMe.call(me.grouping);
		}
		me.grouping=new com.trackplus.itemNavigator.Grouping(me);
		me.grouping.show.call(me.grouping);*/
	},
	showColumnsPopup:function(){
		var me=this;
		var includeLongFields=false;
		var selView=me.selectedIssueViewDescriptor;
		if(selView){
			includeLongFields=selView.useLongFields;
		}
		if(me.chooseColumns){
			me.chooseColumns.destroyMe.call(me.chooseColumns);
		}
		me.chooseColumns=Ext.create('com.trackplus.itemNavigator.ChooseColumns',{
			itemNavigatorController:me,
			filterType:me.model.queryContext.queryType,
			filterID:me.model.queryContext.queryID,
			includeLongFields:includeLongFields
		});
		me.chooseColumns.setIncludeLongFields(includeLongFields);
		me.chooseColumns.showDialog.call(me.chooseColumns);
	},
	changeLayout:function(){
		var me=this;
		var selView=me.selectedIssueViewDescriptor;
		me.selectedIssueViewDescriptor=null;
		me.changeIssueListViewMode(selView,null,true);
	},
	sortChange:function(sort){
		var me=this;
		me.model.layout.sortField=sort.sortField;
		me.model.layout.sortOrder=sort.sortOrder;
		me.model.layout.sortWithSOr=sort.sortWithSO;
	},
	/*appendDashboardParams:function(params){
	 var me=this;
	 if(me.model.dashboardParams){
	 for(var x in me.model.dashboardParams){
	 params['dashboardParams.'+x]=me.model.dashboardParams[x];
	 }
	 }
	 },*/
	changeIssueListViewMode:function(issueListViewDescriptor,handler,storeLast){
		var me=this;
		if(me.selectedIssueViewDescriptor){
			if(me.selectedIssueViewDescriptor.id===issueListViewDescriptor.id){
				return false;
			}
		}
		me.selectedIssueViewDescriptor=issueListViewDescriptor;
		if(me.btnListView) {
			me.btnListView.setText(me.selectedIssueViewDescriptor.name);
			me.btnListView.setIconCls(me.selectedIssueViewDescriptor.iconCls);
			me.btnListView.setTooltip(me.selectedIssueViewDescriptor.description);
		}
		var items = [];
		if(issueListViewDescriptor.id==='com.trackplus.itemNavigator.GanttViewPlugin'){
			items.push(me.btnPrintGantt);
		}else {
			items.push(me.btnExportPDF);
		}
		items.push(me.btnExportXLS);
		items.push(me.btnExportCSV);
		items.push(me.btnExportDOCX);
		items.push(me.btnExportXML);
		items.push(me.btnExportTrackplus);
		me.btnExport.menu.removeAll();
		me.btnExport.menu.add(items);
		//var btnGroupByCmp=Ext.getCmp('btnGroupBy');
		//btnGroupByCmp.setVisible(me.selectedIssueViewDescriptor.enabledGrouping);
		//var btnChooseColumnsCmp=Ext.getCmp('btnChooseColumns');
		//btnChooseColumnsCmp.setVisible(me.selectedIssueViewDescriptor.enabledColumnChoose);
		//var separatorGroupColumns=Ext.getCmp('separatorGroupColumns');
		//separatorGroupColumns.setVisible(me.selectedIssueViewDescriptor.enabledGrouping||me.selectedIssueViewDescriptor.enabledColumnChoose);
		me.removeOrAddPrintGanttIntoPDFAfterChange(issueListViewDescriptor);
		if(storeLast){
			me.selectedIssueViewDescriptorStandard=me.selectedIssueViewDescriptor;
			Ext.Ajax.request({
				url: "itemNavigator!storeLastSelectedView.action",
				params:{
					viewID:me.selectedIssueViewDescriptor.id
				},
				success: function(response){
					me.doChangeIssueListViewMode(issueListViewDescriptor,handler,storeLast);
				},
				failure: function(){
					CWHF.showMsgError('Failure');
				}
			});
		}else{
			me.doChangeIssueListViewMode(issueListViewDescriptor,handler,storeLast);
		}
	},
	/**
	 * This method remove or add the Print into pdf menu item depending on selected item navigator view element.
	 */
	removeOrAddPrintGanttIntoPDFAfterChange: function(issueListViewDescriptor) {
		var me = this;
		if(issueListViewDescriptor.id==='com.trackplus.itemNavigator.GanttViewPlugin'){
			var found = false;
			me.btnExtraActions.menu.items.each(function(item){
				if(item.itemId ) {
					if(item.itemId  === 'exportGanttIntoPDFBtn') {
						found = true;
					}
				}
			});
			if(!found) {
				me.btnExtraActions.menu.add(me.btnExportGanttIntoPDF);
			}
		}else {
			me.btnExtraActions.menu.items.each(function(item){
				if(item.itemId ) {
					if(item.itemId  === 'exportGanttIntoPDFBtn') {
						me.btnExtraActions.menu.remove(item);
					}
				}
			});
		}
	},
	doChangeIssueListViewMode:function(issueListViewDescriptor,handler,storeLast){
		var me=this;
		if(handler){
			handler.call(me);
		}else{
			var urlStr="itemNavigator!reload.action";
			me.refresh(urlStr,me.model.queryContext.id,true);
		}
	},
	createLastQueriesMenu:function(lastQueries){
		var me=this;
		var menu=[];
		if(lastQueries){
			for(var i=0;i<lastQueries.length;i++){
				menu.push(me.createQueryMenu(lastQueries[i]/*.id,lastQueries[i].label*/));
			}
		}
		return Ext.create('Ext.menu.Menu',{items:menu});
	},
	updateMyItemNavigatorModel:function(jsonData){
		var me=this;
		if(jsonData.layout){
			me.model.layout=jsonData.layout;
		}else{
		}
		me.model.issues=jsonData.issues;
		me.model.isFilterView=jsonData.isFilterView;
		me.model.maySaveFilterLayout=jsonData.maySaveFilterLayout;
		me.model.summaryItemsBehavior=jsonData.summaryItemsBehavior;
		me.model.tooManyItems=jsonData.tooManyItems;
		me.model.listViewData=jsonData.listViewData;
		me.model.milestoneWorkitems=jsonData.milestoneWorkitems;
		me.model.totalCount=jsonData.totalCount;
		me.model.forceAllItems=jsonData.forceAllItems===true;
		me.model.overflowItems=jsonData.overflowItems;
		me.model.holidays=jsonData.holidays;
		me.model.localizedToolTipLabels=jsonData.localizedToolTipLabels;
		me.model.count=jsonData.count;
		me.model.lastQueries=jsonData.lastQueries;
		me.model.queryContext=com.trackplus.itemNavigator.ItemNavigatorFacade.createQueryContext(jsonData.queryContext);
		me.model.queryFieldCSS=jsonData.queryFieldCSS;
		me.model.isActiveTopDownDate=jsonData.isActiveTopDownDate;
		me.model.showBaseline=jsonData.showBaseline;
		me.model.validateRelationships=jsonData.validateRelationships;
		me.model.showDragDropInfoMsg=jsonData.showDragDropInfoMsg;
		me.model.showBoth=jsonData.showBoth;
		me.model.highlightCriticalPath=jsonData.highlightCriticalPath;
		me.model.nodeType=me.nodeType;
		me.model.nodeObjectID=me.nodeObjectID;
		me.model.isPrintItemEditable=jsonData.isPrintItemEditable;
		com.trackplus.itemNavigator.ItemNavigatorFacade.updateCssRules(jsonData.queryFieldCSS,jsonData.cssRules);
	},
	refresh:function(urlStr,queryContextID,createView,handlerRefresh){
		//TODO FIXME remove this
		createView=true;
		borderLayout.setLoading(true);
		var me=this;
		if(CWHF.isNull(urlStr)){
			urlStr=me.getBaseAction()+'!refresh.action';
		}
		if(CWHF.isNull(queryContextID)){
			queryContextID=me.model.queryContext.id;
		}
		var params={
			queryContextID:queryContextID,
			nodeType:me.nodeType,
			nodeObjectID:me.nodeObjectID,
			forceAllItems:me.model.forceAllItems,
			fromSession:this.fromSession
		};
		//me.appendDashboardParams.call(me,params);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				borderLayout.setLoading(false);
				me.refreshSuccessHandler.call(me,result,createView,handlerRefresh);
			},
			failure: function(){
				borderLayout.setLoading(false);
				CWHF.showMsgError('Failure');
			},
			method:'POST',
			params:params
		});
	},
	refreshSuccessHandler:function(result,createView,handlerRefresh){
		//TODO FIXME remove this
		createView=true;
		var me=this;
		var jsonData=Ext.decode(result.responseText);
		if(jsonData.success===false){
			CWHF.showMsgError(jsonData.errorMessage);
			return false;
		}
		me.updateMyItemNavigatorModel(jsonData.data);
		me.updateTotalCount();
		me.updateLastExecutedQueries();
		me.updateSelectedIssueListView(createView===true);
		borderLayout.setLoading(false);
		if(handlerRefresh){
			handlerRefresh.call(me);
		}
		me.issueListFacade.addOrRemoveSaveButton(null);
	},
	filterByNodeType:function(nodeData){
		var me=this;
		var nodeObjectID=nodeData.objectID;
		var nodeType=nodeData.nodeType;
		var useFilter=nodeData.useFilter;
		var filterViewID=nodeData.filterViewID;
		if(me.nodeType===nodeType&&me.nodeObjectID===nodeObjectID){
			return false;
		}
		if(me.btnListView){
			me.btnListView.setDisabled(false);
		}
		if(filterViewID&&filterViewID!==''){
			if(me.btnListView){
				me.btnListView.setDisabled(true);
			}
			if(me.selectedIssueViewDescriptor.id!==filterViewID){
				me.nodeType=nodeType;
				me.nodeObjectID=nodeObjectID;
				me.changeIssueListViewMode(me.findView(filterViewID),function(){
					me.doFilterByNode(nodeType,nodeObjectID,useFilter);
				},false);
				return true;
			}
		}else{
			if(me.selectedIssueViewDescriptorStandard&&me.selectedIssueViewDescriptorStandard.id!==me.selectedIssueViewDescriptor.id){
				me.nodeType=nodeType;
				me.nodeObjectID=nodeObjectID;
				me.changeIssueListViewMode(me.selectedIssueViewDescriptorStandard,function(){
					me.doFilterByNode(nodeType,nodeObjectID,useFilter);
				},true);
				return true;
			}
		}
		me.doFilterByNode(nodeType,nodeObjectID,useFilter);
	},
	clearSubfilter:function(){
		var me=this;
		me.doFilterByNode(null,null,null);
	},
	doFilterByNode:function(nodeType,nodeObjectID,useFilter){
		var me=this;
		me.fromSession = false;
		var urlStr=me.getBaseAction()+"!filterByNode.action";
		me.nodeType=nodeType;
		me.nodeObjectID=nodeObjectID;
		var queryContextID=me.model.queryContext.id;
		var params={
			queryContextID:queryContextID,
			nodeType:me.nodeType,
			nodeObjectID:me.nodeObjectID
		};
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching:true,
			success: function(result){
				borderLayout.setLoading(false);
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===false){
					var msg="";
					if(jsonData.errorMessage){
						msg=jsonData.errorMessage;
					}else{
						msg="Failure!";
					}
					CWHF.showMsgError(msg);
					return;
				}
				if(jsonData.data.includeParameters===true){
					//var node=nodeType+"_"+nodeObjectID;
					com.trackplus.admin.Filter.executeFilter(me, nodeObjectID, false);
				}else{
					var createView=jsonData.data.layout!==null;
					if(useFilter===true){
						createView=true;
					}
					me.refreshSuccessHandler.call(me,result,createView);
				}
			},
			failure: function(){
				borderLayout.setLoading(false);
			},
			method:'POST',
			params:params
		});
	},
	executePreviousQuery:function(lastQuery){
		var me=this;
		me.fromSession = false;
		var queryContextID = lastQuery["queryContextID"];
		var filterViewID=lastQuery['viewID'];
		if(me.btnListView){
			me.btnListView.setDisabled(false);
		}
		if(filterViewID&&filterViewID!==''){
			if(me.btnListView){
				me.btnListView.setDisabled(true);
			}
			if(me.selectedIssueViewDescriptor.id!==filterViewID){
				me.changeIssueListViewMode(me.findView(filterViewID),function(){
					var urlStr="itemNavigator!executePreviousQuery.action";
					me.refresh(urlStr,queryContextID,true);
				},false);
				return true;
			}
		}else{
			if(me.selectedIssueViewDescriptorStandard&&me.selectedIssueViewDescriptorStandard.id!==me.selectedIssueViewDescriptor.id){
				me.changeIssueListViewMode(me.selectedIssueViewDescriptorStandard,function(){
					var urlStr="itemNavigator!executePreviousQuery.action";
					me.refresh(urlStr,queryContextID,true);
				},true);
				return true;
			}
		}
		if(me.btnListView){
			me.btnListView.setDisabled(false);
		}
		var urlStr="itemNavigator!executePreviousQuery.action";
		me.refresh(urlStr,queryContextID,true);
	},
	createQueryMenu:function(lastQuery/*queryContext,queryName*/){
		var me=this;
		//var queryType = lastQuery["type"];
		var queryContextID = lastQuery["queryContextID"];
		//var queryID = lastQuery["objectID"];
		var queryName =  lastQuery["label"];
		var tooltip =  lastQuery["tooltip"];
		var icon=lastQuery["icon"];
		var iconCls=lastQuery["iconCls"];
		/*var iconCls='treeFilter-ticon';
		if(queryType===2){//dashboard
			iconCls='dashboard-ticon'
		}
		if(queryType===4){//basket
			iconCls='basket-ticon';
		}
		if(queryType===5){//PROJECT_RELEASE= 5;
			var entityID=0;
			try {
				entityID=parseInt(queryID);
			}catch(e){
				entityID=0;
			}
			if(entityID<0){
				iconCls='projects-ticon';
			}else{
				iconCls='release-ticon';
			}
		}
		if(queryType===6){//SCHEDULED= 6;
			iconCls="schedule-ticon";
		}
		if (queryType===7) {
			iconCls="tqlPlusFilter-ticon";
		}*/
		return {
			text:queryName,
			tooltip: tooltip,
			icon:icon,
			iconCls:iconCls,
			handler:function(){
				me.executePreviousQuery.call(me,lastQuery);
			}
		}
	},
	updateLastExecutedQueries:function(){
		var me=this;
		if(me.useLastQuery) {
			var btnQueries = Ext.getCmp('reportQueryName');
			//btnQueries.setIconCls(me.getQueryContextIcon(me.model.queryContext));
			btnQueries.setText(me.model.queryContext.queryName);
			btnQueries.setMenu(me.createLastQueriesMenu(me.model.lastQueries));
			borderLayout.borderLayoutController.updateLastExecutedQueries.call(borderLayout.borderLayoutController, me.model.lastQueries);
		}
	},
	updateTotalCount:function(){
		var me=this;
		Ext.getCmp('txtReportCount').setText(me.createHtmlTotalNumber());
		Ext.getCmp('txtReportFilteredCount').setText(me.createHtmlFilteredNumber());
		var overflowItems=me.model.overflowItems;
		me.viewAllLink.setVisible(overflowItems&&overflowItems>0);
	},
	createHtmlTotalNumber:function(){
		var me=this;
		var totalCount=me.model.totalCount;
		var overflowItems=me.model.overflowItems;
		var txtTotalNumber="";
		if(totalCount===-1){
			return getText('itemov.lbl.totalNumber') + ' ? ';
		}
		if(overflowItems&&overflowItems>0){
			txtTotalNumber='<span class="warning">!</span> '+getText('itemov.lbl.totalNumber') +' ' +totalCount
		}else{
			txtTotalNumber = getText('itemov.lbl.totalNumber') + ' ' + totalCount;
		}
		return  txtTotalNumber;
	},
	createHtmlFilteredNumber:function(){
		var me=this;
		var count=me.model.count;
		var overflowItems=me.model.overflowItems;
		var txtFiltered="";
		if(count===-1){
			return '   ' + getText('itemov.lbl.filtered')+': ? ';
		}
		if(overflowItems&&overflowItems>0){
			txtFiltered='   ' + getText('itemov.lbl.filtered')+': '+overflowItems+" ("+getText('itemov.lbl.filteredLimitedTo')+" "+count+")";
		}else{
			txtFiltered='   ' + getText('itemov.lbl.filtered')+': '+count;
		}
		return  txtFiltered;
	},
	createIssueListViewButton:function(issueListViewDescriptor){
		var me=this;
		return {
			//itemId:issueListViewDescriptor.id,
			iconCls:issueListViewDescriptor.iconCls,
			overflowText :issueListViewDescriptor.name,
			text :issueListViewDescriptor.name,
			tooltip :issueListViewDescriptor.description,
			handler:function(){
				me.changeIssueListViewMode(issueListViewDescriptor,null,true);
			}
		};
	},
					storeExtraAction:function(extraActionID){
		var me=this;
		if(me.selectedExtraAction===extraActionID){
			return false;
		}
		me.selectedExtraAction=extraActionID;
		var text,iconCls;
		switch(extraActionID){
			case 1:{//MASS_EDIT
				text=getText('common.btn.bulkEdit');
				iconCls='bulkEdit';
				break;
			}
			case 2:{//MASS_COPY
				text=getText('common.btn.bulkCopy');
				iconCls='bulkCopy';
				break;
			}
			case 3:{//EXPORT_REPORT
				text=getText('common.btn.report');
				iconCls='reports16';
				break;
			}
			case 4:{//EXCHANGE
				text=getText('common.btn.export');
				iconCls='export';
				break;
			}
			case 5:{//EXPORT_PDF
				text=getText('itemov.btn.exportPDF');
				iconCls='printIssue';
				break;
			}
			case 6:{//EXPORT_CSV
				text=getText('itemov.btn.exportCSV');
				iconCls='exportCSV';
				break;
			}
			case 7:{//EXPORT_XML
				text=getText('itemov.btn.exportXML');
				iconCls='exportXML';
				break;
			}
			case 8:{//EXPORT_XLS
				text=getText('itemov.btn.exportExcel');
				iconCls='exportExcel';
				break;
			}
			case 9:{//EXPORT_DOCX
				text=getText('itemov.btn.exportDocx');
				iconCls='exportDocx';
				break;
			}
			case 10:{//ADD_LINK
				text=getText('common.btn.addLink');
				iconCls='links16';
				break;
			}
			case 13:{//EXPORT MS. PROJECT
				text=getText('itemov.btn.exportMSProject');
				iconCls='msProject-ticon';
				break;
			}
			case 14:{//IMPORT FROM EXCEL
				text=getText('itemov.btn.importExcel');
				iconCls='exportDocx';
				break;
			}
			case 15:{//IMPORT FROM MS PROJECT
				text=getText('itemov.btn.importMSProject');
				iconCls='msProject-ticon';
				break;
			}
		}
		//me.btnExtraActions.setText(text);
		//me.btnExtraActions.setIconCls(iconCls);
	},
	MASS_EDIT:1,
	MASS_COPY:2,
	EXPORT_REPORT:3,
	EXCHANGE:4,
	EXPORT_PDF:5,
	EXPORT_CSV:6,
	EXPORT_XML:7,
	EXPORT_XLS:8,
	EXPORT_DOCX:9,
	ADD_LINK:10,
	SAVE_AS_STANDARD_LAYOUT:11,
	USE_STANDARD_LAYOUT:12,
	EXPORT_MS_PROJECT:13,
	IMPORT_EXCEL:14,
	IMPORT_MS_PROJECT:15,
	SAVE_AS_FILTER_LAYOUT:16,
	executeExtraAction:function(){
		var me=this;
		var extraActionID=me.selectedExtraAction;
		if(CWHF.isNull(extraActionID)){
			return false;
		}
		switch(extraActionID){
			case 1:{//MASS_EDIT
				me.massOperation.call(me,false);
				break;
			}
			case 2:{//MASS_COPY
				me.massOperation.call(me,true);
				break;
			}
			case 3:{//EXPORT_REPORT
				me.executeReport.call(me);
				//me.executeUrl('reportConfig.action?fromIssueNavigator=true',"_self");
				break;
			}
			case 4:{//EXCHANGE
				me.executeUrl("exchangeExport.action");
				break;
			}
			case 5:{//EXPORT_PDF
				me.executeUrl("reportDatasource.action?exportFormat=pdf");
				break;
			}
			case 6:{//EXPORT_CSV
				me.executeUrl("reportDatasource.action?exportFormat=csv");
				break;
			}
			case 7:{//EXPORT_XML
				me.executeUrl("reportDatasource!serializeDatasource.action?fromIssueNavigator=true");
				break;
			}
			case 8:{//EXPORT_XLS
				me.executeUrl("reportDatasource.action?exportFormat=xls");
				break;
			}
			case 9:{//EXPORT_DOCX
				//me.executeUrl("docxExport.action");
				me.exportDocx();
				break;
			}
			case 10:{
				me.addLink.call(me);
				break;
			}
		}
	},
	initToolbar:function(){
		var me=this;
		var includeCharts=me.model.includeCharts;
		var extraActions=[];
		var btnMassEdit={
			id:'massEdit',
			//itemId:'massEditItemId',
			text:getText('common.btn.bulkEdit'),
			overflowText:getText('common.btn.bulkEdit'),
			tooltip:getText('common.btn.bulkEdit.tt'),
			iconCls: 'bulkEdit',
			//selectedIssueMap && selectedIssueMap.size()>0
			disabled:true,
			handler:function(){
				me.massOperation.call(me,false);
				me.storeExtraAction.call(me,me.MASS_EDIT);
			}
		};
		var btnMassCopy={
			id:'massCopy',
			//itemId:'massCopyItemId',
			text:getText('common.btn.bulkCopy'),
			overflowText:getText('common.btn.bulkCopy'),
			tooltip:getText('common.btn.bulkCopy.tt'),
			iconCls: 'bulkCopy',
			//selectedIssueMap && selectedIssueMap.size()>0
			disabled:true,
			handler:function(){
				me.massOperation.call(me,true);
				me.storeExtraAction.call(me,me.MASS_COPY);
			}
		};
		var btnAddLink={
			id:'addLink',
			//itemId:'addLinkItemId',
			text:getText('common.btn.addLink'),
			overflowText:getText('common.btn.addLink'),
			tooltip:getText('common.btn.addLink.tt'),
			iconCls: 'links16',
			//selectedIssueMap && selectedIssueMap.size()>0
			disabled:true,
			handler:function(){
				me.addLink.call(me);
				me.storeExtraAction.call(me,me.ADD_LINK);
			}
		};
		var btnReports={
			//id:'exportReport',
			//itemId:'exportReportItemId',
			text:getText('common.btn.report'),
			overflowText:getText('common.btn.report'),
			tooltip:getText('common.btn.report.tt'),
			iconCls: 'reports16',
			disabled:false,
			handler:function(){
				//me.executeUrl('reportConfig.action?fromIssueNavigator=true',"_self");
				me.executeReport.call(me);
				me.storeExtraAction.call(me,me.EXPORT_REPORT);
			}
		};
		me.btnExportTrackplus={
			text:getText('itemov.btn.exportTrackplus'),
			overflowText:getText('itemov.btn.exportTrackplus'),
			tooltip:getText('itemov.btn.exportTrackplus.tt'),
			iconCls: 'export',
			disabled:false,//#session.user.sys
			handler:function(){
				me.executeUrl("exchangeExport.action");
				me.storeExtraAction.call(me,me.EXCHANGE);
			}
		};
		me.btnPrintGantt={
			text: getText('itemov.ganttView.print'),
			overflowText: getText('itemov.ganttView.print'),
			tooltip:getText('report.tooltip.printGantt'),
			iconCls: 'export',
			disabled:false,//#session.user.sys
			handler:function(){
				me.issueListFacade.listViewPlugin.view.zoomToFit();
				me.issueListFacade.listViewPlugin.view.print();
			}
		};
		me.btnExportPDF={
			text:getText('itemov.btn.exportPDF'),
			overflowText:getText('itemov.btn.exportPDF'),
			tooltip:getText('report.tooltip.exportPDF'),
			iconCls: 'printIssue',
			disabled:false,
			handler:function(){
				me.executeUrl("reportDatasource.action?exportFormat=pdf");
				me.storeExtraAction.call(me,me.EXPORT_PDF);
			}
		};
		me.btnExportCSV={
			text:getText('itemov.btn.exportCSV'),
			overflowText:getText('itemov.btn.exportCSV'),
			tooltip:getText('report.tooltip.exportCSV'),
			iconCls: 'exportCSV',
			disabled:false,
			handler:function(){
				me.executeUrl("reportDatasource.action?exportFormat=csv");
				me.storeExtraAction.call(me,me.EXPORT_CSV);
			}
		};
		me.btnExportXML={
			text:getText('itemov.btn.exportXML'),
			overflowText:getText('itemov.btn.exportXML'),
			tooltip:getText('itemov.btn.exportXML'),
			iconCls: 'exportXML',
			disabled:false,
			handler:function(){
				me.executeUrl("reportDatasource!serializeDatasource.action?fromIssueNavigator=true&exportFormat=xml");
				me.storeExtraAction.call(me,me.EXPORT_XML);
			}
		};
		me.btnExportXLS={
			text:getText('itemov.btn.exportExcel'),
			overflowText:getText('itemov.btn.exportExcel'),
			tooltip:getText('report.tooltip.exportExcel'),
			iconCls: 'exportExcel',
			disabled:false,
			handler:function(){
				me.executeUrl("reportDatasource.action?exportFormat=xls");
				me.storeExtraAction.call(me,me.EXPORT_XLS);
			}
		};
		me.btnExportMSProject={
			text:getText('itemov.btn.exportMSProject'),
			overflowText:getText('itemov.btn.exportMSProject'),
			tooltip:getText('report.tooltip.exportMSProject'),
			iconCls: 'msProject-ticon',
			disabled:false,
			handler:function(){
				var exportExcelWizard = Ext.create('com.trackplus.admin.action.ExportMsProject', {projectID:-1});
				exportExcelWizard.createPopUpDialog();
				me.storeExtraAction.call(me,me.EXPORT_MS_PROJECT);
			}
		};
		me.btnExportDOCX={
			text:getText('itemov.btn.exportDocx'),
			overflowText:getText('itemov.btn.exportDocx'),
			tooltip:getText('itemov.btn.exportDocx'),
			iconCls: 'word',
			disabled:false,
			handler:function(){
				//me.executeUrl("docxExport.action");
				me.exportDocx();
				me.storeExtraAction.call(me,me.EXPORT_DOCX);
			}
		};
		var items = [];
		if(me.model.lastSelectedView==='com.trackplus.itemNavigator.GanttViewPlugin'){
			items.push(me.btnPrintGantt);
		}else {
			items.push(me.btnExportPDF);
		}
		items.push(me.btnExportXLS);
		items.push(me.btnExportMSProject);
		items.push(me.btnExportCSV);
		items.push(me.btnExportDOCX);
		items.push(me.btnExportXML);
		items.push(me.btnExportTrackplus);
		me.btnExportGanttIntoPDF= {
			itemId: 'exportGanttIntoPDFBtn',
			text: getText('itemov.btn.exportPDF'),
			overflowText: getText('itemov.btn.exportPDF'),
			tooltip: getText('itemov.btn.exportPDF.tt'),
			iconCls: 'exportPDF',
			disabled:false,
			handler:function(){
				var gantView=me.issueListFacade.getView().items.items[1];
				var exportPlugin = null;
				for(var aPlugin in gantView.plugins) {
					if(gantView.plugins[aPlugin].$className === "Gnt.plugin.Export") {
						exportPlugin = gantView.plugins[aPlugin];
					}
				}
				if(exportPlugin ) {
				    Ext.Ajax.request({
				        url : "itemNavigator!getGanttExportPDFConfig.action",
				        disableCaching : true,
				        success : function(response) {
					        var respJSON = Ext.decode(response.responseText);
					        if(respJSON.success) {
					        	exportPlugin.defaultConfig.format = respJSON.format;
					        	exportPlugin.defaultConfig.orientation = respJSON.orientation;
					        	exportPlugin.defaultConfig.range = respJSON.range;
					        }
					        gantView.showExportDialog();
				        },
				        failure : function() {
				        	gantView.showExportDialog();
				        },
				        method : 'POST'
				    });
				}
			}
		};
		me.btnExport={
			text:getText('common.btn.export'),
			overflowText:getText('common.btn.export'),
			tooltip:getText('common.btn.export.tt'),
			iconCls: 'export',
			disabled:false,//#session.user.sys
			menu:Ext.create('Ext.menu.Menu',{
				items:items
			})
		};
		me.btnImportXLS={
			text:getText('itemov.btn.importExcel'),
			overflowText:getText('itemov.btn.importExcel'),
			tooltip:getText('report.tooltip.importExcel'),
			iconCls: 'exportExcel',
			disabled:false,
			handler:function(){
				var importExcelWizard = Ext.create('com.trackplus.admin.action.ImportExcel');
				importExcelWizard.createPopUpDialog(null);
				me.storeExtraAction.call(me,me.IMPORT_EXCEL);
			}
		};
		me.btnImportMSProject={
			text:getText('itemov.btn.importMSProject'),
			overflowText:getText('itemov.btn.importMSProject'),
			tooltip:getText('report.tooltip.importMSProject'),
			iconCls: 'msProject-ticon',
			disabled:false,
			handler:function(){
				var importMsProjPopUpWiz = 	Ext.create('com.trackplus.admin.action.ImportMsProject', {projectID:null});
				importMsProjPopUpWiz.createPopUpDialog(null);
				me.storeExtraAction.call(me,me.IMPORT_MS_PROJECT);
			}
		};
		var importItems = [];
		importItems.push(me.btnImportXLS);
		importItems.push(me.btnImportMSProject);
		me.btnImport={
			text:getText('common.btn.import'),
			overflowText:getText('common.btn.import'),
			tooltip:getText('common.btn.import.tt'),
			iconCls: 'import',
			disabled:false,//#session.user.sys
			menu:Ext.create('Ext.menu.Menu',{
				items:importItems
			})
		};
		extraActions.push(btnMassEdit);
		extraActions.push(btnMassCopy);
		extraActions.push(btnAddLink);
		if (com.trackplus.TrackplusConfig.user.reports) {
			extraActions.push(btnReports);
		}
		extraActions.push(me.btnImport);
		extraActions.push(me.btnExport);
		if(me.model.lastSelectedView==='com.trackplus.itemNavigator.GanttViewPlugin'){
			extraActions.push(me.btnExportGanttIntoPDF);
		}
		me.btnExtraActions=Ext.create('Ext.button.Split',{
			id:'extraActions',
			itemId:'extraActionsItemId',
			text:getText('itemov.btn.extraActions'),
			overflowText:getText('itemov.btn.extraActions'),
			tooltip:getText('itemov.btn.extraActions.tt'),
			iconCls: 'extraActions',
			disabled:false,
			handler:function(){
				me.executeExtraAction.call(me);
			},
			menu:extraActions
		});
	},
	createToolbar:function(){
		var me=this;
		me.initToolbar();
		var toolbarItems=new Array(0);
		if(me.useLastQuery) {
			toolbarItems.push(Ext.create('Ext.button.Split', {
				iconCls: 'queryHistory',//me.getQueryContextIcon(me.model.queryContext),
				text: me.model.queryContext.queryName,
				id: 'reportQueryName',
				menu: me.createLastQueriesMenu(me.model.lastQueries)
			}));
			toolbarItems.push(borderLayout.createItemToolbarSeparator());
		}
		toolbarItems.push({
			xtype: 'tbtext',
			disabled:true,
			id:'txtReportCount',
			text:me.createHtmlTotalNumber()
		});
		toolbarItems.push({
			xtype: 'tbtext',
			disabled:true,
			id:'txtReportFilteredCount',
			text:me.createHtmlFilteredNumber()
		});
		me.viewAllLink=Ext.create('Ext.ux.LinkComponent',{
			handler:me.forceViewAll,
			hidden:(CWHF.isNull(me.model.overflowItems)||me.model.overflowItems===0),
			scope:me,
			margin:'0 0 0 0',
			style:{
				overflow:'hidden'
			},
			label:getText('itemov.lbl.forceShowAll')
		});
		toolbarItems.push(me.viewAllLink);
		toolbarItems.push('->');
		me.btnFilterEdit=Ext.create('Ext.button.Button',{
			iconCls:'queryView',
			enableToggle:true,
			allowDepress:true,
			cls:'toolbarItemAction-noText',
			text:getText('common.btn.filter'),
			overflowText :getText('common.btn.filter'),
			tooltip :getText('common.btn.filter'),
			handler:function(){
				me.showHideFilterEdit();
			},
			scope:me
		});
		if(me.useLastQuery) {
			toolbarItems.push(me.btnFilterEdit);
		}
		toolbarItems.push(me.btnExtraActions);
		if(me.model.issueListViewDescriptors.length>1){
			var listViewMenu=new Array();
			for(var i=0;i<me.model.issueListViewDescriptors.length;i++){
				listViewMenu.push(me.createIssueListViewButton(me.model.issueListViewDescriptors[i]));
			}
			me.btnListView=Ext.create('Ext.button.Split',{
				id:'listView',
				itemId:'elistViewItemId',
				iconCls:me.selectedIssueViewDescriptor.iconCls,
				text:me.selectedIssueViewDescriptor.name,
				overflowText:me.selectedIssueViewDescriptor.name,
				tooltip:me.selectedIssueViewDescriptor.description,
				disabled:me.model.isFilterView,
				handler:function(){
					//me.changeIssueListViewMode();
				},
				menu:listViewMenu
			});
			toolbarItems.push(me.btnListView);
		}
		me.btnToolbarSettings=Ext.create('Ext.button.Button',{
			iconCls:'btnConfig',
			enableToggle:true,
			allowDepress:true,
			cls:'toolbarItemAction-noText',
			text:getText('itemov.lbl.toolbarSettings'),
			overflowText :getText('itemov.lbl.toolbarSettings'),
			tooltip :getText('itemov.lbl.toolbarSettings.tt'),
			handler:function(){
				me.showHideSettings();
			},
			scope:me
		});
		toolbarItems.push(me.btnToolbarSettings);
//		me.issueListFacade.addOrRemoveSaveButton(toolbarItems);
		return toolbarItems;
	},
	forceViewAll:function(){
		var me=this;
		me.model.forceAllItems=true;
		me.refresh();
	},
	showHideFilterEdit:function(){
		var me=this;
		me.filterEditVisible=!me.filterEditVisible;
		Ext.Ajax.request({
			url: "userPreferences.action?property=itemNavigator_filterEditVisible&value="+me.filterEditVisible,
			disableCaching:true,
			success: function(data){
			},
			failure: function(type, error){
			}
		});
		var b=me.filterEditVisible;
		var filterPanel=me.filterEditPanel;
		var el=filterPanel.getEl();
		var settingsHeight=100;//me.settingsHeight;
		var gridEl=me.issueViewPanel.getEl();
		var gridY=gridEl.getY();
		var gridHeight=gridEl.getHeight();
		if(b){
			gridEl.animate({
				top:settingsHeight,
				height:gridHeight-settingsHeight,
				duration:300,
				listeners:{
					'afteranimate':function(){
						filterPanel.setVisible(true);
						el.slideIn('t', {
							easing: 'easeOut',
							duration: 300,
							//remove: false,
							//useDisplay: false,
							listeners:{
								'afteranimate':function(){
									me.view.updateLayout ();
								}
							}
						});
					}
				}
			});
		}else{
			el.slideOut('t', {
				easing: 'easeOut',
				duration: 300,
				listeners:{
					'afteranimate':function(){
						gridEl.animate({
							top:0,
							height:gridHeight+settingsHeight,
							duration:300,
							listeners:{
								'afteranimate':function(){
									filterPanel.setVisible(false);
									me.view.updateLayout ();
								}
							}
						});
					}
				}
			});
		}
	},
	showHideSettings:function(){
		var me=this;
		me.settingsVisible=!me.settingsVisible;
		me.issueListFacade.setVisibleTools(me.settingsVisible);
		Ext.Ajax.request({
			url: "userPreferences.action?property=itemNavigator_settingsVisible&value="+me.settingsVisible,
			disableCaching:true,
			success: function(data){
			},
			failure: function(type, error){
			}
		});
	},
	getSelectedIssues:function(){
		var me=this;
		if(CWHF.isNull(me.selectedIssueViewDescriptor)){
			return null;
		}
		if(CWHF.isNull(me.issueListFacade)){
			return null;
		}
		return me.issueListFacade.getSelectedIssues();
	},
	formatIntegersAsString:function(integers){
		var str="";
		if(integers&&integers.length>0){
			for(var i=0;i<integers.length;i++){
				str+=integers[i];
				if(i<integers.length-1){
					str+=",";
				}
			}
		}
		return str;
	},
	massOperation:function(copy){
		var me=this;
		var selectedIssues=me.getSelectedIssues();
		var workItemIds=me.formatIntegersAsString(selectedIssues);
		var massOperationController=Ext.create('com.trackplus.itemNavigator.MassOperationController',{
			copy:copy,
			selectedIssueIDs:workItemIds/*,
			itemNavigatorController:me*/
		});
		massOperationController.itemNavigatorController=me;
		massOperationController.showDialog();
	},
	addLink:function() {
		/*var fromGantt = false;
		if(this.issueListFacade.descriptor.id === "com.trackplus.itemNavigator.GanttViewPlugin") {
			fromGantt = true;
		}*/
		var selectedIssues=this.getSelectedIssues();
		var workItemIDs=selectedIssues.join();
		var link=Ext.create('com.trackplus.issue.Link',{
			itemNavigatorController:this,
			workItemIDs:workItemIDs//,
			//fromGantt: fromGantt
		});
		link.addLinkFromIssueNavigator();
	},
	executeReport:function() {
		var selectedIssues=this.getSelectedIssues();
		var workItemIDs = null;
		if (selectedIssues) {
			workItemIDs=selectedIssues.join();
		}
		com.trackplus.admin.Report.executeReportFromIssueNavigator(workItemIDs);
	},
	exportDocx: function() {
		var selectedIssues=this.getSelectedIssues();
		var workItemIDs = null;
		if (selectedIssues) {
			workItemIDs=selectedIssues.join();
		}
		var exportDocx = Ext.create("com.trackplus.admin.action.ExportDocx", {workItemIDs:workItemIDs});
		exportDocx.createExportForm();
	},
	executeUrl:function(url) {
		var selectedIssues=this.getSelectedIssues();
		var workItemIDs = null;
		if (selectedIssues) {
			workItemIDs=selectedIssues.join();
		}
		if (CWHF.isNull(workItemIDs)) {
			window.open(url);
		} else {
			//because there could be a large number of selections the url would be too long, we force a http post
			var dummyForm = Ext.create('Ext.form.Panel', {
			items:[],
			url:url,
			baseParams: {
				workItemIDs:workItemIDs
			},
			standardSubmit:true});
			dummyForm.getForm().submit();
		}
	},
	findView:function(viewID){
		var me=this;
		var lastSelectedView=me.model.issueListViewDescriptors[0];
		if(viewID){
			for(var i=0;i<me.model.issueListViewDescriptors.length;i++){
				if(me.model.issueListViewDescriptors[i].id===viewID){
					lastSelectedView=me.model.issueListViewDescriptors[i];
					break;
				}
			}
		}
		return lastSelectedView;
	},
	successHandler:function(data,successExtra){
		this.itemActionSuccessHandler(data,successExtra);
	},
	executeItemAction:function(workItemID,actionID,parentID,workItemIndex,animateTarget,position, createItem, addLinkFromContextMenu){
		var me=this;
		var extraCfg={
			parentID:parentID,
			addLinkFromContextMenu:addLinkFromContextMenu,
			successExtra:{
				workItemIndex:workItemIndex,
				createItem:createItem
			},
			animateTarget:animateTarget
		};
		me.openItem(workItemID,actionID,workItemIndex,extraCfg);
	},
	navigate:function(workItemID,workItemIndex,dir){
		var me=this;
		if(me.issueListFacade){
			return me.issueListFacade.navigate.call(me.issueListFacade,workItemID,workItemIndex,dir);
		}
		return null;
	},
	itemChangeHandler:function(fields){
		var me=this;
		if(me.issueListFacade){
			if(me.issueListFacade.viewContainsFields(fields)) {
				me.refresh();
			}
		}
	},
	selectItem:function(workItemID){
		var me=this;
		if(me.issueListFacade){
			me.issueListFacade.selectItem.call(me.issueListFacade,workItemID);
		}
	},
	deselectItem:function(workItemID){
		var me=this;
		if(me.issueListFacade){
			me.issueListFacade.deselectItem.call(me.issueListFacade,workItemID);
		}
	},
	closeItemDialog:function(itemAction){
		var me=this;
		var workItemID=itemAction.workItemID;
		//me.issueListFacade.deselectItem.call(me.issueListFacade,workItemID);
	},
	chooseParent:function(rowData){
		var me=this;
		var workItemID=rowData.workItemID;
		var projectID=rowData.projectID;
		//var projectName=rowData.projectName;
		var ajaxContext={
			url:'item!setParent.action',
			params:{
				'workItemID':workItemID
			},
			pickItemName:'parentID',
			successHandler:me.itemActionSuccessHandler,
			successHandlerScope:me
		};
		var issuePicker=Ext.create('com.trackplus.util.IssuePicker',{
			workItemID:workItemID,
			parent:true,
			projectID:projectID*-1,
			//projectName:projectName,
			title:getText('common.btn.chooseParent'),
			ajaxContext:ajaxContext,
			width:700,
			height:500,
			stateId:'chooseParent'
		});
		issuePicker.showDialog();
	},
	itemActionSuccessHandler:function(data,successExtra){
		var me=this;
		var workItemID=null;
		if(data){
			workItemID=data.workItemID;
		}else{
			if(successExtra){
				workItemID=successExtra['workItemID'];
			}
		}
		if(successExtra&&successExtra['createItem']===true) {
			CWHF.showMsgInfo(getText('item.msg.newItemCreated', data.workItemIDDisplay, data.title));
		}
		me.refresh(null,null,false,function(){
			var workItemIndex=null;
			if(successExtra){
				workItemIndex=successExtra['workItemIndex'];
			}
			var selectedItems=null;
			if(workItemID){
				selectedItems=me.issueListFacade.selectItem.call(me.issueListFacade,workItemID);
			}
			if(CWHF.isNull(selectedItems)||selectedItems.length===0){
				if(workItemIndex){
					me.issueListFacade.selectItemByIndex.call(me.issueListFacade,workItemIndex);
				}
			}
			/*if(successExtra&&successExtra['actionID']&&successExtra['actionID']===-2){
			 me.issueListFacade.onItemDblClick.call(me.issueListFacade,{workItemID:workItemID});
			 }*/
		});
	},
	executeAJAXItemAction:function(url){
		var me=this;
		Ext.Ajax.request({
			url: url,
			success: function(response){
				me.itemActionSuccessHandler.call(me);
			},
			failure:function(){
				alert("failure");
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//
//Model
Ext.define('com.trackplus.itemNavigator.QueryContext',{
	extend:'Ext.Base',
	config: {
		id:null,
		queryType:null,
		queryID:null,
		queryName:null,
		dashboardParams:null
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	}
});
Ext.define('com.trackplus.itemNavigator.ItemNavigatorModel',{
	extend:'Ext.Base',
	config: {
		layout:null,
		issues:null,
		tooManyItems:false,
		listViewData:null,
		milestoneWorkitems:null,
		totalCount:0,
		overflowItems:0,
		count:0,
		lastQueries:null,
		queryContext:null,
		queryFieldCSS:null,
		issueListViewDescriptors:null,
		isFilterView:false,
		maySaveFilterLayout:false,
		summaryItemsBehavior:true,
		lastSelectedViewPerson:null,
		lastSelectedView:null,
		lastSelectedNavigator:null,
		navigator:null,
		holidays:null,
		localizedToolTipLabels:null
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	}
});
//facade
com.trackplus.itemNavigator.ItemNavigatorFacade=Ext.define('com.trackplus.itemNavigator.ItemNavigatorFacade',{
	extend:'Ext.Base',
	config: {
		model:null,
		useLastQuery:true,
		baseAction:'itemNavigator',
		skipEmptyNodeType:false,
		workItemID:null,
		actionID:null
	},
	statics: {
		createInitialModel: function(initData) {
			var me=this;
			var queryContext=me.createQueryContext(initData.queryContext);
			me.updateCssRules(initData.queryFieldCSS,initData.cssRules);
			return Ext.create('com.trackplus.itemNavigator.ItemNavigatorModel',{
				layout:initData.layout,
				issues:initData.issues,
				tooManyItems:initData.tooManyItems,
				listViewData:initData.listViewData,
				milestoneWorkitems:initData.milestoneWorkitems,
				totalCount:initData.totalCount,
				count:initData.count,
				overflowItems:initData.overflowItems,
				holidays:initData.holidays,
				localizedToolTipLabels:initData.localizedToolTipLabels,
				includeCharts:initData.includeCharts,
				lastQueries:initData.lastQueries,
				queryContext:queryContext,
				queryFieldCSS:initData.queryFieldCSS,
				issueListViewDescriptors:me.createIssueListViewDescriptors(initData.issueListViews),
				isFilterView:initData.isFilterView,
				maySaveFilterLayout:initData.maySaveFilterLayout,
				summaryItemsBehavior:initData.summaryItemsBehavior,
				lastSelectedViewPerson:initData.lastSelectedViewPerson,
				lastSelectedView:initData.lastSelectedView,
				lastSelectedNavigator:initData.lastSelectedNavigator,
				navigator:initData.navigator,
				isActiveTopDownDate:initData.isActiveTopDownDate,
				showBaseline:initData.showBaseline,
				validateRelationships:initData.validateRelationships,
				showDragDropInfoMsg:initData.showDragDropInfoMsg,
				highlightCriticalPath:initData.highlightCriticalPath,
				showBoth:initData.showBoth,
				isPrintItemEditable:initData.isPrintItemEditable
			});
		},
		createIssueListViewDescriptors:function(issueListViews){
			var issueListViewDescriptors=[];
			if(issueListViews){
				for(var i=0;i<issueListViews.length;i++){
					var ilw=issueListViews[i];
					issueListViewDescriptors.push(Ext.create('com.trackplus.itemNavigator.IssueListViewDescriptor',ilw));
				}
			}
			return issueListViewDescriptors;
		},
		createQueryContext:function(queryContextJSON){
			if(CWHF.isNull(queryContextJSON)){
				queryContextJSON={};
			}
			return Ext.create('com.trackplus.itemNavigator.QueryContext',queryContextJSON);
		},
		updateCssRules:function(fieldListID,cssRules){
			var me=this;
			if(me.oldCss){
				Ext.util.CSS.removeStyleSheet(me.oldCss);
				me.oldCss=null;
			}
			if(cssRules){
				var cssTxt='';
				var clsName;
				for(var i=0;i<cssRules.length;i++){
					var r=cssRules[i];
					clsName='rowCls_'+fieldListID+'_'+ r.id;
					var cls='.'+clsName+',.'+clsName+' .x-grid-td, .'+clsName+' .simpleTreeGridCell .x-grid-cell-inner{';
					cls+= r.rule;
					cls+="}";
					cssTxt+=cls;
				}
				me.oldCss="cssList_"+fieldListID;
				Ext.util.CSS.createStyleSheet(cssTxt,me.oldCss);
			}
		}
	},
	constructor : function(cfg) {
		var me = this;
		var config = cfg || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		me.itemNavigatorController=Ext.create('com.trackplus.itemNavigator.ItemNavigatorController',{
			model:me.model,
			useLastQuery:me.useLastQuery,
			baseAction:me.baseAction,
			skipEmptyNodeType:me.skipEmptyNodeType,
			workItemID:me.workItemID,
			actionID:me.actionID,
			settingsVisible:me.settingsVisible,
			filterEditVisible:me.filterEditVisible
		});
	},
	createView:function(model){
		var me=this;
		return me.itemNavigatorController.createView.call(me.itemNavigatorController);
	},
	createNavigator:function(){
		var me=this;
		return me.itemNavigatorController.createNavigator.call(me.itemNavigatorController);
	},
	createToolbar:function(){
		var me=this;
		return me.itemNavigatorController.createToolbar.call(me.itemNavigatorController);
	}
});
Ext.define('com.trackplus.layout.ItemNavigatorLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	toolbarCls:'toolbarActions-leftBorder',
	useSelfToolbarSeparators:true,
	itemNavigatorFacade:null,
	selectedGroup:'itemNavigator',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		var model=com.trackplus.itemNavigator.ItemNavigatorFacade.createInitialModel(me.initData);
		me.itemNavigatorFacade=Ext.create('com.trackplus.itemNavigator.ItemNavigatorFacade',{
			model:model,
			workItemID:me.initData.workItemID,
			baseAction:'itemNavigator',
			actionID:me.initData.actionID,
			useLastQuery:true,
			skipEmptyNodeType:false,
			settingsVisible:me.initData.settingsVisible,
			filterEditVisible:me.initData.filterEditVisible
		});
		me.borderLayoutController.setHelpContext("itemNavigator");
		me.onReady(function(){
			var data=me.initData;
			var toolbar=me.itemNavigatorFacade.createToolbar();
			me.borderLayoutController.setActiveToolbarList(toolbar);
			me.itemNavigatorFacade.itemNavigatorController.issueListFacade.addOrRemoveSaveButton(me.borderLayoutController.getActiveToolbarList());
			if(me.initData.actionID){
				var ctrl=me.itemNavigatorFacade.itemNavigatorController;
				var issueListFacade=ctrl.issueListFacade;
				var nodeDataArray=issueListFacade.listViewPlugin.selectItem(me.initData.workItemID);
				var workItemIndex=null;
				if(nodeDataArray&&nodeDataArray.length>0){
					workItemIndex=nodeDataArray[0]['workItemIndex'];
				}
				ctrl.executeItemAction.call(ctrl,me.initData.workItemID,me.initData.actionID,null,ctrl.navigate,ctrl,workItemIndex);
			}
		});
	},
	createCenterPanel:function(){
		var me=this;
		return me.itemNavigatorFacade.createView();
	},
	createWestPanel:function(){
		return this.itemNavigatorFacade.createNavigator.call(this.itemNavigatorFacade);
	},
	refresh:function(){
		var me=this;
		me.itemNavigatorFacade.itemNavigatorController.refresh();
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ItemNavigatorLiteLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	itemNavigatorFacade:null,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.model=com.trackplus.itemNavigator.ItemNavigatorFacade.createInitialModel(me.initData);
		me.borderLayoutController.setHelpContext("itemNavigator");
	},
	createCenterPanel:function(){
		var me=this;
		var listViewPlugin=Ext.create('com.trackplus.itemNavigator.LiteGridViewPlugin',{
			model:me.model
			//itemNavigatorController:me.itemNavigatorController
		});
		return listViewPlugin.createView.call(listViewPlugin);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.util.WindowConfig',{
	extend:'Ext.Base',
	config: {
		/**
		 * The title of the popup window
		 */
		title:"",
		/**
		 * The width of the popup window
		 */
		width:400,
		/**
		 * The height of the popup window
		 */
		height:300,
		/**
		 * the configuration object for window:
		 * this should contain extra configuration properties for the opened window
		 * (except width, height, and title: they can be specified directly)
		 */
		windowConfig: null,
		/**
		 * the configuration object for the main panel:
		 * this should contain configuration properties for the main panel. Used together with items
		 */
		panelConfig: null,
		/**
		 * the form panel is configured with this items array
		 */
		items:null,
		/**
		 * the formPanel loaded/submitted: alternative to (items:...,panelConfig...): a ready made panel
		 */
		formPanel:null,
		//the load object contains:
		//1. loadUrl: url the load is made from
		//2. loadUrlParams: load parametersc
		//3. isFormPanel: whether the edit form is form panel (load/submit)
		//4. loadHandler: alternative load for edit form (if isFormPanel is false)
		load:null,
		//the submit object contains:
		//1. submitUrl: url the submit is sent to
		//2. submitUrlParams: extra parameters for submit
		//3. submitButtonText: the label for submit button (defaults to the label keyed by 'common.btn.save')
		//4. refreshAfterSubmit: true if not specified, if false the refresh is not called in the submit handler
		//5. closeAfterSubmit: true if not specified, if false the window is not closed in the submit handler
		//6. submitHandler: an alternative submit handler used when isFormPanel is false (probably manual submit of a grid)
		//	refreshAfterSubmit and closeAfterSubmit has no relevance if submitHandler is specified
		//7. submitAction: the action for submit ("add", "edit", "copy", "overwrite"). Not required
		//if there are more actions which need a submit the submit object can be an array of such submit objects
		submit:null,
		//the submit method
		method:"POST",
		//the refresh object contains:
		//1. refreshAfterSubmitHandler: the function to call after the submit (save or delete) operation was made
		//2. refreshParametersBeforeSubmit: refresh parameters known before submit (save or delete): (for example 'nodeIDToReload')
		//3. refreshParametersAfterSubmit: json object array like
		//			[{parameterName:'<refreshParameterName>', fieldNameFromResult:'<fieldNameFromResult>'}, ...]
		//			refresh parameters known only after submit (save or delete). The values are get after save or delete,
		//			from the result json, see submitHandler().
		//			<refreshParameterName> is typically either: 'nodeIDToSelect' (the tree node to select after branch reload) or
		//									'rowToSelect': the grid row to select after grid store reload
		//refresh:null,
		//function to call after the json data to be loaded in the window has arrived from the server
		//(like loading combo data source, show/hide controls depending on data)
		postDataProcess:null,
		//function to call before form submit like adding extra dynamic submit parameters depending on the prepared data
		//(add to submitUrlParams)
		preSubmitProcess:null,
		cancelButtonText: null, //the text for the cancel button
		submitButtonText: null,
		refreshAfterCancel: false, //whether a refresh should be made by closing the window (typically a refresh is made immediately after submits, not here)
		/**
		 * Whether it is a file upload form
		 */
		fileUpload:false,
		/**
		 * extra configuration for the context of the operation (like operation started from tree or from grid whether the the node is leaf)
		 * used mainly for identifying the correct entity labels
		 */
		extraConfig:null,
		overrideButtons: null
	},
	constructor: function(config) {
		var me = this
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	/**
	 * Text for failure
	 */
	failureTitle:getText('common.err.failure'),
	/**
	 * The window to be opened
	 */
	win: null,
	/**
	 * label for the cancel button
	 */
	getCancelButtonText: function() {
		if (this.cancelButtonText) {
			return this.cancelButtonText;
		} else {
			return getText('common.btn.cancel');
		}
	},
	/**
	 * label for save button
	 */
	getSubmitButtonText: function(submit) {
		if (this.submitButtonText) {
			submit.submitButtonText = this.submitButtonText;
		}
		if (submit.submitButtonText) {
		    return submit.submitButtonText;
		} else {
			return getText('common.btn.save');
		}
	},
    getButtonDisabled: function(submit) {
        if (submit && submit.disabled)   {
           return submit.disabled;
        }
        return false;
    },
	/**
	 * Handler for canceling the window
	 */
	cancelHandler:function(scope, submit) {
		if(submit && submit.specialSubmitFailHandler ) {
			submit.specialSubmitFailHandler.call(scope);
		}
		if (this.refreshAfterCancel) {
			this.refreshHandler(scope, null, submit);
		}
		this.win.close();
	},
	/**
	 * Shows the popup window
	 */
	showWindow: function(scope, title, width, height,
			load, submit, /*refresh,*/ windowItems) {
		this.title=title;
		this.width=width;
		this.height=height;
		this.ensureSize();
		this.items = windowItems;
		this.load = load;
		this.submit = submit;
		//this.refresh = refresh;
		this.showWindowByConfig(scope);
	},
	setLoading:function(b){
		var me=this;
		if(me.win){
			me.win.setLoading(b);
		}
	},
	ensureSize:function(){
		var me=this;
		var size=borderLayout.ensureSize(me.width,me.height);
		me.width=size.width;
		me.height=size.height;
	},
	/**
	 * Shows the window according to the windowConfig
	 */
	showWindowByConfig: function(scope) {
		var me = this;
		if(me.win){
			me.win.destroy();
		}
		me.ensureSize();
		if (me.items || me.formPanel) {
			if (me.items) {
				//the formPanel is made here according to the items
				var panelConfig = {
						fileUpload:	me.fileUpload,
						//bodyStyle:	'padding: 5px',
						border: false,
						autoScroll:true,
						margin: '0 0 0 0',
						bodyStyle:{
							padding:'10px'
						},
						/*style:{
							borderBottom:'1px solid #D0D0D0'
						},*/
						defaultType:'textfield',
						defaults: {
							labelStyle:'overflow: hidden;',
							labelWidth:150,
							msgTarget:	'under',
							anchor:'100%'
						},
						method: "POST",
						items : me.items
					};
				if (me.panelConfig) {
					//add extra panel configuration
					for (propertyName in me.panelConfig) {
						panelConfig[propertyName] = me.panelConfig[propertyName];
					}
				}
                if (me.submit && me.submit.timeout)  {
                    panelConfig.timeout = me.submit.timeout;
                }
				me.formPanel = Ext.create('Ext.form.Panel', panelConfig);
			}
			scope.formEdit = me.formPanel;
			var buttons = [];
			var submit = me.submit;
			if(CWHF.isNull(me.overrideButtons)) {
				if (submit) {
					var submitByEnter = null;
					//var submitHandler_submitButtonIndex;
					if (submit instanceof Array) {
						//more than one submit: for example a save and an execute
						//for (i=0;i<submit.length;i++) {
						if (submit[0]) {
							submitByEnter = submit[0];
							buttons.push({text: me.getSubmitButtonText(submit[0]),
	                            disabled: me.getButtonDisabled(submit[0]),
								scope: scope,
								handler : function(){
									me.submitHandler(submit[0], scope, 0, me.extraConfig);
									}
								})
						}
						if (submit[1]) {
							buttons.push({text: me.getSubmitButtonText(submit[1]),
	                            disabled: me.getButtonDisabled(submit[1]),
								scope: scope,
								handler  : function(){
									me.submitHandler(submit[1], scope, 1, me.extraConfig);
									}
								})
	                    }
	                    if (submit[2]) {
	                            buttons.push({text: me.getSubmitButtonText(submit[2]),
	                                disabled: me.getButtonDisabled(submit[2]),
	                                scope: scope,
	                                handler  : function(){
	                                    me.submitHandler(submit[2], scope, 2, me.extraConfig);
	                                }
	                            })
						}
	                    if (submit[3]) {
	                        buttons.push({text: me.getSubmitButtonText(submit[3]),
	                            disabled: me.getButtonDisabled(submit[3]),
	                            scope: scope,
	                            handler  : function(){
	                                me.submitHandler(submit[3], scope, 2, me.extraConfig);
	                            }
	                        })
					}
					} else {
						submitByEnter=submit;
						//submitHandler_submitButtonIndex=0;
						buttons = [{text: me.getSubmitButtonText(submit),
	                                disabled: me.getButtonDisabled(submit),
									scope: scope,
									handler: function(){
										me.submitHandler(submit, scope, 0, me.extraConfig);
									}
								}]
					}
					if (me.formPanel) {
						me.formPanel.addListener('afterRender',function(thisForm, options){
							this.keyNav = Ext.create('Ext.util.KeyNav',{
								target:this.el,
								scope:this,
								enter: {
									fn:function(e){
										var target = e.getTarget();
										if(target['type']==='textarea'){
											return true;
										}
										me.submitHandler(submitByEnter, scope, 0, me.extraConfig);
									},
									defaultEventAction:false
								}
							});
						});
					}
				}
				buttons.push({text: me.getCancelButtonText(),
					scope: scope,
					handler: function(){
						me.cancelHandler(scope, submit);
					}
				});
			}else {
				buttons = me.overrideButtons;
			}
			//show window
			if (me.formPanel) {
				var windowConfig = {
					title	: me.title,
					width	: me.width,
					height	: me.height,
					layout	: 'fit',
					plain	: true,
					modal	: true,
					items	: me.formPanel,
//					autoScroll: true,
					buttons	: buttons
				};
				if (me.windowConfig) {
					//add extra window configuration
					for (propertyName in me.windowConfig) {
						windowConfig[propertyName] = me.windowConfig[propertyName];
					}
				};
				windowConfig.cls='windowConfig bottomButtonsDialog tpspecial';
				// windowConfig.border=false;
				windowConfig.bodyBorder=false;
				windowConfig.margin='0 0 0 0';
				windowConfig.style={
					padding:' 5px 0px 0px 0px'
				};
				windowConfig.bodyPadding='0px';
				me.win = Ext.create('Ext.window.Window', windowConfig);
				//set the win in the scope to be available in the overridden handlers (createEditForm(), submitHandler()
				scope.win = me.win;
				me.win.show();
			};
			if (me.load) {
				var loadHandler = me.load.loadHandler;
				if (CWHF.isNull(loadHandler)) {
					//load data for form panel
					me.formPanel.setLoading(true);
					me.formPanel.getForm().load({
						url : me.load.loadUrl,
						params: me.load.loadUrlParams,
						scope: scope,
						success: function(form, action) {
							me.formPanel.setLoading(false);
							//call postDataProcess only after window is rendered because
							//some fields (like labelEl) are available only after the window is rendered
							if (me.postDataProcess) {
								me.postDataProcess.call(scope, action.result.data, me.formPanel, me.extraConfig);
							}
							//me.formPanel.setLoading(false);
						},
						failure: function(form, action) {
							me.formPanel.setLoading(false);
							Ext.MessageBox.show({
								title: this.failureTitle,
								msg: action.response.responseText,
								buttons: Ext.Msg.OK,
								icon: Ext.MessageBox.ERROR
							})
							//me.formPanel.setLoading(false);
						}
					});
				} else {
					//alternative loading: probably loads a store
					loadHandler.call(scope, me.load.loadUrl, me.load.loadUrlParams);
				}
			}
		}
	},
	/**
	 * The submit handler function
	 */
	submitHandler: function(submit, scope, submitButtonIndex, extraConfig) {
		var submitUrl = submit.submitUrl;
		var submitUrlParams = submit.submitUrlParams;
		var manualSubmitHandler = submit.submitHandler;
		var me = this;
		var onSuccess = function(form, action) {
			if (submit.loading) {
				me.formPanel.setLoading(false);
			}
			me.disableSubmitButton(scope.win, false, submitButtonIndex);
			var result = action.result;
			if (result) {
				if (result.success) {
					//refresh after successful submit
					if (CWHF.isNull(submit.refreshAfterSubmit) || submit.refreshAfterSubmit===true) {
						me.refreshHandler(scope, result, submit);
					}
					if (CWHF.isNull(submit.closeAfterSubmit) || submit.closeAfterSubmit===true) {
						me.win.close();
					}
				} else {
					com.trackplus.util.showError(result);
				}
			}
		};
		var onFailure = function(form, action) {
			if (submit.loading) {
				me.formPanel.setLoading(false);
			}
			me.disableSubmitButton(scope.win, false, submitButtonIndex);
			result = action.result;
			if (result) {
				var errorCode = result.errorCode;
				var title = result.title;
				if (errorCode && (errorCode===4 || errorCode===5)) {
					//4===NEED_CONFIRMATION
					if (errorCode===4) {
						var errorMessage = result.errorMessage;
						Ext.MessageBox.confirm(title,
							errorMessage,
							function(btn){
								if (btn==="no") {
									return false;
								} else {
									submitUrlParams["confirmSave"]=true;
									me.submitHandler(submit, scope, submitButtonIndex);
								}
							}, this);
					} else {
						//5===RECOMMENDED_REPLACE
						if (errorCode===5) {
							scope.recommendedReplace.call(scope, me, submit, result);
						}
					}
				} else {
					errors = result.errors;
					if (errors) {
						//form control errors (with control itemIds)
						form.markInvalid(errors);
					} else {
						var errorMessage = result.errorMessage;
						if (errorMessage) {
							//only error message, no errorCode
							com.trackplus.util.showError(result);
						} else {
							com.trackplus.util.submitFailureHandler(form, action);
						}
					}
				}
			}
			if(submit.specialSubmitFailHandler ) {
				submit.specialSubmitFailHandler.call(scope, result);
			}
		};
		if (submit.validateHandler) {
			var valid = submit.validateHandler.call(scope, submit);
			if (valid && !valid) {
				return;
			}
		}
		if (me.preSubmitProcess) {
			//add extra (dynamic client side) request parameters, right before submit
			submitUrlParams = me.preSubmitProcess.call(scope, submitUrlParams, me.formPanel, submit.submitAction);
		}
		var standardSubmit = submit.standardSubmit;
		if (standardSubmit) {
			me.formPanel.getForm().standardSubmit = standardSubmit;
		}
		var timeOut = submit.timeout;
		if (timeOut) {
			me.formPanel.getForm().timeOut = timeOut;
		}
		if (CWHF.isNull(manualSubmitHandler)) {
			if (submit.loading) {
				me.formPanel.setLoading(true);
			}
			this.disableSubmitButton(scope.win, true, submitButtonIndex);
			me.formPanel.getForm().submit({
				url: submitUrl,
				params: submitUrlParams,
				method: "POST",
				scope: scope,
				success: onSuccess,
				failure: onFailure
			});
		} else {
			//alternative submit: probably loads a store
			//or simply makes a classic submit with specific success handler
			//this handler might close the window
			manualSubmitHandler.call(scope, me.win, submitUrl, submitUrlParams, extraConfig);
		}
		if (standardSubmit && (me.formPanel.getForm().monitor&&me.formPanel.getForm().isValid())) {
			//by standardSubmit the handlers onSuccess or onFailure are not called consequently the popup window would not be closed
			//1. if after a standardSubmit the result is another page, closing the popup does not hurt
			//because anyway the entire page is newly loaded (close the instant query popup after executing it)
			//2. if after a form submit the result should be a file download (for example by generating the report).
			//In this case a standardSubmit should be used because even if AJAX submit would be used the result is a stream so
			//the resulting data is not JSON containing a "success" field i.e. the submit handlers would not be called.
			//A download dialog will appear but the actual page remains consequently the popup should be closed here:
			if(submit.submitMessage){
				CWHF.showMsgInfo(submit.submitMessage);
			}
			Ext.defer(function(){
				me.disableSubmitButton(scope.win, false, submitButtonIndex);
			}, 1000);
		}
	},
	/**
	 * Disable the submit button at a specified index
	 */
	disableSubmitButton: function(window, disable, submitButtonIndex) {
		var toolbars = window.getDockedItems('toolbar[dock="bottom"]');
		if (toolbars && toolbars.length>0) {
			//disable submit button
			if (CWHF.isNull(submitButtonIndex)) {
				submitButtonIndex=0;
			}
			toolbars[0].getComponent(submitButtonIndex).setDisabled(disable);
		}
	},
	refreshHandler: function(scope, result, submit) {
		if (submit && submit.refreshAfterSubmitHandler) {
			var refreshParameters = submit.refreshParametersBeforeSubmit;
			if (CWHF.isNull(refreshParameters)) {
				refreshParameters = new Object();
			}
			if (submit.refreshParametersAfterSubmit && result) {
				Ext.each(submit.refreshParametersAfterSubmit, function(refreshAfterExecuteParmeter) {
					var parameterName = refreshAfterExecuteParmeter.parameterName;
					var fieldNameFromResult = refreshAfterExecuteParmeter.fieldNameFromResult;
					refreshParameters[parameterName]=result[fieldNameFromResult];
				})
			}
			submit.refreshAfterSubmitHandler.call(scope, refreshParameters, result);
		}
	}
})

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Low level handler for request failure
 * @param form
 * @param action
 */
com.trackplus.util.requestFailureHandler = function(response, options) {
	var failureTitle = getText('common.err.failure');
	var message = "status: " + response.status + " statusText: " + response.statusText + " responseText: " + response.responseText;
	if(response.statusText&&response.statusText!==''){
		Ext.MessageBox.show({
			title: getText('common.err.failure'),
			msg: message,
			buttons: Ext.Msg.OK,
			icon: Ext.MessageBox.ERROR
		});
	}
}
/**
 * Handle the submit failure
 * @param form
 * @param action
 */
com.trackplus.util.submitFailureHandler = function(form, action) {
	var failureTitle = getText('common.err.failure');
	switch (action.failureType) {
	case Ext.form.action.Action.CLIENT_INVALID:
		Ext.Msg.alert(failureTitle, getText('common.err.failure.validate'));
		break;
	case Ext.form.action.Action.CONNECT_FAILURE:
		Ext.Msg.alert(failureTitle, getText('common.err.failure.ajax'));
		break;
	case Ext.form.action.Action.SERVER_INVALID:
		decodedResult = action.result;
		if (decodedResult) {
			com.trackplus.util.showError(decodedResult);
		} else {
			com.trackplus.util.requestFailureHandler(action.response);
		}
	}
}
/**
 * Show the errors after an ajax request() or submit()
 * result the decoded JSON result
 */
com.trackplus.util.showError = function(result) {
	if (result) {
		var message = "";
		var title = result['title'];
		var errorCode = result['errorCode'];
		var applicationErrorInfoFound = false;
		if (errorCode) {
			applicationErrorInfoFound = true;
			message += getText('common.err.failure.errorCode') + ": " + errorCode;
		}
		var errorMessage = result.errorMessage;
		if (errorMessage) {
			applicationErrorInfoFound = true;
			message += errorMessage;
		}
		var sucessMessage = result.message;
		if (sucessMessage) {
			applicationErrorInfoFound = true;
			message += sucessMessage;
		}
		if (CWHF.isNull(title)) {
			if (errorMessage || errorCode) {
				title = getText('common.err.failure');
			} else {
				title = getText('common.lbl.message');
			}
		}
		if (!applicationErrorInfoFound) {
			//no standard error fields found, show the entire result
			for (propertyName in result) {
				message += propertyName + " " + result[propertyName] + " ";
			}
		}
		Ext.MessageBox.show({
			title: title,
			msg: message,
			buttons: Ext.Msg.OK,
			icon: Ext.MessageBox.ERROR
		});
	}
}

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('js.ext.com.track.speedometerPlugin.SpeedometerAxis', {
//    extend: 'Ext.chart.axis.Gauge',
	extend: 'Ext.chart.axis.Category',
    alias: 'axis.kpigauge',
	position: 'left',
	drawAxis: function(init) {
        var me = this,
			chart = me.chart,
            surface = chart.surface,
            bbox = chart.chartBBox,
            centerX = bbox.x + (bbox.width / 2),
            centerY = bbox.y + bbox.height,
            margin = me.margin || 10,
            rho = Math.min(bbox.width, 2 * bbox.height) /2 + margin,
            sprites = [], sprite,
            steps = me.steps,
            i, pi = Math.PI,
            cos = Math.cos,
            sin = Math.sin;
        if (me.sprites && !chart.resizing) {
            me.drawLabel();
            return;
        }
        if (me.margin >= 0) {
            if (!me.sprites) {
                //draw circles
                for (i = 0; i <= steps; i++) {
                    sprite = surface.add(Ext.apply({
                        type: 'path',
                        path: ['M', centerX + (rho - margin) * cos(i / steps * pi - pi),
                                    centerY + (rho - margin) * sin(i / steps * pi - pi),
                                    'L', centerX + rho * cos(i / steps * pi - pi),
                                    centerY + rho * sin(i / steps * pi - pi), 'Z']
                    }, me.axisStyle));
                    sprite.setAttributes({
                        hidden: false
                    }, true);
                    sprites.push(sprite);
                }
            } else {
                sprites = me.sprites;
                //draw circles
                for (i = 0; i <= steps; i++) {
                    sprites[i].setAttributes(Ext.apply({
                        path: ['M', centerX + (rho - margin) * cos(i / steps * pi - pi),
                                    centerY + (rho - margin) * sin(i / steps * pi - pi),
                               'L', centerX + rho * cos(i / steps * pi - pi),
                                    centerY + rho * sin(i / steps * pi - pi), 'Z']
                    }, me.axisStyle), true);
                }
            }
        }
        me.sprites = sprites;
        me.drawLabel();
        if (me.title) {
            me.drawTitle();
        }
    },
	drawLabel: function() {
        var me = this,
			chart = me.chart,
            surface = chart.surface,
            bbox = chart.chartBBox,
            centerX = bbox.x + (bbox.width / 2),
            centerY = bbox.y + bbox.height,
            margin = me.margin || 10,
            rho = Math.min(bbox.width, 2 * bbox.height) /2 + 2 * margin,
            round = Math.round,
			labelGroup = me.labelGroup,
            maxValue = me.maximum || 0,
            minValue = me.minimum || 0,
            steps = me.steps, i = 0,
            pi = Math.PI,
            cos = Math.cos,
            sin = Math.sin,
			textLabel, adjY;
		me.label.renderer = me.label.renderer || Ext.identityFn
		for (i = 0; i <= steps; i++) {
			textLabel = labelGroup.getAt(i);
			adjY = (i === 0 || i === steps) ? 7 : 0;
			x = centerX + rho * cos(i / steps * pi - pi);
			y = centerY + rho * sin(i / steps * pi - pi) - adjY
			text = me.label.renderer(round(minValue + i / steps * (maxValue - minValue)));
			if (textLabel) {
				textLabel.setAttributes(Ext.apply({
                    text: text,
                    x: x,
                    y: y
                }, me.label), true);
			} else {
				textLabel = surface.add(Ext.apply({
					group: labelGroup,
					type: 'text',
					x: x,
					y: y,
					text: text,
					zIndex: 10,
					'text-anchor': 'middle'
				}, me.label));
				surface.renderItem(textLabel);
			}
		}
		textLabel.setAttributes({
			hidden: false
		}, true);
    }
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('js.ext.com.track.speedometerPlugin.SpeedometerSeries', {
	extend: 'Ext.chart.series.Gauge',
	alias: 'series.kpigauge',
	type: 'kpigauge',
	needleValue: 0,
	needleValueFill: '#555555',
	drawSeries: function () {
		var me = this,
            chart = me.chart,
            store = chart.getChartStore(),
            group = me.group,
            animate = me.chart.animate,
            axis = me.chart.axes.get(0),
            minimum = axis && axis.minimum || me.minimum || 0,
            maximum = axis && axis.maximum || me.maximum || 0,
			ranges = me.ranges,
            field = me.angleField || me.field || me.xField,
            surface = chart.surface,
            chartBBox = chart.chartBBox,
            rad = me.rad,
            donut = +me.donut,
            values = {},
            items = [],
            seriesStyle = me.seriesStyle,
            seriesLabelStyle = me.seriesLabelStyle,
            cos = Math.cos,
            sin = Math.sin,
            rendererAttributes, centerX, centerY, slice, slices, sprite, value,
            item, ln, record, i, j, r, slice, splitAngle, rl, startAngle, endAngle, middleAngle, sliceLength, path,
            p, spriteOptions, bbox, valueAngle, pivotRadius;
        Ext.apply(seriesStyle, me.style || {});
        me.setBBox();
        bbox = me.bbox;
        //if not store or store is empty then there's nothing to draw
		if (!store || !store.getCount() || me.seriesIsHidden) {
            me.hide();
            me.items = [];
            return;
        }
        centerX = me.centerX = chartBBox.x + (chartBBox.width / 2);
        centerY = me.centerY = chartBBox.y + chartBBox.height;
        me.radius = Math.min(centerX - chartBBox.x, centerY - chartBBox.y);
        me.slices = slices = [];
        me.items = items = [];
        if (!me.value) {
            record = store.getAt(0);
            me.value = record.get(field);
        }
        value = me.value;
		for (r = 0, rl = ranges.length; r < rl; r++) {
			splitFromAngle = -180 * (1 - (ranges[r].from - minimum) / (maximum - minimum));
			splitToAngle = -180 * (1 - (ranges[r].to - minimum) / (maximum - minimum));
			slices.push ({
				startAngle: splitFromAngle,
				endAngle: splitToAngle,
				rho: me.radius,
				color: ranges[r].color
			});
		}
        //do pie slices after.
        for (i = 0, ln = slices.length; i < ln; i++) {
            slice = slices[i];
            sprite = group.getAt(i);
            //set pie slice properties
            rendererAttributes = Ext.apply({
                segment: {
                    startAngle: slice.startAngle,
                    endAngle: slice.endAngle,
                    margin: 0,
                    rho: slice.rho,
                    startRho: slice.rho * +donut / 100,
                    endRho: slice.rho
                }
            }, Ext.apply(seriesStyle, { fill: slice.color}));
            item = Ext.apply({},
            rendererAttributes.segment, {
                slice: slice,
                series: me,
                storeItem: record,
                index: i
            });
            items[i] = item;
            // Create a new sprite if needed (no height)
            if (!sprite) {
                spriteOptions = Ext.apply({
                    type: "path",
                    group: group
                }, Ext.apply(seriesStyle, { fill: slice.color }));
                sprite = surface.add(Ext.apply(spriteOptions, rendererAttributes));
            }
            slice.sprite = slice.sprite || [];
            item.sprite = sprite;
            slice.sprite.push(sprite);
            if (animate) {
                rendererAttributes = me.renderer(sprite, record, rendererAttributes, i, store);
                sprite._to = rendererAttributes;
                me.onAnimate(sprite, {
                    to: rendererAttributes
                });
            } else {
                rendererAttributes = me.renderer(sprite, record, Ext.apply(rendererAttributes, {
                    hidden: false
                }), i, store);
                sprite.setAttributes(rendererAttributes, true);
            }
        }
		if (me.needle) {
			valueAngle = (-180 * (1 - (value - minimum) / (maximum - minimum))) * Math.PI / 180;
			pivotRadius = me.needle.pivotRadius || 7
			if (!me.needleSprite) {
				me.needlePivotSprite = me.chart.surface.add({
					type: 'circle',
					fill: me.needle.pivotFill || '#222',
					radius: pivotRadius,
					x: centerX,
					y: centerY
				});
				me.needleSprite = me.chart.surface.add({
					type: 'path',
					path: [
						'M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
							centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
						'L', centerX + me.radius * cos(valueAngle),
							centerY + -Math.abs(me.radius * sin(valueAngle))
					],
					'stroke-width': me.needle.width || 2,
					'stroke': me.needle.pivotFill || '#222'
				});
				me.valueSprite = me.chart.surface.add({
					type: 'text',
					text: me.needleValue,
					fill: me.needleValueFill,
					font: '18px Arial',
					x: centerX - (centerX * 0.045) - (pivotRadius),
					y: centerY - (me.radius / 2)
				});
			} else {
				if (animate) {
					me.onAnimate(me.needlePivotSprite, {
						to: {
							x: centerX,
							y: centerY
						}
					});
					me.onAnimate(me.needleSprite, {
						to: {
							path: [
								'M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
									centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
							   'L', centerX + me.radius * cos(valueAngle),
									centerY + -Math.abs(me.radius * sin(valueAngle))
							]
						}
					});
				} else {
					me.needlePivotSprite.setAttributes({
						type: 'circle',
						fill: me.needle.pivotFill || '#222',
						radius: me.needle.pivotRadius || 7,
						x: centerX,
						y: centerY
					});
					me.needleSprite.setAttributes({
						type: 'path',
						path: ['M', centerX + (me.radius * 0 / 100) * cos(valueAngle),
									centerY + -Math.abs((me.radius * 0 / 100) * sin(valueAngle)),
							   'L', centerX + me.radius * cos(valueAngle),
									centerY + -Math.abs(me.radius * sin(valueAngle))]
					});
				}
				// Nothing to animate so we use a single call to update the Value Sprite's attributes no matter "animate" config
				me.valueSprite.setAttributes({
					type: 'text',
					text: me.needleValue,
					fill: me.needleValueFill,
					x: centerX - (centerX * 0.045) - (pivotRadius),
					y: centerY - (me.radius / 2)
				});
			}
			me.needlePivotSprite.setAttributes({
				hidden: false
			}, true);
			me.needleSprite.setAttributes({
				hidden: false
			}, true);
			me.valueSprite.setAttributes({
				hidden: false
			}, true);
		}
        delete me.value;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
//Dashboard Config
//dashboard types
Ext.define('js.ext.com.track.dashboard.BaseConfig',{
	extend: 'Ext.form.Panel',
	border: false,
	margin: '0 0 0 0',
	autoScroll:true,
	bodyStyle:{
		padding:'10px'
	},
	/*style:{
		borderBottom:'1px solid #D0D0D0'
	},*/
	frame: false,
	collapsible:false,
	titleCmp:null,
	layout:'anchor',
	config: {
		projectID:null,
		entityType:null,
		jsonData:{}
	},
	defaults:{
		labelWidth:150,
		labelAlign: 'right',
		labelSeparator :':',
		labelStyle:{overflow:'hidden'}
	},
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		for(var i=0;i<me.items.length;i++){
			Ext.apply(me.items[i],me.defaults);
		}
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=[];
		me.titleCmp=Ext.create('Ext.form.field.Text',{
			fieldLabel:getText('title'),
			labelAlign:'right',
			anchor : '100%',
			name:'params.title',
			value:me.jsonData.title
		});
		items.push(me.titleCmp);
		return items;
	},
	isValidParams:function(){
		var me=this;
		return true;
	}
});
//dashboard types
Ext.define('js.ext.com.track.dashboard.DashboardRenderer',{
	extend: 'Ext.panel.Panel',
	border: false,
	margin: '0 0 5 5',
	frame: true,
	collapsible:true,
	bodyPadding: 0,
	padding:0,
	originalTitle:'',
	cls:'dashboardField',
	config: {
		projectID:null,
		useRefresh:true,
		refreshTime:0,
		useConfig:false,
		jsonData:{}
	},
	initComponent: function(){
		var me=this;
		me.useConfig=me.jsonData.useConfig;
		me.useRefresh=true;
		me.refreshTime=me.jsonData.refresh;
		if(me.jsonData.useRefresh===false){
			me.useRefresh=false;
		}
		if(haveLocalization(me.jsonData.title)){
			me.title=getText(me.jsonData.title);
		}else{
			me.title=me.jsonData.title;
		}
		me.originalTitle=me.title;
		var tools=[];
		if(me.useRefresh===true){
			tools.push({
				type:'refresh',
				tooltip: getText("common.btn.reload"),
				handler: function(event, toolEl, panel){
					me.refreshDashboard.call(me);
				}
			});
		}
		if(me.useConfig===true){
			tools.push({
				type:'gear',
                tooltip: getText("common.btn.config"),
				handler:function(){
					me.configDashboard.call(me);
				}
			});
		}
		Ext.apply(this, {
			tools: tools
		});
		me.id="dashboard_"+me.jsonData.dashboardID;
		me.callParent();
		if(me.refreshTime>0){
			me.title=me.originalTitle+" ("+(me.refreshTime/1000)+" s)";
			setTimeout(function(thisObj) {thisObj.refreshDashboard();}, me.refreshTime, me);
		}
	},
	createErrorCmp:function(errorMessage){
		return Ext.create('Ext.Component',{
			cls:'infoBox1',
			html:errorMessage
		});
	},
	changeToError:function(errorMessage){
		var me=this;
		me.removeAll();
		me.add(me.createErrorCmp(errorMessage));
	},
	refreshErrorHandler:function(){
		var me=this;
		me.changeToError(getText('cockpit.err.tooManyItems'));
	},
	refreshDashboard:function(params){
		var me=this;
		var dashboardID=me.jsonData.dashboardID;
		var projectID=me.jsonData.projectID;
		var entityType=me.jsonData.entityType;
		var releaseID=me.jsonData.releaseID;
		var urlStr=com.trackplus.TrackplusConfig.contextPath+'/dashboardAJAX.action?dashboardID='+dashboardID+"&projectID="+projectID+"&releaseID="+releaseID;
		me.setLoading(true);
		Ext.Ajax.request({
			url: urlStr,
			disableCaching :true,
			success: function(result){
				var jsonData = Ext.decode(result.responseText);
				me.setLoading(false);
				if(jsonData.data.tooManyItems===true){
					me.refreshErrorHandler();
				}else{
					me.doRefresh.call(me,jsonData.data);
					me.refreshTime=me.jsonData.refresh;
					if(me.refreshTime>0){
						setTimeout(function(thisObj) {thisObj.refreshDashboard();}, me.refreshTime, me);
					}
					me.setTitle(me.updateTitle.call(me));
				}
			},
			failure: function(error){
				me.setLoading(false);
				//alert("error"+error.message);
			},
			method:"POST",
			params:params
		});
	},
	updateTitle:function(){
		var me=this;
		var title=me.originalTitle;
		if(me.refreshTime>0){
			title=me.originalTitle+" ("+(me.refreshTime/1000)+" s)";
		}
		return title;
	},
	createParamsMap:function() {
		return {};
	},
	doRefresh:function(jsonData){
	},
	configDashboard:function(){
		var me=this;
		var configURL="";
		var projectID=me.jsonData.projectID;
		var entityType=me.jsonData.entityType;
		var dashboardID=me.jsonData.dashboardID;
		var dashboardTitle =me.title;
		if(projectID){
			configURL="dashboardParamsConfig.action?projectID="+projectID+"&entityType="+entityType+"&dashboardID="+dashboardID;
		}else{
			configURL="dashboardParamsConfig.action?dashboardID="+dashboardID;
		}
		com.trackplus.dashboard.openConfigDialog(dashboardID,configURL,projectID,entityType,dashboardTitle, function(){
			me.refreshDashboard.call(me);
		});
	},
	addAll:function(destination,source){
		if(source&&source.length>0){
			for(var i=0;i<source.length;i++){
				destination.push(source[i]);
			}
		}
		return destination;
	}
});
Ext.define('js.ext.com.track.dashboard.Error',{
	extend:'js.ext.com.track.dashboard.DashboardRenderer',
	initComponent : function(){
		var me=this;
		me.html=me.createHtmlString();
		me.callParent();
	},
	createHtmlString:function(){
		var me=this;
		var htmlStr='<div style="height:100%;width:100%;padding:5px;">';
		htmlStr+="<i>No js class  found!</i>";
		htmlStr+='</div>';
		return htmlStr;
	},
	doRefresh:function(jsonData){
		var me=this;
		me.jsonData=jsonData;
		me.update(me.createHtmlString());
	}
});
com.trackplus.dashboard.createPercentGroup=function(title,list,dashboard){
	var gridData=list;
	if(title){
		gridData.unshift({
			label:title,
			h2:true,
			category:true
		});
	}
	var store = Ext.create('Ext.data.Store', {
		fields: [
			{name: 'label'},
			{name: 'number',type:'int'},
			{name: 'width',type:'int'},
			{name: 'percent',type: 'int'},
			{name: 'groupByFieldType',type: 'int'},
			{name: 'projectID',type: 'int',allowNull:true},
			{name: 'releaseID',type: 'int',allowNull:true},
			{name: 'openOnly',type: 'boolean'},
			{name: 'groupByField',type: 'int'},
			{name: 'icon'},
			{name: 'percentLate',type: 'int'},
			{name: 'category',type: 'boolean'},
			{name: 'h2',type: 'boolean'},
			{name: 'widthLate',type: 'int'}
		],
		data: gridData
	});
	var grid = Ext.create('Ext.grid.Panel', {
		cls:'dashboardGrid-noBottomBorder',
		store: store,
		columns: [
			{
				xtype:'linkcolumn',
				text	 :'label',
				width:175,
				sortable:false,
				menuDisabled:true,
				dataIndex: 'label',
				align:'right',
				handler:com.trackplus.dashboard.clickOnLabel,
				scope:dashboard,
				isLink:com.trackplus.dashboard.isLabelLink,
				postProcessRenderer:com.trackplus.dashboard.postProcessRendererLabel
			},{
				text	 :'number',
				width	: 70,
				sortable:false,
				menuDisabled:true,
				renderer : com.trackplus.dashboard.formatNumber,
				align:'right',
				dataIndex: 'number'
			},{
				text	 :'',
				width	: 75,
				sortable:false,
				menuDisabled:true,
				renderer : com.trackplus.dashboard.formatBars,
				dataIndex: 'percent'
			},{
				text	 :'',
				width	: 50,
				sortable:false,
				menuDisabled:true,
				renderer : com.trackplus.dashboard.formatPercent,
				dataIndex: 'percent'
			},{
				text	 :'',
				width:10,
				flex:1,
				sortable:false,
				menuDisabled:true
			}
		],
		border:false,
		bodyBorder:false,
		hideHeaders:true,
		columnLines :false,
		disableSelection: true,
		viewConfig: {
			stripeRows: true,
			trackOver  :false,
			style:{
				overflow:'hidden'
			},
			getRowClass: function(record, rowIndex, rp, ds){
				var cls="";
				if(record.data['category']===true){//grouping
					cls+="dashboardCategoryPercent";
				}
				return cls;
			}
		},
		autoHeight:true
	});
	return grid;
};
com.trackplus.dashboard.updateElementWrapperList=function(list,projectWrapper){
	if(list){
		var elmWrapper;
		for(var i=0;i<list.length;i++){
			elmWrapper=list[i];
			elmWrapper['groupByFieldType']=projectWrapper.groupByFieldType;
			elmWrapper['projectID']=projectWrapper.projectID;
			elmWrapper['releaseID']=projectWrapper.releaseID;
			elmWrapper['openOnly']=projectWrapper.openOnly;
		}
	}
	return list;
};
com.trackplus.dashboard.isLabelLink=function(value,metaData,record,rowIndex,colIndex,store,view){
	return !(record.data['category']===true);
};
com.trackplus.dashboard.postProcessRendererLabel=function(value,metaData,record,rowIndex,colIndex,store,view){
	var htmlStr='';
	if(record.data['category']===true){
		htmlStr='<div style="text-align:left;overflow: visible;">';
		if(record.data['h2']===true){
			htmlStr+='<h2>'+value+'</h2>';
		}else{
			htmlStr+='<B>'+value+'</B>';
		}
		htmlStr+='</div>';
	}else{
		htmlStr=value;
	}
	return htmlStr;
};
com.trackplus.dashboard.clickOnLabel=function(record,cellIndex){
	var me=this;//scope is current dashboard
	var groupByFieldType=record.data['groupByFieldType'];
	var projectID=record.data['projectID'];
	var releaseID=record.data['releaseID'];
	var openOnly=record.data['openOnly'];
	var groupByField=record.data['groupByField'];
	var urlStr='itemNavigator.action';
	var params={
		'queryType':2,//dashboard
		'queryID':me.jsonData.dashboardID,
		'dashboardParams.dashboardID':me.jsonData.dashboardID
	};
	var entityFlag=null;
	if(CWHF.isNull(projectID) && CWHF.isNull(releaseID)){
		projectID=me.jsonData.projectID;
        releaseID=me.jsonData.releaseID;
		entityFlag=me.jsonData.entityType;
        if (entityFlag) {
             if (entityFlag===9 && releaseID) {
                 projectID = releaseID;
             }
        }
	}else{
		if(releaseID){
			entityFlag=9;
            projectID=releaseID;
		}else{
			entityFlag=1;
		}
	}
	if(CWHF.isNull(openOnly)){
		openOnly=false;
	}
	params['dashboardParams.groupByFieldType']=groupByFieldType;
	params['dashboardParams.groupByField']=groupByField;
	params['dashboardParams.projectID']=projectID;
	params['dashboardParams.entityFlag']=entityFlag;
	params['dashboardParams.openOnly']=openOnly;
	var dummyForm = Ext.create('Ext.form.Panel', {
		items:[],
		url:urlStr,
		standardSubmit:true
	});
	dummyForm.getForm().submit({
		params:params
	});
};
com.trackplus.dashboard.formatNumber=function(value,metaData,record,rowIndex,colIndex,store,view){
	if(record.data.category){
		return "";
	}else{
		return value;
	}
};
com.trackplus.dashboard.formatBars=function(value,metaData,record,rowIndex,colIndex,store,view){
	var htmlStr='';
	if(record.data.category){
		htmlStr='';
	}else{
		htmlStr='<div class="barWrapper"> <img src="'+com.trackplus.TrackplusConfig.iconsPath+'BlueBar.gif" '+
			'width="'+record.data.width+'" height="10" alt="BlueBar"><img src="'+
			com.trackplus.TrackplusConfig.iconsPath+'RedBar.gif" '+
			'width="'+record.data.widthLate+'" height="10" alt="RedBar"></div>';
	}
	return htmlStr;
};
com.trackplus.dashboard.formatPercent=function(value,metaData,record,rowIndex,colIndex,store,view){
	var htmlStr='';
	if(record.data.category){
		htmlStr='';
	}else{
		htmlStr=value+"%";
	}
	return htmlStr;
};
com.trackplus.dashboard.reload=function(id){
	var dashComp=Ext.getCmp("dashboard_"+id);
	var extraParams=[];
	if(arguments.length>1){
		for(var i=1;i<arguments.length;i++){
			extraParams.push(arguments[i]);
		}
	}
	var params=dashComp.createParamsMap.apply(dashComp,extraParams);
	dashComp.refreshDashboard.call(dashComp,params);
};
com.trackplus.dashboard.createReportTreeCfg=function(label,name,values,projectID,extraCfg){
	var cfg = {
        anchor:'100%',
        margin: '0 0 5 0'
	};
	var labelWidth=150;
	var labelAlign='right';
	if(extraCfg){
		for (var propertyName in extraCfg) {
			if(propertyName==='labelAlign'){
				labelAlign=extraCfg[propertyName];
				continue;
			}
			if(propertyName==='labelWidth'){
				labelWidth=extraCfg[propertyName];
				continue;
			}
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
    cfg["useRemoveBtn"] = false;
    cfg["useNull"] = true;
    cfg["useTooltip"] = false;
    var reportTree = CWHF.createMultipleTreePicker(label,
        name, [], values, cfg);
    Ext.Ajax.request({
        url: "categoryPicker.action",
        params:{node:"report", useChecked: true},
        //scope:me,
        success: function(response){
            var children = Ext.decode(response.responseText);
            reportTree.updateMyOptions(children);
            reportTree.setValue(values);
        },
        failure: function(response){
            com.trackplus.util.requestFailureHandler(response);
        }
    });
    return reportTree;
};
com.trackplus.dashboard.createReleaseTreeCfg=function(label,name,values,extraCfg){
	var cfg={
		//height: 200
	}
	var labelWidth=150;
	var labelAlign='right';
	if(extraCfg){
		for (var propertyName in extraCfg) {
			if(propertyName==='labelAlign'){
				labelAlign=extraCfg[propertyName];
				continue;
			}
			if(propertyName==='labelWidth'){
				labelWidth=extraCfg[propertyName];
				continue;
			}
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
    cfg["useRemoveBtn"] = false;
    cfg["useNull"] = true;
    cfg["useTooltip"] = false;
    var releaseProjectTree = CWHF.createMultipleTreePicker(label,
        name, [], values, cfg)
    Ext.Ajax.request({
        url: "releasePicker.action",
        params:{useChecked: true},
        //scope:me,
        success: function(response){
            var children = Ext.decode(response.responseText);
            releaseProjectTree.updateMyOptions(children);
            releaseProjectTree.setValue(values);
        },
        failure: function(response){
            com.trackplus.util.requestFailureHandler(response);
        }
    });
    return releaseProjectTree;
};
com.trackplus.dashboard.wrapLabelAndTree=function(labelCmp, treeObject) {
	return Ext.create('Ext.container.Container', {
		border:false,
		layout: {
			type: 'hbox',
			pack: 'start',
			align: 'stretch'
		},
		items: [labelCmp, treeObject]
	});
};
com.trackplus.dashboard.getLabelCmp=function(label, labelAlign, labelWidth) {
	return Ext.create('Ext.Component',{
		cls:labelAlign==='right'?'x-form-item-label-right x-form-item-label':'x-form-item-label',
		style:{
			marginRight:'5px'
		},
		html:label+":",
		width:labelWidth
	});
};
com.trackplus.dashboard.createReleasePickerCfg=function(label,name,releaseID,extraCfg){
	var cfg={
		labelAlign:'right',
		labelWidth:100,
        //width:300,
        anchor:'100%',
        margin: '0 0 5 0'
	};
	if(extraCfg){
		for (var propertyName in extraCfg) {
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
    var picker = CWHF.createSingleTreePicker(label,
        name, [], releaseID, cfg);
    Ext.Ajax.request({
        url: "releasePicker.action",
        //scope:me,
        success: function(response){
            var projectReleaseTree = Ext.decode(response.responseText);
            picker.updateMyOptions(projectReleaseTree);
            picker.setValue(releaseID);
        },
        failure: function(response){
            com.trackplus.util.requestFailureHandler(response);
        }
    });
	//var picker=CWHF.createReleasePicker(label,name,cfg);
	//picker.setValue(releaseLabel);
	return picker;
};
com.trackplus.dashboard.createMultipleReleasePickerCfg=function(label,name,releaseID,extraCfg){
	var cfg={
		labelAlign:'right',
		labelWidth:100,
        //width:300,
        anchor:'100%',
        margin: '0 0 5 0'
	};
	if(extraCfg){
		for (var propertyName in extraCfg) {
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
    var picker = CWHF.createMultipleTreePicker(label,
        name, [], releaseID, cfg);
    Ext.Ajax.request({
        url: "releasePicker.action",
        //scope:me,
        success: function(response){
            var projectReleaseTree = Ext.decode(response.responseText);
            picker.updateMyOptions(projectReleaseTree);
            picker.setValue(releaseID);
        },
        failure: function(response){
            com.trackplus.util.requestFailureHandler(response);
        },
        params: {useChecked:true}
    });
	//var picker=CWHF.createReleasePicker(label,name,cfg);
	//picker.setValue(releaseLabel);
	return picker;
};
com.trackplus.dashboard.createFilterPickerCfg=function(label,name,queryID,extraCfg){
	var cfg={
		allowBlank:false,
		labelWidth:100,
		labelAlign:'right',
		//width:300
		anchor:'100%',
        margin: '0 0 5 0'
	};
	if(extraCfg){
		for (var propertyName in extraCfg) {
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
	var picker = CWHF.createSingleTreePicker(label, name, [], queryID, cfg);
	Ext.Ajax.request({
		url: "categoryPicker.action",
		params: {node:"issueFilter"},
		success: function(response){
			var filterTree = Ext.decode(response.responseText);
			picker.updateMyOptions(filterTree);
			picker.setValue(queryID);
		},
		failure: function(response){
			com.trackplus.util.requestFailureHandler(response);
		}
	});
	return picker;
};
com.trackplus.dashboard.createMultiSelectConfig=function(label,name,data,value,extraCfg){
	var cfg={
		fieldLabel:label,
		labelAlign:'right',
		name:name,
		store: Ext.create('Ext.data.Store', {
			data	: data,
			fields	: [{name:'id', type:'int'}, {name:'label', type:'string'}],
			autoLoad: false
		}),
		border:true,
		bodyBorder:false,
		displayField: 'label',
		valueField: 'id',
		value:value,
		width:300,
		height:125
	};
	if(extraCfg){
		for (var propertyName in extraCfg) {
			cfg[propertyName] = extraCfg[propertyName];
		}
	}
	return Ext.create('Ext.ux.form.MultiSelect',cfg);
};
com.trackplus.dashboard.createSelectConfig=function(label,name,data,value,handler,scope){
	return Ext.create('Ext.form.ComboBox',{
		fieldLabel:label,
		hideLabel:(CWHF.isNull(label)),
		name:name,
		store: Ext.create('Ext.data.Store', {
			data	:(CWHF.isNull(data)?[]:data),
			fields	: [{name:'id', type:'int'}, {name:'label', type:'string'}],
			autoLoad: false
		}),
		border:false,
		bodyBorder:false,
		displayField: 'label',
		valueField: 'id',
		queryMode: 'local',
		value:value,
		width:(CWHF.isNull(label)? 150:300),
		labelAlign:'right',
		listeners: {
			change: function(cmb, newValue, oldValue, options) {
				if(handler){
					handler.call(scope,cmb, newValue, oldValue, options);
				}
			}
		}
	});
};
com.trackplus.dashboard.createMultiSelectComboConfig=function(label,name,data,value,handler,scope){
	return Ext.create('Ext.form.ComboBox',{
		fieldLabel:label,
		hideLabel:(CWHF.isNull(label)),
		name:name,
		store: Ext.create('Ext.data.Store', {
			data	:(CWHF.isNull(data)?[]:data),
			fields	: [{name:'id', type:'int'}, {name:'label', type:'string'}],
			autoLoad: false
		}),
		border:false,
		bodyBorder:false,
		displayField: 'label',
		valueField: 'id',
		queryMode: 'local',
		value:value,
		width:(CWHF.isNull(label)? 150:300),
		labelAlign:'right',
		multiSelect: true,
		listeners: {
			change: function(cmb, newValue, oldValue, options) {
				if(handler){
					handler.call(scope,cmb, newValue, oldValue, options);
				}
			}
		}
	});
};
com.trackplus.dashboard.createRadioGroupConfig=function(label,name,options,value,handler,scope){
	var items=[];
	if(options){
		for(var i=0;i<options.length;i++){
			items.push({
				name:name,
				inputValue: options[i].id,
				//id:id+"_"+options[i].id,
				boxLabel:options[i].label,
				checked:options[i].id===value
			});
		}
	}
	var inputComp=Ext.create('Ext.form.RadioGroup',{
		fieldLabel:label,
		labelStyle:{overflow:'hidden'},
		labelWidth:100,
		labelAlign:'right',
		anchor:'100%',
		layout: 'hbox',
		defaults:{margin:'0 5 0 0'},
		listeners: {
			change: function(radioGroup, newValue, oldValue, options) {
				if(handler){
					handler.call(scope,radioGroup, newValue, oldValue, options);
				}
			}
		},
		items:items
	});
	return inputComp;
};
var dashboardCfgWin;
com.trackplus.dashboard.showConfigDialog=function(dashboardID,data,projectID,entityType,dashboardTitle, handlerCallback,scopeCallBack){
	var w=600;
	var h=400;
	var title=getText('cockpit.screenEdit.config.title');
	if(dashboardTitle){
		title=title+" : "+dashboardTitle;
	}
	if(dashboardCfgWin){
		dashboardCfgWin.destroy();
	}
	var cfgClass=data.cfgClass;
	var prefWidth=data.jsonData.prefWidth;
	var prefHeight=data.jsonData.prefHeight;
	if(prefWidth){
		w=prefWidth;
	}
	if(prefHeight){
		h=prefHeight;
	}
	var dashboardConfigPanel=Ext.create(cfgClass,{
		projectID:data.projectID,
		entityType:data.entityType,
		jsonData:data.jsonData,
		bodyStyle:{
			padding:'10px'
		}
	});
	var size=borderLayout.ensureSize(w,h);
	w=size.width;
	h=size.height;
	dashboardCfgWin = Ext.create('Ext.window.Window',{
		layout	  : 'fit',
		width	   : w,
		height	  : h,
		iconCls:'btnConfig16',
		cls:'bottomButtonsDialog',
		border:false,
		bodyBorder:true,
		margin:'0 0 0 0',
		style:{
			padding:'5px 0px 0px 0px'
		},
		closeAction :'hide',
		plain	   : true,
		title		 :title,
		modal	   :true,
		items	   :dashboardConfigPanel,
		autoScroll  :false,
		buttons: [
			{text :getText('common.btn.save'),
				handler  : function(){
					saveDashParams(dashboardID,dashboardConfigPanel,projectID,entityType, handlerCallback,scopeCallBack);
				}
			},{
				text :getText('common.btn.close'),
				handler  : function(){
					dashboardCfgWin.hide();
				}
			}
		]
	 });
	 dashboardCfgWin.show();
};
com.trackplus.dashboard.openConfigDialog=function(dashboardID,urlStr,projectID,entityType,dashboardTitle, handlerCallback,scopeCallBack){
	borderLayout.setLoading(true);
	Ext.Ajax.request({
		url:urlStr,
		success: function(response){
			var jsonData=Ext.decode(response.responseText);
			com.trackplus.dashboard.showConfigDialog(dashboardID,jsonData.data,projectID,entityType,dashboardTitle, handlerCallback,scopeCallBack);
			borderLayout.setLoading(false);
		},
		failure:function(response){
			borderLayout.setLoading(false);
		}
	});
};
function saveDashParams(dashboardID,dashboardConfigPanel,projectID,entityType, handler,scope){
	var urlSave="";
	if(projectID){
		urlSave="dashboardParamsConfig!save.action?projectID="+projectID+"&entityType="+entityType+"&dashboardID="+dashboardID;
	}else{
		urlSave="dashboardParamsConfig!save.action?dashboardID="+dashboardID;
	}
	if(!dashboardConfigPanel.isValidParams.call(dashboardConfigPanel)){
		return false;
	}
	dashboardCfgWin.setLoading(true);
	dashboardConfigPanel.getForm().submit({
		url: urlSave,
		success: function(form, action) {
			dashboardCfgWin.setLoading(false);
			dashboardCfgWin.hide();
			if(handler){
				handler.call(scope);
			}
		},
		failure: function(form, action) {
			dashboardCfgWin.setLoading(false);
		}
	});
	//var params=dashboardConfigPanel.getParameters.call(dashboardConfigPanel);
	/*Ext.Ajax.request({
		url: urlSave,
		disableCaching:true,
		success: function(result){
		},
		failure: function(){
			alert("failure");
		},
		method:'POST',
	}); */
}
Ext.define('com.trackplus.screen.DashboardFieldErrorView',{
	extend:'com.trackplus.screen.FieldErrorView',
	margin: '0 0 5 5',
	frame: true,
	style:{
		borderColor:'red'
	},
	collapsible:true,
	padding:0,
	title:'Dashboard field error'
});
Ext.define('com.trackplus.screen.DashboardTabView',{
    extend: 'com.trackplus.screen.TabView',
    layout:{
        type:'anchor'
    },
    defaults:{
        anchor:'100%'
    },
    autoScroll:true,
	bodyStyle:{}
});
Ext.define('com.trackplus.screen.DashboardPanelView',{
	extend:'com.trackplus.screen.PanelView',
	getPanelConfig:function(panelModel,index,length){
		var me=this;
		var margins='0 5 2 0';
		if(index===0){
			margins='5 5 2 0';
		}
		return {
			style: {
				overflow:'hidden'
			},
			border:false,
			margin	 : margins,
			cls:'dashboardPanel',
			layout: {
				type: 'table',
				columns: panelModel.colsNo,
				tableAttrs: {
					style: {
						width: '100%',
						tableLayout:'fixed'
					}
				},
				tdAttrs:{
					style:{
						'vertical-align':'top'
					}
				}
			},
			defaults: {
				frame:false,
				border: false
			}
		};
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.HomeLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	screenModel:null,
	screenFacade:null,
	selectedGroup:'cockpit',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.screenModel=com.trackplus.screen.createScreenModel(me.initData.screen);
		me.screenFacade= Ext.create('com.trackplus.screen.BaseScreenFacade',{
			screenModel:me.screenModel,
			showOneTab:true,
			lastSelectedTab:me.initData.lastSelectedTab,
			refreshTabUrl:'dashboardTabRuntime!execute.action',
			storeTabUrl:'dashboard!storeLastSelectedTab.action',
            tabViewCls:'com.trackplus.screen.DashboardTabView',
			panelViewCls:'com.trackplus.screen.DashboardPanelView',
			fieldErrorCls:'com.trackplus.screen.DashboardFieldErrorView'
		});
		me.borderLayoutController.setHelpContext("dashboard");
		me.onReady(function(){
			if (com.trackplus.TrackplusConfig.user.configureCockpit) {
				var dashToolbar=[me.createEditDashButton()];
				if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
					dashToolbar.push(me.createResetDashButton());
					dashToolbar.push(me.createSaveAsTemplateDashButton());
				}
				me.borderLayoutController.setActiveToolbarList.call(me.borderLayoutController,dashToolbar);
			}
		});
	},
	createCenterPanel:function(){
		var me=this;
		return me.screenFacade.createViewComponent.call(me.screenFacade);
	},
	createEditDashButton:function(){
		var me=this;
		return Ext.create('Ext.button.Button',{
			xtype:'button',
			overflowText:getText('cockpit.config'),
			tooltip:getText('cockpit.config.tt'),
			text: getText('cockpit.config'),
			iconCls: 'cockpitEdit',
			disabled:false,
			handler:function(){
				me.editDashboard();
			}
		});
	},
	createResetDashButton:function(){
		var me=this;
		return Ext.create('Ext.button.Button',{
			xtype:'button',
			overflowText:getText('cockpit.reset'),
			tooltip:getText('cockpit.reset'),
			text: getText('cockpit.reset'),
			iconCls: 'cockpitReset',
			disabled:false,
			handler:function(){
				me.resetDashboard();
			}
		});
	},
	createSaveAsTemplateDashButton:function(){
		var me=this;
		return Ext.create('Ext.button.Button',{
			xtype:'button',
			overflowText:getText('cockpit.saveAsTemplate'),
			tooltip:getText('cockpit.saveAsTemplate.tooltip'),
			text: getText('cockpit.saveAsTemplate'),
			iconCls: 'cockpitSave',
			disabled:false,
			handler:function(){
				me.saveAsDefault();
			}
		});
	},
	editDashboard:function(){
		window.location.href='dashboardEdit.action?backAction=cockpit.action';
	},
	resetDashboard:function(){
		var me=this;
		com.trackplus.dashboard.resetDashboard('dashboardTemplate!resetDashboard.action',{}, me.resetDashboardSuccess,me);
	},
	resetDashboardSuccess:function(){
		window.location.href='cockpit.action';
	},
	saveAsDefault:function(){
		var me=this;
		com.trackplus.dashboard.saveAsDefault();
	}
});
com.trackplus.dashboard.resetWin=null;
com.trackplus.dashboard.resetDashboard=function(url,params,handlerCallback,scopeCallBack){
	var urlStr='dashboardTemplate!loadNotAssigned.action';
	borderLayout.setLoading(true);
	Ext.Ajax.request({
		url: urlStr,
		disableCaching:true,
		success: function(response){
			var jsonData=Ext.decode(response.responseText);
			var options=jsonData.data;
			borderLayout.setLoading(false);
			com.trackplus.dashboard.openResetDialog(options,url,params,handlerCallback,scopeCallBack);
		},
		failure: function(){
			borderLayout.setLoading(false);
			//alert("failure");
		}
	});
};
com.trackplus.dashboard.openResetDialog=function(options,urlStr,params,handlerCallback,scopeCallBack){
	var store = Ext.create('Ext.data.Store', {
		fields	: [{name:'id', type:'int'}, {name:'label', type:'string'},{name:'selected',type:'bool'}],
		data :options
	});
	var cmb=Ext.create('Ext.form.ComboBox', {
		store: store,
		queryMode: 'local',
		displayField: 'label',
		valueField: 'id',
		editable: false,
		name:'resetID',
		fieldLabel : getText('cockpit.reset.lbl.defaultCockpit'),
		labelStyle:{overflow:'hidden'},
		labelAlign:'right',
		labelWidth:150,
		anchor:'100%'
	});
	var btnDelete=Ext.create('Ext.button.Button',{
		text:getText('common.btn.delete'),
		disabled:true,
		handler:function(){
			borderLayout.setLoading(true);
			var id= cmb.getValue();
			var urlDeleteItems="dashboardAssign!delete.action";
			var messageConfirmDelete=getText("common.lbl.messageBox.removeSelected.confirm");
			var titleDelete=getText("common.btn.delete");
			var okLabel=getText("common.btn.ok");
			Ext.MessageBox.show({
				title:titleDelete,
				msg: messageConfirmDelete,
				//buttons:{yes : yesLabel, no : noLabel},
				buttons: Ext.MessageBox.YESNO,
				fn: function(btn){
					if(btn==="yes"){
						var deletedItems=id;
						Ext.Ajax.request({
							url: urlDeleteItems,
							disableCaching:true,
							success: function(){
								var urlStr='dashboardTemplate!loadNotAssigned.action';
								Ext.Ajax.request({
									url: urlStr,
									disableCaching:true,
									success: function(response){
										var jsonData=Ext.decode(response.responseText);
										var options=jsonData.data;
										btnDelete.setDisabled(true);
										cmb.setValue(null);
										cmb.getStore().loadData(options);
										borderLayout.setLoading(false);
									},
									failure: function(){
										borderLayout.setLoading(false);
										//alert("failure");
									}
								});
							},
							failure: function(){
								borderLayout.setLoading(false);
							},
							method:'POST',
							params:{"deletedItems":deletedItems}
						});
					}
				},
				//animEl: 'mb4',
				icon: Ext.MessageBox.QUESTION
			});
		}
	});
	cmb.addListener('select',function( combo, records, eOpts){
		if(records&&records.length>0){
			var selected=records[0].data['selected'];
			var id=records[0].data['id'];
			btnDelete.setDisabled(!selected);
		}else{
			btnDelete.setDisabled(true);
		}
	});
	var formPanel=Ext.create('Ext.form.Panel',{
		layout:'anchor',
		standardSubmit:false,
		bodyBorder:false,
		border    : false,
		autoScroll:false,
		margin: '0 0 0 0',
		bodyStyle:{
			padding:'10px 10px 5px 10px'
		},
		/*style:{
		 borderBottom:'1px solid #D0D0D0'
		 },*/
		items:[cmb]
	});
	if(com.trackplus.dashboard.resetWin){
		com.trackplus.dashboard.resetWin.destroy();
	}
	com.trackplus.dashboard.resetWin = Ext.create('Ext.window.Window',{
		layout      : 'fit',
		width       : 400,
		height      : 115,
		minWidth:360,
		minHeight:115,
		closeAction :'destroy',
		plain       : true,
		title		 : getText('cockpit.reset'),
		modal       : true,
		cls:'bottomButtonsDialog',
		border:false,
		bodyBorder:true,
		margin:'0 0 0 0',
		style:{
			padding:'5px 0px 0px 0px'
		},
		bodyPadding:'0px',
		autoScroll  : false,
		items       : [formPanel],
		buttons     : [
			{text:getText('common.btn.ok') ,handler  :function(){
				formPanel.getForm().submit({
					url:urlStr,
					params:params,
					success: function(form, action) {
						com.trackplus.dashboard.resetWin.destroy();
						if(handlerCallback){
							handlerCallback.call(CWHF.isNull(scopeCallBack)?this:scopeCallBack);
						}
					},
					failure: function(form, action) {
						alert("failure");
					}
				});
			}},btnDelete,
			{text:getText('common.btn.cancel'),handler  :function(){com.trackplus.dashboard.resetWin.destroy();}}
		]
	});
	com.trackplus.dashboard.resetWin.show();
};
com.trackplus.dashboard.saveAsDefault=function(projectID,entityType,handlerCallback,scopeCallBack){
	var urlStr='dashboardTemplate!copyAsTemplateDashboard.action';
	if(projectID){
		urlStr=urlStr+"?projectID="+projectID+"&entityType="+entityType;
	}
	borderLayout.setLoading(true);
	Ext.Ajax.request({
		url: urlStr,
		disableCaching:true,
		success: function(response){
			var jsonData=Ext.decode(response.responseText);
			borderLayout.setLoading(false);
			com.trackplus.dashboard.openSaveAsDefaultDialog(jsonData.data);
		},
		failure: function(){
			borderLayout.setLoading(false);
		}
	});
};
com.trackplus.dashboard.openSaveAsDefaultDialog=function(data,handlerCallback,scopeCallBack){
	var items=[
		CWHF.createHiddenField('dashboardID',{itemId:'dashboardID',labelWidth:150,value:data.id}),
		CWHF.createTextField('common.lbl.name','name', {labelWidth:150,anchor:'100%', allowBlank:false,value:data.name}),
		CWHF.createTextAreaField('common.lbl.description','description', {labelWidth:150,anchor:'100%',value:data.description})
	];
	var formPanel=Ext.create('Ext.form.Panel',{
		layout:'anchor',
		standardSubmit:false,
		bodyBorder:false,
		border    : false,
		autoScroll:false,
		margin: '0 0 0 0',
		bodyStyle:{
			padding:'10px 10px 5px 10px'
		},
		defaults: {
			labelStyle:'overflow: hidden;',
			labelWidth:150,
			msgTarget:	'under',
			anchor:'100%'
		},
		/*style:{
		 borderBottom:'1px solid #D0D0D0'
		 },*/
		items:items
	});
	var urlStr="dashboardTemplate!saveAsTemplateDashboard.action";
	if(com.trackplus.dashboard.resetWin){
		com.trackplus.dashboard.resetWin.destroy();
	}
	com.trackplus.dashboard.resetWin = Ext.create('Ext.window.Window',{
		layout      : 'fit',
		width       : 500,
		height      : 300,
		minWidth:400,
		minHeight:300,
		closeAction :'destroy',
		plain       : true,
		title		 : getText('cockpit.saveAsTemplate'),
		modal       : true,
		cls:'bottomButtonsDialog',
		border:false,
		bodyBorder:true,
		margin:'0 0 0 0',
		style:{
			padding:'5px 0px 0px 0px'
		},
		bodyPadding:'0px',
		autoScroll  : false,
		items       : [formPanel],
		buttons     : [
			{text:getText('common.btn.ok') ,handler  :function(){
				formPanel.getForm().submit({
					url:urlStr,
					success: function(form, action) {
						com.trackplus.dashboard.resetWin.destroy();
						if(handlerCallback){
							handlerCallback.call(CWHF.isNull(scopeCallBack)?this:scopeCallBack);
						}else{
							CWHF.showMsgInfo(getText('cockpit.saveAsTemplate.successMessage'));
						}
					},
					failure: function(form, action) {
						alert("failure");
					}
				});
			}},
			{text:getText('common.btn.cancel'),handler  :function(){com.trackplus.dashboard.resetWin.destroy();}}
		]
	});
	com.trackplus.dashboard.resetWin.show();
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/*ScreenController.instance=new ScreenController("updateDashboardScreenProperty","dashboardEdit");
TabController.instance=new TabController("","dashboardTab");
PanelController.instance=new PanelController("updateDashboardPanelProperty","dashboardPanel");
FieldScreenController.instance=new FieldScreenController("updateDashboardFieldProperty","dashboardField");*/
Ext.define('js.ext.com.track.dashboard.DashboardFieldEditWrapper',{
	extend: 'com.trackplus.screen.FieldEditWrapperView',
	emptyText:getText('cockpit.screenEdit.lbl.emptyField'),
	getFieldCls:function(){
		return "dashboardDesignField";
	},
	getFieldWrapperConfig:function(){
		var me=this;
		if(me.model.empty){
			return me.callParent();
		}
		return {
			border: true,
			margin: '0 0 5 5',
			frame: true,
			collapsible:false,
			bodyPadding: 2,
			padding:0,
			title:me.model.name
		}
	}
});
Ext.define('com.trackplus.screen.DashboardEditPanelView',{
	extend:'com.trackplus.screen.PanelView',
	getPanelConfig:function(panelModel,index,length){
		var me=this;
		var cls="screenDesignPanel";
		var margin='0 0 5 0';
		me.myComponentCls=cls;
		return {
			cls:cls,
			style: {
				overflow:'hidden'
			},
			border:true,
			bodyPadding:2,
			margin	 : margin,
			layout: {
				type: 'table',
				columns: panelModel.colsNo,
				tableAttrs: {
					style: {
						width: '100%'
					}
				},
				tdAttrs:{
					width:(100/panelModel.colsNo)+'%',
					style:{
						'vertical-align':'top'
					}
				}
			},
			defaults: {
				frame:false,
				border: false
			}
		};
	}
});
Ext.define('com.trackplus.screen.DashboardScreenEditController',{
	extend:'com.trackplus.screen.ScreenEditController',
	isConfigurableItem:function(){
		var me=this;
		var me=this;
		var model=me.selectedComponent.model;
		var compType=model.type;
		return (compType==="Field");
	},
	configItem:function(){
		var me=this;
		var model=me.selectedComponent.model;
		var compType=model.type;
		if(compType==="Field"){
			var  dashboardID=model.getId();
			var url=me.configURL+dashboardID;
			com.trackplus.dashboard.openConfigDialog(dashboardID,url);
		}
	}
});
Ext.define('com.trackplus.layout.DashboardEditLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	screenEditFacade:null,
	screenModel:null,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("dashboardEdit");
		me.screenModel=com.trackplus.screen.createScreenModel(me.initData.screen);
		me.screenEditFacade = Ext.create('com.trackplus.screen.ScreenEditFacade',{
			screenModel:me.screenModel,
			refreshTabUrl:'dashboardTab!reload.action',
			controllerCls:'com.trackplus.screen.DashboardScreenEditController',
			fieldWrapperCls:'js.ext.com.track.dashboard.DashboardFieldEditWrapper',
			panelViewCls:'com.trackplus.screen.DashboardEditPanelView',
			urlFieldList:'dashboardPluginList!list.action',
			titleFieldList:getText("cockpit.screenEdit.lbl.views"),
			useConfig:true,
			configURL:me.initData.configURL,
			screenAction:'dashboardEdit',
			screenUpdateAction:'updateDashboardScreenProperty',
			tabAction:'dashboardTab',
			tabUpdateAction:'updateDashboardTabProperty',
			panelAction:'dashboardPanel',
			panelUpdateAction:'updateDashboardPanelProperty',
			fieldAction:'dashboardField',
			fieldUpdateAction:'updateDashboardFieldProperty',
			messageDeletePanel:getText('cockpit.screenEdit.question.deletePanel'),
			messageDeleteTab:getText('cockpit.screenEdit.question.deleteTab'),
			messageDeleteField:getText('cockpit.screenEdit.question.deleteField'),
			messageCantDeleteScreen:getText('cockpit.screenEdit.message.cantDeleteScreen'),
			messageCantDeleteLastTab:getText('cockpit.screenEdit.message.cantDeleteLastTab'),
			backAction:me.initData.backAction
		});
		me.onReady(function(){
			var dashToolbar=me.screenEditFacade.getToolbar.call(me.screenEditFacade);
			me.borderLayoutController.setActiveToolbarActionList(dashToolbar);
		});
	},
	createCenterPanel:function(){
		var me=this;
		return me.screenEditFacade.createScreenEditViewComponent.call(me.screenEditFacade);
	}
});

/* Copyright (C) 2012 Trackplus
 * $Id$
 */
Ext.define('Ext.ux.LinkComponent', {
	extend: 'Ext.Component',
	alias: ['widget.linkcomponent'],
	config:{
		handler:null,
		scope:null,
		clsLink:'synopsis_blue',
		label:'',
		prefix:null,
		suffix:null
	},
	initComponent: function(){
		var me=this;
		me.initHTML();
		me.callParent();
		me.addListener('afterrender',function(comp){
			comp.getEl().addListener('click',me.elementClick,me);
		},me);
	},
	initHTML:function(){
		var me=this;
		if(me.label!=null){
			me.html='<a class="'+me.clsLink+'" href="javascript:void(0)">'+me.label+'</a>'
			if(me.prefix!=null){
				me.html=me.prefix+me.html;
			}
			if(me.suffix!=null){
				me.html=me.html+me.suffix;
			}
		}else{
			me.html='';
		}
	},
	setLabel:function(label){
		var me=this;
		me.label=label;
		me.initHTML();
		me.update(me.html);
	},
	setClsLink:function(clsLink){
		var me=this;
		me.clsLink=clsLink;
		me.initHTML();
		me.update(me.html);
	},
	elementClick:function(e){
		var me=this;
		var match = e.getTarget().className.indexOf(me.clsLink)!=-1;
		if(match){
			if(me.handler!=null){
				me.handler.call(me.scope||me);
			}
			e.stopEvent();
			return false;
		}
	},
	getMyLabel:function(){
		var me=this;
		return me.label;
	}
});

/**
 * This layout manager is used to center contents within a container. As a subclass of
 * {@link Ext.layout.container.Fit fit layout}, CenterLayout expects to have one child
 * item; multiple items will be placed overlapping. The layout does not require any config
 * options. Items in the container can use percentage width or height rather than be fit
 * to the full size of the container.
 *
 * Example usage:
 *
 *	  // The content panel is centered in the container
 *
 *	  var p = Ext.create('Ext.Panel', {
 *		  title: 'Center Layout',
 *		  layout: 'ux.center',
 *		  items: [{
 *			  title: 'Centered Content',
 *			  width: '75%',  // assign 75% of the container width to the item
 *			  html: 'Some content'
 *		  }]
 *	  });
 *
 * If you leave the title blank and specify no border you can create a non-visual, structural
 * container just for centering the contents.
 *
 *	  var p = Ext.create('Ext.Container', {
 *		  layout: 'ux.center',
 *		  items: [{
 *			  title: 'Centered Content',
 *			  width: 300,
 *			  height: '90%', // assign 90% of the container height to the item
 *			  html: 'Some content'
 *		  }]
 *	  });
 */
Ext.define('Ext.ux.layout.Center', {
	extend: 'Ext.layout.container.Fit',
	alias: 'layout.ux.center',
	config:{
		maxWidth:null
	},
	percentRe: /^\d+(?:\.\d+)?\%$/,
	itemCls: 'ux-layout-center-item',
	initLayout: function () {
		this.callParent(arguments);
		this.owner.addCls('ux-layout-center');
	},
	getItemSizePolicy: function (item) {
		var policy = this.callParent(arguments);
		if (typeof item.width == 'number') {
			policy = this.sizePolicies[policy.setsHeight ? 2 : 0];
		}
		return policy;
	},
	getPos: function (itemContext, info, dimension) {
		var size = itemContext.props[dimension] + info.margins[dimension],
			pos = Math.round((info.targetSize[dimension] - size) / 2);
		return Math.max(pos, 0);
	},
	getSize: function (item, info, dimension) {
		var ratio = item[dimension];
		if (typeof ratio == 'number') {
			return ratio - info.margins[dimension];
		}
		if (typeof ratio == 'string' && this.percentRe.test(ratio)) {
			ratio = parseFloat(ratio) / 100;
		} else {
			ratio = item[dimension + 'Ratio']; // backwards compat
		}
		return info.targetSize[dimension] * (ratio || 1) - info.margins[dimension];
	},
	positionItemX: function (itemContext, info) {
		var left = this.getPos(itemContext, info, 'width');
		itemContext.setProp('x', left);
	},
	positionItemY: function (itemContext, info) {
		var top = this.getPos(itemContext, info, 'height');
		itemContext.setProp('y', top);
	},
	setItemHeight: function (itemContext, info) {
		var height = this.getSize(itemContext.target, info, 'height');
	   itemContext.setHeight(height);
	},
	setItemWidth: function (itemContext, info) {
		var width = this.getSize(itemContext.target, info, 'width');
		if(this.maxWidth!=null){
			if(width>this.maxWidth){
				width=this.maxWidth;
			}
		}
		itemContext.setWidth(width);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.ACField', {
    extend: 'Ext.form.field.Text',
    initComponent: function() {
        Ext.each(this.fieldSubTpl, function(oneTpl, idx, allItems) {
            if (Ext.isString(oneTpl)) {
                allItems[idx] = oneTpl.replace('autocomplete="off"', 'autocomplete="on"');
            }
        });
        this.callParent(arguments);
    }
});
Ext.define('com.trackplus.logon.LogonPage',{
	extend:'Ext.Base',
	config: {
		context: 1,
		jsonData: null
	},
	constructor: function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	logonView:null,
	logonController:null,
	createCenterPanel:function(){
		var me=this;
		me.logonController=Ext.create('com.trackplus.logon.LogonPageController',{
			model:me.jsonData
		});
		me.logonView=me.logonController.createView.call(me.logonController);
		if(isDemo){
			me.infoMessage=Ext.create('Ext.Component',{
				html: initData.teaserText,
				border:true,
				cls:'infoBoxDemoSite',
				region:'north'
			});
			var cmpLogin=Ext.create('Ext.panel.Panel',{
				region: 'center',
				cls:'logonPageWrapper',
				border: false,
				baseCls:'x-plain',
				unstyled: true,
				layout:{
					type:'ux.center',
					maxWidth:me.logonController.WIDTH_COLLAPSED
				},
				items:[me.logonView]
			});
			return Ext.create('Ext.panel.Panel',{
				region: 'center',
				border: false,
				baseCls:'x-plain',
				unstyled: true,
				layout:{
					type:'border',
					maxWidth:me.logonController.WIDTH_COLLAPSED
				},
				items:[me.infoMessage,cmpLogin]
			});
		}else{
			return Ext.create('Ext.panel.Panel',{
				region: 'center',
				cls:'logonPageWrapper',
				border: false,
				baseCls:'x-plain',
				unstyled: true,
				layout:{
					type:'ux.center',
					maxWidth:me.logonController.WIDTH_COLLAPSED
				},
				items:[me.logonView]
			});
		}
	},
	setFocus:function(){
		this.logonController.setFocus.call(this.logonController);
	}
});
Ext.define('com.trackplus.logon.LogonPageView',{
	extend: 'Ext.form.Panel',
	config:{
		model:{},
		logonController:null
	},
	id: 'logonpageview', //custom
	url:'logon!login.action',
	standardSubmit : false,
	title:getText('common.btn.login'),
	/*header:{
		height:38
	},*/
	//iconCls: 'custom_lock', //'login16',
	layout:'border',
	txtHiddenPassword:null,
	txtUsername:null,
	txtPassword:null,
	linkForgotPassword:null,
	linkSelfRegistration:null,
	cmpMotd:null,
	linkExpandMOTD:null,
	toolExpanCollapse:null,
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.height=me.logonController.HEIGHT_COLLAPSED;
		me.width='100%';
		//me.width=me.logonController.WIDTH_COLLAPSED;
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		me.txtHiddenPassword=Ext.create('com.trackplus.ACField',{
			hidden:true,
			name:'j_password',
			inputId: 'password'
		});
		me.txtUsername=Ext.create('com.trackplus.ACField',{
			cls:'loginInputField',
			fieldLabel:getText('logon.lbl.username'),
			labelAlign :'right',
			itemId :'j_username',
			name:'j_username',
			inputId: 'username',
			allowBlank :false,
			validateOnBlur :false,
			validateOnChange:true,
			tabIndex:1,
			width:310,
			value:Ext.util.Cookies.get('username'),//  me.model.j_username,
			blankText:getText('logon.err.username.required')
		});
		me.txtPassword=Ext.create('Ext.form.field.Text',{
			cls:'loginInputField',
			fieldLabel: getText('logon.lbl.password'),
			labelAlign :'right',
			inputType: 'password',
			name:'k_password',
			itemId:'k_password',
			allowBlank :false,
			validateOnBlur :false,
			validateOnChange:true,
			submitValue: false,
			tabIndex:2,
			width:310,
			value:Ext.util.Cookies.get('passwd'),
			blankText:com.trackplus.TrackplusConfig.getText('logon.err.password.required')
			//addChildEls:me.linkForgotPassword
		});
		me.btnLogin=Ext.create('Ext.button.Button',{
			text: getText('common.btn.login'),
			tabIndex:3,
			formBind: true, //only enabled once the form is valid
			handler: me.logonController.login,
			scope:me.logonController,
			minWidth:75
		});
		if(com.trackplus.TrackplusConfig.isSelfRegAllowed){
			me.linkSelfRegistration=Ext.create('Ext.ux.LinkComponent',{
				handler:me.logonController.selfRegistration,
				scope:me.logonController,
				id: 'registerLink',
				clsLink:'registerLink',
				tabIndex:10,
				//hidden:true,
				hideMode:'offsets',
				style:{
					opacity:0
				},
				width: 310,
				label:getText("logon.lbl.register")
			});
		}
		me.linkForgotPassword=Ext.create('Ext.ux.LinkComponent',{
			handler:me.logonController.forgetPassword,
			scope:me.logonController,
			id: 'pw_forgot',
			clsLink:'forgotPwd',
			tabIndex:4,
			style:{
				opacity:0
			},
			hideMode:'offsets',
			width: 310,
			label:getText("logon.lbl.passwordForgotten")
		});
		me.checkRemeberMe=Ext.create('Ext.form.field.Checkbox',{
			boxLabel  : getText('logon.lbl.remember'),
			fieldLabel: '&nbsp;',
			labelSeparator:'',
			labelAlign :'right',
			cls:'rememberMe',
			name: 'rememberME',
			style:{
				opacity:0
			},
			//hidden:true,
			hideMode:'offsets',
			width: 310,
			tabIndex:5,
			inputValue : true,
			checked : Ext.util.Cookies.get('rememberMe')==='true'
		});
		var panelUsername=Ext.create('Ext.container.Container',{
			layout: {
				type:'vbox',
				padding:'0',
				align:'left'
			},
			id:'usernamePanel',
			//height:42,
			width:310,
			border:false,
			items:[me.txtUsername, me.checkRemeberMe]
		});
		var pwdItems=[];
		pwdItems.push(me.txtPassword);
		pwdItems.push(me.linkForgotPassword);
		if(me.linkSelfRegistration){
			pwdItems.push(me.linkSelfRegistration);
		}
		var panelPassword=Ext.create('Ext.container.Container',{
			layout: {
				type:'vbox',
				padding:'0',
				align:'left'
			},
			id:'passwordPanel',
			//height:58,
			width:310,
			border:false,
			bodyBorder:false,
			items:pwdItems
		});
		var items=[];
		items.push(panelUsername);
		items.push(panelPassword);
		items.push(me.txtHiddenPassword);
		var inputPanel=Ext.create('Ext.container.Container',{
			region:'center',
			layout:'hbox',
			border:false,
			padding:'6 0 5 5',
			margin:'15 0 0 0',
			cls: 'loginPanel',
			items:items
		});
		var panelEast=Ext.create('Ext.container.Container',{
			layout:{
				type:'vbox',
				align:'left',
				padding:'19 25 5 0'
			},
			border:false,
			region:'east',
			cls:'tpspecial',
			items:[me.btnLogin]
		});
		var panelTeaser=me.createTeaserPanel();
		var northPanel=Ext.create('Ext.container.Container',{
			layout:'border',
			border:false,
			region:'north',
			cls: 'loginNorthPanel',
			//padding: '15 0 0 0',
			items:[inputPanel,panelEast,panelTeaser],
			height:me.logonController.HEIGHT_COLLAPSED-35
		});
		me.cmpMotd=Ext.create('Ext.Component', {
			region:'center',
			cls: "motd",
			border:false,
			bodyBorder:false,
			autoScroll:true,
			html:''
		});
		return [northPanel,me.cmpMotd];
	},
	createTeaserPanel:function(){
		var me=this;
		var items=[];
		me.linkExpandMOTD=Ext.create('Ext.ux.LinkComponent',{
			handler:me.logonController.expandMOTD,
			scope:me.logonController,
			label: getText("logon.lbl.expandMOTD"),
			clsLink:'expandMOTD',
			tabIndex:6,
			style:{
				textAlign:'left',
				whiteSpace:'nowrap',
				padding:'0px 5px 0px 10px',
				margin:'2px 5px 2px 0'
			}
		});
		me.teaserText=Ext.create('Ext.Component',{
			html:me.model.teaserText,
			cls: 'versionInfoLabel',
			margin:'0 25 0 0',
			style:{
				//opacity:0,
				overflow:'hidden',
				whiteSpace:'nowrap'
			},
			flex:1
		});
		items.push(me.teaserText);
		items.push(me.linkExpandMOTD);
		var panelTeaser=Ext.create('Ext.container.Container',{
			layout:'hbox',
			region:'south',
			cls:'panelTeaser',
			height:42,
			padding: '10 0 0 20',
			items:items
		});
		return panelTeaser;
	}
});
Ext.define('com.trackplus.logon.LogonPageController',{
	extend:'Ext.Base',
	config: {
		context: 1,
		model: {}
	},
	logonView:null,
	expandedMOTD:false,
	HEIGHT_EXPANDED:600,
	HEIGHT_COLLAPSED:175,
	WIDTH_COLLAPSED:750,
	profile:null,
	windowConfigProfile:null,
	constructor: function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	createView:function(){
		var me=this;
		me.logonView=Ext.create('com.trackplus.logon.LogonPageView',{
			model:me.model,
			logonController:me
		});
		me.addListeners();
		return me.logonView;
	},
	addListeners:function(){
		var me=this;
		me.logonView.txtUsername.addListener('specialkey',me.onInputKeyPressed,me);
		me.logonView.txtPassword.addListener('specialkey',me.onInputKeyPressed,me);
	},
	setFocus:function(){
		var me = this;
		var uf = me.logonView.txtUsername;
		uf.focus(true);
	},
	expandMOTD:function(){
		var me=this;
		me.expandedMOTD=!me.expandedMOTD;
		var y=me.logonView.ownerCt.getEl().getY();
		var height=me.logonView.ownerCt.body.getSize().height;
		if(me.expandedMOTD){
			if(me.logonView.linkSelfRegistration){
				me.logonView.linkSelfRegistration.getEl().fadeIn({
					opacity: 1, //can be any value between 0 and 1 (e.g. .5)
					easing: 'easeOut',
					duration: 600
				});
			}
			me.logonView.linkForgotPassword.getEl().fadeIn({
				opacity: 1, //can be any value between 0 and 1 (e.g. .5)
				easing: 'easeOut',
				duration: 600
			});
			me.logonView.checkRemeberMe.getEl().fadeIn({
				opacity: 1, //can be any value between 0 and 1 (e.g. .5)
				easing: 'easeOut',
				duration: 600
			});
			/*me.logonView.teaserText.getEl().fadeIn({
				opacity: 1, //can be any value between 0 and 1 (e.g. .5)
				easing: 'easeOut',
				duration: 600
			});*/
			me.logonView.getEl().animate({
				y:y+20,
				duration:600
			});
			me.logonView.body.animate({
				height:height-40,
				duration:600,
				listeners:{
					'afteranimate':{
						fn:function(){
							me.logonView.height='100%';
							me.logonView.width='100%';
							me.logonView.cmpMotd.getEl().fadeOut({
								opacity: 0.1, //can be any value between 0 and 1 (e.g. .5)
								easing: 'easeOut',
								duration: 15,
								remove: false,
								useDisplay: false,
								callback:function(){
											me.logonView.cmpMotd.update(me.model.motd);
											me.logonView.cmpMotd.getEl().fadeIn({
												opacity: 1, //can be any value between 0 and 1 (e.g. .5)
												easing: 'easeOut',
												duration: 300
											});
								}
							});
							me.logonView.linkExpandMOTD.setClsLink("collapseMOTD");
							me.logonView.linkExpandMOTD.setLabel(getText("logon.lbl.collapseMOTD"));
							me.logonView.ownerCt.updateLayout ();
							me.logonView.updateLayout ();
						}
					}
				}
			});
		}else{
			if(me.logonView.linkSelfRegistration){
				me.logonView.linkSelfRegistration.getEl().fadeOut({
					opacity: 0,
					easing: 'easeOut',
					duration: 600,
					remove: false,
					useDisplay: false
				});
			}
			me.logonView.linkForgotPassword.getEl().fadeOut({
				opacity: 0,
				easing: 'easeOut',
				duration: 600,
				remove: false,
				useDisplay: false
			});
			me.logonView.checkRemeberMe.getEl().fadeOut({
				opacity: 0,
				easing: 'easeOut',
				duration: 600,
				remove: false,
				useDisplay: false
			});
			/*me.logonView.teaserText.getEl().fadeOut({
				opacity: 0,
				easing: 'easeOut',
				duration: 600,
				remove: false,
				useDisplay: false
			});*/
			var height=me.logonView.ownerCt.body.getSize().height;
			var y=me.logonView.ownerCt.getEl().getY();
			var pos=Math.round(height/2)-Math.round(me.HEIGHT_COLLAPSED/2);
			me.logonView.getEl().animate({
				y:y+20+pos,
				duration:600
			});
			me.logonView.body.animate({
				height:me.HEIGHT_COLLAPSED-40,
				duration:625,
				listeners:{
					'afteranimate':{
						fn:function(){
							me.logonView.height=me.HEIGHT_COLLAPSED;
							me.logonView.width='100%';
							//me.logonView.width=me.WIDTH_COLLAPSED;
							me.logonView.cmpMotd.update('');
							me.logonView.linkExpandMOTD.setClsLink("expandMOTD");
							me.logonView.linkExpandMOTD.setLabel(getText("logon.lbl.expandMOTD"));
							me.logonView.ownerCt.updateLayout ();
							me.logonView.updateLayout ();
						}
					}
				}
			});
		}
	},
	onTxtEmailTestInputKeyPressed:function(field, e){
		var me=this;
		if (e.getKey() === e.ENTER&&me.txtEmail.isValid()) {
			me.doForgetPassword();
		}
	},
	doForgetPassword:function(){
		var me=this;
		if (me.forgotForm.getForm().isValid()) {
			me.logon_forgotWin.setLoading(true);
			me.forgotForm.getForm().submit({
				success: function(form, action) {
					me.logon_forgotWin.setLoading(false);
					me.logon_forgotWin.hide();
					//var emailSent=action.result.data.emailSent;
					CWHF.showMsgInfo(getText('logon.newpassword.welcome'));
					me.setFocus();
				},
				failure: function(form, action) {
					me.logon_forgotWin.setLoading(false);
					var msg="";
					if(action.result.errors&&action.result.errors.length>0){
						var errs=action.result.errors;
						for(var i=0;i<errs.length;i++){
							msg=msg+errs[i].message;
						}
					}
					CWHF.showMsgError(msg);
				}
			});
		}
	},
	selfRegistration:function(){
		var me=this;
		var result=com.trackplus.admin.user.createSelfRegistrationDialog();
		me.profile=result.profile;
		me.windowConfigProfile=result.windowConfig;
	},
	forgetPassword:function(){
		var me = this;
		if(me.logon_forgotWin){
			me.logon_forgotWin.destroy();
		}
		me.txtEmail=Ext.create('Ext.form.field.Text',{
			anchor:'100%',
			vtype: 'email',
			name:'email',
			allowBlank: false
		});
		me.txtEmail.addListener('specialkey',me.onTxtEmailTestInputKeyPressed,me);
		me.forgotForm=Ext.create('Ext.form.Panel', {
			border: false,
			autoScroll:false,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			layout:'anchor',
			url: 'resetPassword.action',
			items:[
				{
					xtype:'displayfield',
					value:getText('logon.newpassword.prompt.text'),
					itemId: 'forgotLabel',
					height: '32px'
				},me.txtEmail
			]
		});
		me.logon_forgotWin = Ext.create('Ext.window.Window',{
			width	   : 400,
			height	  : 155,
			closeAction :'hide',
			plain	   : true,
			title		:com.trackplus.TrackplusConfig.getText('logon.newpassword.title'),
			modal	   :true,
			items	   :[me.forgotForm],
			autoScroll  :true,
			margin:'0 0 0 0',
			style:{
				padding:' 5px 0px 0px 0px'
			},
			bodyPadding:'0px',
			cls:'forgotPassword bottomButtonsDialog tpspecial',
			buttons: [
				{
					text: com.trackplus.TrackplusConfig.getText('common.btn.ok'),
					itemID:'btnOkForgetPassword',
					handler  :me.doForgetPassword,
					scope:me
				},{
					text : getText('common.btn.cancel'),
					itemID:'btnCancelForgetPassword',
					handler  : function(){
						me.logon_forgotWin.hide();
						me.setFocus();
					}
				}
			],
			defaultFocus:me.txtEmail
		});
		me.logon_forgotWin.show(me.linkForgotPassword);
	},
	onInputKeyPressed:function(field, e){
		var me=this;
		if (e.getKey() === e.ENTER) {
			me.login.call(me);
		}
	},
	login:function(){
		var me=this;
		var form = me.logonView.getForm();
		if (!form.isValid()) {
			return true;
		}
		var pw = me.logonView.txtHiddenPassword;
		var kpw = me.logonView.txtPassword.getValue();
		var usernameValue=me.logonView.txtUsername.getValue();
		var expiry = new Date(new Date().getTime() + 30 * 24 * 60 * 60 * 1000);
		var rememberMe=me.logonView.checkRemeberMe.getValue();
		if(rememberMe===true){
			Ext.util.Cookies.set('username', usernameValue,expiry);
			Ext.util.Cookies.set('passwd', kpw,expiry);
			Ext.util.Cookies.set('rememberMe','true',expiry);
		}else{
			Ext.util.Cookies.clear('username');
			Ext.util.Cookies.clear('passwd');
			Ext.util.Cookies.clear('rememberMe');
		}
		var the_res = '';
		var key = me.model.nonce.charCodeAt(0);
		var maybeMobile = me.model.mayBeMobile;
		// Some very simple, easy to break password encryption. There is no
		// way this can be done any better, though. Protect your passwords
		// using an SSL connection between server and client; anything else
		// just does not work, no matter what you try.
		for(var i=0;i<kpw.length;++i){
			var ccode = kpw.charCodeAt(i);
			ccode = key ^ ccode;
			the_res+=me.decimalToHex(ccode,4);
		}
		pw.setValue(the_res);
		borderLayout.setLoading(true);
		form.submit({
				url:'logon!login.action',
				success: function(form, action) {
					var jsonURL=action.result.data.jsonURL;
					var ftever=action.result.data.ftever;
					var licURL=action.result.data.licURL;
								borderLayout.setLoading(true);
								document.location=jsonURL;
				},
				failure: function(form, action) {
					if(me.model.nonce!==action.result.data.nonce){
						if(CWHF.isNull(action.result.data.nonce)) {
							location.reload(true);
							return true;
						}else {
							me.model.nonce = action.result.data.nonce;
							me.login.call(me);
							return true;
						}
					}
					borderLayout.setLoading(false);
					if (action.failureType!=='client') {
						me.handleErrors(action.result.data);
					}
				}
			}
		);
	},
	decimalToHex:function(d, padding) {
		var hex = Number(d).toString(16);
		padding =  CWHF.isNull(padding) ? padding = 2 : padding;
		while (hex.length < padding) {
			hex = "0" + hex;
		}
		return hex;
	},
	handleErrors:function(data){
		var me = this;
		var errors =  data.errors;
		var strErr="";
		// Check first if banned
		if (data.banned) {
			document.location=data.jsonURL;
		}
		if(errors&&errors.length>0){
			for(var i=0;i<errors.length;i++){
				if(errors[i].label==='errCredentials') {
					var un = me.logonView.txtUsername;
					var pn = me.logonView.txtPassword;
					un.markInvalid(errors[i].id);
					pn.markInvalid(errors[i].id);
					data.continyou=false;
				}
				if(errors[i].label==='errGeneralError') {
					strErr+=errors[i].id+"\n";
					data.continyou=false;
				}
				if(errors[i].label==='errLicenseError') {
					strErr+=errors[i].id+"\n";
				}
			}
			if (strErr  && strErr.length > 0) {
				Ext.MessageBox.show({
					title: '',
					msg: strErr,
					modal: true,
					fn: function(btn){
						if (data.continyou===true) {
							document.location=data.jsonURL;
						}
					},
					buttons: Ext.MessageBox.OK,
					icon: Ext.MessageBox.ERROR
				});
			}else{
				me.shakeWin();
			}
		}
	},
	shakeWin:function(){
		var me=this;
		var x=me.logonView.getEl().getX();
		var dif=15;
		me.logonView.getEl().animate({
			keyframes:{
				'0%': {x:x-dif},
				'25%':{x:x+dif},
				'50%':{x:x-dif},
				'75%':{x:x+dif},
				'100%':{x:x}
			},
			duration:250
		});
	}
});
Ext.define('com.trackplus.layout.LogonLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	logonPage:null,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.logonPage = Ext.create('com.trackplus.logon.LogonPage',{
			jsonData:me.initData
		});
		me.borderLayoutController.setHelpContext("logon");
		me.onReady(function(){
			me.logonPage.setFocus.call(me.logonPage);
			Ext.DomHelper.append('logonpageview', {tag: 'div', cls: '', id: 'logonBoxShadow',html: "&nbsp;"});
			}
		);
	},
	createCenterPanel:function(){
		var me=this;
		return me.logonPage.createCenterPanel.call(me.logonPage);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.BannedLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("logon");
	},
	createCenterPanel:function(){
		return Ext.create('Ext.panel.Panel',{
			region: 'center',
			cls:'messagePageWrapper',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			html:'<div class="boxMessage boxMessage-error">'+
				'<div class="messageIcon"><img src="design/silver/32x32/cancel.png"/></div>'+
				'<div class="messageBody">'+getText("logon.banned.body")+'</div>'+
				'</div>'
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ConfirmedUserLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("logon");
	},
	createCenterPanel:function(){
		return Ext.create('Ext.panel.Panel',{
			region: 'center',
			cls:'messagePageWrapper',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			html:'<div class="boxMessage boxMessage-ok">'+
				'<div class="messageIcon"><img src="design/silver/32x32/check.png"/></div>'+
				'<div class="messageBody">'+getText('logon.register.msg.confirmationSuccess')+'</div>'+
				'<div class="redirectToLoginDiv"> <a class="redirectToLogin" href="logoff.action">'+getText('common.btn.login')+'...</a></div>'+
				'</div>'
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ExpiredUserLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("logon");
	},
	createCenterPanel:function(){
		return Ext.create('Ext.panel.Panel',{
			region: 'center',
			cls:'messagePageWrapper',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			html:'<div class="boxMessage boxMessage-error">'+
					'<div class="messageIcon"><img src="design/silver/32x32/cancel.png"/></div>'+
					'<div class="messageBody">'+getText('logon.register.msg.tokenExpired')+'</div>'+
					'<div class="redirectToLoginDiv"> <a class="redirectToLogin" href="logoff.action">'+getText('common.btn.login')+'...</a></div>'+
				'</div>'
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ResetPasswordLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("logon");
	},
	applyPasswordVType: function() {
		// Add the additional 'advanced' VTypes
		Ext.apply(Ext.form.field.VTypes, {
			password: function(val, field) {
				if (field.initialPassField) {
					// var pwd = field.up('form').down('#' + field.initialPassField);
					var pwd = Ext.getCmp(field.initialPassField);
					return (val === pwd.getValue());
				}
				return true;
			},
			passwordText: getText('admin.user.profile.err.password.match')
		});
	},
	resetPassword:function(){
		var me=this;
		me.form.getForm().submit({
			url:'resetPassword!reset.action',
			params:{
				'ctk':me.initData.token
			},
			success:function(form,action){
				me.saveSuccess.call(me,form,action);
			},
			scope:me,
			failure:me.saveFailure
		});
	},
	//In case of changing password succeeded, the user will be logged in
	//automatically and redirected to default page.
	saveSuccess:function(form, action){
		var me=this;
		var data=null;
		if(action){
			data=action.result.data;
		}
		var title=getText("logon.resetPassword.title");
		var message=getText("logon.resetPassword.msg.resetSuccessfully");
		Ext.MessageBox.show({
			title: title,
			msg: message,
			width: 400,
			buttons: Ext.Msg.OK,
			fn: function(){
				var loginActionResponse = action.response.responseText;
				var loginActionResponseJSON  = Ext.JSON.decode(loginActionResponse);
				var JSONUrl = loginActionResponseJSON.data.jsonURL;
				var ftever = loginActionResponseJSON.data.ftever;
				var licURL = loginActionResponseJSON.data.licURL;
				var ftever=action.result.data.ftever;
				var licURL=action.result.data.licURL;
				if(JSONUrl  && JSONUrl !== "") {
					if (ftever) {
						Ext.MessageBox.show({
						    msg: getText('logon.getLicense'),
						    width: 450,
						    height: 300,
						    cls: 'licenseRequest',
						    closable:false,
						    buttonText: {ok: getText('logon.register')},
						    buttons: Ext.Msg.OK,
						    fn: function(buttonId) {
						    	window.open(licURL,'_blank');
						    	document.location=jsonURL;
						    },
						    icon: Ext.window.MessageBox.INFO
						});
					}
					document.location = JSONUrl;
				}else {
					window.location.href="logoff.action"
				}
			},
			icon: Ext.MessageBox.INFO
		});
	},
	saveFailure:function(form, action){
		var title=getText("logon.resetPassword.title");
		var message=getText("logon.resetPassword.error.cantResetPassword");
		Ext.MessageBox.show({
			title: title,
			msg: message,
			width: 400,
			buttons: Ext.Msg.OK,
			icon: Ext.MessageBox.ERROR
		});
	},
	createCenterPanel:function(){
		var me=this;
		me.applyPasswordVType();
		var btnReset=Ext.create('Ext.Button',{
			text: getText('common.btn.reset'),
			margin:'10 0 0 255',
			formBind: true,
			handler:me.resetPassword,
			scope:me
		});
		me.form=Ext.create('Ext.form.Panel', {
			layout: 'anchor',
			border: false,
			margin: '0 0 0 0',
			baseCls:'x-plain',
			unstyled: true,
			bodyStyle: {
				padding: '10px'
			},
			items: [CWHF.createTextField('admin.user.profile.lbl.passwd','passwd',
					{itemId:'passwd', inputType:'password',minLength:5, id:'passwd',allowBlank:false}),
				CWHF.createTextField('admin.user.profile.lbl.passwd2','passwd2',
					{itemId:'passwd2', inputType:'password',vtype:'password',initialPassField:'passwd',allowBlank:false}),
				btnReset
			]
		});
		var box=Ext.create('Ext.panel.Panel',{
			cls:'boxMessage boxMessage-ok',
			baseCls:'x-plain',
			unstyled: true,
			items:[
				{xtype:'component',html:getText('logon.resetPassword.msg',me.initData.loginName)},
				me.form]
		});
		return Ext.create('Ext.panel.Panel',{
			region: 'center',
			cls:'messagePageWrapper',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			items:[box]
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ResetPasswordExpiredLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("logon");
	},
	createCenterPanel:function(){
		return Ext.create('Ext.panel.Panel',{
			region: 'center',
			cls:'messagePageWrapper',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			html:'<div class="boxMessage boxMessage-error">'+
				'<div class="messageIcon"><img src="design/silver/32x32/cancel.png"/></div>'+
				'<div class="messageBody">'+getText('logon.register.msg.tokenResetPasswordExpired')+'</div>'+
				'<div class="redirectToLoginDiv"> <a class="redirectToLogin" href="logoff.action">'+getText('common.btn.login')+'...</a></div>'+
				'</div>'
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.browseProjects.urlEditScreen="dashboardEdit.action";
com.trackplus.browseProjects.urlResetScreen="browseProjects!resetDashboard.action";
com.trackplus.browseProjects.btnProjectDashEdit= new Ext.Button({
	id:'projectDashEditButton',
	itemId:'projectDashEditButtonItemID',
	overflowText:getText('cockpit.config'),
	tooltip:getText('cockpit.config.tt'),
	text: getText('cockpit.config'),
	iconCls: 'cockpitEdit',
	disabled:true,
	handler:function(){
		window.location.href=com.trackplus.browseProjects.urlEditScreen;
	}
});
com.trackplus.browseProjects.btnProjectDashReset= new Ext.Button({
	xtype:'button',
	id:'projectDashResetButton',
	overflowText:getText('cockpit.reset'),
	tooltip:getText('cockpit.reset'),
	text: getText('cockpit.reset'),
	iconCls: 'cockpitReset',
	disabled:true,
	handler:function(){
		com.trackplus.browseProjects.resetDashboard();
	}
});
com.trackplus.browseProjects.btnSaveAsTemplatetDash= new Ext.Button({
	xtype:'button',
	id:'projectDashSaveAsTemplatetButton',
	overflowText:getText('cockpit.saveAsTemplate'),
	tooltip:getText('cockpit.saveAsTemplate'),
	text: getText('cockpit.saveAsTemplate.tooltip'),
	iconCls: 'cockpitSave',
	disabled:true,
	handler:function(){
		com.trackplus.browseProjects.saveAsDefault();
	}
});
com.trackplus.browseProjects.westPanel=null;
com.trackplus.browseProjects.browseProjectCenterPanel=null;
com.trackplus.browseProjects.treeProjects=null;
com.trackplus.browseProjects.resetDashboard=function(){
	var me=this;
	com.trackplus.dashboard.resetDashboard(com.trackplus.dashboard.urlResetScreen,{}, me.resetDashboardSuccess,me);
};
com.trackplus.browseProjects.resetDashboardSuccess=function(){
	com.trackplus.browseProjects.showProject(com.trackplus.browseProjects.projectID,com.trackplus.browseProjects.entityType,com.trackplus.browseProjects.releaseID);
};
com.trackplus.browseProjects.saveAsDefault=function(){
	var me=this;
	com.trackplus.dashboard.saveAsDefault(com.trackplus.browseProjects.projectID,com.trackplus.browseProjects.entityType);
};
com.trackplus.browseProjects.createWestPanel=function(){
	var store = Ext.create('Ext.data.Store', {
	fields: [
		{name: 'label'},
		{name: 'value'},
		{name: 'cssClass'},
		{name: 'img'},
		{name: 'entityID'},
		{name:'optionID'}
		],
		data: []
	});
	// create the Grid
	var grid = Ext.create('Ext.grid.Panel', {
		//region:'center',
		id:'gridDetail',
		store: store,
		border:false,
		disableSelection: true,
		columns: [
			{dataIndex: 'label',flex:1},
			{dataIndex: 'value',flex:1,renderer : com.trackplus.browseProjects.gridDetailRenderer}
		],
		hideHeaders:true,
		columnLines :false,
		viewConfig: {
			stripeRows: true,
			trackOver  :false
		},
		autoHeight:true
	});
	var panelWest = Ext.create('Ext.panel.Panel',{
		layout: 'border',
		id: 'layout-browser',
		region:'west',
		border: false,
		split:true,
		width: 275,
		listeners:{
			collapse:function(e){
				com.trackplus.browseProjects.storeSplitCollapsed();
			},
			expand:function(e){
				com.trackplus.browseProjects.storeSplitCollapsed();
			}
		},
		items:[com.trackplus.browseProjects.treeProjects,
			Ext.create('Ext.panel.Panel',{
				id:'projectDetailPanel',
				region:'south',
				border:false,
				bodyBorder:false,
				height:325,
				split:true,
				margins:'0 0 0 0',
				collapsible:true,
				/*layout: {
					type: 'vbox',
					align : 'stretch',
					pack  : 'start'
				},*/
				collapseMode:'mini',
				title:'Detail',
				items:[
					{
						border:false,
						bodyBorder:false,
						margin:'0 0 0 0',
						layout:{
							type: 'hbox'
						},
						items:[
							{xtype: 'image',id:'imageDetail',src:com.trackplus.TrackplusConfig.iconsPath+'project.png',width:20, margin:'5 5 0 5'},
							{xtype: 'displayfield',id:'titleDetail',value:'<b>...</b>',flex:1,margin:'5 5 0 0'}
						]
					},
					{xtype: 'displayfield',id:'descriptionDetail',value:'...'},
					grid
				]
			})
		]
	});
	return panelWest;
};
com.trackplus.browseProjects.replaceDetail=function(data){
	var imgDetail=Ext.getCmp("imageDetail");
	var titleDetail=Ext.getCmp("titleDetail");
	var descriptionDetail=Ext.getCmp("descriptionDetail");
	var gridDetail=Ext.getCmp("gridDetail");
	imgDetail.setSrc(com.trackplus.TrackplusConfig.iconsPath+data.image);
	titleDetail.setValue(data.title);
	descriptionDetail.setValue(data.description);
	gridDetail.store.loadData(data.gridData);
};
com.trackplus.browseProjects.gridDetailRenderer=function(value,metaData,record,colIndex,store,view){
	var result="";
	if(record.data.img&&record.data.img!==''){
		result+='<img src="'+com.trackplus.TrackplusConfig.iconsPath+record.data.img+'"\>';
	}
	if(record.data.optionID&&record.data.optionID!==''){
		var srcImg="optionIconStream.action?fieldID="+record.data.entityID+"&optionID="+record.data.optionID;
		result+='<img src="'+srcImg+'" style="margin-right:3px"\>';
	}
	if(record.data.cssClass){
		result+='<span class="'+record.data.cssClass+'">'+value+'</span>';
	}else{
		result+=value;
	}
	return result;
};
com.trackplus.browseProjects.showProject=function(projectID,entityType,releaseID){
	Ext.Ajax.request({
		url: 'dashboard.action',
		disableCaching :true,
		method:'POST',
		params:{"projectID":projectID,"entityType":entityType,'releaseID':releaseID},
		success: function(response){
			var jsonData=Ext.decode(response.responseText);
			var data=jsonData.data;
			var screenModel=com.trackplus.screen.createScreenModel(data.screen);
			var refreshTabUrl='dashboardTabRuntime!execute.action?projectID='+projectID;
			var storeTabUrl='dashboard!storeLastSelectedTab.action?projectID='+projectID+"&entityType="+entityType;
			if(releaseID){
				refreshTabUrl+="&releaseID="+releaseID;
			}
			var screenFacade= Ext.create('com.trackplus.screen.BaseScreenFacade',{
				screenModel:screenModel,
				lastSelectedTab:data.lastSelectedTab,
				projectID:data.projectID,
				releaseID:data.releaseID,
				refreshTabUrl:refreshTabUrl,
				storeTabUrl:storeTabUrl,
				tabViewCls:'com.trackplus.screen.DashboardTabView',
				panelViewCls:'com.trackplus.screen.DashboardPanelView',
				fieldErrorCls:'com.trackplus.screen.DashboardFieldErrorView'
			});
			var tabPanel= screenFacade.createViewComponent();
			com.trackplus.browseProjects.browseProjectCenterPanel.removeAll(true);
			com.trackplus.browseProjects.browseProjectCenterPanel.add(tabPanel);
			com.trackplus.browseProjects.browseProjectCenterPanel.updateLayout();
		}
	});
	/*com.trackplus.browseProjects.browseProjectCenterPanel.getLoader().load({
		url: 'browseProject.action',
		params: {"projectID":project,"releaseID":release,"entityType":entityType},
		scripts:true
	});*/
};
com.trackplus.browseProjects.findParentProject=function(node){
	var parentNode=node.parentNode;
	if(parentNode.data.id<0){//project
		return (-1)*node.parentNode.data.id;
	}else{
		return com.trackplus.browseProjects.findParentProject(parentNode);
	}
};
com.trackplus.browseProjects.treeNodeClick=function(view,node){
	var entityType=1;//PROJECT
	var projectID;
	var releaseID=null;
	var id=node.data.id;
	var entityID=parseInt(id);
	var urlStr;
	var projectDetailPanel=Ext.get("projectDetailPanel");
	var urlDetail;
	//com.trackplus.browseProjects.btnProjectDashEdit.setDisabled(true);
	if(entityID<0){
		//project
		entityType=1;//PROJECT
		projectID=-1*entityID;
		com.trackplus.browseProjects.urlEditScreen="dashboardEdit.action?backAction=browseProjects.action&projectID="+projectID+"&entityType=1";
		com.trackplus.dashboard.urlResetScreen="project!cokpitAssignment.action?projectID="+projectID+"&entityType=1"
	}else{
		//release
		releaseID=entityID;
		entityType=9;//RELEASESCHEDULED
		var parentID=com.trackplus.browseProjects.findParentProject(node);
		projectID=parentID;
		com.trackplus.browseProjects.urlEditScreen="dashboardEdit.action?backAction=browseProjects.action&projectID="+projectID+"&entityType=9";
		com.trackplus.dashboard.urlResetScreen="project!cokpitAssignment.action?projectID="+projectID+"&entityType=9"
	}
	var detailPanel=Ext.getCmp('projectDetailPanel');
	detailPanel.setLoading(com.trackplus.TrackplusConfig.getText("common.lbl.loading"));
	Ext.Ajax.request({
		url: 'browseProjects!entityDetail.action',
		params:{"entityID":entityID,"entityType":entityType},
		success: function(response){
			var jsonData=Ext.decode(response.responseText);
			var newPanel;
			var data={};
			var canEdit=jsonData.data.canEdit;
			if(canEdit===true){
				com.trackplus.browseProjects.btnProjectDashEdit.setDisabled(false);
				com.trackplus.browseProjects.btnProjectDashReset.setDisabled(false);
				com.trackplus.browseProjects.btnSaveAsTemplatetDash.setDisabled(false);
			}else{
				com.trackplus.browseProjects.btnProjectDashEdit.setDisabled(true);
				com.trackplus.browseProjects.btnProjectDashReset.setDisabled(true);
				com.trackplus.browseProjects.btnSaveAsTemplatetDash.setDisabled(true);
			}
			if(entityType===1){//project
				data.title=jsonData.data.projectLabel;
				data.description=jsonData.data.projectDescription;
				data.image='project.png';
				var projectLinkingImg="bulkCheck.gif";
				if(jsonData.data.projectLinking){
					projectLinkingImg='bulkCheck-select.gif';
				}
				var projectWorkCostImg="bulkCheck.gif";
				if(jsonData.data.projectWorkCost){
					projectWorkCostImg='bulkCheck-select.gif';
				}
				data.gridData=[
					{label:getText('common.lbl.projectType'),value:jsonData.data.projectType},
					{label:getText('admin.customize.localeEditor.type.projectStatus'),value:jsonData.data.projectState},
					{label:getText('admin.project.lbl.defaultManager'),value:jsonData.data.defaultManager},
					{label:getText('admin.project.lbl.defaultResponsible'),value:jsonData.data.defaultResponsible},
					{label:getText('admin.project.lbl.defaultInitialState'),value:jsonData.data.defaultItemState,
						cssClass:'dataEmphasize',optionID:jsonData.data.defaultItemStateID,entityID:-4},
					{label:getText('admin.project.lbl.defaultIssueType'),value:jsonData.data.defaultIssueType,
						optionID:jsonData.data.defaultIssueTypeID,entityID:-2},
					{label:getText('admin.project.lbl.defaultPriority'),value:jsonData.data.defaultPriority,
						optionID:jsonData.data.defaultPriorityID,entityID:-10},
					{label:getText('admin.project.lbl.defaultSeverity'),value:jsonData.data.defaultSeverity,
						optionID:jsonData.data.defaultSeverityID,entityID:-11},
					{label:getText('admin.project.lbl.linking'),value:'',img:projectLinkingImg},
					{label:getText('admin.project.lbl.accounting'),value:'',img:projectWorkCostImg}
				];
			}else{//release
				data.title=jsonData.data.label;
				data.description=jsonData.data.description;
				data.image='releaseActive.png';
				var imgNoticed="bulkCheck.gif";
				if(jsonData.data.noticedDefault){
					imgNoticed='bulkCheck-select.gif';
				}
				var imgSchedule="bulkCheck.gif";
				if(jsonData.data.scheduleDefault){
					imgSchedule='bulkCheck-select.gif';
				}
				data.gridData=[
					{label:getText('admin.customize.localeEditor.type.releaseStatus'),value:jsonData.data.state},
					{label:getText('admin.project.release.lbl.dueDate'),value:jsonData.data.dueDate},
					{label:getText('admin.project.release.lbl.defaultReleaseNoticed'),value:'',img:imgNoticed},
					{label:getText('admin.project.release.lbl.defaultReleaseScheduled'),value:'',img:imgSchedule}
				];
				//newPanel=com.trackplus.browseProjects.createReleaseDetailPanel(jsonData.data);
			}
			com.trackplus.browseProjects.replaceDetail(data);
			detailPanel.updateLayout();
			detailPanel.setLoading(false);
			/*detailPanel.removeAll();
			detailPanel.add(newPanel);
			detailPanel.updateLayout();*/
			//var detailDiv = document.getElementById("detailDiv");
			//detailDiv.innerHTML=result.responseText;
		},
		failure: function(error){
			detailPanel.setLoading(false);
			//var detailDiv = document.getElementById("detailDiv");
			//detailDiv.innerHTML=error.message;
		},
		method:"POST"
	});
	com.trackplus.browseProjects.projectID=projectID;
	com.trackplus.browseProjects.entityType=entityType;
	com.trackplus.browseProjects.releaseID=releaseID;
	com.trackplus.browseProjects.showProject(projectID,entityType,releaseID);
};
com.trackplus.browseProjects.storeSplitCollapsed=function(){
	Ext.Ajax.request({
		url: "browseProjects!storeSpliterCollapsed.action",
		disableCaching:true,
		success: function(){
		},
		failure: function(){
		},
		method:'POST',
		params:{"editSpliterCollapses":com.trackplus.browseProjects.westPanel.collapsed}
	});
};
com.trackplus.browseProjects.createCustomCenterPanel=function(data){
	var store = Ext.create('Ext.data.TreeStore', {
		proxy:{
			type: 'ajax',
			url: 'browseProjects!expandNode.action'
		},
		fields: ['id','text','type', 'canEdit','icon','leaf'],
		root: {
			expanded: true,
			text:"",
			user:"",
			status:"",
			children:CWHF.isNull(data.treeDataProjects)?[]:data.treeDataProjects
		}
	});
	com.trackplus.browseProjects.treeProjects=Ext.create('Ext.tree.Panel', {
		region:'center',
		useArrows: true,
		autoScroll: true,
		store: store,
		rootVisible: false,
		border: false,
		margins: '0 0 0 0',
		baseCls:'x-plain',
		bodyStyle:{border:'none'},
		cls:'westTreeNavigator'
	});
	//com.trackplus.browseProjects.treeProjects.store.on('beforeexpand', function(node) {
	com.trackplus.browseProjects.treeProjects.store.on('beforeload', function(store, operation) {
		var node=operation.node;
		if(node){
			var id=node.data.id;
			id=id.substring(1,id.length);
			var entityID=parseInt(id);
			var entityType=node.data.type;
			com.trackplus.browseProjects.treeProjects.store.proxy.extraParams = {
				entityID:entityID,
				entityType:entityType
			}
		}
	});
	//com.trackplus.browseProjects.treeProjects.expandAll();
	//treeProjects = new ApiPanel();
	com.trackplus.browseProjects.treeProjects.on('itemclick',com.trackplus.browseProjects.treeNodeClick);
	//com.trackplus.browseProjects.westPanel=com.trackplus.browseProjects.createWestPanel();
	com.trackplus.browseProjects.browseProjectCenterPanel=new Ext.Panel({
		region:'center',
		border:false,
		autoScroll: true,
		header:false,
		style:{
			// borderLeft:'1px solid #D0D0D0'
		},
		bodyStyle:{
			padding:'2px 0px 0px 0px'
		},
		layout:'fit'
	});
	/*var mainPanel = new Ext.Panel({
		region: 'center',
		margins: '0 0 0 0',
		border: false,
		baseCls:'x-plain',
		layout:'border',
	 	items: [com.trackplus.browseProjects.westPanel,com.trackplus.browseProjects.browseProjectCenterPanel]
	});*/
	return com.trackplus.browseProjects.browseProjectCenterPanel;
};
Ext.define('com.trackplus.layout.BrowseProjectsLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	selectedGroup:'browseProjects',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("browseProject");
		me.onReady(function(){
			var data=me.initData;
			var dashToolbar=[com.trackplus.browseProjects.btnProjectDashEdit];
			if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
				dashToolbar.push(com.trackplus.browseProjects.btnProjectDashReset);
				dashToolbar.push(com.trackplus.browseProjects.btnSaveAsTemplatetDash);
			}
			me.borderLayoutController.setActiveToolbarList(dashToolbar);
			if(CWHF.isNull(data.treeDataProjects)){
				CWHF.showMsgError(getText("browseProject.err.noProjectToBrowse"));
				return;
			}
			var node=com.trackplus.browseProjects.treeProjects.getStore().getNodeById(data.selectedNode);
			if(node){
				com.trackplus.browseProjects.treeProjects.getSelectionModel().select(node);
				com.trackplus.browseProjects.treeProjects.expandPath(node.getPath());
				com.trackplus.browseProjects.treeNodeClick(null,node);
			}
		});
	},
	createCenterPanel:function(){
		var me=this;
		return com.trackplus.browseProjects.createCustomCenterPanel(me.initData);
	},
	createWestPanel:function(){
		com.trackplus.browseProjects.westPanel=com.trackplus.browseProjects.createWestPanel();
		return com.trackplus.browseProjects.westPanel;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.util.RefreshAfterSubmit = function() {
}
/**
 * Refresh a tree one single level
 */
com.trackplus.util.RefreshAfterSubmit.refreshSimpleTree = function(refreshParamsObject) {
	//nodeID is null after delete, and not null after add/edit
	var nodeID = refreshParamsObject.node;
	var reloadTree = refreshParamsObject.reloadTree;
	if (reloadTree) {
		//tree reload is needed: after delete, add and edit with label change
		var treeStore = this.tree.getStore();
		var options = {};
		if (CWHF.isNull(nodeID) && treeStore.getRootNode().hasChildNodes()) {
			var childNodes = treeStore.getRootNode().childNodes;
			if (childNodes) {
				var numberOfChildren = childNodes.length;
				if (numberOfChildren>0) {
					//select the first row after delete
					var firstNode = treeStore.getRootNode().getChildAt(0);
					if (firstNode) {
						var selectedNodeID = null;
						if (this.selectNode) {
							selectedNodeID = this.selectedNode.get("id");
						}
						nodeID = firstNode.get("id");
						if (nodeID===selectedNodeID) {
							//the first row was deleted, try to select the second row if exists
							nodeID = null;
							if (numberOfChildren>1) {
								var secondNode = treeStore.getRootNode().getChildAt(1);
								if (secondNode) {
									nodeID = secondNode.get("id");
								}
							}
						}
					}
				}
			}
		}
		if (nodeID) {
			options.callback = this.selectNode;
			options.scope = {tree:this.tree, nodeIdToSelect:nodeID}
		} else {
			//no node to select reset the detail panel and toolbar
			options.callback = this.resetDetailPanel;
			options.scope = this;
		}
		treeStore.load(options);
	} else {
		//edit without label change
		var selectionModel = this.tree.getSelectionModel();
		if (nodeID) {
			//get the node by id
			var nodeToSelect = this.tree.getStore().getNodeById(nodeID);
			if (nodeToSelect) {
				selectionModel.select(nodeToSelect);
			}
		}
	}
}
/**
 * Refresh the tree after submit
 */
com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit = function(refreshParametersObject) {
	var nodeIDToSelect = refreshParametersObject.nodeIDToSelect;
	var nodeIDToReload = refreshParametersObject.nodeIDToReload;
	var reloadTree = refreshParametersObject.reloadTree;
    var resetDetail = refreshParametersObject.resetDetail;
	if (reloadTree) {
		//tree reload is needed: after delete, add and edit with label change
		var treeStore = this.tree.getStore();
		var options = {};
		if (nodeIDToReload) {
			options.node = this.tree.getStore().getNodeById(nodeIDToReload);
		}
		if (nodeIDToSelect) {
			options.callback = com.trackplus.util.RefreshAfterSubmit.selectTreeNodeAfterReload;
			options.scope = {treePanel:this.tree, nodeIDToSelect:nodeIDToSelect}
		} else {
			if (resetDetail) {
				options.callback = this.resetDetailPanel;
				options.scope = this;
			}
		}
		treeStore.load(options);
	} else {
		//edit without label change
		com.trackplus.util.RefreshAfterSubmit.selectTreeNodeAfterReload.call({treePanel:this.tree, nodeIDToSelect:nodeIDToSelect});
	}
}
/**
 *  Refreshes the grid and tree after an operation requiring a refresh
 *  The scope should contain tree and grid attributes
 * 	refreshParametersObject may contain the following parameters:
 * 	nodeIDToReload: the branch node to reload
 * 	nodeIDToSelect: the tree node to select after branch reload
 * 	rowToSelect: the grid row to select after grid store reload
**/
com.trackplus.util.RefreshAfterSubmit.refreshGridAndTreeAfterSubmit = function(refreshParametersObject) {
	var nodeIDToReload = null;
	var nodeIDToSelect = null;
	var rowToSelect = null;
	if (refreshParametersObject) {
		nodeIDToReload = refreshParametersObject.nodeIDToReload;
		nodeIDToSelect = refreshParametersObject.nodeIDToSelect;
		rowToSelect = refreshParametersObject.rowToSelect;
	}
	var nodeToReload;
	if (nodeIDToReload) {
		nodeToReload=this.tree.getStore().getNodeById(nodeIDToReload);
	} else {
		if (this.selectedNode) {
			//typically no nodeIDToReload specified when this.selectedNode is the one to reload
			nodeToReload = this.selectedNode;
			nodeIDToReload = this.selectedNodeID;
		} else {
			//no node was selected to add to means adding to the root
			//(for example by project configuration add a project specific filter directly to the "branch" root)
			nodeToReload = this.tree.getRootNode();
			nodeIDToReload = this.rootID;
		}
	}
	if (nodeToReload) {
		if (nodeToReload.isLoaded()) {
			//reload the node only if the node was already loaded (expanded)
			//set the global this.rowToSelect for selecting a row after the grid has been reloaded. See treeWithGrid.onGridStoreLoad()
			//(in selectTreeNodeAfterReload the grid row can't be selected: see selectTreeNodeAfterReload
			this.rowIdToSelect = rowToSelect;
			if (CWHF.isNull(nodeIDToSelect)) {
				nodeIDToSelect = nodeIDToReload;
			}
			var scope={treePanel:this.tree, grid:this.grid, nodeIDToSelect:nodeIDToSelect, rowToSelect:rowToSelect, scope: this};
			this.tree.store.load({node:nodeToReload,
								callback:com.trackplus.util.RefreshAfterSubmit.selectTreeNodeAfterReload,
								synchronous:false,
								scope:scope});
		} else {
			//tree node was not loaded previously: refresh the grid only
			if (this.grid) {
				com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit.call(this, {rowToSelect:rowToSelect});
			}
		}
	}
}
/**
 * Refreshes a grid's store and selects a row by rowToSelect parameter if it is specified
 * Called from selectAfterReload() (grid and tree refresh) and from simple grid CRUD
 */
/*com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit = function(grid, rowIdToSelect) {
	if (grid) {
		grid.getStore().load({scope:this, callback:function(){
			if (rowIdToSelect) {
				var row = grid.getStore().getById(rowIdToSelect);
				if (row) {
					var gridSelectionModel = grid.getSelectionModel();
					gridSelectionModel.select(row);
				}
			}
		}})
	}
}*/
/**
 * Callback after the branch is reloaded
 */
com.trackplus.util.RefreshAfterSubmit.selectTreeNodeAfterReload = function() {
	//re-selection should be made by code because after reload the tree node selection gets lost:
	//1. if the node to select is the reloaded node: the reloaded node looses the selection by the this.tree.store.load()
	//2. if the node to select is a child of the reloaded node it looses the selection anyway
	//Although this tree node selection by code will reload the grid (because it triggers the treeNodeSelect()),
	//but the corresponding grid row can't be selected here directly (if it would be the case) that's why it is selected
	//in treeWithGrid.onGridStoreLoad() after the global this.rowToSelect was set
	var treeSelectionModel = this.treePanel.getSelectionModel();
	if (this.nodeIDToSelect) {
		var nodeToSelect=this.treePanel.getStore().getNodeById(this.nodeIDToSelect);
		if (nodeToSelect) {
			if (treeSelectionModel.isSelected(nodeToSelect)) {
				//if already selected deselect it first because
				//otherwise the select does not trigger the select handler (for refreshing the detail part)
				treeSelectionModel.deselect(nodeToSelect);
			}
			treeSelectionModel.select(nodeToSelect);
			if (!nodeToSelect.isVisible()) {
				this.treePanel.expandPath(nodeToSelect.getPath());
			}
		}
	}
}
/**
 * Refreshes a grid's store and selects a row by rowToSelect parameter if it is specified
 * Called from selectAfterReload() (grid and tree refresh) and from simple grid CRUD
 */
com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit = function(refreshParametersObject) {
	this.grid.getStore().load({
		scope:this,
		callback:function(){
			if (refreshParametersObject) {
				var rowToSelect = refreshParametersObject.rowToSelect;
				if (rowToSelect) {
					var row = this.grid.getStore().getById(rowToSelect);
					if (row) {
						var gridSelectionModel = this.grid.getSelectionModel();
						gridSelectionModel.select(row);
					}
				}
			}
		}
	});
}

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.CrudBase',{
	extend:'Ext.Base',
	config: {},
	/**
	 * The base struts action name (without method name) in struts.xml
	 * Mandatory field
	 */
	baseAction: null,
	/**
	 * Whether to allow multiple selections (for delete, drag and drop)
	 */
	allowMultipleSelections:false,
	/**
	 * Whether to allow deselecting (applies if allowMultipleSelections is false)
	 */
	allowDeselect: false,
	/**
	 * The width of the edit window
	 * Mandatory field
	 */
	editWidth:600,
	/**
	 * The height of the edit window
	 * Mandatory field
	 */
	editHeight:400,
	/**
	 * Whether by deleting an entity should be asked for a confirmation, independently of any dependency
	 */
	confirmDeleteEntity:true,
	/**
	 * Whether to ask for extra confirmation if the entity to be deleted has dependencies
	 */
	confirmDeleteNotEmpty:false,
	/**
	 * Whether the deletion of a not empty entity was already confirmed
	 * This is also the name of the request parameter
	 * Makes sense only if confirmDeleteNotEmpty is true
	 */
	deleteConfirmed:false,
	/**
	 * Width of the replacement window
	 */
	replacementWidth: 500,
	/**
	 * Height of the replacement window
	 */
	replacementHeight: 200,
	/**
	 * The simple grid or grid part of tree-grid
	 */
	//grid:null,
	/**
	 * The possible toolbar and context menu actions
	 */
	actions:null,
	/**
	 * The popup window for editing an entity
	 * (it is not used here directly but may be used in the overridden methods
	 * of the derived classes to access for ex. the toolbar of the window for disabling some buttons)
	 * Injected by windowConfig
	 */
	win:null,
	/**
	 * The form for editing an entity. Created in the createEditForm() method, or from items
	 * Injected by windowConfig
	 */
	formEdit:null,
	ERROR_CODE_NEED_REPLACE: 1,
	NOT_EMPTY_WARNING: 3,
	constructor: function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	/**
	 * The title for a failure message
	 */
	failureTitle:getText('common.err.failure'),
	/**
	 * Gets the base struts action
	 */
	getBaseAction: function() {
		return this.baseAction;
	},
	/**********************************************label, tooltip, icon values***********************************************/
	/**
	 * The localized entity name based on the localization key: should be implemented
	 */
	/*protected abstract*/getEntityLabel: function(extraConfig) {
		return "";
		//return getText('...');
	},
	/**
	 * The iconCls for the add button
	 */
	/*protected*/getAddIconCls: function() {
		return 'add';
	},
	/**
	 * The key for "add" button text
	 */
	/*protected*/getAddButtonKey: function() {
		return 'common.btn.add';
	},
	/**
	 * The title for "add" popup and "add" action tooltip
	 */
	/*protected*/getAddTitleKey: function() {
		return 'common.lbl.add';
	},
	/**
	 * The iconCls for the edit button
	 */
	/*protected*/getEditIconCls: function() {
		return 'edit';
	},
	/**
	 * The key for "edit" button text
	 */
	/*protected*/getEditButtonKey: function() {
		return 'common.btn.edit';
	},
	/**
	 * The title for "edit" popup and "edit" action tooltip
	 */
	/*protected*/getEditTitleKey: function() {
		return 'common.lbl.edit';
	},
	/**
	 * The iconCls for the copy button
	 */
	/*protected*/getCopyIconCls: function() {
		return 'copy';
	},
	/**
	 * The key for "copy" button text
	 */
	/*protected*/getCopyButtonKey: function() {
		return 'common.btn.copy';
	},
	/**
	 * The title for "copy" popup and "copy" action tooltip
	 */
	/*protected*/getCopyTitleKey: function() {
		return 'common.lbl.copy';
	},
	/**
	 * The iconCls for the delete button
	 */
	/*protected*/getDeleteIconCls: function() {
		return 'delete';
	},
	/**
	 * The key for "delete" button text
	 */
	/*protected*/getDeleteButtonKey: function() {
		return 'common.btn.delete';
	},
	/**
	 * The title for "delete" popup and "delete" action tooltip
	 */
	/*protected*/getDeleteTitleKey: function() {
		return 'common.lbl.delete';
	},
	/**
	 * The delete confirmation text (if it will be asked for confirmation)
	 */
	/*protected*/getRemoveWarningKey: function() {
		return 'common.lbl.removeWarning';
	},
	/**
	 * Get the title for add/edit/copy/delete window used also as tooltip for toolbar buttons
	 */
	/*protected*/getTitle: function(tooltipKey, extraConfig) {
		if (tooltipKey) {
			//add tooltipKey to extraConfig to identify the action
			//can be that the entity label depends also on the action to be executed
			//(for example add "status" but upload "icon")
			if (extraConfig===undefined) {
				extraConfig = new Object();
			}
			extraConfig['tooltipKey'] = tooltipKey;
		}
		return getText(tooltipKey, this.getEntityLabel(extraConfig));
	},
	/**********************************************action/context menu related methods***********************************************/
	/**
	 * Initialize the actions: should be overridden
	 */
	/*protected abstract*/initActions: function(){
		this.actions=[];
	},
	/**
	 * Get the toolbar actions.
	 * By default all actions, override if not all actions should appear in toolbar
	 */
	/*protected*/getToolbarActions: function(){
		return this.actions;
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 * By default all actions, override if not all actions should appear in the grid context menu
	 */
	/*protected*/getGridContextMenuActions: function(selectedRecord) {
		return this.actions;
	},
	/**
	 * Create a new Ext.Action
	 * labelKey the label key of the operation
	 * iconCls the icon class for the action
	 * handler the action handler
	 * disabled whether by creation it should be disabled
	 * tooltipKey makes sense only for toolbar buttons (not for context menu items)
	 * itemId for finding those actions which should have different labels depending on the context
	 * important only for tree with grid actions: for example edit action should be editLeaf entity or
	 * editFolder entity depending on the current selection
	 */
	/*public*/createAction: function(labelKey, iconCls, handler, disabled, tooltipKey, itemId, otherSettings) {
		var me = this;
		var actionConfig = {
				text: getText(labelKey),
				overflowText: getText(labelKey),
				iconCls: iconCls,
				scope: me,
				handler: handler
		};
		if (disabled) {
			actionConfig.disabled = disabled;
		}
		if (tooltipKey) {
			//tooltip is not an Ext.Action config field,
			//but it should be available when a button is created based on action
			//for simple grid actions the tooltip remains the same, so it is set and tooltipKey is not needed any more
			//actionConfig.tooltip = me.getTitle(tooltipKey);
			//but for tree with grid the tooltip might change based on the selected entity: "edit"/"delete" "folder"/"leaf"
			//that's why we store also the tooltipKey to be able to dynamically change the tooltips based on the current selection
			actionConfig.tooltipKey = tooltipKey;
			actionConfig.tooltip = this.getTitle(tooltipKey);
		}
		if (itemId) {
			actionConfig.itemId = itemId;
		}
		if (otherSettings) {
			//for example enableToggle should be set here
			for (propertyName in otherSettings) {
				actionConfig[propertyName] = otherSettings[propertyName];
			}
		}
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Create a new Ext.Action action with localized text and tooltip
	 * label the localized label of the operation
	 * iconCls the icon class for the action
	 * handler the action handler
	 * tooltip makes sense only for toolbar buttons (not for context menu items)
	 * 		this is the localized tooltip not the tooltip key, because the tooltip for localized actions should not change
	 * 		depending on the context
	 * disabled whether by creation it should be disabled
	 */
	/*public*/createLocalizedAction: function(label, iconCls, handler, tooltip, disabled) {
		var me = this;
		var actionConfig = {
				text: label,
				overflowText: label,
				iconCls: iconCls,
				scope: me,
				handler: handler
		};
		if (disabled) {
			actionConfig.disabled = disabled;
		}
		if (tooltip) {
			//tooltip is not an Ext.Action config field,
			//but it should be available when a button is created based on action
			//for "add" action(s) the tooltip remains the same, tooltipKey is not needed any more
			actionConfig.tooltip = tooltip;
		}
		return Ext.create('Ext.Action', actionConfig);
	},
	/**
	 * Creates a context menu based on an array of actions
	 */
	/*public*/createContextMenu: function(record, actions) {
		var contextMenu = new Ext.menu.Menu({
			items: []
		});
		if (actions) {
			for(var i=0;i<actions.length;i++){
				var action=actions[i];
				var contextMenuItemCfg = {
					text:action.getText(),
					iconCls:action.getIconCls()+"16",
					scope:action,
					tooltip:action.initialConfig.tooltip,
					//handler:action.execute,
					handler: action.initialConfig.handler,
					//scope: action.initialConfig.scope,
					itemId: action.itemId};
				if (action.initialConfig.scope!=null) {
					contextMenuItemCfg.scope = action.initialConfig.scope;
				}
				contextMenu.add(contextMenuItemCfg);
				if (action.itemId) {
					var contextMenuItem = contextMenu.getComponent(action.itemId);
					contextMenuItem.tooltipKey = action.initialConfig.tooltipKey;
				}
			}
		}
		return contextMenu;
	},
	/**********************************************reload methods***********************************************/
	/**
	 * Reload after a change operation
	 * In the implementations set to the corresponding com.trackplus.util.RefreshAfterSubmit method
	 */
	/*protected abstract*/reload:null,
	/**
	 * Parameters for reloading after a delete operation
	 * By delete the reload and select parameters are known before
	 */
	/*protected abstract*/getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		return responseJson;
	},
	/**********************************************popup content and handler methods***********************************************/
	/**
	 * The form in the popup window.
	 * Either this or getEditPanelItems() should be implemented
	 * recordData: the selected entity data
	 * action: the submit action
	 */
	/*protected abstract*/createEditForm: function(recordData, action){
		return null;
	},
	/**
	 * The items in the popup window.
	 * Either this or getEditFormItems() should be implemented
	 * recordData: the selected entity data
	 * action: the submit action
	 */
	/*protected abstract*/getEditPanelItems:function(recordData, action){
		return null;
	},
	/**
	 * Handler for loading the form data
	 * Should be implemented only when panel is not form panel (for ex. a grid)
	 * and the load is made "manually"
	 */
	/*protected*/loadHandler:null,
	/**
	 * Handler for sending the form data to the sever
	 * Should be implemented only when panel is not form panel (for ex. a grid)
	 * and the save is made "manually"
	 */
	/*protected*/submitHandler:null,
	/**********************************************popup URL and params***********************************************/
	/**
	 * Get the base action name from struts configuration
	 * Should be overridden
	 */
	/*public abstract*/getNodeBaseAction: function(extraConfig) {
		return null;
	},
	/**
	 * An array of of additional actions are needed beyond save and cancel
	 * The objects in the array should be composed in the same manner as the submit object for save
	 * the submit object contains:
	 * submitUrl: url the submit is sent to
	 * submitUrlParams: extra parameters for submit
	 * submitButtonText: the label for submit button (defaults to the label keyed by 'common.btn.save')
	 * refreshAfterSubmit: true if not specified, if false the refresh is not called in the submit handler
	 * closeAfterSubmit: true if not specified, if false the window is not closed in the submit handler
	 * submitHandler: an alternative submit handler used when isFormPanel is false (probably manual submit of a grid)
	 * 	refreshAfterSubmit and closeAfterSubmit has no relevance if submitHandler is specified
	 * submitAction: the action for submit ("add", "edit", "copy", "overwrite"). Not required
	 * if there are more actions which need a submit the submit object can be an array of such submit objects
	 *
	 */
	/*protected*/getAdditionalActions: function(recordData, submitParams, operation) {
		return null;
	},
	/**
	 * Get the ID based from the recordData and extraConfig
	 * recordData: the data for a single record (for multiple selection this method is applied for each record separately)
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected abstract*/getRecordID: function(recordData, extraConfig) {
		return null;
	},
	/**
	 * Whether a new entity can be created
	 */
	/*protected*/canCreateEntity: function(){
		return true;
	},
	/**
	 * The struts action for delete/replace
	 */
	/*protected*/getDeleteUrlBase: function(extraConfig) {
		return this.getNodeBaseAction(extraConfig);
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getDeleteUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!delete.action';
	},
	/**
	 * Parameter name for the submitted id(s) by delete
	 * If allowMultipleSelections===false then the same this.entityID (simple grid) or
	 * 	node (tree with grid) can be used on the server side for both delete and edit submits
	 * If allowMultipleSelections===true this should return another name
	 * 	the submitted value will be stored on the server typically
	 * 	in an Integer[] (simple grid) or String[] (tree with grid) variable
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 * Must be overridden if allowMultipleSelections===true
	 */
	/*protected abstract*/getDeleteParamName: function(extraConfig) {
		return null;
	},
	/**
	 * Parameters for deleting entity
	 * recordData: the selected entity data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getDeleteParams: function(selectedRecords, extraConfig) {
		var params=new Object();
		var selectionParam = this.getSelectedIDs(selectedRecords, extraConfig);
		params[this.getDeleteParamName(extraConfig)]=selectionParam;
		if (this.confirmDeleteNotEmpty) {
			params['deleteConfirmed'] = this.deleteConfirmed;
		}
		return params;
	},
	/**
	 * Url for preparing the replacement data rendering
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getRenderReplaceUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!renderReplace.action';
	},
	/**
	 * Parameters for preparing the replacement data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getRenderReplaceParams: function(selectedRecords, extraConfig) {
		return this.getDeleteParams(selectedRecords, extraConfig);
	},
	/**
	 * Url for replacing and deleting of an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getReplaceAndDeleteUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!replaceAndDelete.action';
	},
	/**
	 * Parameters for replacing and deleting of an entity
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getReplaceAndDeleteParams: function(selectedRecords, extraConfig) {
		return this.getDeleteParams(selectedRecords, extraConfig);
	},
	/**
	 * Function to be called before submit to add dynamic parameters
	 * to existing submitUrlParams based on the panel's content*/
	/*protected*/preSubmitProcess: /* function(submitUrlParams, panel) {
	 	//add parameters to submitUrlParams based on panel
		return submitUrlParams;
	},*/null,
	/**
	 * The label for the save button
	 */
	/*protected*/getSaveLabel: function(operation) {
		return getText('common.btn.save');
	},
	/**
	 * The label for the cancel button
	 */
	/*protected*/getCancelLabel: function() {
		return getText('common.btn.cancel');
	},
	/**
	 * The label for the delete button
	 */
	/*protected*/getDeleteLabel: function() {
		return getText('common.btn.delete');
	},
	/************************************delete related fields ***************************************/
	/**
	 * The localized entity name to be deleted
	 * Should be implemented only if differs from entity name
	 * (for example in field configuration: entity label is "field configuration" but delete label is "field")
	 */
	/*protected*/getDeleteEntityLabel:function(extraConfig) {
		return this.getEntityLabel(extraConfig);
	},
	/**
	 * The a message patameterized with the deleteEntityLabel
	 */
	getDeleteEntityMessage: function(titleKey, extraConfig) {
		return getText(titleKey, this.getDeleteEntityLabel(extraConfig));
	},
	/**
	 * Handler for deleting the selected data.
	 * It can be single or multiple selection
	 * title:
	 */
	/*private*/deleteHandler: function(selectedRecords, extraConfig){
		var me=this;
		if (CWHF.isNull(selectedRecords)) {
			return true;
		}
		this.deleteConfirmed = false;
		if (me.confirmDeleteEntity) {
			Ext.MessageBox.confirm(me.getDeleteEntityMessage(me.getDeleteTitleKey(), extraConfig),
				me.getDeleteEntityMessage(me.getRemoveWarningKey(), extraConfig),
					function(btn){
						if (btn==="no") {
							return false;
						} else {
							me.deleteSelected.call(me, selectedRecords, extraConfig);
						}
					});
		} else {
			me.deleteSelected(selectedRecords, extraConfig);
		}
	},
	/**
	 * Delete handler
	 * selectedRecords the selected data (node(s)/row(s)) to be deleted
	 * extraConfig implementation specific extra configuration object
	 */
	/*private*/deleteSelected: function(selectedRecords, extraConfig) {
		var me=this;
		var deleteParams = me.getDeleteParams(selectedRecords, extraConfig);
		Ext.Ajax.request({
			url: me.getDeleteUrl(extraConfig),
			params: deleteParams,
			disableCaching:true,
			scope: me,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success===true) {
					//delete done (no replacement were needed)
					me.reload.call(me, me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson));
				} else {
					var errorCode = responseJson.errorCode;
					if (errorCode) {
						if (errorCode===me.ERROR_CODE_NEED_REPLACE) {
							//render dialog for selecting the replacement
							var windowItems = me.getReplacementItems(responseJson, selectedRecords, extraConfig);
							var title = me.getTitle(me.getDeleteTitleKey(), extraConfig);
							var load = {loadUrl:me.getRenderReplaceUrl(extraConfig),
									loadUrlParams:me.getRenderReplaceParams(selectedRecords, extraConfig)};
							var submit = {	submitUrl:me.getReplaceAndDeleteUrl(extraConfig),
											submitUrlParams:me.getReplaceAndDeleteParams(selectedRecords, extraConfig),
											submitButtonText:me.getDeleteLabel(),
											//deleting more users can be a lengthy operation
	                                        timeout:300,
											refreshAfterSubmitHandler:me.reload,
											refreshParametersBeforeSubmit:me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson)
										};
							var windowConfig = Ext.create('com.trackplus.util.WindowConfig',
									{postDataProcess:me.replaceOptionPostDataProcess, extraConfig:extraConfig});
							windowConfig.showWindow(me, title, me.replacementWidth, me.replacementHeight, load, submit, /*refresh,*/ windowItems);
						} else {
							//the entity to be deleted is not empty an extra confirmation box is shown
							if (errorCode===me.NOT_EMPTY_WARNING) {
								var errorMessage = responseJson.errorMessage;
								Ext.MessageBox.confirm(me.getDeleteEntityMessage(me.getDeleteTitleKey(), extraConfig),
									errorMessage,
									function(btn){
										if (btn==="no") {
											return false;
										} else {
											this.deleteConfirmed = true;
											me.deleteSelected.call(me, selectedRecords, extraConfig);
										}
									}, this);
							} else {
								Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
							}
						}
					} else {
						//no right to delete (for ex. with fake URL-Params)
						me.errorHandlerDelete(responseJson, selectedRecords);
					}
				}
			},
			failure: function(response){
				com.trackplus.util.requestFailureHandler(response);
			},
			method:"POST"
		});
	},
	/**
	 * Gather selected ID as a comma separated string
	 * selectedRecords - the selected record(s): simple or multiple selection:
	 * 	if simple the selection the record, if multiple an array of records
	 * getIDFormEntityFunction - function for getting the ID from an entity JSON
	 * extraConfig
	 */
	/*private*/getSelectedIDs: function(selectedRecords, extraConfig) {
		if (this.allowMultipleSelections) {
			var idArray = [];
			Ext.Array.forEach(selectedRecords, function(record) {
				idArray.push(this.getRecordID(record.data, extraConfig));
			}, this);
			return idArray.join();
		} else {
			return this.getRecordID(selectedRecords.data, extraConfig);
		}
	},
	/**
	 * Error handler for delete. In the overridden versions depending on error code
	 * the deleteSelected() might be called again with extra/modified submit parameters
	 */
	/*protected*/errorHandlerDelete: function(result, selectedRecords){
		com.trackplus.util.showError(result);
	},
	/**
	 * The replacement items for the deleted entity
	 * (The replacement panel will be created with on this items)
	 */
	/*protected*/getReplacementItems: function(responseJson, selectedRecords, extraConfig) {
		return [{xtype : 'label',
				itemId: 'replacementWarning'},
				CWHF.createCombo('Replacement',
						'replacementID',
						{itemId:"replacementID",
						labelWidth:200,
						allowBlank:false,
						blankText: getText('common.err.replacementRequired',
								this.getEntityLabel(extraConfig))})];
	},
	/**
	 * Load the data in the replacement panel when it arrives from server
	 * the complete replacementWarning could be composed on the server
	 * If not, it will be composed on the client, but at least
	 * the label of the entity to be deleted should be specified
	 */
	/*private*/replaceOptionPostDataProcess: function(data, panel, extraConfig) {
		var replacementWarning = panel.getComponent('replacementWarning');
		var replacementWarningText = data['replacementWarning'];
		if (CWHF.isNull(replacementWarningText)) {
			var label = data['label'];
			replacementWarningText = getText("common.lbl.replacementWarning", this.getEntityLabel(extraConfig), label);
			replacementWarningText = replacementWarningText + getText("common.lbl.cancelDeleteAlert");
		}
		replacementWarning.setText(replacementWarningText, false);
		var replacementList = panel.getComponent('replacementID');
		this.loadReplacementOptionData(replacementList, data);
		var replacementListLabel = data.replacementListLabel;
		if (CWHF.isNull(replacementListLabel)) {
			replacementListLabel =  this.getTitle('common.lbl.replacement', extraConfig);
		}
		replacementList.labelEl.dom.innerHTML = replacementListLabel;
	},
	/**
	 * Load the data source and value for the replacement options combo
	 * Override this for different tree based pickers
	 */
	/*protected*/loadReplacementOptionData: function(replacementControl, data) {
		replacementControl.store.loadData(data["replacementList"]);
		replacementControl.setValue(null);
	},
	/************************************selection utility methods***************************************/
	/**
	 * Get the configuration for selection model
	 */
	/*protected*//*getGridSelectionModel: function() {
		var selectionModelConfig = new Object();
		if (this.allowMultipleSelections) {
			selectionModelConfig.mode="MULTI";
		} else {
			selectionModelConfig.mode="SINGLE";
			if (this.allowDeselect) {
				selectionModelConfig.allowDeselect=this.allowDeselect;
			}
		}
		if (CWHF.isNull(this.gridSelectionModel)) {
			return Ext.create("Ext.selection.RowModel", selectionModelConfig);
		} else {
			return this.gridSelectionModel;
		}
	},*/
	//grid specific selection utility methods
	/**
	 * The the last selected grid row (only one row)
	 */
	/*getLastSelectedGridRow: function() {
		if (this.grid) {
			return this.grid.getSelectionModel().getLastSelected();
		}
		return null;
	},*/
	/**
	 * The the selected grid rows (possibly more than one)
	 */
	/*getGridSelection: function() {
		if (this.grid) {
			return this.grid.getSelectionModel().getSelection();
		}
		return null;
	},*/
	/**
	 * Select and returns a record in the grid
	 * (used by activating the context menu)
	 */
	/*selectGridRow: function(record) {
		//false to not retain existing selections
		if (this.grid) {
			this.grid.getSelectionModel().select(record, false);
		}
		return record;
	},*/
	//general selection utility methods
	/**
	 * Gets the last selected data (either tree node or grid row)
	 */
	/*getLastSelected: function() {
		return this.getLastSelectedGridRow();
	},*/
	/**
	 * Get the selection(s) (either in tree or in grid )
	 */
	/*getSelection: function() {
		return this.getGridSelection();
	},*/
	/**
	 * Gets the selected data
	 * it can be simple or multiple selection
	 */
	/*getSelectedRecords: function() {
		var me=this;
		if (me.allowMultipleSelections) {
			return me.getSelection();
		} else {
			return me.getLastSelected();
		}
	},*/
	/**
	 * Whether the selection is simple or multiple
	 */
	/*selectionIsSimple: function() {
		if (this.allowMultipleSelections) {
			var selectedRecords = this.getSelection();
			return selectedRecords && selectedRecords.length===1;
		} else {
			var selectedRecord = this.getLastSelected();
			return selectedRecord!==null;
		}
	},*/
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 * param: typically fromTree
	 */
	/*private*//*getSingleSelectedRecordData: function(param) {
		var selectedRecord = this.getSingleSelectedRecord(param);
		if (selectedRecord) {
			return selectedRecord.data;
		}
		return null;
	},*/
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 */
	/*private*//*getSingleSelectedRecord: function(param) {
		var selectedRecords = this.getSelectedRecords(param);
		if (selectedRecords) {
			if (this.allowMultipleSelections) {
				if (selectedRecords && selectedRecords.length===1) {
					return selectedRecords[0];
				} else {
					return null;
				}
			} else {
				return selectedRecords;
			}
		} else {
			return null;
		}
	},*/
	/**
	 * Select and return a record by activating the context menu
	 */
	/*selectRecord: function(record) {
		return this.selectGridRow(record);
	}*/
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.ActionBase',{
	extend:'Ext.Base',
	/**
	 * The title for a failure message
	 */
	failureTitle:getText('common.err.failure'),
	/**
	 * The iconCls for the add button
	 */
	/*protected*/getAddIconCls: function() {
		return 'add';
	},
	/**
	 * The key for "add" button text
	 */
	/*protected*/getAddButtonKey: function() {
		return 'common.btn.add';
	},
	/**
	 * The title for "add" popup and "add" action tooltip
	 */
	/*protected*/getAddTitleKey: function() {
		return 'common.lbl.add';
	},
	/**
	 * The iconCls for the edit button
	 */
	/*protected*/getEditIconCls: function() {
		return 'edit';
	},
	/**
	 * The key for "edit" button text
	 */
	/*protected*/getEditButtonKey: function() {
		return 'common.btn.edit';
	},
	/**
	 * The title for "edit" popup and "edit" action tooltip
	 */
	/*protected*/getEditTitleKey: function() {
		return 'common.lbl.edit';
	},
	/**
	 * The iconCls for the copy button
	 */
	/*protected*/getCopyIconCls: function() {
		return 'copy';
	},
	/**
	 * The key for "copy" button text
	 */
	/*protected*/getCopyButtonKey: function() {
		return 'common.btn.copy';
	},
	/**
	 * The title for "copy" popup and "copy" action tooltip
	 */
	/*protected*/getCopyTitleKey: function() {
		return 'common.lbl.copy';
	},
	/**
	 * The iconCls for the delete button
	 */
	/*protected*/getDeleteIconCls: function() {
		return 'delete';
	},
	/**
	 * The key for "delete" button text
	 */
	/*protected*/getDeleteButtonKey: function() {
		return 'common.btn.delete';
	},
	/**
	 * The title for "delete" popup and "delete" action tooltip
	 */
	/*protected*/getDeleteTitleKey: function() {
		return 'common.lbl.delete';
	},
	/**
	 * The delete confirmation text (if it will be asked for confirmation)
	 */
	/*protected*/getRemoveWarningKey: function() {
		return 'common.lbl.removeWarning';
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Base class for all tree-based pages (tree with grid and tree detail)
 */
Ext.define('com.trackplus.admin.TreeBase', {
	extend : 'com.trackplus.admin.CrudBase',
	config : {
	    /**
		 * The ID of the root node
		 */
	    rootID : '_',
	    /**
		 * the url for leaf detail if showGridForLeaf is false
		 */
	    // the width of the tree panel
	    treeWidth : 200
	},
	replaceCenterPanel : null,
	 /**
	 * Whether more tree nodes can be selected on the same time
	 */
    allowMultipleNodeSelections : false,
	/**
	 * The base struts action name (without method name) in struts.xml for
	 * the set this if it differs from base action (folder and leaf
	 * operations are in different struts actions)
	 */
    folderAction : null,
	/**
	 * Whether selecting a folder node in the tree results in a grid in the
	 * detail part or other detail info
	 */
	showGridForFolder : false,
	/**
	 * If showGridForFolder is false, then whether the folder details are loaded
	 * manually or through a form load method
	 */
	folderDetailByFormLoad : false,
	/**
	 * Whether to show a grid with a single row instead of other detailed view
	 * of the leaf node
	 */
	// showGridForLeaf: false,
	/**
	 * If showGridForLeaf is false, then whether the leaf details are loaded
	 * manually or through a form load method
	 */
	leafDetailByFormLoad : false,
	/**
	 * Whether to completely replace the toolbar for tree node select or only
	 * change the disabled status If true, the toolbar actions for nodes of
	 * different levels change radically, replace the toolbar after each node
	 * select In this case getToolbarActionsForTreeNodeSelect() should be
	 * implemented If false, the toolbar actions are relative constant. In this
	 * case getToolbarActionChangesForTreeNodeSelect() should be implemented
	 */
	replaceToolbarOnTreeNodeSelect : false,
	/**
	 * whether to allow cut/copy-paste in the tree
	 */
	useCopyPaste : false,
	/**
	 * whether to enable drag and drop on the tree
	 */
	dragAndDropOnTree : false,
	/**
	 * Whether the tree has context menu listener
	 */
	treeHasItemcontextmenu : true,
	/**
	 * Whether the tree has double click listener
	 */
	treeHasItemdblclick : true,
	/**
	 * The tree
	 */
	tree : null,
	/**
	 * The selected node in the tree
	 */
	selectedNode : null,
	/**
	 * The id of the selected node in the tree
	 */
	selectedNodeID : null,
	/**
	 * the node to cut/copy
	 */
	cutCopyNode : null,
	/**
	 * Whether it is copy/paste or cut/paste
	 */
	copy : false,
	/**
	 * The panel with the tree and detail part
	 */
	mainPanel : null,
	/**
	 * The panel where the grid (for folder node) or node detail (for leaf node)
	 * is rendered
	 */
	centerPanel : null,
	constructor : function(config) {
	    var config = config || {};
	    this.initConfig(config);
	    this.initBase();
	},
	getFolderAction: function() {
		return this.folderAction;
	},
	/**
	 * Initialization method
	 */
	/* protected */initBase : function() {
	    this.initActions();
	},
	/**
	 * Get the base action name from struts configuration: either the baseAction
	 * or the folderAction if folderAction is null the base action is taken for
	 * both leafs and folders
	 */
	getNodeBaseAction : function(extraConfig) {
	    if (CWHF.isNull(this.getFolderAction()) || "" === this.getFolderAction()) {
		    // in this case we suppose there is no different struts action for
			// folder and leaf
		    return this.getBaseAction();
	    }
	    var isLeaf = true;
	    if (extraConfig ) {
		    isLeaf = extraConfig.isLeaf;
	    }
	    if (isLeaf) {
		    return this.getBaseAction();
	    } else {
		    return this.getFolderAction();
	    }
	},
	/**
	 * ********************************************action/context menu related
	 * methods**********************************************
	 */
	/**
	 * The iconCls for the add button
	 */
	/* protected */getAddFolderIconCls : function() {
	    return 'add';
	},
	/**
	 * The iconCls for the "cut" button
	 */
	/* protected */getCutIconCls : function() {
	    return 'cut';
	},
	/**
	 * The key for "cut" button text
	 */
	/* protected */getCutButtonKey : function() {
	    return 'common.btn.cut';
	},
	/**
	 * The key for "cut" context menu button' text
	 */
	/* protected */getCutTitleKey : function() {
	    return 'common.lbl.cut';
	},
	/**
	 * The iconCls for the "paste" button
	 */
	/* protected */getPasteIconCls : function() {
	    return 'paste';
	},
	/**
	 * The key for "paste" button text
	 */
	/* protected */getPasteButtonKey : function() {
	    return 'common.btn.paste';
	},
	/**
	 * The key for "paste" context menu button' text
	 */
	/* protected */getPasteTitleKey : function() {
	    return 'common.lbl.paste';
	},
	/**
	 * Gets the tree's fields
	 */
	/* protected */getTreeFields : function() {
	    return [ {
	        name : 'id',
	        mapping : 'id',
	        type : 'string'
	    }, {
	        name : 'text',
	        mapping : 'text',
	        type : 'string'
	    }, {
	        name : 'leaf',
	        mapping : 'leaf',
	        type : 'boolean'
	    }, {
	        name : 'iconCls',
	        mapping : 'iconCls',
	        type : 'string'
	    } ];
	},
	/**
	 * Extra parameters additionally to 'node' by expanding a node from the tree
	 * If the data in the tree is homogeneous then the node can be decoded
	 * uniquely But if not then extra parameters are needed to decide how to
	 * interpret the node id
	 */
	/* protected */getTreeExpandExtraParams : function(node) {
	    return null;
	},
	/**
	 * Get the itemId of those actions whose context menu text or toolbar button
	 * tooltip should be changed according to the current selection
	 */
	/* protected abstract */getActionItemIdsWithContextDependentLabel : function() {
	    return [];
	},
	/**
	 * Get the actions available in context menu depending on the currently
	 * selected row
	 *
	 */
	/* protected abstract */getTreeContextMenuActions : function(selectedRecord, selectionIsSimple) {
	    return [];
	},
	/**
	 * Context menu actions for tree
	 */
	/* protected */getContextMenuActions : function(selectedRecords, selectionIsSimple, fromTree) {
	    return this.getTreeContextMenuActions(selectedRecords, selectionIsSimple);
	},
	/**
	 * Show the context menu in grid
	 */
	/* private */onTreeNodeCtxMenu : function(tree, record, item, index, evtObj) {
	    this.onCtxMenu(true, record, evtObj);
	    return false;
	},
	/**
	 * Show the context menu in grid
	 */
	/* private */onCtxMenu : function(fromTree, record, evtObj) {
	    evtObj.stopEvent();
	    this.selectRecord(record, fromTree);
	    var selectedRecords = this.getSelectedRecords(fromTree);
	    var selectionIsSimple = this.selectionIsSimple(fromTree);
	    var actions = this.getContextMenuActions(selectedRecords, selectionIsSimple, fromTree);
	    if (actions  && actions.length > 0) {
		    var treeNodeCtxMenu = this.createContextMenu(record, actions);
		    this.adjustContextMenuText(treeNodeCtxMenu, selectedRecords, fromTree);
		    treeNodeCtxMenu.showAt(evtObj.getXY());
	    }
	    return false;
	},
	/**
	 * Change the text for an action depending on entity context (from grid or
	 * from three and for folder or for leaf)
	 */
	/* private */adjustContextMenuText : function(ctxMenu, selectedRecord, fromTree) {
	    actionIds = this.getActionItemIdsWithContextDependentLabel();
	    for (var i = 0; i < actionIds.length; i++) {
		    var actionId = actionIds[i];
		    var action = ctxMenu.getComponent(actionId);
		    if (action ) {
			    var isLeaf = this.selectedIsLeaf(fromTree);
			    action.text = this.getTitle(action.tooltipKey, {
			        isLeaf : isLeaf,
			        fromTree : fromTree,
			        selectedRecord : selectedRecord
			    });
			    action.setTooltip(this.getTitle(action.tooltipKey, {
			        isLeaf : isLeaf,
			        fromTree : fromTree,
			        selectedRecord : selectedRecord
			    }));
		    }
	    }
	},
	/**
	 * Change the text for an action depending on entity context (from grid or
	 * from three and for folder or for leaf)
	 */
	/* private */adjustToolbarButtonsTooltip : function(selectedNode, fromTree) {
	    actionIds = this.getActionItemIdsWithContextDependentLabel();
	    var toolbar = borderLayout.getActiveToolbarList();
	    for (var i = 0; i < actionIds.length; i++) {
		    var actionId = actionIds[i];
		    var toolbarButton = toolbar.getComponent(actionId);
		    if (toolbarButton ) {
			    var isLeaf = this.selectedIsLeaf(fromTree);
			    toolbarButton.setTooltip(this.getTitle(toolbarButton.tooltipKey, {
			        isLeaf : isLeaf,
			        fromTree : fromTree,
			        selectedRecord : selectedNode
			    }));
		    }
	    }
	},
	/**
	 * ********************************************tree
	 * methods**********************************************
	 */
	/**
	 * Whether drag and drop on tree is possible
	 */
	/* protected */hasDragAndDropOnTree : function(node) {
	    return this.dragAndDropOnTree;
	},
	/**
	 * The drag and drop configuration object
	 */
	/* protected */getDragAndDropOnTreeConfig : function() {
	    return {
	        ptype : 'treeviewdragdrop',
	        dragGroup : this.getBaseAction() + 'DDGroup',
	        dropGroup : this.getBaseAction() + 'DDGroup',
	        appendOnly : true,
	        enableDrag : true,
	        enableDrop : true
	    };
	},
	/**
	 * Initialize the tree
	 */
	/* private */initTree : function() {
		var me=this;
	    var treeStore = Ext.create('Ext.data.TreeStore', {
	        root : {
	            expanded : true,
	            id : me.getRootID()
	        },
		    proxy : {
			    fromCenterPanel : true,
			    type : 'ajax',
			    url : this.getNodeBaseAction({
				    isLeaf : false
			    }) + '!expand.action',
			    // for expanding the root
			    extraParams : this.getTreeExpandExtraParams(),
			    listeners : {
				    exception : function(proxy, response, operation, opts) {
					    var responseJson = Ext.decode(response.responseText);
					    com.trackplus.util.showError(responseJson);
				    }
			    }
		    },
		    fields : this.getTreeFields()
	    });
	    var treeConfig = {
	        xtype : 'treepanel',
	        store : treeStore,
	        selModel : this.getTreeSelectionModel(),
	        region : 'west',
	        autoScroll : true,
	        width : this.getTreeWidth(),
		    margin : '0 -5 0 0',
	        split: me.isTreeSplitOn(),
	        // collapsible: true,
	        header : false,
	        border : false,
	        bodyBorder : false,
	        style : {
		        borderRight : '1px solid #D0D0D0'
	        },
	        animate : false,
	        useArrows : true,
	        containerScroll : true,
	        rootVisible : false,
	        cls : 'simpleTree'
	    };
	    /*
		 * The (re)loading a branch of a tree deactivates the node (looses a
		 * selection) and the selectionChange event is called with no selection
		 * (that means also by loosing a selection). It removes all from the
		 * detail panel but leaves it empty because there is no new selection to
		 * present the details for That's why, instead of selectionchange we use
		 * select event
		 */
	    var treeListeners = new Object();
	    if (this.allowMultipleNodeSelections) {
		    treeListeners.selectionchange = {
		        fn : this.treeNodeSelectionchange,
		        scope : this
		    };
	    } else {
		    treeListeners.select = {
		        fn : this.treeNodeSelect,
		        scope : this
		    };
	    }
	    // var treeListeners = {/*selectionchange:*/select:
		// {fn:this.treeNodeSelect, scope:this}};
	    if (this.treeHasItemcontextmenu) {
		    treeListeners.itemcontextmenu = {
		        fn : this.onTreeNodeCtxMenu,
		        scope : this
		    };
	    }
	    if (this.treeHasItemdblclick) {
		    treeListeners.itemdblclick = {
		        fn : this.onTreeNodeDblClick,
		        scope : this
		    };
	    }
	    treeConfig.listeners = treeListeners;
	    if (this.hasDragAndDropOnTree()) {
		    // add drag and drop
		    treeConfig.viewConfig = {
		        plugins : this.getDragAndDropOnTreeConfig(),
		        // allowCopy: true,
		        listeners : {
		            beforedrop : {
		                scope : this,
		                fn : function(node, data, overModel, dropPosition) {
			                var nodeToDrag = data.records[0];
			                var copy = data.copy;
			                if (CWHF.isNull(copy)) {
				                // move by default
				                copy = false;
			                }
			                return this.canDragDropNode(nodeToDrag, copy, overModel);
		                }
		            },
		            drop : {
		                scope : this,
		                fn : function(node, data, overModel, dropPosition) {
			                var copy = data.copy;
			                if (CWHF.isNull(copy)) {
				                // move by default
				                copy = false;
			                }
			                this.onDropTreeNode(data.records[0], overModel, copy);
		                }
		            }
		        }
		    };
	    }
	    this.tree = Ext.create('Ext.tree.Panel', treeConfig);
	    // treeStore.on('beforeexpand', function(node) {
	    treeStore.on('beforeload', function(store, operation) {
		    /*
			 * Dynamic extra parameters depending on the expanded node
			 * additionally to 'node' parameter by expanding a node from the
			 * tree If the data in the tree is homogeneous then the node can be
			 * decoded uniquely But if not then extra parameters are needed to
			 * decide how to interpret the node id The last extraParams value
			 * wins, so by reloading a tree node for refreshing the content the
			 * extraParams should also be actualized
			 */
		    if (operation.node ) {
			    var extraParams = this.getTreeExpandExtraParams(operation.node);
			    if (extraParams ) {
				    treeStore.proxy.extraParams = extraParams;
			    }
		    }
	    }, this);
	    treeStore.on('load', function(treeStore,  records, successful, operation, node, eOpts) {
		    this.onTreeNodeLoad(treeStore, node);
	    }, this);
	},
	/**
	 * Get the configuration for selection model
	 */
	/* protected */getTreeSelectionModel : function() {
	    var selectionModelConfig = new Object;
	    if (this.allowMultipleNodeSelections) {
		    selectionModelConfig.mode = "MULTI";
	    } else {
		    selectionModelConfig.mode = "SINGLE";
		    if (this.allowDeselect) {
			    selectionModelConfig.allowDeselect = this.allowDeselect;
		    }
	    }
	    if (CWHF.isNull(this.treeSelectionModel)) {
		    return Ext.create("Ext.selection.TreeModel", selectionModelConfig);
	    } else {
		    return this.treeSelectionModel;
	    }
	},
	/**
	 * Handler after loading the node
	 */
	onTreeNodeLoad : function(treeStore, node) {
	    // typically used to make something after loading the children of the
		// root
	    // if (node.isRoot()) {
	    // }
	},
	/**
	 * Return false if dragging this node is not allowed
	 */
	canDragDropNode : function(nodeToDrag, copy, overModel) {
	    /*
		 * var leaf = nodeToDrag.data["leaf"]; //by default only leafs are
		 * allowed to drag if (!leaf) { return false; }
		 */
	    return false;
	},
	/**
	 * Which base action should execute the paste/drop operation depending on
	 * the dragged node's leaf property the folderAction or the baseAction (leaf
	 * action) (can be that independently from the leaf property the same action
	 * should be used)
	 */
	/* protected */getDragDropBaseAction : function(draggedNodeIsLeaf) {
	    return this.getNodeBaseAction({
		    isLeaf : draggedNodeIsLeaf
	    });
	},
	/**
	 * Paste a node in the tree after copy/cut
	 */
	onDropTreeNode : function(nodeFrom, nodeTo, copy) {
	    var leafTo = nodeTo.isLeaf();
	    if (leafTo) {
		    nodeTo = nodeTo.parentNode;
	    }
	    var isLeaf = this.selectedIsLeaf(nodeFrom);
	    var strutsBaseAction = this.getDragDropBaseAction(isLeaf);
	    // After a paste the nodeTo should be refreshed.
	    // If the paste was after a cut the nodeFrom should be also refreshed.
	    // Get the parent hierarchy of the nodeTo, because it should be expanded
		// after paste.
	    // Although the path till nodeTo is already expanded if the paste is
		// made after a cut (not copy)
	    // in and the nodeTo is in a subtree of the nodeFrom after the nodeFrom
		// will be refreshed it will "hide"
	    // the path to nodeTo, that's why the path should be expanded manually
		// using this array
	    /*
		 * var parentHierarchy = [nodeTo.raw["id"]]; var parentNode =
		 * nodeTo.parentNode; while (parentNode && parentNode.raw)
		 * {//parentNode.raw is null for root node
		 * parentHierarchy.push(parentNode.raw["id"]); parentNode =
		 * parentNode.parentNode; }
		 */
	    Ext.Ajax.request({
	        fromCenterPanel : true,
	        url : strutsBaseAction + '!copy.action',
	        params : {
	            nodeFrom : nodeFrom.data["id"],
	            nodeTo : nodeTo.data["id"],
	            copy : copy
	        },
	        scope : this,
	        disableCaching : true,
	        success : function(response) {
		        var responseJson = Ext.decode(response.responseText);
		        if (responseJson.success === true) {
			        // reload the nodeFrom but only if cut
			        if (!copy) {
				        // after a cut the nodeFrom's parent should be also
						// refreshed
				        // if the nodeTo is in a subtree of the nodeFrom after
						// the nodeFrom's parent would be refreshed it would
						// "hide"
				        // the path to the already expanded nodeTo. That's why
						// we do not refresh it but delete it directly
				        nodeFrom.remove(true);
				        /*
						 * var fromParentID = nodeFrom.parentNode.raw["id"];
						 * //reload of nodeFrom if cut
						 * this.refreshGridAndTreeAfterSubmit({nodeIDToReload:fromParentID});
						 * //if nodeFrom reload "hides" the nodeTo then expand
						 * the path till nodeTo again if
						 * (parentHierarchy.indexOf(fromParentID)!==-1) { var
						 * parentNode =
						 * this.tree.getStore().getNodeById(parentHierarchy.pop());
						 * while (parentNode) { parentNode.expand(); var
						 * nextId = parentHierarchy.pop(); if (nextId) {
						 * parentNode =
						 * this.tree.getStore().getNodeById(nextId); } else {
						 * parentNode = null; } } }
						 */
			        }
			        // nodeTo.removeAll(true);
			        com.trackplus.util.RefreshAfterSubmit.refreshGridAndTreeAfterSubmit.call(this, {
			            nodeIDToReload : nodeTo.data["id"],
			            nodeIDToSelect : responseJson.node
			        });
		        } else {
			        if (responseJson.errorMessage ) {
				        // no right to delete
				        Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
			        }
		        }
	        },
	        failure : function(result) {
		        Ext.MessageBox.alert(this.failureTitle, result.responseText);
	        },
	        method : "POST"
	    });
	},
	/* protected */onTreeNodeDblClick : function(view, record) {
	},
	/**
	 * The message to appear first time after selecting this menu entry Is
	 * should be shown by selecting the root but the root is typically not
	 * visible
	 */
	/* protected abstract */getRootMessage : function() {
	    return "";
	    // return getText('...');
	},
	/**
	 * Initialize the center panel with data by initializing the tree and
	 * eventually the detail part (if it is independent of the selected tree
	 * node) By default only the tree is initialized
	 */
	/* protected */initCenterPanel : function() {
	    this.initTree();
	},
	/**
	 * Creates the center panel containing the tree and the details part
	 */
	createCenterPanel : function() {
	    var items = [];
	    var rootMessage = this.getRootMessage();
	    if (rootMessage && rootMessage !== "") {
		    items = this.getInfoBoxItems(rootMessage);
	    }
	    this.centerPanel = Ext.create('Ext.form.Panel', {
	        region : 'center',
	        /*
			 * style:{ borderLeft:'1px solid #D0D0D0' },
			 */
	        border : false,
	        autoScroll : true,
	        header : false,
	        items : items
	    });
	    this.initCenterPanel();
		this.mainPanel = Ext.create('Ext.panel.Panel',{
			region:'center',
			layout:'fit',
			border:false,
			bodyBorder:false,
			items:[this.centerPanel]
		});
	    this.postInitCenterPanel(this.tree.getRootNode());
		var panelCenterWrapper=Ext.create('Ext.panel.Panel',{
			layout:'border',
			region:'center',
			border:false,
			bodyBorder:false,
			items:[this.tree,this.mainPanel]
		});
		return panelCenterWrapper;
	},
	/**
	 * Callback called after creating the center panel
	 */
	postInitCenterPanel : function(rootNode) {
	},
	getInfoBoxItems : function(content) {
	    if (content  && content !== "") {
		    return [ {
		        xtype : 'component',
		        cls : 'infoBox_bottomBorder',
		        border : true,
		        html : content
		    } ];
	    } else {
		    return [];
	    }
	},
	/**
	 * Handler for selecting a node in the tree
	 */
	/* private */treeNodeSelect : function(rowModel, node, index, opts) {
	    var leaf = false;
	    if (node ) {
		    // typical: called for the select event from the tree
		    leaf = node.data['leaf'];
		    this.selectedNodeID = node.data['id'];
		    this.selectedNode = node;
	    } else {
		    // treeNodeSelect was manually triggered (not by tree node's select
			// event):
		    // for example from from a toolbar action
		    // in this case the tree last selected node from tree is taken
		    node = this.selectedNode;
	    }
	    this.loadDetailPanel(node, leaf, opts);
	    // toolbar content
	    this.actualizeToolbarOnTreeSelect(node);
	},
	/**
	 * Handler for selecting a node in the tree
	 */
	/* private */treeNodeSelectionchange : function(rowModel, selections, opts) {
	    var selectionIsSimple = this.selectionIsSimple(true);
	    var node = null;
	    if (selectionIsSimple) {
		    node = selections[0];
	    }
	    if (node ) {
		    // typical: called for the select event from the tree
		    this.selectedNodeID = node.data['id'];
		    this.selectedNode = node;
	    } else {
		    // treeNodeSelect was manually triggered (not by tree node's select
			// event):
		    // for example from from a toolbar action
		    // in this case the tree last selected node from tree is taken
		    node = this.selectedNode;
	    }
	    if (node ) {
		    this.loadDetailPanel(node, false);
	    } else {
		    this.resetDetailPanel();
	    }
	    // toolbar content
	    this.getToolbarActionChangesForTreeNodeSelectionChange(selections);
	},
	/* protected abstract */actualizeToolbarOnTreeSelect : function(selectedNode) {
	    if (this.replaceToolbarOnTreeNodeSelect) {
		    // replace the entire toolbar on tree node select
		    // if (selectedNode.length>0) {
		    // only for select (do not call by deselecting the old node)
		    // replace the existing toolbar totally
		    borderLayout.setActiveToolbarActionList(this.getToolbarActionsForTreeNodeSelect(selectedNode));
		    this.adjustToolbarButtonsTooltip(selectedNode, true);
		    // }
	    } else {
		    // in this moment actions are initialized in initAction() methods
			// called in init() and
		    // set on toolbar by
			// borderLayout.setActiveToolbarActionList(treeBaseImpl.getToolbarActions());
		    // leave the current toolbar only enable/disable toolbar actions
		    this.getToolbarActionChangesForTreeNodeSelect(selectedNode);
		    this.adjustToolbarButtonsTooltip(selectedNode, true);
	    }
	},
	/* protected abstract */loadDetailPanel : function(node, leaf, opts) {
	    return null;
	},
	/**
	 * Get the array of toolbar actions for a tree node select Implement only if
	 * replaceToolbarOnTreeNodeSelect is true
	 */
	/* protected abstract */getToolbarActionsForTreeNodeSelect : function(selectedNode) {
	    return this.getToolbarActions();
	},
	/**
	 * Which actions to enable/disable depending on tree selection Implement
	 * only if replaceToolbarOnTreeNodeSelect is false
	 */
	/* protected abstract */getToolbarActionChangesForTreeNodeSelect : function(selectedNode) {
	},
	/**
	 * Which actions to enable/disable depending on tree selection Implement
	 * only if replaceToolbarOnTreeNodeSelect is false
	 */
	/* protected abstract */getToolbarActionChangesForTreeNodeSelectionChange : function(selections) {
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	/* private */getDetailUrl : function(node, add) {
	    var leaf = node  && node.isLeaf();
	    if (leaf || add) {
		    return this.getLeafDetailUrl(node, add);
	    } else {
		    return this.getFolderDetailUrl(node, add);
	    }
	},
	/**
	 * The url for getting the folder detail: either this should be overridden
	 * or the folderDetailUrl should be specified in the config
	 */
	/* protected */getFolderDetailUrl : function(node, add) {
	    //if (CWHF.isNull(this.folderDetailUrl)) {
		    return this.getFolderAction() + '!load.action';
	    /*} else {
		    return folderDetailUrl;
	    }*/
	},
	/**
	 * The url for getting the leaf detail: either this should be overridden or
	 * the leafDetailUrl should be specified in the config
	 */
	/* protected */getLeafDetailUrl : function(node, add) {
	    //if (CWHF.isNull(this.leafDetailUrl)) {
		    return this.getBaseAction() + '!load.action';
		/*} else {
		    return this.getLeafDetailUrl();
	    }*/
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	/* private */getDetailParams : function(node, add, extraDetailParameters) {
	    if (add) {
		    var leaf = node  && node.isLeaf();
		    if (leaf) {
			    return this.getAddLeafParams(extraDetailParameters);
		    } else {
			    return this.getAddFolderParams(extraDetailParameters);
		    }
	    } else {
		    return this.getEditParams(true, extraDetailParameters);
	    }
	},
	/**
	 * Gets the items collection for detail node: the selected node add: whether
	 * it is add or edit responseJson: the JSON response for
	 * loadSimpleDetailPanel(). (When called from loadDetailPanelWithFormLoad()
	 * not specified)
	 */
	/* private */getDetailItems : function(node, add, responseJson) {
	    var leaf = node  && node.isLeaf();
	    if (leaf || add) {
		    return this.getLeafDetailItems(node, add, responseJson);
	    } else {
		    return this.getFolderDetailItems(node, add, responseJson);
	    }
	},
	/**
	 *
	 * Get the items array to render for folder detail either based on the
	 * response JSON (if folderDetailByFormLoad is false) or based on
	 * form.load() (if folderDetailByFormLoad is true) Should be implemented if
	 * showGridForFolder is false node: the selected node for add/edit add:
	 * whether it is an add or edit operation. When save is called directly from
	 * the detail part (tree-detail, not tree-grid-popup) then 'add' should be
	 * added to the form as hidden parameter (difference between save after edit
	 * and save after add) (alternatively a class level 'add' field should be
	 * declared and added to the save parameters in getSaveParams())
	 * responseJson: the response from the server (if folderDetailByFormLoad is
	 * false, otherwise null)
	 */
	/* protected */getFolderDetailItems : function(node, add, responseJson) {
	    return [];
	},
	/**
	 * Get the items array to render for leaf detail either based on the
	 * response JSON (if leafDetailByFormLoad is false) or based on form.load()
	 * (if leafDetailByFormLoad is true) Should be implemented if
	 * showGridForLeaf is false node: the selected node for add/edit add:
	 * whether it is an add or edit operation. When save is called directly from
	 * the detail part (tree-detail, not tree-grid-popup) then 'add' should be
	 * added to the form as hidden parameter (difference between save after edit
	 * and save after add) (alternatively a class level 'add' field should be
	 * declared and added to the save parameters in getSaveParams())
	 * responseJson: the response from the server (if leafDetailByFormLoad is
	 * false, otherwise null)
	 */
	/* protected */getLeafDetailItems : function(node, add, responseJson) {
	    return [];
	},
	/**
	 * Extra options for the detail panel
	 */
	getDetailPanelConfigOptions : function() {
	    return null;
	},
	/**
	 * Show the node detail using a form.load() method
	 */
	/*private*/loadDetailPanelWithFormLoad : function(node, add, extraDetailParameters) {
	    if (this.centerPanel ) {
		    this.mainPanel.remove(this.centerPanel, true);
	    }
	    var panelConfig = {
	        region : 'center',
	        border : false,
	        autoScroll : true,
	        header : false,
	        items : this.getDetailItems(node, add)
	    };
	    var panelConfigOptions = this.getDetailPanelConfigOptions();
	    if (panelConfigOptions ) {
		    for (propertyName in panelConfigOptions) {
			    panelConfig[propertyName] = panelConfigOptions[propertyName];
		    }
	    }
		this.centerPanel = Ext.create('Ext.form.Panel', panelConfig);
		if (this.replaceCenterPanel) {
		    this.replaceCenterPanel.call(this, this.centerPanel);
	    } else {
		    this.mainPanel.add(this.centerPanel);
	    }
	    this.centerPanel.getForm().load({
	        fromCenterPanel : true,
	        url : this.getDetailUrl(node, add),
	        scope : this,
	        params : this.getDetailParams(node, add, extraDetailParameters),
	        success : function(form, action) {
		        var isLeaf = add;
		        if (node ) {
			        isLeaf = node.isLeaf();
		        }
		        var postDataProcess = this.getEditPostDataProcess(node, isLeaf, add);
		        if (postDataProcess ) {
			        try {
				        postDataProcess.call(this, action.result.data, this.centerPanel);
			        } catch (ex) {
			        }
		        }
	        },
	        failure : function(form, action) {
		        Ext.MessageBox.alert(this.failureTitle, action.response.responseText);
	        }
	    });
	},
	/**
	 * Show the node detail based on responseJson
	 */
	/* private */loadSimpleDetailPanel : function(node, add, extraDetailParameters) {
	    Ext.Ajax.request({
	        fromCenterPanel : true,
	        url : this.getDetailUrl(node, add),
	        params : this.getDetailParams(node, add, extraDetailParameters),
	        scope : this,
	        disableCaching : true,
	        success : function(response) {
		        var responseJson = Ext.decode(response.responseText);
		        if (this.centerPanel ) {
			        this.mainPanel.remove(this.centerPanel, true);
		        }
		        this.centerPanel = Ext.create('Ext.panel.Panel', {
		            region : 'center',
		            border : false,
		            autoScroll : true,
		            header : false,
		            items : this.getDetailItems(node, add, responseJson)
		        });
		        if (this.replaceCenterPanel ) {
			        this.replaceCenterPanel.call(this, this.centerPanel);
		        } else {
			        this.mainPanel.add(this.centerPanel);
		        }
	        },
	        failure : function(result) {
		        Ext.MessageBox.alert(this.failureTitle, result.responseText);
	        },
	        method : "POST"
	    });
	},
	/**
	 * Reset the detail panel
	 */
	/* private */resetDetailPanel : function() {
	    var rootMessage = this.getRootMessage();
	    if (rootMessage  || rootMessage !== "") {
		    items = this.getInfoBoxItems(rootMessage);
	    }
	    if (this.centerPanel ) {
		    this.mainPanel.remove(this.centerPanel, true);
	    }
	    this.centerPanel = Ext.create('Ext.form.Panel', {
	        region : 'center',
	        border : false,
	        autoScroll : true,
	        header : false,
	        items : items
	    });
	    if (this.replaceCenterPanel ) {
		    this.replaceCenterPanel.call(this, this.centerPanel);
	    } else {
		    this.mainPanel.add(this.centerPanel);
	    }
	    this.actualizeToolbarOnTreeSelect();
	},
	/**
	 * ********************************************popup methods: URL and
	 * params**********************************************
	 */
	/**
	 * Parameters for adding to a folder node
	 */
	/* protected */getAddFolderParams : function(extraDetailParameters) {
	    return this.getAddParams(false, extraDetailParameters);
	},
	/**
	 * Parameters for adding to a leaf node normally you add a node to the
	 * selected leaf node's parent, that means sibling to the selected node
	 */
	/* protected */getAddLeafParams : function(extraDetailParameters) {
	    return this.getAddParams(true, extraDetailParameters);
	},
	/**
	 * Parameters for adding a new leaf
	 */
	/* private */getAddParams : function(leaf, extraDetailParameters) {
	    var addParams = null;
	    if (extraDetailParameters ) {
		    addParams = extraDetailParameters;
	    } else {
		    addParams = new Object;
	    }
	    addParams['add'] = true;
	    addParams['leaf'] = leaf;
	    // var addParams = {add:true, leaf:leaf};
	    var addToNode = null;
	    if (this.selectedNode ) {
		    if (leaf && this.selectedNode.isLeaf()) {
			    // add leaf to a leaf node -> means add sibling (add node to the
				// parent of the leaf node)
			    addToNode = this.selectedNode.parentNode;
		    } else {
			    // add child to a folder node
			    addToNode = this.selectedNode;
		    }
		    if (addToNode ) {
			    addParams['node'] = addToNode.data['id'];
		    }
	    } else {
		    // adding when no node is selected: for ex. project specific
			// queries: add means adding to the (project specific branch) root
		    addParams['node'] = this.getRootID();
	    }
	    return addParams;
	},
	/**
	 * Parameters for editing an existing entity recordData: the selected entity
	 * data
	 */
	/* protected */getEditParams : function(fromTree, extraDetailParameters) {
	    var editParams = null;
	    if (extraDetailParameters ) {
		    editParams = extraDetailParameters;
	    } else {
		    editParams = new Object();
	    }
	    var recordData = this.getSingleSelectedRecordData(fromTree);
	    if (recordData ) {
		    var nodeID = null;
		    if (fromTree) {
			    nodeID = recordData['id'];
		    } else {
			    nodeID = recordData['node'];
		    }
		    if (nodeID ) {
			    // return {node:nodeID};
			    editParams.node = nodeID;
		    }
	    }
	    // should not be null because dynamic parameters might be added right
		// before submit
	    // (in either submitHandler() or preSubmitProcess() implementations)
	    return editParams;// new Object();
	},
	/**
	 * The method to process the data to be loaded arrived from the server
	 */
	/* protected */getEditPostDataProcess : function(record, isLeaf, add) {
	    var recordData = null;
	    if (record ) {
		    recordData = record.data;
	    }
	    if (isLeaf) {
		    if (this.getEditLeafPostDataProcess ) {
			    return this.getEditLeafPostDataProcess(recordData, add);
		    }
	    } else {
		    if (this.getEditFolderPostDataProcess ) {
			    return this.getEditFolderPostDataProcess(recordData, add);
		    }
	    }
	    return null;
	},
	/**
	 * Method to process the data to be loaded arrived from the server by
	 * editing the folder
	 */
	/* protected abstract */getEditFolderPostDataProcess : null,
	/**
	 * Method to process the data to be loaded arrived from the server by
	 * editing the leaf
	 */
	/* protected abstract */getEditLeafPostDataProcess : null,
	/**
	 * Parameter name for the submitted entityID(s) by delete If
	 * allowMultipleSelections===false then the same entityID can be used for
	 * delete and edit submits If allowMultipleSelections===true this should
	 * return another name (the submitted value will be stored on the server
	 * typically in an Integer[])
	 */
	/* protected */getDeleteParamName : function(extraConfig) {
	    return 'node';
	},
	/**
	 * Helper for preparing the params get the ID based on the record and extra
	 * config
	 */
	/* protected */getRecordID : function(recordData, extraConfig) {
	    var fromTree = null;
	    if (extraConfig ) {
		    fromTree = extraConfig.fromTree;
	    }
	    if (fromTree) {
		    return recordData['id'];
	    } else {
		    return recordData['node'];
	    }
	},
	/**
	 * **********************************selection utility methods**************************************
	 */
	// tree specific selection utility methods (the grid specific ones are
	// inherited from crudBase.js)
	/**
	 * Select a node by id
	 * Scope is contains tree, nodeIdToSelect
	 */
	selectNode: function() {
		var selectionModel = this.tree.getSelectionModel();
		if (this.nodeIdToSelect) {
			//get the node by id
			var nodeToSelect = this.tree.getStore().getNodeById(this.nodeIdToSelect);
			if (nodeToSelect) {
				selectionModel.select(nodeToSelect);
			}
		}
	},
	/**
	 * Get the (last) selected tree node
	 */
	/* public */getLastSelectedTreeNode : function() {
	    if (this.tree ) {
		    return this.tree.getSelectionModel().getLastSelected();
	    }
	    return null;
	},
	/**
	 * The the selected tree nodes
	 */
	/* public */getTreeSelection : function() {
	    if (this.tree ) {
		    return this.tree.getSelectionModel().getSelection();
	    }
	    return null;
	},
	/**
	 * Select and returns a record in the tree by activating the context menu
	 */
	/* public */selectTreeNode : function(record) {
	    // false to not retain existing selections
	    if (this.tree ) {
		    this.tree.getSelectionModel().select(record, true);
	    }
	    return record;
	},
	/**
	 * Gets the selected record either from tree node or from grid row
	 */
	/*public*/getLastSelected : function(fromTree) {
	    if (fromTree) {
		    return this.getLastSelectedTreeNode();
	    } else {
		    return this.getLastSelectedGridRow();
	    }
	},
	/*public*/getLastSelectedGridRow: function() {
		if (this.grid) {
			return this.grid.getSelectionModel().getLastSelected();
		}
		return null;
	},
	getSelection : function(fromTree) {
	    if (fromTree) {
		    return this.getTreeSelection();
	    } else {
		    return this.getGridSelection();
	    }
	},
	/*public*/getGridSelection: function() {
		if (this.grid) {
			return this.grid.getSelectionModel().getSelection();
		}
		return null;
	},
	/**
	 * Gets the selected data (either in tree or in grid )
	 */
	/*public*/getSelectedRecords : function(fromTree) {
	    var allowMultiple = false;
	    if (fromTree) {
		    //multiple tree nodes
		    allowMultiple = this.allowMultipleNodeSelections;
	    } else {
		    //multiple grid rows
		    allowMultiple = this.allowMultipleSelections;
	    }
	    if (allowMultiple) {
		    return this.getSelection(fromTree);
	    } else {
		    return this.getLastSelected(fromTree);
	    }
	},
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 */
	/*private*/getSingleSelectedRecord : function(fromTree) {
	    var selectedRecords = this.getSelectedRecords(fromTree);
	    if (selectedRecords ) {
		    var allowMultiple = false;
		    if (fromTree) {
			    //multiple tree nodes
			    allowMultiple = this.allowMultipleNodeSelections;
		    } else {
			    //multiple grid rows
			    allowMultiple = this.allowMultipleSelections;
		    }
		    if (allowMultiple) {
			    if (selectedRecords  && selectedRecords.length === 1) {
				    return selectedRecords[0];
			    } else {
				    return null;
			    }
		    } else {
			    return selectedRecords;
		    }
	    } else {
		    return null;
	    }
	},
	/**
	 * Whether the selected tree node or grid row is leaf or not
	 * operationType: 'add'/'edit'/'copy'
	 * triggeredFrom: 'grid'/'tree'
	 */
	/*private*/selectedIsLeaf : function(fromTree) {
	    var lastSelectedRecord = this.getLastSelected(fromTree);
	    if (lastSelectedRecord ) {
		    if (fromTree) {
			    return lastSelectedRecord.isLeaf();
		    } else {
			    return lastSelectedRecord.data.leaf;
		    }
	    }
	    return true;
	},
	/**
	 * Whether the selection is simple or multiple
	 */
	/*public*/selectionIsSimple : function(fromTree) {
	    var allowMultiple = false;
	    if (fromTree) {
		    //multiple tree nodes
		    allowMultiple = this.allowMultipleNodeSelections;
	    } else {
		    //multiple grid rows
		    allowMultiple = this.allowMultipleSelections;
	    }
	    if (allowMultiple) {
		    var selectedRecords = this.getSelection(fromTree);
		    return selectedRecords  && selectedRecords.length === 1;
	    } else {
		    var selectedRecord = this.getLastSelected(fromTree);
		    return selectedRecord !== null;
	    }
	},
	/**
	 * Select a record by activating the context menu
	 */
	/*public*/selectRecord : function(record, fromTree) {
	    if (fromTree) {
		    return this.selectTreeNode(record);
	    } else {
		    return this.selectGridRow(record);
	    }
	},
	/*public*/selectGridRow: function(record) {
		//false to not retain existing selections
		if (this.grid) {
			this.grid.getSelectionModel().select(record, false);
		}
		return record;
	},
	/**
	 * Gather selected ID as a comma separated string
	 * selectedRecords - the selected record(s): simple or multiple selection:
	 * 	if simple the selection the record, if multiple an array of records
	 * getIDFormEntityFunction - function for getting the ID from an entity JSON
	 * extraConfig
	 */
	/*private*/getSelectedIDs : function(selectedRecords, extraConfig) {
	    var fromTree = null;
	    if (extraConfig ) {
		    fromTree = extraConfig.fromTree;
	    }
	    if (fromTree) {
		    //multiple tree nodes
		    allowMultiple = this.allowMultipleNodeSelections;
	    } else {
		    //multiple grid rows
		    allowMultiple = this.allowMultipleSelections;
	    }
	    if (allowMultiple) {
		    var idArray = [];
		    Ext.Array.forEach(selectedRecords, function(record) {
			    idArray.push(this.getRecordID(record.data, extraConfig));
		    }, this);
		    return idArray.join();
	    } else {
		    return this.getRecordID(selectedRecords.data, extraConfig);
	    }
	},
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 * param: typically fromTree
	 */
	/*private*/getSingleSelectedRecordData: function(param) {
		var selectedRecord = this.getSingleSelectedRecord(param);
		if (selectedRecord) {
			return selectedRecord.data;
		}
		return null;
	},
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 */
	/*private*/getSingleSelectedRecord: function(param) {
		var selectedRecords = this.getSelectedRecords(param);
		if (selectedRecords) {
			if (this.allowMultipleSelections) {
				if (selectedRecords && selectedRecords.length===1) {
					return selectedRecords[0];
				} else {
					return null;
				}
			} else {
				return selectedRecords;
			}
		} else {
			return null;
		}
	},
	/**
	 * Select a record by activating the context menu
	 */
	/*public*/changeAndRefreshNode : function(tree, nodeId, data, reloadIfExpanded) {
	    var treeStore = tree.getStore();
	    var node = treeStore.getNodeById(nodeId);
	    if (node ) {
		    if (data ) {
			    for (propertyName in data) {
				    node.data[propertyName] = data[propertyName];
			    }
		    }
		    node.commit();
		    var treeView = tree.getView();
		    var index = treeView.indexOf(node);
		    treeView.refreshNode(index);
		    if (node.isLoaded() && reloadIfExpanded) {
			    treeStore.load({
				    node : node
			    });
		    }
	    }
	},
	isTreeSplitOn: function() {
		return true;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Base class for all "tree-detail"-based CRUD operations
 */
Ext.define('com.trackplus.admin.TreeDetail',{
	extend:'com.trackplus.admin.TreeBase',
	config: {
	},
	/**
	 * Whether selecting a folder node in the tree results in a grid in the detail part or other detail info
	 */
	showGridForFolder: false,
	/**
	 * If showGridForFolder is false, then whether the folder details are loaded manually or through a form load method
	 */
	folderDetailByFormLoad: false,
	/**
	 * Whether to show a grid with a single row instead of other detailed view of the leaf node
	 */
	//showGridForLeaf: false,
	/**
	 * whether the leaf details are loaded manually or through a form load method
	 */
	leafDetailByFormLoad: true,
	/**
	 * Whether the tree has double click listener
	 */
	treeHasItemdblclick: false,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	/**
	 * Get the detail part after selecting a tree node
	 */
	/*protected*/loadDetailPanel: function(node, leaf, opts) {
		if (leaf) {
			if (this.leafDetailByFormLoad) {
				this.loadDetailPanelWithFormLoad(node, false);
			} else {
				this.loadSimpleDetailPanel(node, false);
			}
		} else {
			if (this.folderDetailByFormLoad) {
				this.loadDetailPanelWithFormLoad(node, false);
			} else {
				this.loadSimpleDetailPanel(node, false);
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Base class for "tree with grid"-based CRUD operations
 */
Ext.define('com.trackplus.admin.TreeWithGrid',{
	extend:'com.trackplus.admin.TreeBase',
	config: {
	},
	/**
	 * Whether selecting a folder node in the tree results in a grid in the detail part or other detail info
	 */
	showGridForFolder: true,
	/**
	 * If showGridForFolder is false, then whether the folder details are loaded manually or through a form load method
	 */
	folderDetailByFormLoad: false,
	/**
	 * Whether to show a grid with a single row instead of other detailed view of the leaf node
	 */
	showGridForLeaf: true,
	/**
	 * Whether the grid has context menu listener
	 */
	gridHasItemcontextmenu: true,
	/**
	 * Whether the grid has double click listener
	 */
	gridHasItemdblclick: true,
	/**
	 * If showGridForLeaf is false, then whether the leaf details are loaded manually or through a form load method
	 */
	leafDetailByFormLoad: false,
	/**
	 * The width of the folder edit window
	 * Mandatory field
	 */
	folderEditWidth: 600,
	/**
	 * The height of the folder edit window
	 * Mandatory field
	 */
	folderEditHeight: 400,
	/**
	 * Whether to use drag and drop inside the grid
	 */
	dragAndDropOnGrid: false,
	/**
	 * actions
	 */
	actionAddFolder: null,
	actionAddLeaf: null,
	actionEditGridRow: null,
	actionEditTreeNode: null,
	actionCutTreeNode: null,
	actionCopyTreeNode: null,
	actionPasteTreeNode: null,
	actionDeleteGridRow: null,
	actionDeleteTreeNode: null,
	//set in com.trackplus.util.RefreshAfterSubmit.refreshGridAndTreeAfterSubmit
	rowIdToSelect: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	getShowGridForLeaf: function() {
		return this.showGridForLeaf;
	},
	/**
	 * Gets the grid store's fields for the selected node
	 */
	/*protected abstract*/getGridFields: function(node) {
		return [];
	},
	/**
	 * Gets the grid columns for the selected node
	 */
	/*protected abstract*/getGridColumns: function(node) {
		return [];
	},
	/**
	 * Initialize all possible actions
	 */
	/*protected*/initActions: function(){
		this.actionAddFolder = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {isLeaf:false}),
				this.getAddFolderIconCls(), this.onAddFolder, this.getTitle(this.getAddTitleKey(), {isLeaf:false}));
		this.actionAddLeaf = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {isLeaf:true}),
				this.getAddIconCls(), this.onAddLeaf, this.getTitle(this.getAddTitleKey(), {isLeaf:true}), true);
		this.actionEditGridRow = this.createAction(this.getEditButtonKey(),
				this.getEditIconCls(), this.onEditGridRow, true, this.getEditTitleKey(), "editGridRow");
		this.actionEditTreeNode = this.createAction(this.getEditButtonKey(),
				this.getEditIconCls(), this.onEditTreeNode, false, this.getEditTitleKey(), "editTreeNode");
		this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(),
				this.getDeleteIconCls(), this.onDeleteFromGrid, true, this.getDeleteTitleKey(), "deleteGridRow");
		this.actionDeleteTreeNode = this.createAction(this.getDeleteButtonKey(),
				this.getDeleteIconCls(), this.onDeleteFromTree, false, this.getDeleteTitleKey(), "deleteTreeNode");
		if (this.useCopyPaste) {
			this.actionCutTreeNode = this.createAction(this.getCutButtonKey(), this.getCutIconCls(), this.onCutTreeNode, false, this.getCutTitleKey());
			this.actionCopyTreeNode = this.createAction(this.getCopyButtonKey(), this.getCopyIconCls(), this.onCopyTreeNode, false, this.getCopyTitleKey());
			this.actionPasteTreeNode = this.createAction(this.getPasteButtonKey(), this.getPasteIconCls(), this.onPasteTreeNode, false, this.getPasteTitleKey());
			this.actions=[this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow,
				this.actionCutTreeNode, this.actionCopyTreeNode, this.actionPasteTreeNode, this.actionDeleteGridRow];
		} else {
			this.actions=[this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow, this.actionDeleteGridRow];
		}
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	/*protected*/getToolbarActions: function() {
		return [this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow, this.actionDeleteGridRow];
	},
	/**
	 * Get the itemId of those actions whose context menu text or
	 * toolbar button tooltip should be changed according to the current selection
	 */
	/*protected*/getActionItemIdsWithContextDependentLabel: function() {
		return ["editGridRow", "editTreeNode", "deleteGridRow", "deleteTreeNode"];
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	/*protected*/getGridContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectionIsSimple) {
			return [this.actionEditGridRow, this.actionDeleteGridRow];
		} else {
			return [this.actionDeleteGridRow];
		}
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 *
	 */
	/*protected*/getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var actions = null;
		if (selectionIsSimple) {
			var leaf = selectedRecord.isLeaf();
			if (!leaf) {
				actions = [this.actionAddFolder];
			} else {
				actions = [];
			}
			actions.push(this.actionAddLeaf);
			actions.push(this.actionEditTreeNode);
		} else {
			actions = [];
		}
		if (this.useCopyPaste) {
			actions.push(this.actionCutTreeNode);
			actions.push(this.actionCopyTreeNode);
			actions.push(this.actionPasteTreeNode);
		}
		actions.push(this.actionDeleteTreeNode);
		return actions;
	},
	/**
	 * Get the context menu actions either for grid or for tree
	 */
	/*private*/getContextMenuActions: function(selectedRecords, selectionIsSimple, fromTree) {
		if (fromTree) {
			return this.getTreeContextMenuActions(selectedRecords, selectionIsSimple);
		} else {
			return this.getGridContextMenuActions(selectedRecords, selectionIsSimple);
		}
	},
	/**
	 * Show the context menu in grid
	 */
	/*private*/onGridRowCtxMenu: function(grid, record, item, index, evtObj) {
		this.onCtxMenu(false, record, evtObj);
		//var scope = this.getSelectedNodeSpecificScope(record, false);
		//this.onCtxMenu.call(scope, false, record, evtObj);
		return false;
	},
	/**
	 * Get the detail part after selecting a tree node
	 */
	/*protected*/loadDetailPanel: function(node, leaf, opts) {
		if (leaf) {
			if (this.getShowGridForLeaf()) {
				this.getGridPanel(node, opts);
			} else {
				if (this.leafDetailByFormLoad) {
					this.loadDetailPanelWithFormLoad(node, false);
				} else {
					this.loadSimpleDetailPanel(node, false);
				}
			}
		} else {
			if (this.showGridForFolder) {
				this.getGridPanel(node, opts);
			} else {
				if (this.folderDetailByFormLoad) {
					this.loadDetailPanelWithFormLoad(node, false);
				} else {
					this.loadSimpleDetailPanel(node, false);
				}
			}
		}
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	/*protected*/getToolbarActionChangesForTreeNodeSelect: function(selectedNode) {
		//var singleSelection = arrSelectedNodes.length===1;
		this.actionAddFolder.setDisabled(false);
		this.actionAddLeaf.setDisabled(false);
		//nothing selected in the grid
		this.actionEditGridRow.setDisabled(true);
		this.actionDeleteGridRow.setDisabled(true);
	},
	/*protected*/onTreeNodeDblClick: function(view, record) {
		this.onEditTreeNode();
	},
	/**
	 * Whether drag and drop on tree is possible
	 */
	/*protected*/hasDragAndDropOnGrid: function(node) {
		return this.dragAndDropOnGrid;
	},
	/*protected*/onGridDrop: function(node, data, dropRec, dropPosition) {
		var before = false;
		if (dropPosition==="before") {
			before = true;
		}
		var request={node:data.records[0].get('node'), droppedToNode:dropRec.get('node'), before:before};
		this.onOrderChange(this.getBaseAction() + "!droppedNear.action", request);
	},
	/**
	 * Move the selected grid row up
	 */
	onMoveUpGridRow: function() {
		var gridRow = this.getLastSelectedGridRow();
		if (gridRow) {
			nodeID = gridRow.data.node;
			this.onOrderChange(this.getBaseAction() + "!moveUp.action", {node:nodeID});
		}
	},
	/**
	 * Move the selected grid row down
	 */
	onMoveDownGridRow: function() {
		var gridRow = this.getLastSelectedGridRow();
		if (gridRow) {
			nodeID = gridRow.data.node;
			this.onOrderChange(this.getBaseAction() + "!moveDown.action", {node:nodeID});
		}
	},
	/**
	 * Private function foe changing the order by drag and drop or move up/down
	 */
	onOrderChange: function(url, params) {
		Ext.Ajax.request({
			url: url,
			disableCaching: true,
			scope: this,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success !== true) {
					Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
				}
				this.reload.call(this, {rowToSelect:responseJson.node});
			},
			failure: function(reponse){
				Ext.MessageBox.alert(this.failureTitle, reponse.responseText);
			},
			isUpload: false,
			method:'POST',
			params: params
		});
	},
	/**
	 * Get the extra parameters for the gridStore
	 */
	/*protected*/getGridExtraParams: function(node, opts) {
		return {
			node: this.selectedNodeID
		};
	},
	/**
	 * Shows the grid according to the selected node
	 */
	/*private*/getGridPanel: function(node, opts) {
		var fields = this.getGridFields(node);
		var columnModelArr = this.getGridColumns(node);
		var store = Ext.create("Ext.data.Store", {
			proxy: {
				type: "ajax",
				url: this.getNodeBaseAction({isLeaf:false}) + "!loadList.action",
				extraParams: this.getGridExtraParams(node, opts),
				reader: {
					type: 'json'
				}
			},
			fields: fields,
			idProperty: "node",
			autoLoad: true,
			listeners: {load: {fn:this.onGridStoreLoad, scope:this}}
		});
		var gridConfig = {
				xtype: "grid",
				region:"center",
				store: store,
				columns: columnModelArr,
				selModel: this.getGridSelectionModel(node),
				autoWidth: true,
				border: false,
				bodyBorder:false,
				cls:"gridNoBorder",
				stripeRows: true
			};
		gridConfig.viewConfig = this.getGridViewConfig(node);
		var gridListeners = {selectionchange: {fn:this.onGridSelectionChange, scope:this}};
		if (this.gridHasItemcontextmenu) {
			gridListeners.itemcontextmenu = {fn:this.onGridRowCtxMenu, scope:this};
		}
		if (this.gridHasItemdblclick) {
			gridListeners.itemdblclick = {fn:this.onGridRowDblClick, scope:this};
		}
		gridConfig.listeners = gridListeners;
		this.grid = Ext.create("Ext.grid.Panel", gridConfig);
		if (this.centerPanel) {
			this.mainPanel.remove(this.centerPanel, true);
		}
		this.centerPanel = this.grid;
		if (this.replaceCenterPanel) {
			this.replaceCenterPanel.call(this,this.centerPanel);
		} else {
			this.mainPanel.add(this.centerPanel);
		}
		this.postGridPanel(this.grid);
		return this.grid;
	},
	getGridViewConfig: function(node) {
		if (this.hasDragAndDropOnGrid(node)) {
			return {
				plugins: {
					ptype: "gridviewdragdrop",
					dragGroup: this.getBaseAction() + "gridDDGroup",
					dropGroup: this.getBaseAction() + "gridDDGroup",
					enableDrag: true,
					enableDrop: true
				},
				listeners: {
					drop: {scope:this, fn: function(node, data, dropRec, dropPosition) {
						this.onGridDrop(node, data, dropRec, dropPosition);
						}
					}
				}
			};
		}
		return null;
	},
	postGridPanel: function(grid) {
	},
	/**
	 * Once the data for store is loaded select the corresponding row from the grid if rowIdToSelect is set
	 */
	onGridStoreLoad: function(store) {
		if (this.rowIdToSelect) {
			var row = store.getById(this.rowIdToSelect);
			if (row) {
				var gridSelectionModel = this.grid.getSelectionModel();
				gridSelectionModel.select(row);
			}
		} else {
			if (store.getTotalCount()===1) {
				//if the grid contains only one entry (especially by showGridForLeaf===true)
				//then select it also automatically to activate the grid selection specific toolbar buttons
				var gridSelectionModel = this.grid.getSelectionModel();
				gridSelectionModel.select(0);
			}
		}
		//this.selectedRowId = null;
	},
	/**
	 * Enable/disable actions based on the actual selection
	 */
	/*protected*/onGridSelectionChange: function (view, selections) {
		this.enableDisableToolbarButtons(view, selections);
		var selectedRow = null;
		if (selections && selections.length>0) {
			selectedRow = selections[0];
		}
		this.adjustToolbarButtonsTooltip(selectedRow, false);
	},
	/*protected*/onGridRowDblClick: function(view, record) {
		this.onEditGridRow();
	},
	/**
	 * Enable/disable actions based on the actual selection
	 */
	/*protected*/enableDisableToolbarButtons: function (view, selections) {
		if (CWHF.isNull(selections) || selections.length===0) {
			if (this.actionDeleteGridRow) {
				this.actionDeleteGridRow.setDisabled(true);
			}
			if (this.actionEditGridRow) {
				this.actionEditGridRow.setDisabled(true);
			}
		} else {
			if (this.actionDeleteGridRow) {
				this.actionDeleteGridRow.setDisabled(false);
			}
			if (this.actionEditGridRow) {
				if (selections.length===1) {
					this.actionEditGridRow.setDisabled(false);
				} else {
					this.actionEditGridRow.setDisabled(true);
				}
			}
		}
	},
	/**
	 * Url for editing an entity
	 * We suppose that add/edit use the same edit method on server side
	 * Differentiation is made based on "node", "add" and "leaf" request parameters
	 * addFolder: "node" is the parent node, "add" is true, "leaf" is false
	 * addLeaf: "node" is the parent node, "add" is true, "leaf" is true
	 * edit: "node" is the id of the edited entity (whether it is folder or leaf is decoded based on the structure of the "node")
	 */
	/*protected*/getEditUrl: function(isLeaf) {
		return this.getNodeBaseAction({isLeaf:isLeaf}) + '!edit.action';
	},
	/**
	 * Url for saving of an entity
	 */
	/*protected*/getSaveUrl: function(isLeaf) {
		return this.getNodeBaseAction({isLeaf:isLeaf}) + '!save.action';
	},
	/**
	 * Reload method
	 */
	/*protected*/reload:com.trackplus.util.RefreshAfterSubmit.refreshGridAndTreeAfterSubmit,
	/**
	 * Get the node to reload after save after add operation
	 */
	/*protected*/getAddReloadParamsAfterSave: function(addLeaf) {
		if (this.selectedNode) {
			var leaf = this.selectedNode.data['leaf'];
			if (leaf) {
				//selected node is leaf: add to a leaf
				var parentNode = this.selectedNode.parentNode;
				if (parentNode) {
					if (addLeaf) {
						//add leaf to a leaf -> means add sibling -> the parent of the selectedNode should be reloaded
						return {nodeIDToReload: parentNode.data['id']};
					} else {
						//add folder when a leaf is selected -> add sibling to the parent's node, the parent of the parent should be reloaded
						//(from tree context menu it is not possible, only from toolbar)
						parentNode = parentNode.parentNode;
						if (parentNode) {
							return {nodeIDToReload: parentNode.data['id']};
						}
					}
				}
			} else {
				//selected node is folder
				//if (addLeaf) {
					return {nodeIDToReload: this.selectedNode.data['id']};
				/*} else {
					//add folder when a folder is selected
					var parentNode = this.selectedNode.parentNode;
					if (parentNode) {
						return {nodeIDToReload: parentNode.data['id']};
					}
				}*/
			}
		}
		return null;
	},
	/**
	 * Get the node to reload after save after edit operation
	 */
	/*protected*/getEditReloadParamsAfterSave: function(fromTree) {
		if (this.selectedNode) {
			if (fromTree) {
				//edited/copied from tree
				var parentNode = this.selectedNode.parentNode;
				if (parentNode) {
					//the parent of the edited node should be reloaded
					return {nodeIDToReload: parentNode.data['id']};
				}
			} else {
				//edited from grid:
				if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
					//in the tree a leaf node selected -> grid with a single row: the parent of the selected tree node should be reloaded
					var parentNode = this.selectedNode.parentNode;
					if (parentNode) {
						//the parent of the edited node should be reloaded
						return {nodeIDToReload: parentNode.data['id']};
					}
				} else {
					//in the tree the parent of the edited grid row is selected: the actually selected tree node should be reloaded
					return {nodeIDToReload: this.selectedNode.data['id']};
				}
			}
		}
		return null;
	},
	/**
	 * Get the node to select after save after add operation
	 */
	/*private*/getAddSelectionAfterSaveFromResult: function() {
		//specify nodeIDToSelect to select the added node based on the 'node' field from resulting JSON,
		//do not specify rowToSelect, do not select anything in the grid after add
		//return {parameterName:'nodeIDToSelect', fieldNameFromResult:'node'};
		return [{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
				{parameterName:'rowToSelect', fieldNameFromResult:'node'}];
	},
	/**
	 * Get the node to select after save after edit operation
	 */
	/*private*/getEditReloadParamsAfterSaveFromResult: function(fromTree) {
		if (fromTree) {
			//edited from tree: select
			return [{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
					{parameterName:'rowToSelect', fieldNameFromResult:'node'}];
		} else {
			//edited from grid: whatever the tree selection was it remains ()
			//specify rowToSelect to select the edited row in the grid based on the 'node' json field,
			if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
				//leaf node selected: select it again after reload
				return [{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
				 {parameterName:'rowToSelect', fieldNameFromResult:'node'}];
			} else {
				//parent of the edited node selected: leave the parent node selected
				return {parameterName:'rowToSelect', fieldNameFromResult:'node'};
			}
		}
	},
	/**
	 * Handler for adding a folder node
	 */
	/*private*/onAddFolder: function() {
		var operation = "addFolder";
		var title = this.getTitle(this.getAddTitleKey(), {isLeaf:false, selectedRecord:this.getLastSelected(true)});
		var loadParams = this.getAddFolderParams();
		var submitParams = this.getAddFolderParams();
		var reloadParams = this.getAddReloadParamsAfterSave(false);
		var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
		var selectedRecord = this.getSingleSelectedRecord(true);
		if (CWHF.isNull(selectedRecord)) {
			selectedRecord = this.tree.getRootNode();
		}
		return this.onAddEdit(title, selectedRecord, operation, false, true, true,
				loadParams, submitParams, reloadParams, reloadParamsFromResult);
	},
	/**
	 * Handler for adding a leaf node
	 */
	/*private*/onAddLeaf: function() {
		var operation = "addLeaf";
		var title = this.getTitle(this.getAddTitleKey(), {isLeaf:true, selectedRecord:this.getLastSelected(true)});
		var loadParams = this.getAddLeafParams();
		var submitParams = this.getAddLeafParams();
		var reloadParams = this.getAddReloadParamsAfterSave(true);
		var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
		var selectedRecord = this.getSingleSelectedRecord(true);
		if (CWHF.isNull(selectedRecord)) {
			selectedRecord = this.tree.getRootNode();
		}
		return this.onAddEdit(title, selectedRecord, operation, true, true, true,
				loadParams, submitParams, reloadParams, reloadParamsFromResult);
	},
	/**
	 * Handler for editing a grid row
	 */
	/*private*/onEditGridRow: function() {
		return this.onEdit(false);
	},
	/**
	 * Handler for editing a grid row
	 */
	/*private*/onEditTreeNode: function() {
		return this.onEdit(true);
	},
	/**
	 * Handler for edit
	 */
	/*private*/onEdit: function(fromTree) {
		var operation = "edit";
		var isLeaf = this.selectedIsLeaf(fromTree);
		var title = this.getTitle(this.getEditTitleKey(), {isLeaf:isLeaf, fromTree:fromTree, selectedRecord:this.getLastSelected(fromTree)});
		var loadParams = this.getEditParams(fromTree);
		var submitParams = this.getEditParams(fromTree);
		var reloadParams = this.getEditReloadParamsAfterSave(fromTree);
		var reloadParamsFromResult = this.getEditReloadParamsAfterSaveFromResult(fromTree);
		var selectedRecord = this.getSingleSelectedRecord(fromTree);
		return this.onAddEdit(title, selectedRecord, operation, isLeaf, false, fromTree,
				loadParams, submitParams, reloadParams, reloadParamsFromResult);
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * operation: "edit"/"add" or anything else in the derived classes
	 * isLeaf: whether to add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	/*private*/onAddEdit: function(title, record, operation, isLeaf, add, fromTree, loadParams, submitParams,
			refreshParams, refreshParamsFromResult) {
		var recordData = null;
		if (record) {
			recordData = record.data;
		}
		var width = this.getEditWidth(recordData, isLeaf, add, fromTree, operation);
		var height = this.getEditHeight(recordData, isLeaf, add, fromTree, operation);
		var loadUrl =  this.getEditUrl(isLeaf);
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = this.getSaveUrl(isLeaf);
		var submit = {
			submitUrl:submitUrl,
			submitUrlParams:submitParams,
			submitButtonText:this.getSaveLabel(operation),
			submitHandler:this.submitHandler,
			submitAction:operation,
			refreshAfterSubmitHandler:this.reload,
			refreshParametersBeforeSubmit:refreshParams,
			refreshParametersAfterSubmit:refreshParamsFromResult
		};
		var postDataProcess = this.getEditPostDataProcess(record, isLeaf, add, fromTree, operation);
		var preSubmitProcess = this.getEditPreSubmitProcess(recordData, isLeaf, add);
		var items = this.getPanelItems(recordData, isLeaf, add, fromTree, operation);
	    var additionalActions = this.getAdditionalActions(recordData, submitParams, operation, items);
	    if (additionalActions) {
	        additionalActions.push(submit);
	        submit = additionalActions;
	    }
		var windowParameters = {title:title,
			width:width,
			height:height,
			load:load,
			submit:submit,
			items:items,
			postDataProcess:postDataProcess,
			preSubmitProcess:preSubmitProcess};
		var extraWindowParameters = this.getExtraWindowParameters(recordData, operation);
		if (extraWindowParameters) {
			for (propertyName in extraWindowParameters) {
				windowParameters[propertyName] = extraWindowParameters[propertyName];
			}
		}
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	/**
	 * The width of the edit window
	 * recordData: the record data (for the record to be edited or added to)
	 * isLeaf: whether add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * operation:  the name of the operation
	 */
	/*protected*/getEditWidth: function(recordData, isLeaf, add, fromTree, operation) {
		if (isLeaf) {
			return this.editWidth;
		} else {
			return this.folderEditWidth;
		}
	},
	/**
	 * The height of the edit window
	 * recordData: the record data (for the record to be edited or added to)
	 * isLeaf: whether add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * operation:  the name of the operation
	 */
	/*protected*/getEditHeight: function(recordData, isLeaf, add, fromTree, operation) {
		if (isLeaf) {
			return this.editHeight;
		} else {
			return this.folderEditHeight;
		}
	},
	/**
	 * Get the panel items
	 * recordData: the record data (for the record to be edited or added to)
	 * isLeaf: whether add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * operation:  the name of the operation
	 */
	/*private*/getPanelItems: function(recordData, isLeaf, add, fromTree, operation) {
		if (isLeaf) {
			return this.getEditLeafPanelItems(recordData, add, fromTree, operation);
		} else {
			return this.getEditFolderPanelItems(recordData, add, fromTree, operation);
		}
	},
	/**
	 * Gets the items for a folder
	 * recordData: the record data (for the record to be edited or added to)
	 * add: whether it is add or edit
	 * operation:  the name of the operation
	 */
	/*protected abstract*/getEditFolderPanelItems: function(recordData, add, operation) {
		return [];
	},
	/**
	 * Gets the items for a leaf
	 * recordData: the record data (for the record to be edited or added to)
	 * add: whether it is add or edit
	 * operation:  the name of the operation
	 */
	/*protected abstract*/getEditLeafPanelItems: function(recordData, add, operation) {
		return [];
	},
	/**
	 * Add extra window configuration fields by add/edit
	 * windowConfiguration argument is configured with the required fields but
	 * 		any already specified windowConfig field can be overridden, and
	 * 		further optional window options can be specified
	 * type: typically "folder" or "leaf" but for more leaf types it can be customized
	 */
	/*protected abstract*/getExtraWindowParameters: function(recordData, operation) {
		//optionally specify
		/*
		return {fileUpload: ...
			windowConfig: ...
			panelConfig: ...}
		*/
	},
	/*private*/getEditPreSubmitProcess: function(recordData, isLeaf, add) {
		if (isLeaf) {
			if (this.getEditLeafPreSubmitProcess) {
				return this.getEditLeafPreSubmitProcess(recordData, add);
			}
		} else {
			if (this.getEditFolderPreSubmitProcess) {
				return this.getEditFolderPreSubmitProcess(recordData, add);
			}
		}
		return null;
	},
	/**
	 * Method to add extra request parameters be sent to the sever before submitting the folder data
	 */
	/*protected abstract*/getEditFolderPreSubmitProcess: null,
	/**
	 * Method to add extra request parameters be sent to the sever before submitting the leaf data
	 */
	/*protected abstract*/getEditLeafPreSubmitProcess: null,
	/**
	 * Cut a tree node
	 */
	onCutTreeNode: function() {
		this.cutCopyNode = this.selectedNode;
		this.copy = false;
	},
	/**
	 * Copy a tree node
	 */
	onCopyTreeNode: function() {
		this.cutCopyNode = this.selectedNode;
		this.copy = true;
	},
	/**
	 * Paste a node in the tree after copy/cut
	 */
	onPasteTreeNode: function() {
		this.onDropTreeNode(this.cutCopyNode, this.selectedNode, this.copy);
		this.cutCopyNode = null;
	},
	/**
	 * Delete handler for deleting from the grid
	 */
	/*private*/onDeleteFromGrid: function() {
		this.onDelete(false);
	},
	/**
	 * Delete handler for deleting from the tree
	 */
	/*private*/onDeleteFromTree: function() {
		this.onDelete(true);
	},
	/**
	 * Handler for delete
	 */
	/*private*/onDelete: function(fromTree) {
		var selectedRecords = this.getSelectedRecords(fromTree);
		if (selectedRecords) {
			var isLeaf = this.selectedIsLeaf(fromTree);
			var extraConfig = {fromTree:fromTree, isLeaf:isLeaf};
			this.deleteHandler(selectedRecords, extraConfig);
		}
	},
	/**
	 * Get the refresh parameters after delete
	 */
	/*private*/getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		if (selectedRecords) {
			//we suppose that only one selection is allowed in tree
			var selNode = selectedRecords;
			if (selNode) {
				var parentNode = null;
				var parentNodeID = null;
				if (extraConfig) {
					fromTree = extraConfig.fromTree;
					if (fromTree) {
						//delete from tree
						parentNode = selNode.parentNode;
						if (parentNode) {
							parentNodeID = parentNode.data.id;
							//select the parent of the deleted node for reload and select
							return {nodeIDToReload:parentNodeID, nodeIDToSelect:parentNodeID};
						}
					} else {
						//delete from grid: the parent is selected already in tree, leave that to be reloaded and selected
						if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
							//in the tree a leaf node selected -> grid with a single row: the parent of the selected tree node should be reloaded
							var parentNode = this.selectedNode.parentNode;
							if (parentNode) {
								//the parent of the edited node should be reloaded
								return {nodeIDToReload: parentNode.data['id']};
							}
						} else {
							//in the tree the parent of the edited grid row is selected: the actually selected tree node should be reloaded
							return {nodeIDToReload: this.selectedNode.data['id']};
						}
					}
				}
			}
		}
		return null;
	},
	/**
	 * Get the configuration for selection model
	 */
	/*protected*/getGridSelectionModel: function() {
		var selectionModelConfig = new Object();
		if (this.allowMultipleSelections) {
			selectionModelConfig.mode="MULTI";
		} else {
			selectionModelConfig.mode="SINGLE";
			if (this.allowDeselect) {
				selectionModelConfig.allowDeselect=this.allowDeselect;
			}
		}
		if (CWHF.isNull(this.gridSelectionModel)) {
			return Ext.create("Ext.selection.RowModel", selectionModelConfig);
		} else {
			return this.gridSelectionModel;
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.admin.CategoryConfig = Ext.define('com.trackplus.admin.customize.category.CategoryConfig', {
	extend : 'com.trackplus.admin.TreeWithGrid',
	config : {
	    rootID : '',
	    // set for automail settings, filters, reports in project configuration
	    projectID : null,
	    // exclude private repository entities by default automail conditions
	    // (project specific or global)
	    excludePrivate : false
	},
	//used in FieldExpressionAction (not directly here)
	issueFilter : false,
	confirmDeleteEntity : true,
	confirmDeleteNotEmpty : true,
	folderAction : "categoryConfig",
	entityID : 'node',
	//category edit sizes
	folderEditWidth : 400,
	folderEditHeight : 115,
	reportEditWidth : 500,
	reportEditHeight : 150,
	useCopyPaste : true,
	dragAndDropOnTree : true,
	labelWidth : 170,
	/* filter specific fields */
	instant : false,
	// gather the rendered upper select fields
	upperSelectFields : null,
	indexMax : null,
	// actions
	actionInstantFilter : null,
	actionExecuteGridRow : null,
	actionExecuteTreeNode : null,
	actionLinkGridRow : null,
	actionLinkTreeNode : null,
	actionDownloadGridRow : null,
	actionDownloadTreeNode : null,
	// actionImport: null,
	// actionExport: null,
	btnExecute : null,
	statics : {
	    showInstant : function(scope, loadUrl) {
	        var title = getText("menu.findItems.instantFilter");
	        var width = com.trackplus.admin.Filter.issueFilterWindowWidth;
	        var height = com.trackplus.admin.Filter.issueFilterWindowHeight;
	        var items = com.trackplus.admin.Filter.getTreeFilterItems(true, true);
	        var loadParams = {
	            instant : true,
	            add : true,
	            leaf : true
	        };
	        var load = {
	            loadUrl : loadUrl,
	            loadUrlParams : loadParams
	        };
	        var submitUrl = "savedFilterExecute!executeUnwrapped.action";
	        // ajax is true. Although the entire page is refreshed after
	        // executing an instant filter, standardSubmit is not set to true
	        // because in case of error in instant filter (for ex. too many
	        // open/closed parenthesis) an error message should be shown without
	        // page refresh
	        // the page refresh is solved in refreshAfterSubmitHandler:
	        // com.trackplus.admin.Filter.executeInstantFilter
	        var submitParams = {
	            instant : true,
	            add : true,
	            leaf : true,
	            ajax : true
	        };
	        var applySubmit = {
	            submitUrl : submitUrl,
	            submitUrlParams : submitParams,
	            submitButtonText : getText("common.btn.applyFilter"),
	            refreshAfterSubmitHandler : com.trackplus.admin.Filter.executeInstantFilter
	        };
	        var resetSubmit = {
	            submitUrl : "filterConfig!edit.action",
	            submitUrlParams : {
	                clearFilter : true,
	                instant : true
	            },
	            submitButtonText : getText("common.btn.reset"),
	            closeAfterSubmit : false,
	            refreshParametersBeforeSubmit : {
		            items : items
	            },
	            refreshAfterSubmitHandler : com.trackplus.admin.Filter.clearFilter
	        };
	        var submit = [ applySubmit, resetSubmit ];
	        var windowConfig = Ext.create("com.trackplus.util.WindowConfig", {
	            postDataProcess : com.trackplus.admin.Filter.postLoadProcessTreeFilter,
	            preSubmitProcess : com.trackplus.admin.Filter.preSubmitProcessIssueFilter
	        });
	        // test for right parenthesis. You might comment this method to
	        // avoid two server accesses but then set the standardSubmit=true
	        // directly on the first submit button
	        /*
			 * submit[0].submitHandler = function(window, submitUrl,
			 * submitUrlParams, extraConfig) { var theForm =
			 * this.formEdit.getForm(); theForm.submit({ url:
			 * "savedFilterExecute!testUnwrappedTree.action", params:
			 * submitUrlParams, method: "POST", scope: scope, success:
			 * function(form, action) { submit[0].submitHandler = null;
			 * submit[0].standardSubmit = true; //now the "classic"
			 * submitHandler windowConfig.submitHandler(submit[0], scope, 0); },
			 * failure: function(form, action) {
			 * com.trackplus.util.submitFailureHandler(form, action); } }); }
			 */
	        windowConfig.showWindow(scope, title, width, height, load, submit, items);
	    },
	    showAddEditFilter : function(scope, refreshScope, refreshMethod, add, filterID, filterType, title) {
	        var width = com.trackplus.admin.Filter.issueFilterWindowWidth;
	        var height = com.trackplus.admin.Filter.issueFilterWindowHeight;
	        var items = com.trackplus.admin.Filter.getTreeFilterItems(true, false);
	        var loadParams = {
	            add : add,
	            filterID : filterID,
	            filterType : filterType,
	            fromNavigatorContextMenu : true
	        };
	        var load = {
	            loadUrl : "filterConfig!edit.action",
	            loadUrlParams : loadParams
	        };
	        var submitUrl = "filterConfig!save.action";
	        var submitParams = loadParams;
	        var saveSubmit = {
	            submitUrl : submitUrl,
	            submitUrlParams : submitParams,
	            submitButtonText : getText("common.btn.save"),
	            refreshParametersBeforeSubmit : {
	                refreshScope : refreshScope,
	                refreshMethod : refreshMethod
	            },
	            refreshAfterSubmitHandler : function(refreshParameters, result) {
		            refreshMethod.call(refreshScope);
	            }
	        };
	        var resetSubmit = {
	            submitUrl : "filterConfig!edit.action",
	            submitUrlParams : {
	                clearFilter : true,
	                instant : true
	            },
	            submitButtonText : getText("common.btn.reset"),
	            closeAfterSubmit : false,
	            refreshParametersBeforeSubmit : {
		            items : items
	            },
	            refreshAfterSubmitHandler : com.trackplus.admin.Filter.clearFilter
	        };
	        var submit = [ saveSubmit, resetSubmit ];
	        var windowConfig = Ext.create("com.trackplus.util.WindowConfig", {
	            postDataProcess : com.trackplus.admin.Filter.postLoadProcessTreeFilter,
	            preSubmitProcess : com.trackplus.admin.Filter.preSubmitProcessIssueFilter
	        });
	        windowConfig.showWindow(scope, title, width, height, load, submit, items);
	    }
	},
	constructor : function(config) {
	    var config = config || {};
		this.initConfig(config);
	    this.baseAction = this.initBaseAction();
	    if (this.isIssueFilter()) {
		    this.btnExecute = "common.btn.applyFilter";
	    } else {
		    if (this.isReport()) {
			    this.btnExecute = "common.btn.executeReport";
		    }
	    }
	    this.initBase();
	},
	isIssueFilter : function() {
	    // this.rootID cold be a project specific branch node
	    return this.getRootID().indexOf("issueFilter") === 0;
	},
	isNotifyFilter : function() {
	    // this.rootID cold be a project specific branch node
	    return this.getRootID().indexOf("notifyFilter") === 0;
	},
	isReport : function() {
	    // this.rootID cold be a project specific branch node
	    return this.getRootID().indexOf("report") === 0;
	},
	getShowGridForLeaf : function() {
	    return this.isReport();
	},
	/**
	 * Gets the base action depending on the rootID
	 */
	initBaseAction : function() {
	    if (this.isIssueFilter() || this.isNotifyFilter()) {
		    if (this.isIssueFilter()) {
			    this.issueFilter = true;
		    }
		    return "filterConfig";
	    }
	    if (this.isReport()) {
		    return "reportConfig";
	    }
	},
	/**
	 * Gets the base action depending on the rootID
	 */
	getEditWidth : function(recordData, isLeaf, add, fromTree, operation) {
	    if (isLeaf) {
		    if (this.isIssueFilter()) {
			    return com.trackplus.admin.Filter.issueFilterWindowWidth;
		    } else {
			    if (this.isNotifyFilter()) {
				    return com.trackplus.admin.Filter.notifyFilterWindowWidth;
			    } else {
				    return this.reportEditWidth;
			    }
		    }
	    } else {
		    return this.folderEditWidth;
	    }
	},
	/**
	 * Gets the base action depending on the rootID
	 */
	getEditHeight : function(recordData, isLeaf, add, fromTree, operation) {
	    if (isLeaf) {
		    if (this.isIssueFilter()) {
			    return com.trackplus.admin.Filter.issueFilterWindowHeight;
		    } else {
			    if (this.isNotifyFilter()) {
				    return com.trackplus.admin.Filter.notifyFilterWindowHeight;
			    } else {
				    return this.reportEditHeight;
			    }
		    }
	    } else {
		    return this.folderEditHeight;
	    }
	},
	/**
	 * The message to appear first time after selecting this menu entry Is
	 * should be shown by selecting the root but the root is typically not
	 * visible
	 */
	getRootMessage : function(rootID) {
	    if (this.isIssueFilter()) {
		    return getText("admin.customize.queryFilter.lbl.description");
	    } else {
		    if (this.isNotifyFilter()) {
			    return getText("admin.customize.automail.filter.lbl.description");
		    } else {
			    return getText("admin.customize.reportTemplate.lbl.description");
		    }
	    }
	},
	/**
	 * The localized entity name
	 */
	getEntityLabel : function(extraConfig) {
	    var entityLabel = null;
	    var isLeaf = true;
	    if (extraConfig ) {
		    isLeaf = extraConfig.isLeaf;
	    }
	    if (isLeaf) {
		    if (this.isIssueFilter()) {
			    return getText("admin.customize.queryFilter.lbl.issueFilter");
		    } else {
			    if (this.isNotifyFilter()) {
				    return getText("admin.customize.automail.filter.lblOperation");
			    } else {
				    return getText("admin.customize.reportTemplate.lbl");
			    }
		    }
	    } else {
		    return getText('admin.customize.queryFilter.lbl.category');
	    }
	},
	/**
	 * The label for the save button
	 */
	/* protected */getSaveLabel : function(operation) {
	    if (operation === "instant") {
		    return getText(this.btnExecute);
	    } else {
		    return getText('common.btn.save');
	    }
	},
	/**
	 * The url for getting the leaf detail: either this should be overridden or
	 * the leafDetailUrl should be specified in the config
	 */
	/* protected */getLeafDetailUrl : function() {
	    return this.getFolderAction() + '!leafDetail.action';
	},
	initActions : function() {
	    var addFolderIconCls = null;
	    var addLeafIconCls = null;
	    var editIconCls = null;
	    if (this.isNotifyFilter()) {
		    addFolderIconCls = this.getAddFolderNotifyFilterIconCls();
		    addLeafIconCls = this.getAddNotifyFilterIconCls();
		    editIconCls = this.getEditNotifyFilterIconCls();
	    } else {
		    if (this.isIssueFilter()) {
			    addFolderIconCls = this.getAddFolderIssueFilterIconCls();
			    addLeafIconCls = this.getAddIssueFilterIconCls();
			    editIconCls = this.getEditIssueFilterIconCls();
		    } else {
			    if (this.isReport()) {
				    addFolderIconCls = this.getAddFolderReportIconCls();
				    addLeafIconCls = this.getAddReportIconCls();
				    editIconCls = this.getEditReportIconCls();
			    }
		    }
	    }
	    this.actionAddFolder = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {
		    isLeaf : false
	    }), addFolderIconCls, this.onAddFolder, this.getTitle(this.getAddTitleKey(), {
		    isLeaf : false
	    }), true);
	    this.actionAddLeaf = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {
		    isLeaf : true
	    }), addLeafIconCls, this.onAddLeaf, this.getTitle(this.getAddTitleKey(), {
		    isLeaf : true
	    }), true);
	    this.actionEditGridRow = this.createAction(this.getEditButtonKey(), editIconCls, this.onEditGridRow, true, 
	    		this.getEditTitleKey(), "editGridRow");
	    this.actionEditTreeNode = this.createAction(this.getEditButtonKey(), editIconCls, this.onEditTreeNode, false,
	            this.getEditTitleKey(), "editTreeNode");
	    if (this.isIssueFilter()) {
		    this.actionExecuteGridRow = this.createAction(this.btnExecute, 'filterExec', this.onExecuteGridRow, true,
		            this.btnExecute);
		    this.actionExecuteTreeNode = this.createAction(this.btnExecute, 'filterExec', this.onExecuteTreeNode, true,
		            this.btnExecute);
		    this.actionInstantFilter = this.createAction("menu.findItems.instantFilter", "filterInst",
		            this.onInstantFilter, false, "menu.findItems.newInstantFilter.tt");
		    this.actionLinkGridRow = this.createLocalizedAction(getText('common.btn.link'), 'filterLink',
		            this.onLinkGridRow, getText("admin.customize.queryFilter.lbl.filterURL.report.encodedUrl"), true);
		    this.actionLinkTreeNode = this.createLocalizedAction(getText('common.btn.permURL'), 'filterLink',
		            this.onLinkTreeNode, getText("admin.customize.queryFilter.lbl.filterURL.report.encodedUrl"), true);
	    } else {
		    if (this.isReport()) {
			    this.actionExecuteGridRow = this.createAction(this.btnExecute, 'rtemplateExec', this.onExecuteGridRow,
			            true, this.btnExecute);
			    this.actionExecuteTreeNode = this.createAction(this.btnExecute, 'rtemplateExec',
			            this.onExecuteTreeNode, true, this.btnExecute);
			    this.actionDownloadGridRow = this.createAction('common.btn.download', 'download',
			            this.onDownloadGridRow, true, "common.lbl.download", "downloadGridRow");
			    this.actionDownloadTreeNode = this.createAction('common.btn.download', 'download',
			            this.onDownloadTreeNode, true, "common.lbl.download", "downloadTreeNode");
			    /*
				 * this.actionImport =
				 * this.createLocalizedAction(getText("common.btn.import"),
				 * 'import', this.onImport, this.getTitle("common.lbl.import"));
				 * this.actionExport =
				 * this.createLocalizedAction(getText("common.btn.export"),
				 * 'export', this.onExport, this.getTitle("common.lbl.export"),
				 * true);
				 */
		    }
	    }
	    this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(),
	            this.onDeleteFromGrid, true, this.getDeleteTitleKey(), "deleteGridRow");
	    this.actionDeleteTreeNode = this.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(),
	            this.onDeleteFromTree, false, this.getDeleteTitleKey(), "deleteTreeNode");
	    if (this.useCopyPaste) {
		    // cut/copy - paste and drag and drop
		    this.actionCutTreeNode = this.createAction(this.getCutButtonKey(), this.getCutIconCls(),
		            this.onCutTreeNode, false, this.getCutTitleKey(), "cut");
		    this.actionCopyTreeNode = this.createAction(this.getCopyButtonKey(), this.getCopyIconCls(),
		            this.onCopyTreeNode, false, this.getCopyTitleKey(), "copy");
		    this.actionPasteTreeNode = this.createAction(this.getPasteButtonKey(), this.getPasteIconCls(),
		            this.onPasteTreeNode, false, this.getPasteButtonKey());
	    }
	},
	getActionItemIdsWithContextDependentLabel : function() {
	    return [ "editGridRow", "editTreeNode", "deleteGridRow", "deleteTreeNode", "downloadGridRow",
	            "downloadTreeNode", "cut", "copy" ];
	},
	/**
	 * Expanding the node
	 */
	getTreeExpandExtraParams : function(node) {
	    var extraParams = {
		    excludePrivate : this.getExcludePrivate()
	    /*
		 * , fromIssueNavigator:this.fromIssueNavigator
		 */
	    };
	    if (this.getProjectID()) {
		    // in project configuration
		    extraParams["projectID"] = this.getProjectID();
	    }
	    return extraParams;
	},
	/**
	 * Get the extra parameters for the gridStore
	 */
	getGridExtraParams : function(node, opts) {
	    if (CWHF.isNull(node)) {
		    // called manually
		    node = this.selectedNode;
	    }
	    var params = {
	        node : node.data['id'],
	        excludePrivate : this.getExcludePrivate()
	    /*
		 * , fromIssueNavigator:this.fromIssueNavigator
		 */
	    };
	    if (this.getProjectID() ) {
		    // in project configuration
		    params["projectID"] = this.getProjectID();
	    }
	    return params;
	},
	/**
	 * Return false if dragging this node is not allowed
	 */
	canDragDropNode : function(nodeToDrag, copy, overModel) {
	    if (nodeToDrag.data['readOnly']) {
		    // do not drag hardcoded node
		    return false;
	    }
	    if (!nodeToDrag.data['modifiable'] && !copy) {
		    // do not move a not modifiable node
		    return false;
	    }
	    var dropOverNode = overModel;
	    var overLeaf = dropOverNode.isLeaf();
	    if (overLeaf) {
		    dropOverNode = dropOverNode.parentNode;
	    }
	    if (!dropOverNode.data['canAddChild']) {
		    // do not drop in a node with nor right to add child
		    return false;
	    }
	    return true;
	},
	/* protected */getDragDropBaseAction : function(draggedNodeIsLeaf) {
	    return this.getFolderAction();
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	getToolbarActionChangesForTreeNodeSelect : function(selectedNode) {
	    var canAddChild = false;
	    if (selectedNode ) {
		    if (this.getProjectID()  && selectedNode.isRoot()) {
			    // after initializing the project specific branch for issue
			    // filter and report:
			    // although in the filter/report tree no node is selected, the
			    // add refers to the project specific root
			    // (for notify filter the add methods are allowed only after an
			    // explicit selection
			    // in notify filters branch, because there are both the public
			    // and project (for the actual project)
			    // specific notification filters so it is not obvious where to
			    // add when nothing is selected
			    // selectedNode.isRoot(): after deleting a node directly below
			    // root
			    if (this.isIssueFilter() || this.isReport()) {
				    canAddChild = true;
			    }
		    } else {
			    canAddChild = selectedNode.data['canAddChild'];
		    }
	    }
	    this.actionAddFolder.setDisabled(!canAddChild);
	    this.actionAddLeaf.setDisabled(!canAddChild);
	    // nothing selected in the grid
	    this.actionEditGridRow.setDisabled(true);
	    this.actionDeleteGridRow.setDisabled(true);
	    if (this.isIssueFilter() || this.isReport()) {
		    this.actionExecuteGridRow.setDisabled(true);
		    if (this.isIssueFilter()) {
			    this.actionLinkGridRow.setDisabled(true);
		    } else {
			    this.actionDownloadGridRow.setDisabled(true);
			    // this.actionExport.setDisabled(true);
		    }
	    }
	},
	/**
	 * Automatically expand the private repository
	 */
	onTreeNodeLoad : function(treeStore, node) {
	    if (node.isRoot() && CWHF.isNull(this.getProjectID())) {
		    // for not project specific categories expand the private repository
		    // (first child)
		    treeStore.load({
		        node : node.firstChild,
		        callback : function() {
			        node.firstChild.expand();
		        }
		    });
	    }
	},
	/**
	 * Create the edit
	 */
	onTreeNodeDblClick : function(view, record) {
	    var readOnly = record.data['readOnly'];
	    if (CWHF.isNull(readOnly) || readOnly === false) {
		    this.onEditTreeNode();
	    }
	},
	onGridRowDblClick : function(view, record) {
	    var readOnly = record.data['readOnly'];
	    if (CWHF.isNull(readOnly) || readOnly === false) {
		    this.onEditGridRow();
	    }
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields : function() {
	    return [ {
	        name : 'id',
	        mapping : 'id',
	        type : 'string'
	    }, {
	        name : 'text',
	        mapping : 'text',
	        type : 'string'
	    }, {
	        name : 'readOnly',
	        mapping : 'readOnly',
	        type : 'boolean'
	    }, {
	        name : 'modifiable',
	        mapping : 'modifiable',
	        type : 'boolean'
	    }, {
	        name : 'deletable',
	        mapping : 'deletable',
	        type : 'boolean'
	    }, {
	        name : 'canCopy',
	        mapping : 'canCopy',
	        type : 'boolean'
	    }, {
	        name : 'categoryType',
	        mapping : 'categoryType',
	        type : 'string'
	    }, {
	        name : 'treeFilter',
	        mapping : 'treeFilter',
	        type : 'boolean'
	    }, {
	        name : 'reportConfigNeeded',
	        mapping : 'reportConfigNeeded',
	        type : 'boolean'
	    }, {
	        name : 'leaf',
	        mapping : 'leaf',
	        type : 'boolean'
	    }, {
	        name : 'iconCls',
	        mapping : 'iconCls',
	        type : 'string'
	    }, {
	        name : 'canAddChild',
	        mapping : 'canAddChild',
	        type : 'boolean'
	    } ];
	},
	/**
	 * Get the items array to render for leaf detail based on the response JSON
	 * Should be implemented if showGridForLeaf is false
	 */
	getLeafDetailItems : function(node, add, responseJson) {
	    if (responseJson.success === true) {
		    var detailData = responseJson.errorMessage;
		    return [ Ext.create('Ext.Component', {
		        html : detailData,
		        cls : 'categoryConfigLeafDetail',
		        border : true
		    }) ];
	    }
	    return [];
	},
	getGridViewConfig: function() {
		return {
			forceFit: true,
			markDirty: false
		};
	},
	/**
	 * Gets the grid store's fields for the selected node
	 */
	getGridFields : function(node) {
	    if (this.isIssueFilter() && node.data['id'] !== "issueFilter_3") {
		    // Fields for issue filters
		    return [ {
		        name : 'node',
		        type : 'string'
		    }, {
		        name : 'categoryType',
		        type : 'string'
		    }, {
		        name : 'text',
		        type : 'string'
		    }, {
		        name : 'typeLabel',
		        type : 'string'
		    }, {
		        name : 'styleFieldLabel',
		        type : 'string'
		    }, {
		        name : 'viewName',
		        type : 'string'
		    }, {
		        name : 'includeInMenu',
		        type : 'boolean'
		    }, {
		        name : 'treeFilter',
		        type : 'boolean'
		    }, {
		        name : 'modifiable',
		        type : 'boolean'
		    }, {
		        name : 'deletable',
		        type : 'boolean'
		    }, {
		        name : 'leaf',
		        type : 'boolean'
		    } ];
	    } else {
		    // Fields for notify filters or reports or (hardcoded) projects
		    return [ {
		        name : 'node',
		        type : 'string'
		    }, {
		        name : 'categoryType',
		        type : 'string'
		    }, {
		        name : 'text',
		        type : 'string'
		    }, {
		        name : 'typeLabel',
		        type : 'string'
		    }, {
		        name : 'modifiable',
		        type : 'boolean'
		    }, {
		        name : 'deletable',
		        type : 'boolean'
		    }, {
		        name : 'readOnly',
		        mapping : 'readOnly',
		        type : 'boolean'
		    }, {
		        name : 'reportConfigNeeded',
		        mapping : 'reportConfigNeeded',
		        type : 'boolean'
		    }, {
		        name : 'icon',
		        mapping : 'icon',
		        type : 'string'
		    }, {
		        name : 'leaf',
		        type : 'boolean'
		    } ];
	    }
	},
	/**
	 * Gets the grid columns for the selected node
	 */
	getGridColumns : function(node) {
	    // Common columns for notify filters/issue filters/reports/(hardcoded)
	    // projects/
	    var columns = [ {
	    	text : getText('common.lbl.name'),
	        flex : 1,
	        dataIndex : 'text',
	        sortable : false,
	        hidden : false
	    }, {
	    	text : getText('common.lbl.type'),
	        flex : 1,
	        dataIndex : 'typeLabel',
	        sortable : false,
	        hidden : false
	    } ];
	    if (this.isIssueFilter() && node.data['id'] !== "issueFilter_3") {
		    // Extra columns for issue filters
		    columns.push({
		    	text : getText('admin.customize.queryFilter.lbl.styleField'),
		        flex : 1,
		        dataIndex : 'styleFieldLabel',
		        sortable : false,
		        hidden : false
		    });
		    columns.push({
		        xtype : 'checkcolumn',
		        text : getText('admin.customize.queryFilter.lbl.menu'),
		        flex : 1,
		        dataIndex : 'includeInMenu',
		        sortable : false,
		        hidden : false,
		        listeners: {"checkchange": {fn: this.changeSubscribe, scope:this}}});
		    columns.push({
		    	text : getText('admin.customize.queryFilter.lbl.view'),
		        flex : 1,
		        dataIndex : 'viewName',
		        sortable : false,
		        hidden : false
		    });
	    } else {
		    if (this.isReport()) {
			    // Extra columns for reports
			    /*
				 * columns.push({text:
				 * getText('admin.customize.reportTemplate.lbl.icon'), flex:1,
				 * dataIndex: 'icon', sortable: false, hidden:false,
				 * renderer:function (val) { return '<img src="' + val + '"/>';
				 * }});
				 */
		    }
	    }
	    return columns;
	},
	changeSubscribe: function(checkBox, rowIndex, checked, eOpts) {
		var record = this.grid.getStore().getAt(rowIndex);
		if (record) {
			var params = {node:record.data["node"], includeInMenu:checked};
			Ext.Ajax.request({
				url: this.getBaseAction() + "!changeSubscribe.action",
				params: params,
				scope: this,
				success: function(response) {
				},
				failure: function(response) {
					Ext.MessageBox.alert(this.failureTitle, response.responseText);
				}
			});
		}
	},
	postGridPanel : function(grid) {
	    if (this.isReport()) {
		    var view = grid.getView();
		    var tip = Ext.create('Ext.tip.ToolTip', {
		        target : view.el,
		        delegate : view.itemSelector,
		        trackMouse : true,
		        id : 'templatePreview',
		        renderTo : Ext.getBody(),
		        dismissDelay : 0,
		        listeners : {
			        beforeshow : function updateTipBody(tip) {
				        var appWidth = borderLayout.getWidth();
				        tip.maxWidth = 900;
				        if (appWidth < 850) {
					        tip.maxWidth = appWidth - 150;
				        }
				        var leaf = view.getRecord(tip.triggerElement).get('leaf');
				        if (leaf) {
					        var node = view.getRecord(tip.triggerElement).get('node');
					        var templateID = node.substring(node.lastIndexOf("_") + 1);
					        tip.removeAll();
					        var imgCmp = Ext.create('Ext.Img', {
					            src : 'reportDatasource!showPreviewImage.action?templateID=' + templateID,
					            alt : getText('admin.customize.reportTemplate.err.noPreviewAvailable'),
					            listeners : {
						            render : function(c) {
							            c.getEl().on('load', function() {
								            tip.updateLayout();
							            });
						            }
					            }
					        });
					        tip.add(imgCmp);
				        } else {
					        // folder
					        tip.removeAll();
					        var text = view.getRecord(tip.triggerElement).get('text');
					        tip.add(Ext.create('Ext.Component', {
						        html : text
					        }));
				        }
			        }
		        }
		    });
	    }
	},
	/**
	 * Get the configuration for selection model
	 */
	getGridSelectionModel : function(node) {
	    if (this.isReport()) {
		    // report selection model (for export)
		    return Ext.create("Ext.selection.CheckboxModel", {
			    mode : "MULTI"
		    });
	    } else {
		    // filter selection model
		    return Ext.create("Ext.selection.RowModel", {
			    mode : "SINGLE"
		    });
	    }
	},
	getSelectedReportIDs : function() {
	    var selectedReportIDs = new Array();
	    var selectedRecordsArr = this.getSelection();
	    if (selectedRecordsArr ) {
		    Ext.Array.forEach(selectedRecordsArr, function(record, index, allItems) {
			    var nodeID = record.data['node'];
			    var lastIndexOf = nodeID.lastIndexOf("_");
			    selectedReportIDs.push(nodeID.substring(lastIndexOf + 1));
		    }, this);
	    }
	    return selectedReportIDs.join(",");
	},
	enableDisableToolbarButtons : function(view, arrSelections) {
	    if (CWHF.isNull(arrSelections) || arrSelections.length === 0) {
		    this.actionDeleteGridRow.setDisabled(true);
		    this.actionEditGridRow.setDisabled(true);
		    if (this.isIssueFilter() || this.isReport()) {
			    this.actionExecuteGridRow.setDisabled(true);
			    if (this.isIssueFilter()) {
				    this.actionLinkGridRow.setDisabled(true);
			    } else {
				    this.actionDownloadGridRow.setDisabled(true);
				    // this.actionExport.setDisabled(true);
			    }
		    }
	    } else {
		    if (arrSelections.length === 1) {
			    var selectedRecord = arrSelections[0];
			    var isLeaf = selectedRecord.data.leaf;
			    var modifiable = selectedRecord.data.modifiable;
			    if (this.isIssueFilter() && isLeaf) {
				    // for issue filter at least the include in menu and style
				    // field should be editable
				    this.actionEditGridRow.setDisabled(false);
			    } else {
				    this.actionEditGridRow.setDisabled(!modifiable);
			    }
			    if (this.isIssueFilter() || this.isReport()) {
				    this.actionExecuteGridRow.setDisabled(!isLeaf);
				    if (this.isIssueFilter()) {
					    this.actionLinkGridRow.setDisabled(!isLeaf);
				    } else {
					    this.actionDownloadGridRow.setDisabled(!isLeaf);
				    }
			    }
		    } else {
			    // more than one selection
			    this.actionEditGridRow.setDisabled(true);
			    if (this.isIssueFilter() || this.isReport()) {
				    this.actionExecuteGridRow.setDisabled(true);
				    if (this.isIssueFilter()) {
					    this.actionLinkGridRow.setDisabled(true);
				    } else {
					    this.actionDownloadGridRow.setDisabled(true);
				    }
			    }
		    }
		    var allIsDeletable = true;
		    for (var i = 0; i < arrSelections.length; i++) {
			    var selectedRecord = arrSelections[i];
			    var deletable = selectedRecord.data.deletable;
			    if (!deletable) {
				    allIsDeletable = false;
			    }
		    }
		    this.actionDeleteGridRow.setDisabled(!allIsDeletable);
	    }
	},
	/**
	 * Prepare adding/editing a report or filter category
	 */
	getEditFolderPanelItems : function(data, add, fromTree, operation) {
	    var modifiable = false;
	    if (add) {
		    modifiable = true;
	    } else {
		    modifiable = data['modifiable'];
	    }
	    return [ CWHF.createTextField('common.lbl.name', "label", {
	        disabled : !modifiable,
	        allowBlank : false,
	        labelWidth : this.labelWidth
	    }) ];
	},
	/**
	 * Prepare adding/editing a report
	 */
	getEditLeafPanelItems : function(data, add, fromTree, operation) {
	    var modifiable = false;
	    if (add) {
		    modifiable = true;
	    } else {
		    modifiable = (CWHF.isNull(data) || data["modifiable"]);
	    }
	    if (this.isIssueFilter()) {
		    var instant = false;
		    /*
			 * if (operation==="instant") { instant = true; }
			 */
		    if (add || CWHF.isNull(data) || CWHF.isNull(data["treeFilter"]) || data["treeFilter"]) {
			    return com.trackplus.admin.Filter.getTreeFilterItems(modifiable, instant);
		    } else {
			    return com.trackplus.admin.Filter.getTQLFilterItems(modifiable);
		    }
	    } else {
		    if (this.isNotifyFilter()) {
			    return com.trackplus.admin.Filter.getNotifyFilterItems(modifiable);
		    } else {
			    return this.getReportItems(modifiable, add);
		    }
	    }
	},
	/**
	 * Prepare adding/editing a report
	 */
	getReportItems : function(modifiable, add) {
	    var windowItems = [ CWHF.createTextField('common.lbl.name', "label", {
	        disabled : !modifiable,
	        allowBlank : false,
	        labelWidth : this.labelWidth
	    }) ];
	    if (add) {
		    windowItems.push(CWHF.createFileField('admin.customize.reportTemplate.lbl.reportFile', "reportFile", {
		        disabled : !modifiable,
		        allowBlank : false,
		        labelWidth : this.labelWidth,
		        itemId     : "reportFile"
		    }));
	    }
	    return windowItems;
	},
	/**
	 * Method to process the data to be loaded arrived from the server by
	 * editing the leaf
	 */
	getEditLeafPostDataProcess : function(recordData, add) {
	    if (this.isIssueFilter()) {
		    if (CWHF.isNull(recordData) || add || recordData['treeFilter']) {
			    return com.trackplus.admin.Filter.postLoadProcessTreeFilter;
		    } else {
			    return com.trackplus.admin.Filter.postLoadProcessTQLFilter;
		    }
	    } else {
		    if (this.isNotifyFilter()) {
			    return com.trackplus.admin.Filter.postLoadProcessNotifyFilter;
		    }
	    }
	},
	/**
	 * Method to add extra request parameters be sent to the sever before
	 * submitting the leaf data
	 */
	getEditLeafPreSubmitProcess : function(recordData, add) {
	    // is not TQL filter
	    if (this.isIssueFilter() && (CWHF.isNull(recordData) || recordData['treeFilter'] || add)) {
		    return com.trackplus.admin.Filter.preSubmitProcessIssueFilter;
	    } else {
		    if (this.isNotifyFilter()) {
			    return com.trackplus.admin.Filter.preSubmitProcessNotifyFilter;
		    } else {
			    return null;
		    }
	    }
	},
	/**
	 * Add extra window configuration fields by add/edit windowConfiguration
	 * argument is configured with the required fields but any already specified
	 * windowConfig field can be overridden, and further optional window options
	 * can be specified type: typically "folder" or "leaf" but for more leaf
	 * types it can be customized
	 */
	getExtraWindowParameters : function(recordData, operation) {
	    if (this.isReport() && operation === "addLeaf") {
		    // only by add (by edit no upload)
		    return {
		        fileUpload : true,
		        windowConfig : {
		            minWidth : 450,
		            minHeight : 150
		        },
		        panelConfig : {
			        autoScroll : false
		        }
		    };
	    }
	    return null;
	},
	/**
	 * Handler for adding an instant issue filter
	 */
	onInstantFilter : function() {
	    this.instant = true;
	    this.indexMax = 0;
	    com.trackplus.admin.CategoryConfig.showInstant(this, this.getBaseAction() + '!edit.action');
	},
	/**
	 * Execute a leaf node
	 */
	onExecuteTreeNode : function() {
	    this.onExecute(true);
	},
	/**
	 * Execute a grid row
	 */
	onExecuteGridRow : function() {
	    this.onExecute(false);
	},
	/**
	 * Execute a tree node or a grid row
	 */
	onExecute : function(fromTree) {
	    var recordData = this.getSingleSelectedRecordData(fromTree);
	    if (recordData ) {
		    var leaf = this.selectedIsLeaf(fromTree);
		    var node = this.getRecordID(recordData, {
			    fromTree : fromTree
		    });
		    if (leaf) {
			    var lastIndex = node.lastIndexOf("_");
			    var objectID = node.substring(lastIndex + 1);
			    if (this.isIssueFilter()) {
				    com.trackplus.admin.Filter.executeFilter(this, objectID);
			    } else {
				    com.trackplus.admin.Report.executeReport(this, objectID, recordData["reportConfigNeeded"], false);
			    }
		    }
	    }
	},
	/**
	 * Generate a permanent link for an issue filter tree node
	 */
	onLinkTreeNode : function() {
	    this.onLink(true);
	},
	/**
	 * Generate a permanent link for an issue filter grid row
	 */
	onLinkGridRow : function() {
	    this.onLink(false);
	},
	/**
	 * Generate permanent link for issue filter
	 */
	onLink : function(fromTree) {
	    var recordData = this.getSingleSelectedRecordData(fromTree);
	    if (recordData ) {
		    var leaf = this.selectedIsLeaf(fromTree);
		    if (leaf && this.isIssueFilter()) {
			    var node = this.getRecordID(recordData, {
				    fromTree : fromTree
			    });
			    com.trackplus.admin.Filter.generateFilterLink(this, node);
		    }
	    }
	},
	/**
	 * Download the report for a tree node
	 */
	onDownloadTreeNode : function() {
	    this.downloadReport(true);
	},
	/**
	 * Download the report for the grid row
	 */
	onDownloadGridRow : function() {
	    this.downloadReport(false);
	},
	/**
	 * Downloads a report zip
	 */
	downloadReport : function(fromTree) {
	    var recordData = this.getSingleSelectedRecordData(fromTree);
	    if (recordData ) {
		    var leaf = this.selectedIsLeaf(fromTree);
		    if (leaf && this.isReport()) {
			    var node = this.getRecordID(recordData, {
				    fromTree : fromTree
			    });
			    attachmentURI = this.getBaseAction() + '!download.action?node=' + node;
			    window.open(attachmentURI);
		    }
	    }
	},
	/**
	 * Add a leaf: filter or report
	 */
	onAddLeaf : function() {
	    if (this.isIssueFilter() || this.isNotifyFilter()) {
		    this.indexMax = 0;
		    if (this.isIssueFilter()) {
			    this.instant = false;
		    }
	    }
	    this.callParent(arguments);
	},
	/**
	 * Additional execute method for issue filter
	 */
	getAdditionalActions : function(recordData, submitParams, operation, items) {
	    // only for "edit", not for "add" or "instant"
	    if (this.isIssueFilter() && recordData  && recordData.leaf) {
		    var actions = [];
		    if (operation === "edit") {
			    actions.push({
			        submitUrl : 'savedFilterExecute!unwrappedContainsParameter.action',
			        submitUrlParams : submitParams,
			        submitButtonText : getText(this.btnExecute),
			        refreshAfterSubmitHandler : this.executeUnwrappedFilter
			    });
		    }
		    var modifiable = recordData["modifiable"];
		    if (modifiable) {
			    if (CWHF.isNull(submitParams)) {
				    submitParams = new Object();
			    }
			    submitParams["clearFilter"] = true;
			    actions.push({
			        submitUrl : 'filterConfig!edit.action',
			        submitUrlParams : submitParams,
			        submitButtonText : getText("common.btn.reset"),
			        closeAfterSubmit : false,
			        refreshParametersBeforeSubmit : {
				        items : items
			        },
			        refreshAfterSubmitHandler : com.trackplus.admin.Filter.clearFilter
			    });
		    }
		    return actions;
	    }
	    return null;
	},
	/**
	 * Whether the filter contains parameter(s)
	 */
	executeUnwrappedFilter : function(refreshParameters, result) {
	    containsParameter = result.value;
	    if (containsParameter) {
		    this.renderFilterParameter();
	    } else {
		    window.location.href = com.trackplus.TrackplusConfig.contextPath + "/itemNavigator.action";
	    }
	},
	/**
	 * Render the filter parameters
	 */
	renderFilterParameter : function() {
	    var title = getText('admin.customize.queryFilter.lbl.parameters');
	    var width = 1000;
	    var height = 800;
	    var windowItems = com.trackplus.admin.Filter.getTreeFilterParameterItems();
	    var loadUrl = 'filterParameters!renderParameters.action';
	    var submitUrl = 'savedFilterExecute!replaceSubmittedParameters.action';
	    var windowConfig = Ext.create('com.trackplus.util.WindowConfig', {
		    postDataProcess : com.trackplus.admin.Filter.postLoadProcessTreeFilterParameters
	    });
	    windowConfig.showWindow(this, title, width, height, {
		    loadUrl : loadUrl
	    }, {
	        submitUrl : submitUrl,
	        submitButtonText : getText(this.btnExecute),
	        standardSubmit : true
	    }, windowItems);
	},
	/**
	 * Add a leaf: filter or report
	 */
	onEditGridRow : function() {
	    if (this.isIssueFilter() || this.isNotifyFilter()) {
		    this.indexMax = 0;
		    if (this.isIssueFilter()) {
			    this.instant = false;
		    }
	    }
	    this.callParent(arguments);
	},
	/**
	 * Add a leaf: filter or report
	 */
	onEditTreeNode : function() {
	    if (this.isIssueFilter() || this.isNotifyFilter()) {
		    this.indexMax = 0;
		    if (this.isIssueFilter()) {
			    this.instant = false;
		    }
	    }
	    this.callParent(arguments);
	},
	/**
	 * The struts action for delete/replace: deleting of both leafs and folders
	 * are made in the folderAction
	 */
	getDeleteUrlBase : function(extraConfig) {
	    return this.getFolderAction();
	},
	/**
	 * The replacement items for the deleted entity
	 */
	getReplacementItems : function(responseJson, selectedRecords, extraConfig) {
	    // var excludePrivate = selectedRecords.data["repository"];
	    /*
		 * var nodeIDField = "node"; var fromTree = true; if (extraConfig &&
		 * extraConfig.fromTree) { nodeIDField = "id"; } var nodeID =
		 * selectedRecords.data[nodeIDField]; var excludePrivate = false; var
		 * exceptID = null; if (nodeID) { var parts = nodeID.split("_");
		 * if (parts) { if (parts.length>1) { var repository = parts[1];
		 * if (repository!=="1") { //replacing a non-private only with a
		 * non-private excludePrivate = true; } } if (parts.length>3) { exceptID =
		 * parts[3]; } } }
		 */
	    return [ {
	        xtype : 'label',
	        itemId : 'replacementWarning'
	    }, CWHF.createSingleTreePicker("Replacement", "replacementID", [], null, {
	        allowBlank : false,
	        blankText : getText('common.err.replacementRequired', this.getEntityLabel(extraConfig)),
	        labelWidth : 200,
	        margin : '5 0 0 0',
	        itemId:'replacementID'
	    }) ];
	},
	/**
	 * Load the data source and value for the replacement options combo Override
	 * this for different tree based pickers
	 */
	loadReplacementOptionData : function(replacementControl, data) {
	    replacementControl.updateMyOptions(data["replacementTree"]);
	},
	/**
	 * panel for importing the e-mail templates
	 */
	getImportPanel : function() {
	    this.formPanel = new Ext.form.FormPanel({
	        border : false,
	        bodyStyle : 'padding:5px',
	        defaults : {
	            labelStyle : 'overflow: hidden;',
	            margin : "5 5 0 0",
	            msgTarget : 'side',
	            anchor : '-20'
	        },
	        method : 'POST',
	        fileUpload : true,
	        items : [ CWHF.createCheckbox('common.lbl.overwriteExisting', 'overwriteExisting', {
		        labelWidth : 200,itemId:'overwriteExisting'
	        }), CWHF.createFileField('admin.customize.reportTemplate.lbl.reportFile', 'uploadFile', {
	            allowBlank : false,
	            labelWidth : 200,
	            itemId     : "uploadFile"
	        }) ]
	    });
	    return this.formPanel;
	},
	/**
	 * Get the actions available in context menu depending on the currently
	 * selected row
	 *
	 */
	getTreeContextMenuActions : function(selectedRecord, selectionIsSimple) {
	    var modifiable = selectedRecord.data['modifiable'];
	    var deletable = selectedRecord.data['deletable'];
	    var canAddChild = selectedRecord.data['canAddChild'];
	    var canCopy = selectedRecord.data['canCopy'];
	    var leaf = selectedRecord.data['leaf'];
	    var actions = [];
	    if (selectionIsSimple) {
		    if (canAddChild) {
			    if (!leaf) {
				    actions.push(this.actionAddFolder);
			    }
			    actions.push(this.actionAddLeaf);
		    }
		    if (modifiable || (leaf && this.isIssueFilter())) {
			    actions.push(this.actionEditTreeNode);
		    }
		    if (leaf && (this.isIssueFilter() || this.isReport())) {
			    actions.push(this.actionExecuteTreeNode);
			    if (this.isReport()) {
				    actions.push(this.actionDownloadTreeNode);
			    } else {
				    if (this.isIssueFilter()) {
					    actions.push(this.actionLinkTreeNode);
				    }
			    }
		    }
	    } else {
		    actions = [];
	    }
	    if (this.useCopyPaste) {
		    if (canCopy) {
			    if (modifiable) {
				    actions.push(this.actionCutTreeNode);
			    }
			    actions.push(this.actionCopyTreeNode);
		    }
		    if (canAddChild && this.cutCopyNode ) {
			    actions.push(this.actionPasteTreeNode);
		    }
	    }
	    if (deletable) {
		    actions.push(this.actionDeleteTreeNode);
	    }
	    return actions;
	},
	/**
	 * Get the actions available in context menu depending on the currently
	 * selected row
	 *
	 */
	getGridContextMenuActions : function(selectedRecord, selectionIsSimple) {
	    var modifiable = selectedRecord.data['modifiable'];
	    var leaf = selectedRecord.data['leaf'];
	    var actions = [];
	    if (leaf) {
		    // leaf
		    if (modifiable || this.isIssueFilter()) {
			    actions.push(this.actionEditGridRow);
		    }
		    if (this.isIssueFilter() || this.isReport()) {
			    actions.push(this.actionExecuteGridRow);
			    if (this.isReport()) {
				    actions.push(this.actionDownloadGridRow);
			    } else {
				    if (this.isIssueFilter()) {
					    actions.push(this.actionEditGridRow);
					    actions.push(this.actionLinkGridRow);
				    }
			    }
		    }
	    } else {
		    // branch
		    if (modifiable) {
			    actions.push(this.actionEditGridRow);
		    }
	    }
	    /*
		 * if (modifiable) { if (selectionIsSimple) {
		 * actions.push(this.actionEditGridRow); } if (leaf &&
		 * (this.isIssueFilter() || this.isReport())) {
		 * actions.push(this.actionExecuteGridRow); if (this.isReport()) {
		 * actions.push(this.actionDownloadGridRow); } else { if
		 * (this.isIssueFilter()) { actions.push(this.actionLinkGridRow); } } }
		 * actions.push(this.actionDeleteGridRow); }
		 */
	    return actions;
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions : function() {
	    if (this.isIssueFilter()) {
		    return this.getIssueFilterToolbarItems();
	    }
	    if (this.isNotifyFilter()) {
		    return this.getNotifyFilterToolbarItems();
	    }
	    if (this.isReport()) {
		    return this.getReportToolbarItems();
	    }
	},
	/**
	 * Toolbar items for issue filter
	 */
	getIssueFilterToolbarItems : function() {
	    if (CWHF.isNull(this.getProjectID())) {
		    return [ this.actionInstantFilter, this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow,
		            this.actionExecuteGridRow, this.actionLinkGridRow, this.actionDeleteGridRow ];
	    } else {
		    return [ this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow, this.actionExecuteGridRow,
		            this.actionLinkGridRow, this.actionDeleteGridRow ];
	    }
	},
	/**
	 * Toolbar items for notify filter
	 */
	getNotifyFilterToolbarItems : function() {
	    return [ this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow, this.actionDeleteGridRow ];
	},
	/**
	 * Toolbar items for report
	 */
	getReportToolbarItems : function() {
	    return [ this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow, this.actionExecuteGridRow,
	            this.actionDownloadGridRow, this.actionDeleteGridRow /*
																		 * ,this.actionImport,
																		 * this.actionExport
																		 */];
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getAddFolderIssueFilterIconCls : function() {
	    return "categoryFilterAdd";
	},
	getAddIssueFilterIconCls : function() {
	    return "filterAdd";
	},
	getEditIssueFilterIconCls : function() {
	    return "filterEdit";
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getAddFolderNotifyFilterIconCls : function() {
	    return "categoryFilterAdd";
	},
	getAddNotifyFilterIconCls : function() {
	    return "filterAdd";
	},
	getEditNotifyFilterIconCls : function() {
	    return "filterEdit";
	},
	getPasteIconCls : function() {
	    return "filterPaste";
	},
	getAddFolderReportIconCls : function() {
	    return "categoryReportAdd";
	},
	getAddReportIconCls : function() {
	    return "rtemplateAdd";
	},
	getEditReportIconCls : function() {
	    return "rtemplateEdit";
	},
	/**
	 * The iconCls for the add button, overwrites base class icon
	 */
	getAddIconCls : function() {
	    return 'rtemplateAdd';
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.ReportConfig', {
	    extend : 'com.trackplus.admin.TreeDetail',
	    config : {
	    	repCfgLayout: null
	    },
	    baseAction : "reportConfig",
	    folderAction : "categoryConfig",
	    btnExecute : null,
	    confirmDeleteEntity : true,
	    confirmDeleteNotEmpty : true,
	    entityID : 'node',
	    folderEditWidth : 400,
	    folderEditHeight : 115,
	    reportEditWidth : 500,
	    reportEditHeight : 150,
	    useCopyPaste : true,
	    dragAndDropOnTree : true,
	    labelWidth : 170,
	    treeHasItemdblclick : true,
	    allowMultipleSelections : true,
	    // actions
	    actionAddFolder : null,
	    actionAddLeaf : null,
	    actionEditGridRow : null,
	    actionEditTreeNode : null,
	    actionCutTreeNode : null,
	    actionCopyTreeNode : null,
	    actionPasteTreeNode : null,
	    actionDeleteGridRow : null,
	    actionDeleteTreeNode : null,
	    localizedLabels : null,
	    instant : false,
	    selectedRecords : {},
	    statics : {},
	    constructor : function(config) {
	        var cfg = config || {};
			this.initConfig(cfg);
	        this.btnExecute = "common.btn.executeReport";
	        this.initBase();
	    },
	    initActions : function() {
	        var addFolderIconCls;
	        var addLeafIconCls;
	        var editIconCls;
	        addFolderIconCls = this.getAddFolderReportIconCls();
	        addLeafIconCls = this.getAddReportIconCls();
	        editIconCls = this.getEditReportIconCls();
	        this.actionAddFolder = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {
	            isLeaf : false
	        }), addFolderIconCls, this.onAddFolder, this.getTitle(this.getAddTitleKey(), {
	            isLeaf : false
	        }), true);
	        this.actionAddLeaf = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {
	            isLeaf : true
	        }), addLeafIconCls, this.onAddLeaf, this.getTitle(this.getAddTitleKey(), {
	            isLeaf : true
	        }), true);
	        this.actionEditGridRow = this.createAction(this.getEditButtonKey(), editIconCls,
	                this.onEditGridRow, true, this.getEditTitleKey(), "editGridRow");
	        this.actionEditTreeNode = this.createAction(this.getEditButtonKey(), editIconCls,
	                this.onEditTreeNode, false, this.getEditTitleKey(), "editTreeNode");
	        this.actionExecuteGridRow = this.createAction(this.btnExecute, 'rtemplateExec',
	                this.onExecuteGridRow, true, this.btnExecute);
	        this.actionExecuteTreeNode = this.createAction(this.btnExecute, 'rtemplateExec',
	                this.onExecuteTreeNode, true, this.btnExecute);
	        this.actionDownloadGridRow = this.createAction('common.btn.download', 'download',
	                this.onDownloadGridRow, true, "common.lbl.download", "downloadGridRow");
	        this.actionDownloadTreeNode = this.createAction('common.btn.download', 'download',
	                this.onDownloadTreeNode, true, "common.lbl.download", "downloadTreeNode");
	        this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(),
	                this.getDeleteIconCls(), this.onDeleteFromGrid, true, this.getDeleteTitleKey(),
	                "deleteGridRow");
	        this.actionDeleteTreeNode = this.createAction(this.getDeleteButtonKey(), this
	                .getDeleteIconCls(), this.onDeleteFromTree, false, this.getDeleteTitleKey(),
	                "deleteTreeNode");
	        if (this.useCopyPaste) {
	            // cut/copy - paste and drag and drop
	            this.actionCutTreeNode = this.createAction(this.getCutButtonKey(), this.getCutIconCls(),
	                    this.onCutTreeNode, false, this.getCutTitleKey(), "cut");
	            this.actionCopyTreeNode = this.createAction(this.getCopyButtonKey(), this.getCopyIconCls(),
	                    this.onCopyTreeNode, false, this.getCopyTitleKey(), "copy");
	            this.actionPasteTreeNode = this.createAction(this.getPasteButtonKey(), this
	                    .getPasteIconCls(), this.onPasteTreeNode, false, this.getPasteButtonKey());
	        }
	    },
	    /**
		 * Get the detail part after selecting a tree node
		 */
	    loadDetailPanel : function(node, leaf, opts) {
	        this.getGridPanel(node, opts);
	    },
	    getGridPanel : function(node, opts) {
	        var me = this;
	        this.params = {};
	        this.params = this.getGridExtraParams(node, opts);
	        this.getDataViewPanelData();
	    },
	    getDataViewPanelData : function(parameters) {
	        var me = this;
	        Ext.Ajax.request({
	            url : this.getNodeBaseAction({
	                isLeaf : false
	            }) + '!loadList.action',
	            params : this.params,
	            success : function(result) {
	                var jsonData = Ext.decode(result.responseText);
	                me.centerDataViewDataArrived(jsonData);
	            },
	            failure : function() {
	            },
	            method : 'GET'
	        });
	    },
	    centerDataViewDataArrived : function(jsonData) {
	        var me = this;
	        var storeData = [];
	        for ( var ind in jsonData) {
	            var tmpObj = {};
	            tmpObj.text = jsonData[ind].text;
	            tmpObj.typeLabel = jsonData[ind].typeLabel;
	            tmpObj.icon = jsonData[ind].icon;
	            var nodeVal = jsonData[ind].node;
	            tmpObj.node = jsonData[ind].node;
	            tmpObj.templateIDLong = nodeVal;
	            tmpObj.modifiable = jsonData[ind].modifiable;
	            tmpObj.leaf = jsonData[ind].leaf;
	            tmpObj.templateID = nodeVal.substring(nodeVal.lastIndexOf("_") + 1);
	            tmpObj.reportConfigNeeded = jsonData[ind].reportConfigNeeded;
	            tmpObj.categoryType = jsonData[ind].categoryType;
	            tmpObj.deletable = jsonData[ind].deletable;
	            tmpObj.iconCls = jsonData[ind].iconCls;
	            storeData.push(tmpObj);
	        }
	        var myStore = Ext.create('Ext.data.Store', {
	            id : 'imagesStore',
	            fields : [ {
	                name : 'text',
	                type : 'string'
	            }, {
	                name : 'typeLabel',
	                type : 'string'
	            }, {
	                name : 'templateID',
	                type : 'string'
	            }, {
	                name : 'node',
	                type : 'string'
	            }, {
	                name : 'templateIDLong',
	                type : 'string'
	            }, {
	                name : 'modifiable',
	                type : 'boolean'
	            }, {
	                name : 'reportConfigNeeded',
	                type : 'boolean'
	            }, {
	                name : 'deletable',
	                type : 'boolean'
	            }, {
	                name : 'categoryType',
	                type : 'string'
	            }, {
	                name : 'iconCls',
	                type : 'string'
	            }, {
	                name : 'leaf',
	                type : 'boolean'
	            } ],
	            data : storeData
	        });
	        var mosaicTmpl = new Ext.XTemplate(
	                '<tpl for=".">',
	                '<div class="mosaicDiv">',
	                '<tpl if="leaf===true">',
	                '<a class="example-image-link" href="reportDatasource!showPreviewImage.action?templateID={templateID}&leaf={leaf}&iconCls={iconCls}" data-lightbox="example-set">',
	                '<img class = "mosaicImageReport" src="reportDatasource!showPreviewImage.action?templateID={templateID}&leaf={leaf}" />',
	                '<p class = "titeLabel" >{text}/{typeLabel}</p>',
	                '</a>',
	                '</tpl>',
	                '<tpl if="leaf===false">',
	                '<tpl if="iconCls===\'projects-ticon\'">',
	                '<img class = "mosaicImageFolder" src="reportDatasource!showPreviewImage.action?templateID={templateID}&leaf={leaf}&iconCls={iconCls}" />',
	                '<p class = "titeLabel">{text}</p>',
	                '</tpl>',
	                '<tpl if="iconCls===\'folder\'">',
	                '<img class = "mosaicImageFolder" src="reportDatasource!showPreviewImage.action?templateID={templateID}&leaf={leaf}&iconCls={iconCls}" />',
	                '<p class = "titeLabel">{text}</p>', '</tpl>', '</tpl>', '</div>', '</tpl>',
	                '<div class="x-clear"></div>');
	        var dataViewListeners = {};
	        this.dataView = Ext.create('Ext.view.View', {
	            store : myStore,
	            tpl : mosaicTmpl,
	            cls : 'reportsCenterContent',
	            itemSelector : 'div.mosaicDiv',
	            overItemCls : 'x-item-over',
	            simpleSelect : false,
	            darggable : true,
	            listeners : {
	                selectionchange : function(dv, selections) {
	                    me.onDataViewChange(dv, selections);
	                },
	                itemcontextmenu : function(dataView, record, item, index, evtObj) {
	                    me.onGridRowCtxMenu(dataView, record, item, index, evtObj);
	                },
	                itemdblclick : function(dataView, record, item, index, evtObj) {
	                    me.itemdblclick(dataView, record, item, index, evtObj);
	                }
	            },
	            multiSelect : true,
	            trackOver : true
	        });
	        me.initDraDrop();
	        this.centerPanel = this.dataView;
	        if (this.replaceCenterPanel) {
	            this.replaceCenterPanel.call(this, this.centerPanel);
	        } else {
	            this.mainPanel.add(this.centerPanel);
	        }
	    },
		replaceCenterPanel:function(centerPanel){
			var me = this;
			me.getRepCfgLayout().borderLayoutController.setCenterContent.call(me.getRepCfgLayout().borderLayoutController, centerPanel);
		},
	    initDraDrop : function() {
	        var me = this;
	        this.dataView.on('render', function(v) {
	            me.dataView = new Ext.dd.DragZone(me.dataView.getEl(), {
	                getDragData : function(e) {
	                    var sourceEl = e.getTarget('div.mosaicDiv', 10);
	                    if (sourceEl) {
	                        d = sourceEl.cloneNode(true);
	                        d.id = Ext.id();
	                        sourceEl.cls = '';
	                        return {
	                            ddel : d,
	                            sourceEl : sourceEl,
	                            repairXY : Ext.fly(sourceEl).getXY(),
	                            sourceStore : v.store,
	                            item : v.getRecord(sourceEl)
	                        }
	                    }
	                },
	                getRepairXY : function() {
	                    return this.dragData.repairXY;
	                }
	            });
	            me.dataView.dropZone = Ext.create('Ext.dd.DropZone', me.dataView.getEl(), {
	                getTargetFromEvent : function(e) {
	                    var sourceEl = e.getTarget('div.mosaicDiv', 10);
	                    if (sourceEl) {
	                        return {
		                        item : v.getRecord(sourceEl)
	                        }
	                    }
	                },
	                onNodeDrop : function(target, dd, e, data) {
	                    var nodeTo = target.item;
	                    nodeTo.data.id = nodeTo.data.node;
	                    var nodeFrom = data.item;
	                    nodeFrom.data.id = nodeFrom.data.node;
	                    if (me.dataViewDropIsAllowed(nodeFrom.data, nodeTo.data)) {
	                        me.onDropDataViewNode(nodeFrom, nodeTo, false);
	                    }
	                },
	                onNodeOver : function(target, dd, e, data) {
	                    var nodeTo = target.item.data;
	                    var nodeFrom = data.item.data;
	                    if (me.dataViewDropIsAllowed(nodeFrom, nodeTo)) {
	                        return Ext.dd.DropZone.prototype.dropAllowed;
	                    } else {
	                        return Ext.dd.DropZone.prototype.dropNotAllowed;
	                    }
	                }
	            });
	            // init drop area for tree
	            me.tree.dropZone = Ext.create('Ext.dd.DropZone', me.tree.getEl(), {
	                getTargetFromEvent : function(e) {
	                    var sourceEl = e.getTarget('.x-grid-row', 10);
	                    if (sourceEl) {
	                        return {
		                        item : me.tree.getView().getRecord(sourceEl)
	                        }
	                    }
	                },
	                onNodeDrop : function(target, dd, e, data) {
	                    var nodeTo = target.item;
	                    nodeTo.data.id = nodeTo.raw.id;
	                    var nodeFrom = data.item;
	                    nodeFrom.data.id = nodeFrom.data.node;
	                    if (me.dataViewDropIsAllowed(nodeFrom.data, nodeTo.data)) {
	                        me.onDropDataViewNode(nodeFrom, nodeTo, false);
	                    }
	                },
	                onNodeOver : function(target, dd, e, data) {
	                    var nodeTo = target.item.data;
	                    var nodeFrom = data.item.data;
	                    if (me.dataViewDropIsAllowed(nodeFrom, nodeTo)) {
	                        return Ext.dd.DropZone.prototype.dropAllowed;
	                    } else {
	                        return Ext.dd.DropZone.prototype.dropNotAllowed;
	                    }
	                }
	            });
	        });
	    },
	    dataViewDropIsAllowed : function(nodeFrom, nodeTo) {
	        if (nodeTo.leaf || nodeTo.node === nodeFrom.node) {
	            return false;
	        }
	        return true;
	    },
	    /**
		 * Enable/disable actions based on the actual selection
		 */
	    onDataViewChange : function(view, selections) {
	        this.enableDisableToolbarButtons(view, selections);
	        var selectedRow = null;
	        if (selections  && selections.length > 0) {
	            selectedRow = selections[0];
	            this.selectedRecord = selections[0];
	            this.selectedRecords = selections;
	        }
	        this.adjustToolbarButtonsTooltip(selectedRow, false);
	    },
	    /**
		 * Automatically expand the private repository
		 */
	    onTreeNodeLoad : function(treeStore, node) {
	        var me = this;
	        if (node.isRoot() && CWHF.isNull(this.projectID)) {
	            for ( var ind in node.childNodes) {
	                // Load and expand public reports
	                if (node.childNodes[ind].data.id === "report_2") {
	                    treeStore.load({
	                        node : node.childNodes[ind],
	                        callback : function() {
		                        node.childNodes[ind].expand()
	                        }
	                    });
	                    me.params = {};
	                    me.params.node = node.childNodes[ind].data.id;
	                    me.nodeIDToSelect = node.childNodes[ind].data.id;
	                    me.getDataViewPanelData();
	                }
	            }
	        }
	    },
	    enableDisableToolbarButtons : function(view, arrSelections) {
	        if (CWHF.isNull(arrSelections) || arrSelections.length === 0) {
	            this.actionDeleteGridRow.setDisabled(true);
	            this.actionEditGridRow.setDisabled(true);
	            this.actionExecuteGridRow.setDisabled(true);
	            this.actionDownloadGridRow.setDisabled(true);
	        } else {
	            if (arrSelections.length === 1) {
	                var selectedRecord = arrSelections[0];
	                var isLeaf = selectedRecord.data.leaf;
	                var modifiable = selectedRecord.data.modifiable;
	                this.actionEditGridRow.setDisabled(!modifiable);
	                this.actionExecuteGridRow.setDisabled(!isLeaf);
	                this.actionDownloadGridRow.setDisabled(!isLeaf);
	            } else {
	                // more than one selection
	                this.actionEditGridRow.setDisabled(true);
	                this.actionExecuteGridRow.setDisabled(true);
	                this.actionDownloadGridRow.setDisabled(true);
	            }
	            var allIsDeletable = true;
	            for (var i = 0; i < arrSelections.length; i++) {
	                var selectedRecord = arrSelections[i];
	                var deletable = selectedRecord.data.deletable;
	                if (!deletable) {
	                    allIsDeletable = false;
	                }
	            }
	            this.actionDeleteGridRow.setDisabled(!allIsDeletable);
	        }
	    },
	    /**
		 * Handler for edit
		 */
	    onEdit : function(fromTree) {
	        var operation = "edit";
	        var isLeaf = this.selectedIsLeaf(fromTree);
	        var title = this.getTitle(this.getEditTitleKey(), {
	            isLeaf : isLeaf,
	            fromTree : fromTree,
	            selectedRecord : this.getLastSelected(fromTree)
	        });
	        var loadParams = {};
	        var submitParams = {};
	        var reloadParams = {};
	        var reloadParamsFromResult = {};
	        var selectedRecord = {};
	        if (fromTree) {
	            loadParams = this.getEditParams(fromTree);
	            submitParams = this.getEditParams(fromTree);
	            reloadParams = this.getEditReloadParamsAfterSave(fromTree);
	            reloadParamsFromResult = this.getEditReloadParamsAfterSaveFromResult(fromTree);
	            selectedRecord = this.getSingleSelectedRecord(fromTree);
	        } else {
	            selectedRecord = this.selectedRecord;
	            loadParams.node = this.selectedRecord.data.templateIDLong;
	            submitParams.node = this.selectedRecord.data.templateIDLong;
	            // reloadParams =
				// this.getEditReloadParamsAfterSave(fromTree);
	        }
	        return this.onAddEdit(title, selectedRecord, operation, isLeaf, false, fromTree, loadParams,
	                submitParams, reloadParams, reloadParamsFromResult);
	    },
	    /**
		 * Add a leaf: filter or report
		 */
	    onEditTreeNode : function() {
	        this.onEdit(true);
	    },
	    /**
		 * Get the node to select after save after edit operation
		 */
	    getEditReloadParamsAfterSaveFromResult : function(fromTree) {
	        if (fromTree) {
	            // edited from tree: select
	            return [ {
	                parameterName : 'nodeIDToSelect',
	                fieldNameFromResult : 'node'
	            }, {
	                parameterName : 'rowToSelect',
	                fieldNameFromResult : 'node'
	            } ];
	        }
	    },
	    /**
		 * Create the edit
		 */
	    onTreeNodeDblClick : function(view, record) {
	        var readOnly = record.data['readOnly'];
	        if (CWHF.isNull(readOnly) || readOnly === false) {
	            this.onEditTreeNode();
	        }
	    },
	    /**
		 * Handler for add/edit a node/row title:
		 * 'add'/'edit'/'copy' recordData: the selected record (tree
		 * node data or grid row data) operation: "edit"/"add" or
		 * anything else in the derived classes isLeaf: whether to
		 * add a leaf or a folder add: whether it is add or edit
		 * fromTree: operations started from tree or from grid
		 * loadParams submitParams refreshParams
		 * refreshParamsFromResult
		 */
	    onAddEdit : function(title, record, operation, isLeaf, add, fromTree, loadParams, submitParams,
	            refreshParams, refreshParamsFromResult) {
	        var recordData = null;
	        if (record ) {
	            recordData = record.data;
	        }
	        var width = this.getEditWidth(recordData, isLeaf, add, fromTree, operation);
	        var height = this.getEditHeight(recordData, isLeaf, add, fromTree, operation);
	        var loadUrl = this.getEditUrl(isLeaf);
	        var load = {
	            loadUrl : loadUrl,
	            loadUrlParams : loadParams
	        };
	        var submitUrl = this.getSaveUrl(isLeaf);
	        var submit = {
	            submitUrl : submitUrl,
	            submitUrlParams : submitParams,
	            submitButtonText : this.getSaveLabel(operation),
	            submitHandler : this.submitHandler,
	            submitAction : operation,
	            refreshAfterSubmitHandler : this.reload,
	            refreshParametersBeforeSubmit : refreshParams,
	            refreshParametersAfterSubmit : refreshParamsFromResult
	        };
	        var postDataProcess = this.getEditPostDataProcess(record, isLeaf, add, fromTree, operation);
	        var preSubmitProcess = this.getEditPreSubmitProcess(recordData, isLeaf, add);
	        var items = this.getPanelItems(recordData, isLeaf, add, fromTree, operation);
	        var additionalActions = this.getAdditionalActions(recordData, submitParams, operation, items);
	        if (additionalActions ) {
	            additionalActions.push(submit);
	            submit = additionalActions;
	        }
	        var windowParameters = {
	            title : title,
	            width : width,
	            height : height,
	            load : load,
	            submit : submit,
	            items : items,
	            postDataProcess : postDataProcess,
	            preSubmitProcess : preSubmitProcess
	        };
	        var extraWindowParameters = this.getExtraWindowParameters(recordData, operation);
	        if (extraWindowParameters ) {
	            for (propertyName in extraWindowParameters) {
	                windowParameters[propertyName] = extraWindowParameters[propertyName];
	            }
	        }
	        var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
	        windowConfig.showWindowByConfig(this);
	    },
	    /**
		 * Reload method
		 */
	    reload : function(params) {
	        var me = this;
	        params.reloadTree = true;
	        com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit.call(this, params);
	        me.getDataViewPanelData();
	    },
	    /**
		 * Handler for adding a folder node
		 */
	    onAddFolder : function() {
	        var operation = "addFolder";
	        var title = this.getTitle(this.getAddTitleKey(), {
	            isLeaf : false,
	            selectedRecord : this.getLastSelected(true)
	        });
	        var loadParams = this.getAddFolderParams();
	        var submitParams = this.getAddFolderParams();
	        var reloadParams = this.getAddReloadParamsAfterSave(false);
	        var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
	        var selectedRecord = this.getSingleSelectedRecord(true);
	        if (CWHF.isNull(selectedRecord)) {
	            selectedRecord = this.tree.getRootNode();
	        }
	        return this.onAddEdit(title, selectedRecord, operation, false, true, true, loadParams,
	                submitParams, reloadParams, reloadParamsFromResult);
	    },
	    /**
		 * Add a leaf: filter or report
		 */
	    onAddLeaf : function() {
	        var operation = "addLeaf";
	        var title = this.getTitle(this.getAddTitleKey(), {
	            isLeaf : true,
	            selectedRecord : this.getLastSelected(true)
	        });
	        var loadParams = this.getAddLeafParams();
	        var submitParams = this.getAddLeafParams();
	        var reloadParams = this.getAddReloadParamsAfterSave(true);
	        var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
	        var selectedRecord = this.getSingleSelectedRecord(true);
	        if (CWHF.isNull(selectedRecord)) {
	            selectedRecord = this.tree.getRootNode();
	        }
	        return this.onAddEdit(title, selectedRecord, operation, true, true, true, loadParams,
	                submitParams, reloadParams, reloadParamsFromResult);
	    },
	    /**
		 * Download the report for a tree node
		 */
	    onDownloadTreeNode : function() {
	        this.downloadReport(true);
	    },
	    /**
		 * Downloads a report zip
		 */
	    downloadReport : function(fromTree) {
	        if (fromTree) {
	            var recordData = this.getSingleSelectedRecordData(fromTree);
	            if (recordData ) {
	                var leaf = this.selectedIsLeaf(fromTree);
	                var node = this.getRecordID(recordData, {
	                    fromTree : fromTree
	                });
	                attachmentURI = this.getBaseAction() + '!download.action?node=' + node;
	                window.open(attachmentURI);
	            }
	        } else {
	            var leaf = this.selectedRecord.data.leaf;
	            var node = this.selectedRecord.data.templateIDLong;
	            attachmentURI = this.getBaseAction() + '!download.action?node=' + node;
	            window.open(attachmentURI);
	        }
	    },
	    /**
		 * The struts action for delete/replace
		 */
		getDeleteUrlBase: function(extraConfig) {
			return "categoryConfig";
		},
	    /**
		 * Delete handler for deleting from the tree
		 */
	    onDeleteFromTree : function() {
	        this.onDelete(true);
	    },
	    /**
		 * Delete handler for deleting from the grid
		 */
	    onDeleteFromGrid : function() {
	        this.onDelete(false);
	    },
	    /**
		 * Handler for delete
		 */
	    onDelete : function(fromTree) {
	        var selectedRecords = [];
	        if (fromTree) {
	            selectedRecords = this.getSelectedRecords(fromTree);
	        } else {
	            var obj = {};
	            obj.data = this.selectedRecords[0];
	            selectedRecords = this.selectedRecords;
	        }
	        if (selectedRecords ) {
	            var isLeaf = this.selectedIsLeaf(fromTree);
	            var extraConfig = {
	                fromTree : fromTree,
	                isLeaf : isLeaf
	            };
	            this.deleteHandler(selectedRecords, extraConfig);
	        }
	    },
	    /**
		 * Cut a tree node
		 */
	    onCutTreeNode : function() {
	        this.cutCopyNode = this.selectedNode;
	        this.copy = false;
	    },
	    /**
		 * Copy a tree node
		 */
	    onCopyTreeNode : function() {
	        this.cutCopyNode = this.selectedNode;
	        this.copy = true;
	    },
	    /**
		 * Paste a node in the tree after copy/cut
		 */
	    onPasteTreeNode : function() {
	        this.onDropTreeNode(this.cutCopyNode, this.selectedNode, this.copy);
	        this.cutCopyNode = null;
	    },
	    /**
		 * Show the context menu in grid
		 */
	    onGridRowCtxMenu : function(dataView, record, item, index, evtObj) {
	        evtObj.stopEvent();
	        this.selectedRecord = record;
	        var selectionIsSimple = this.selectionIsSimple(false);
	        var actions = this.getContextMenuActions(record, selectionIsSimple, false);
	        if (actions  && actions.length > 0) {
	            var treeNodeCtxMenu = this.createContextMenu(record, actions);
	            this.adjustContextMenuText(treeNodeCtxMenu, record, false);
	            treeNodeCtxMenu.showAt(evtObj.getXY());
	        }
	        return false;
	    },
	    itemdblclick : function(dataView, record, item, index, evtObj) {
	        this.params = {};
	        var me = this;
	        this.params.node = record.data.node;
	        this.nodeIDToSelect = record.data.node;
	        this.treePanel = this.tree;
	        // com.trackplus.util.RefreshAfterSubmit.selectTreeNodeAfterReload.call(this);
	        this.getDataViewPanelData();
	    },
	    /**
		 * Download the report for the grid row
		 */
	    onDownloadGridRow : function() {
	        this.downloadReport(false);
	    },
	    /**
		 * Add a leaf: filter or report
		 */
	    onEditGridRow : function() {
	        this.onEdit(false);
	    },
	    /**
		 * Execute a leaf node
		 */
	    onExecuteTreeNode : function() {
	        this.onExecute(true);
	    },
	    /**
		 * Execute a grid row
		 */
	    onExecuteGridRow : function() {
	        this.onExecute(false);
	    },
	    /**
		 * Execute a tree node or a grid row
		 */
	    onExecute : function(fromTree) {
	        if (fromTree) {
	            var recordData = this.getSingleSelectedRecordData(fromTree);
	            if (recordData ) {
	                var leaf = this.selectedIsLeaf(fromTree);
	                var node = this.getRecordID(recordData, {
	                    fromTree : fromTree
	                });
	                if (leaf) {
	                    var lastIndex = node.lastIndexOf("_");
	                    var objectID = node.substring(lastIndex + 1);
	                    com.trackplus.admin.Report.executeReport(this, objectID,
	                            recordData["reportConfigNeeded"], false);
	                }
	            }
	        } else {
	            var leaf = this.selectedRecord.data.leaf;
	            var node = this.selectedRecord.data.node
	            var repConfigNeeded = this.selectedRecord.data.reportConfigNeeded;
	            if (leaf) {
	                var lastIndex = node.lastIndexOf("_");
	                var objectID = node.substring(lastIndex + 1);
	                com.trackplus.admin.Report.executeReport(this, objectID, true, false);
	            }
	        }
	    },
	    /**
		 * The localized entity name
		 */
	    getEntityLabel : function(extraConfig) {
	        var entityLabel = null;
	        var isLeaf = true;
	        if (extraConfig ) {
	            isLeaf = extraConfig.isLeaf;
	        }
	        if (isLeaf) {
	            return getText("admin.customize.reportTemplate.lbl");
	        } else {
	            return getText('admin.customize.queryFilter.lbl.category');
	        }
	    },
	    /**
		 * The label for the save button
		 */
	    getSaveLabel : function(operation) {
	        if (operation === "instant") {
	            return getText(this.btnExecute);
	        } else {
	            return getText('common.btn.save');
	        }
	    },
	    /**
		 * The url for getting the leaf detail: either this should
		 * be overridden or the leafDetailUrl should be specified in
		 * the config
		 */
	    getLeafDetailUrl : function() {
	        return this.getFolderAction() + '!leafDetail.action';
	    },
	    /**
		 * The message to appear first time after selecting this
		 * menu entry Is should be shown by selecting the root but
		 * the root is typically not visible
		 */
	    getRootMessage : function(rootID) {
	        return getText("admin.customize.reportTemplate.lbl.description");
	    },
	    getActionItemIdsWithContextDependentLabel : function() {
	        return [ "editGridRow", "editTreeNode", "deleteGridRow", "deleteTreeNode", "downloadGridRow",
	                "downloadTreeNode", "cut", "copy" ];
	    },
	    /**
		 * Gets the tree's fields
		 */
	    getTreeFields : function() {
	        return [ {
	            name : 'id',
	            mapping : 'id',
	            type : 'string'
	        }, {
	            name : 'text',
	            mapping : 'text',
	            type : 'string'
	        }, {
	            name : 'readOnly',
	            mapping : 'readOnly',
	            type : 'boolean'
	        }, {
	            name : 'modifiable',
	            mapping : 'modifiable',
	            type : 'boolean'
	        }, {
	            name : 'deletable',
	            mapping : 'deletable',
	            type : 'boolean'
	        }, {
	            name : 'canCopy',
	            mapping : 'canCopy',
	            type : 'boolean'
	        }, {
	            name : 'categoryType',
	            mapping : 'categoryType',
	            type : 'string'
	        }, {
	            name : 'treeFilter',
	            mapping : 'treeFilter',
	            type : 'boolean'
	        }, {
	            name : 'reportConfigNeeded',
	            mapping : 'reportConfigNeeded',
	            type : 'boolean'
	        }, {
	            name : 'leaf',
	            mapping : 'leaf',
	            type : 'boolean'
	        }, {
	            name : 'iconCls',
	            mapping : 'iconCls',
	            type : 'string'
	        }, {
	            name : 'canAddChild',
	            mapping : 'canAddChild',
	            type : 'boolean'
	        } ];
	    },
	    /**
		 * Get the extra parameters for the gridStore
		 */
	    getGridExtraParams : function(node, opts) {
	        return {
	            node : this.selectedNodeID
	        }
	    },
	    /**
		 * Expanding the node
		 */
	    getTreeExpandExtraParams : function(node) {
	        var extraParams = {
	            excludePrivate : this.excludePrivate
	        /*
			 * , fromIssueNavigator:this.fromIssueNavigator
			 */
	        };
	        if (this.projectID ) {
	            // in project configuration
	            extraParams["projectID"] = this.projectID;
	        }
	        return extraParams;
	    },
	    getAddFolderReportIconCls : function() {
	        return 'categoryReportAdd';
	    },
	    getAddReportIconCls : function() {
	        return 'rtemplateAdd';
	    },
	    getEditReportIconCls : function() {
	        return 'rtemplateEdit';
	    },
	    /**
		 * Initialize all actions and return the toolbar actions
		 */
	    getToolbarActions : function() {
	        return this.getReportToolbarItems();
	    },
	    /**
		 * Toolbar items for report
		 */
	    getReportToolbarItems : function() {
	        return [ this.actionAddFolder, this.actionAddLeaf, this.actionEditGridRow,
	                this.actionExecuteGridRow, this.actionDownloadGridRow, this.actionDeleteGridRow ];
	    },
	    /**
		 * Which actions to enable/disable depending on tree
		 * selection
		 */
	    getToolbarActionChangesForTreeNodeSelect : function(selectedNode) {
	        var canAddChild = false;
	        if (selectedNode ) {
	            if (this.projectID  && selectedNode.isRoot()) {
	                // after initializing the project specific
					// branch for issue filter and report:
	                // although in the filter/report tree no node is
					// selected, the add refers to the project
					// specific root
	                // (for notify filter the add methods are
					// allowed only after an explicit selection
	                // in notify filters branch, because there are
					// both the public and project (for the actual
					// project)
	                // specific notification filters so it is not
					// obvious where to add when nothing is selected
	                // selectedNode.isRoot(): after deleting a node
					// directly below root
	                canAddChild = true;
	            } else {
	                canAddChild = selectedNode.data['canAddChild'];
	            }
	        }
	        this.actionAddFolder.setDisabled(!canAddChild);
	        this.actionAddLeaf.setDisabled(!canAddChild);
	        // nothing selected in the grid
	        this.actionEditGridRow.setDisabled(true);
	        this.actionDeleteGridRow.setDisabled(true);
	        this.actionExecuteGridRow.setDisabled(true);
	        this.actionDownloadGridRow.setDisabled(true);
	        // this.actionExport.setDisabled(true);
	    },
	    getLastSelected : function(fromTree) {
	        if (fromTree) {
	            return this.getLastSelectedTreeNode();
	        } else {
	            return this.selectedRecord.data;
	        }
	    },
	    getSelection : function(fromTree) {
	        if (fromTree) {
	            return this.getTreeSelection();
	        } else {
	            return this.selectedRecords;
	        }
	    },
	    getShowGridForLeaf : function() {
	        return true;
	    },
	    selectedIsLeaf : function(fromTree) {
	        var lastSelectedRecord = this.getLastSelected(fromTree);
	        if (lastSelectedRecord ) {
	            if (fromTree) {
	                return lastSelectedRecord.isLeaf();
	            } else {
	                return lastSelectedRecord.leaf;
	            }
	        }
	        return true;
	    },
	    /**
		 * Get the refresh parameters after delete
		 */
	    getReloadParamsAfterDelete : function(selectedRecords, extraConfig, responseJson) {
	        if (selectedRecords ) {
	            // we suppose that only one selection is allowed in
				// tree
	            var selNode = selectedRecords;
	            if (selNode ) {
	                var parentNode = null;
	                var parentNodeID = null;
	                if (extraConfig ) {
	                    fromTree = extraConfig.fromTree;
	                    if (fromTree) {
		                    // delete from tree
		                    parentNode = selNode.parentNode;
		                    if (parentNode ) {
			                    parentNodeID = parentNode.data.id;
			                    // select the parent of the deleted
								// node for reload and select
			                    return {
			                        nodeIDToReload : parentNodeID,
			                        nodeIDToSelect : parentNodeID
			                    };
		                    }
	                    } else {
		                    // delete from grid: the parent is
							// selected already in tree, leave that
							// to be reloaded and selected
		                    if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
			                    // in the tree a leaf node selected
								// -> grid with a single row: the
								// parent of the selected tree node
								// should be reloaded
			                    var parentNode = this.selectedNode.parentNode;
			                    if (parentNode ) {
				                    // the parent of the edited node
									// should be reloaded
				                    return {
					                    nodeIDToReload : parentNode.data['id']
				                    }
			                    }
		                    } else {
			                    // in the tree the parent of the
								// edited grid row is selected: the
								// actually selected tree node
								// should be reloaded
			                    return {
				                    nodeIDToReload : this.selectedNode.data['id']
			                    };
		                    }
	                    }
	                }
	            }
	        }
	        return null;
	    },
	    /**
		 * Get the node to reload after save after add operation
		 */
	    /* protected */getAddReloadParamsAfterSave : function(addLeaf) {
	        if (this.selectedNode ) {
	            var leaf = this.selectedNode.data['leaf'];
	            if (leaf) {
	                // selected node is leaf: add to a leaf
	                var parentNode = this.selectedNode.parentNode;
	                if (parentNode ) {
	                    if (addLeaf) {
		                    // add leaf to a leaf -> means add
							// sibling -> the parent of the
							// selectedNode should be reloaded
		                    return {
			                    nodeIDToReload : parentNode.data['id']
		                    };
	                    } else {
		                    // add folder when a leaf is selected ->
							// add sibling to the parent's node, the
							// parent of the parent should be
							// reloaded
		                    // (from tree context menu it is not
							// possible, only from toolbar)
		                    var parentNode = parentNode.parentNode;
		                    if (parentNode ) {
			                    return {
				                    nodeIDToReload : parentNode.data['id']
			                    };
		                    }
	                    }
	                }
	            } else {
	                // selected node is folder
	                // if (addLeaf) {
	                return {
	                    nodeIDToReload : this.selectedNode.data['id']
	                };
	                /*
					 * } else { //add folder when a folder is
					 * selected var parentNode =
					 * this.selectedNode.parentNode; if
					 * (parentNode) { return {nodeIDToReload:
					 * parentNode.data['id']}; } }
					 */
	            }
	        }
	        return null;
	    },
	    /**
		 * Get the node to select after save after add operation
		 */
	    getAddSelectionAfterSaveFromResult : function() {
	        // specify nodeIDToSelect to select the added node based
			// on the 'node' field from resulting JSON,
	        // do not specify rowToSelect, do not select anything in
			// the grid after add
	        // return {parameterName:'nodeIDToSelect',
			// fieldNameFromResult:'node'};
	        return [ {
	            parameterName : 'nodeIDToSelect',
	            fieldNameFromResult : 'node'
	        }, {
	            parameterName : 'rowToSelect',
	            fieldNameFromResult : 'node'
	        } ];
	    },
	    /**
		 * Url for editing an entity We suppose that add/edit use
		 * the same edit method on server side Differentiation is
		 * made based on "node", "add" and "leaf" request parameters
		 * addFolder: "node" is the parent node, "add" is true,
		 * "leaf" is false addLeaf: "node" is the parent node, "add"
		 * is true, "leaf" is true edit: "node" is the id of the
		 * edited entity (whether it is folder or leaf is decoded
		 * based on the structure of the "node")
		 */
	    getEditUrl : function(isLeaf) {
	        return this.getNodeBaseAction({
	            isLeaf : isLeaf
	        }) + '!edit.action';
	    },
	    /**
		 * Url for saving of an entity
		 */
	    getSaveUrl : function(isLeaf) {
	        return this.getNodeBaseAction({
	            isLeaf : isLeaf
	        }) + '!save.action';
	    },
	    getEditPreSubmitProcess : function(recordData, isLeaf, add) {
	        if (isLeaf) {
	            if (this.getEditLeafPreSubmitProcess ) {
	                return this.getEditLeafPreSubmitProcess(recordData, add);
	            }
	        } else {
	            if (this.getEditFolderPreSubmitProcess ) {
	                return this.getEditFolderPreSubmitProcess(recordData, add);
	            }
	        }
	        return null;
	    },
	    /**
		 * Get the panel items recordData: the record data (for the
		 * record to be edited or added to) isLeaf: whether add a
		 * leaf or a folder add: whether it is add or edit fromTree:
		 * operations started from tree or from grid operation: the
		 * name of the operation
		 */
	    getPanelItems : function(recordData, isLeaf, add, fromTree, operation) {
	        if (isLeaf) {
	            return this.getEditLeafPanelItems(recordData, add, fromTree, operation);
	        } else {
	            return this.getEditFolderPanelItems(recordData, add, fromTree, operation);
	        }
	    },
	    /**
		 * Add extra window configuration fields by add/edit
		 * windowConfiguration argument is configured with the
		 * required fields but any already specified windowConfig
		 * field can be overridden, and further optional window
		 * options can be specified type: typically "folder" or
		 * "leaf" but for more leaf types it can be customized
		 */
	    getExtraWindowParameters : function(recordData, operation) {
	        if (operation === "addLeaf") {
	            // only by add (by edit no upload)
	            return {
	                fileUpload : true,
	                windowConfig : {
	                    minWidth : 450,
	                    minHeight : 150
	                },
	                panelConfig : {
	                    autoScroll : false
	                }
	            };
	        }
	        return null;
	    },
	    /**
		 * Prepare adding/editing a report or filter category
		 */
	    getEditFolderPanelItems : function(data, add, fromTree, operation) {
	        var modifiable = false;
	        if (add) {
	            modifiable = true;
	        } else {
	            var modifiable = data.modifiable;
	        }
	        return [ CWHF.createTextField('common.lbl.name', "label", {
	            disabled : !modifiable,
	            allowBlank : false,
	            labelWidth : this.labelWidth
	        }) ];
	    },
	    /**
		 * Prepare adding/editing a report
		 */
	    getEditLeafPanelItems : function(data, add, fromTree, operation) {
	        var modifiable = false;
	        if (add) {
	            modifiable = true;
	        } else {
	            var modifiable = data.modifiable;
	        }
	        return this.getReportItems(modifiable, add);
	    },
	    /**
		 * Prepare adding/editing a report
		 */
	    getReportItems : function(modifiable, add) {
	        var windowItems = [ CWHF.createTextField('common.lbl.name', "label", {
	            disabled : !modifiable,
	            allowBlank : false,
	            labelWidth : this.labelWidth
	        }) ];
	        if (add) {
	            windowItems.push(CWHF.createFileField('admin.customize.reportTemplate.lbl.reportFile',
	                    "reportFile", {
	                        disabled : !modifiable,
	                        allowBlank : false,
	                        labelWidth : this.labelWidth,
	                        itemId     : "reportFile"
	                    }));
	        }
	        return windowItems;
	    },
	    /**
		 * Gets the base action depending on the rootID
		 */
	    getEditWidth : function(recordData, isLeaf, add, fromTree, operation) {
	        if (isLeaf) {
	            return this.reportEditWidth;
	        } else {
	            return this.folderEditWidth;
	        }
	    },
	    /**
		 * Gets the base action depending on the rootID
		 */
	    getEditHeight : function(recordData, isLeaf, add, fromTree, operation) {
	        if (isLeaf) {
	            return this.reportEditHeight;
	        } else {
	            return this.folderEditHeight;
	        }
	    },
	    /**
		 * Get the node to reload after save after edit operation
		 */
	    getEditReloadParamsAfterSave : function(fromTree) {
	        if (this.selectedNode ) {
	            if (fromTree) {
	                // edited/copied from tree
	                var parentNode = this.selectedNode.parentNode;
	                if (parentNode ) {
	                    // the parent of the edited node should be
						// reloaded
	                    return {
		                    nodeIDToReload : parentNode.data['id']
	                    }
	                }
	            } else {
	                if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
	                    // in the tree a leaf node selected -> grid
						// with a single row: the parent of the
						// selected tree node should be reloaded
	                    var parentNode = this.selectedNode.parentNode;
	                    if (parentNode ) {
		                    // the parent of the edited node should
							// be reloaded
		                    return {
			                    nodeIDToReload : parentNode.data['id']
		                    }
	                    }
	                } else {
	                    // in the tree the parent of the edited grid
						// row is selected: the actually selected
						// tree node should be reloaded
	                    return {
		                    nodeIDToReload : this.selectedNode.node
	                    };
	                }
	            }
	        }
	        return null;
	    },
	    /**
		 * Get the actions available in context menu depending on
		 * the currently selected row
		 *
		 */
	    getGridContextMenuActions : function(selectedRecord, selectionIsSimple) {
	        var modifiable = selectedRecord.data['modifiable'];
	        var leaf = selectedRecord.data.leaf;
	        var actions = [];
	        if (leaf) {
	            // leaf
	            if (modifiable) {
	                actions.push(this.actionEditGridRow);
	            }
	            actions.push(this.actionExecuteGridRow);
	            actions.push(this.actionDownloadGridRow);
	        } else {
	            // branch
	            if (modifiable) {
	                actions.push(this.actionEditGridRow);
	            }
	        }
	        return actions;
	    },
	    /**
		 * Get the actions available in context menu depending on
		 * the currently selected row
		 *
		 */
	    getTreeContextMenuActions : function(selectedRecord, selectionIsSimple) {
	        var modifiable = selectedRecord.data['modifiable'];
	        var deletable = selectedRecord.data['deletable'];
	        var canAddChild = selectedRecord.data['canAddChild'];
	        var canCopy = selectedRecord.data['canCopy'];
	        var leaf = selectedRecord.data['leaf'];
	        var actions = [];
	        if (selectionIsSimple) {
	            if (canAddChild) {
	                if (!leaf) {
	                    actions.push(this.actionAddFolder);
	                }
	                actions.push(this.actionAddLeaf);
	            }
	            if (modifiable) {
	                actions.push(this.actionEditTreeNode);
	            }
	            if (leaf) {
	                actions.push(this.actionExecuteTreeNode);
	                actions.push(this.actionDownloadTreeNode);
	            }
	        } else {
	            actions = [];
	        }
	        if (this.useCopyPaste) {
	            if (canCopy) {
	                if (modifiable) {
	                    actions.push(this.actionCutTreeNode);
	                }
	                actions.push(this.actionCopyTreeNode);
	            }
	            if (canAddChild && this.cutCopyNode ) {
	                actions.push(this.actionPasteTreeNode);
	            }
	        }
	        if (deletable) {
	            actions.push(this.actionDeleteTreeNode);
	        }
	        return actions;
	    },
	    /**
		 * Get the context menu actions either for grid or for tree
		 */
	    getContextMenuActions : function(selectedRecords, selectionIsSimple, fromTree) {
	        if (fromTree) {
	            return this.getTreeContextMenuActions(selectedRecords, selectionIsSimple);
	        } else {
	            return this.getGridContextMenuActions(selectedRecords, selectionIsSimple);
	        }
	    },
	    /**
		 * Helper for preparing the params get the ID based on the
		 * record and extra config
		 */
	    getRecordID : function(recordData, extraConfig) {
	        var fromTree = null;
	        if (extraConfig ) {
	            fromTree = extraConfig.fromTree;
	        }
	        if (fromTree) {
	            return recordData['id'];
	        } else {
	            return recordData['node'];
	        }
	    },
	    canDragDropNode : function(nodeToDrag, copy, overModel) {
	        if (nodeToDrag.data['readOnly']) {
	            // do not drag hardcoded node
	            return false;
	        }
	        if (!nodeToDrag.data['modifiable'] && !copy) {
	            // do not move a not modifiable node
	            return false;
	        }
	        var dropOverNode = overModel;
	        var overLeaf = dropOverNode.isLeaf();
	        if (overLeaf) {
	            dropOverNode = dropOverNode.parentNode;
	        }
	        if (!dropOverNode.data['canAddChild']) {
	            // do not drop in a node with nor right to add child
	            return false;
	        }
	        return true;
	    },
	    getDragDropBaseAction : function(draggedNodeIsLeaf) {
	        return this.getFolderAction();
	    },
	    /**
		 * Paste a node in the tree after copy/cut
		 */
	    onDropDataViewNode : function(nodeFrom, nodeTo, copy) {
	        var me = this;
	        var isLeaf = nodeFrom.data.leaf;// this.selectedIsLeaf(nodeFrom);
	        var strutsBaseAction = this.getDragDropBaseAction(isLeaf);
	        Ext.Ajax.request({
	            fromCenterPanel : true,
	            url : strutsBaseAction + '!copy.action',
	            params : {
	                nodeFrom : nodeFrom.data["id"],
	                nodeTo : nodeTo.data["id"],
	                copy : copy
	            },
	            scope : this,
	            disableCaching : true,
	            success : function(response) {
	                var responseJson = Ext.decode(response.responseText);
	                if (responseJson.success === true) {
	                    me.reload({
	                        nodeIDToReload : nodeTo.data["id"],
	                        nodeIDToSelect : nodeTo.data["id"]
	                    });
	                } else {
	                    if (responseJson.errorMessage ) {
	                        // no right to delete
	                        Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage)
	                    }
	                }
	            },
	            failure : function(result) {
	                Ext.MessageBox.alert(this.failureTitle, result.responseText)
	            },
	            method : "POST"
	        });
	    },
	    isTreeSplitOn: function() {
	    	return false;
	    }
	});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.admin.Report = function() {
};
/**
 * Whether the filter contains extra parameter(s) beyond basic datasource
 */
com.trackplus.admin.Report.executeReport = function(scope, templateID, reportConfigNeeded, fromIssueNavigator, workItemIDs, projectID, dashboardID) {
	if (!reportConfigNeeded) {
		var url = 'reportDatasource.action?templateID='+templateID;
		if (fromIssueNavigator) {
			url = url+"&fromIssueNavigator="+fromIssueNavigator;
		}
		if (workItemIDs) {
			url = url+ "&workItemIDs="+workItemIDs;
		}
		if (projectID) {
			url = url+ "&projectID="+projectID;
		}
		if (dashboardID) {
			url = url+ "&dashboardID="+dashboardID;
		}
		window.open(url);
	} else {
		params = {templateID: templateID};
		if (fromIssueNavigator) {
			params["fromIssueNavigator"]=fromIssueNavigator;
		}
		if (workItemIDs) {
			params["workItemIDs"]=workItemIDs;
		}
		if (projectID) {
			params["projectID"]=projectID;
		}
		if (dashboardID) {
			params["dashboardID"]=dashboardID;
		}
		Ext.Ajax.request({
			url: 'reportDatasource!configPage.action',
			params: params,
			scope: scope,
			disableCaching:true,
			success: function(response){
				var data = Ext.decode(response.responseText);
				var configClass = data["configClass"];
				//show the xml datasource button only from report configuration (not when coming from issue navigator)
				var implementSerialization = !fromIssueNavigator && data["implementSerialization"];
				var configData = data["configData"];
				var configForm = Ext.create(configClass, configData);
				com.trackplus.admin.Report.showConfigPage(scope, templateID, configForm, implementSerialization);
			},
			failure: function(result){
				Ext.MessageBox.alert(scope.failureTitle, result.responseText);
			},
			method:"POST"
		});
	}
};
/**
 * Render the report datasource parameters
 */
com.trackplus.admin.Report.showConfigPage = function(scope, templateID, configForm, implementSerialization) {
	//var loadUrl = 'reportDatasource!getConfigPage.action';
	//var loadUrlParams = {templateID: reportID};
	//do not use getForm().load() because the form class to instantiate is specified with the form data in the same JSON result
	//getForm().load() could be used with two AJAX requests: first get the form name and instantiate then getForm().load()
	//this does not worth because then postDataProcess() should be called (like loading the combos)
	//which in this case can be made directly because data is available in the correspondingly initialized JSON result
	var load = {loadHandler:com.trackplus.admin.Report.loadConfigPage};
	var submitUrl = 'reportDatasource.action';
	var submitUrlParams = {
		templateID:templateID
	};
	var submitMessage=getText("admin.customize.reportTemplate.msg.waitForReportCreate");
	var submitExecute = {standardSubmit:true, submitUrl:submitUrl, submitUrlParams:submitUrlParams, submitButtonText:getText('common.btn.executeReport'),submitMessage:submitMessage};
	if (implementSerialization) {
		var submitDatasource = {standardSubmit:true, submitUrl:"reportDatasource!serializeDatasource.action",
				submitUrlParams:submitUrlParams, submitButtonText:getText('common.btn.XML'),
				submitMessage:submitMessage};
		submit = [submitExecute, submitDatasource];
	} else {
		submit = submitExecute;
	}
	var windowParameters = {title:getText("admin.customize.reportTemplate.lbl.configure"),
			width:450,
			height:450,
			load: load,
			submit: submit,
			cancelButtonText: getText('common.btn.done'),
			formPanel: configForm};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(scope);
};
/**
 * Empty (but not null) function to avoid the calling of getForm().load() in windowConfig
 */
com.trackplus.admin.Report.loadConfigPage = function() {
};
/**
 * Executes a report from issue navigator: first choose report then render configuration (if needed)
 */
com.trackplus.admin.Report.executeReportFromIssueNavigator=function(workItemIDs) {
	var reportPicker = CWHF.createSingleTreePicker("admin.customize.reportTemplate.lblAlone",
	    "templateID", [], null,
	    {allowBlank:false,
	     labelWidth:100,
	     itemId: 'templateID'
	    });
	var load = {loadUrl:"reportDatasource!chooseReport.action"};
	var submitUrlParams = {
			fromIssueNavigator:true,
			workItemIDs: workItemIDs
		};
	var submit = {standardSubmit:true, submitUrlParams:submitUrlParams,
			submitButtonText:getText('common.btn.executeReport'),
			submitHandler:com.trackplus.admin.Report.submitReport};
	var windowParameters = {title:getText("admin.customize.reportTemplate.lbl.choose"),
			width:500,
			height:120,
	        load: load,
			submit: submit,
	        postDataProcess:com.trackplus.admin.Report.postDataProcess,
			items: [reportPicker]};
	var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
	windowConfig.showWindowByConfig(this);
};
com.trackplus.admin.Report.postDataProcess = function(data, formPanel) {
	var reportPicker = formPanel.getComponent("templateID");
	if (reportPicker) {
	    reportPicker.updateMyOptions(data["categoryTree"]);
	    reportPicker.setValue(data["templateID"]);
	}
};
com.trackplus.admin.Report.submitReport = function(window, submitUrl, submitUrlParams) {
	var theForm = this.formEdit;
	var templateID = theForm.getComponent("templateID").getSubmitValue();
	if (templateID) {
		Ext.Ajax.request({
			url: 'reportDatasource!hasDatasourcePlugin.action',
			params: {templateID:templateID},
			scope: this,
			disableCaching:true,
			success: function(response){
				var data = Ext.decode(response.responseText);
				var reportConfigNeeded = data["value"];
				com.trackplus.admin.Report.executeReport(this, templateID, reportConfigNeeded, true, submitUrlParams.workItemIDs);
			},
			failure: function(result){
				Ext.MessageBox.alert(scope.failureTitle, result.responseText);
			},
			method:"POST"
		});
		window.close();
	}
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ReportConfigLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	reportsConfig:null,
	selectedGroup:'reports',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		var fromIssueNavigator=me.initData.fromIssueNavigator;
		me.borderLayoutController.setHelpContext("reportConfig");
		me.reportsConfig=Ext.create('com.trackplus.admin.customize.ReportConfig',{
			rootID: 'report',
			fromIssueNavigator: fromIssueNavigator,
			repCfgLayout: me
		});
		me.onReady(function(){
			var data=me.initData;
			me.borderLayoutController.setActiveToolbarList(me.reportsConfig.getToolbarActions());
		});
	},
	createCenterPanel:function(){
		var me=this;
		if(CWHF.isNull(me.reportsConfig.centerPanel)){
			me.reportsConfig.createCenterPanel();
		}
		return me.reportsConfig.centerPanel;
	},
	createWestPanel:function(){
		var me=this;
		if(CWHF.isNull(me.reportsConfig.tree)){
			me.reportsConfig.createCenterPanel();
		}
		me.reportsConfig.tree.addCls('westTreeNavigator');
		Ext.apply(me.reportsConfig.tree,{'split':true,collapseMode : 'mini'});
		return me.reportsConfig.tree;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('GeneralLearning.ux.VerticalHeader', {
	alias: 'plugin.verticalheader',
	grid: null,
	extraCfg:null,
	textMetric: null,
	init: function (grid) {
		var me = this;
		me.grid = grid;
		me.grid.addCls('v-vertical-header-grid');
		me.textMetric = new Ext.util.TextMetrics();
		if (me.isLocked()) {
			var normalGridPlugin = Ext.create('GeneralLearning.ux.VerticalHeader',me.extraCfg),
				lockedGridPlugin = Ext.create('GeneralLearning.ux.VerticalHeader',me.extraCfg);
			normalGridPlugin.init(me.grid.normalGrid);
			lockedGridPlugin.init(me.grid.lockedGrid);
			me.grid.normalGrid.plugins.push(normalGridPlugin);
			me.grid.lockedGrid.plugins.push(lockedGridPlugin);
		} else {
			me.grid.on({
				afterrender:{
					scope: me,
					fn: me.handleAfterLayout
				},
				afterlayout: {
					scope: me,
					fn: me.handleAfterLayout
				}
			});
		}
	},
	constructor: function (cfg) {
		var me = this;
		me.extraCfg = cfg;
		Ext.apply(this, cfg);
		me.callParent(arguments);
	},
	handleAfterLayout: function (cmp) {
		var me = this,
			maxWidth = 0,
			headerItems = cmp.headerCt.items,
			curremtWidth;
		headerItems.each(function (item) {
			if ((curremtWidth = me.textMetric.getWidth(item.text)) > maxWidth) {
				maxWidth = curremtWidth + 10;
			}
		});
		cmp.headerCt.el.select('.x-column-header-text').each(function (el) {
			el.setSize(maxWidth, maxWidth);
		});
	},
	isLocked: function () {
		var me = this;
		return me.grid.normalGrid && me.grid.lockedGrid;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.linking.LinkingController', {
	extend: 'Ext.Base',
	config: {
		model: {}
	},
	view: null,
	constructor: function (config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	createView: function () {
		var me = this;
		if (CWHF.isNull(me.view)) {
			me.view=Ext.create('com.trackplus.linking.LinkingView',{
				model:me.model
			});
		}
		return me.view;
	}
});
Ext.define('com.trackplus.linking.LinkingView', {
	extend: 'Ext.panel.Panel',
	config: {
		model: {}
	},
	border: false,
	layout: 'border',
	cls:'linking',
	northPanel:null,
	centerPanel:null,
	readOnly:false,
	initComponent: function () {
		var me = this;
		me.items = me.createChildren();
		me.callParent();
	},
	createChildren: function () {
		var me = this;
		me.createNorthPanel();
		me.centerPanel=Ext.create('Ext.panel.Panel',{
			region:'center',
			layout:'fit',
			html:'....'
		});
		return [me.northPanel,me.centerPanel];
	},
	createNorthPanel:function(){
		var me = this;
		var columnFilterID = me.model['columnFilterID'];
		var rowFilterID = me.model['rowFilterID'];
		var linkTypeWithDirection = me.model['linkTypeWithDirection'];
		var columnFilterTree = me.model["columnFilterTree"];
		var rowFilterTree = me.model["rowFilterTree"];
		me.cmbColumFilter = CWHF.createSingleTreePicker(null, "columnFilterID", columnFilterTree, columnFilterID);
		var radioColumnItems = CWHF.getRadioButtonItems(me.model["linkFlags"],
				"columnLinkedFlag", "id", "label", me.model["columnLinkedFlag"], false, false);
		me.radioColumnGroup = CWHF.getRadioGroup("linking.lbl.columnLinkedFlag", 600, radioColumnItems, {labelWidth:150});
		var columnPanel = Ext.create('Ext.form.FieldContainer', {
	        fieldLabel : getText('linking.lbl.columnFilter'),
	        labelWidth : 150,
	        labelAlign : "right",
	        labelStyle : {
		        overflow : 'hidden'
	        },
	        layout : 'hbox',
	        items : [ me.cmbColumFilter, me.radioColumnGroup ]
	    });
		me.cmbRowFilter = CWHF.createSingleTreePicker(null, "rowFilterID", rowFilterTree, rowFilterID);
		var radioRowItems = CWHF.getRadioButtonItems(me.model["linkFlags"],
				"rowLinkedFlag", "id", "label", me.model["rowLinkedFlag"], false, false);
		me.radioRowGroup = CWHF.getRadioGroup("linking.lbl.rowLinkedFlag", 600, radioRowItems, {labelWidth:150});
		var rowPanel = Ext.create('Ext.form.FieldContainer', {
	        fieldLabel : getText('linking.lbl.rowFilter'),
	        labelWidth : 150,
	        labelAlign : "right",
	        labelStyle : {
		        overflow : 'hidden'
	        },
	        layout : 'hbox',
	        items : [ me.cmbRowFilter, me.radioRowGroup ]
	    });
		me.cmbLinkType = CWHF.createCombo("linking.lbl.linkType", "linkTypeWithDirection",
			{labelWidth:150, width:500, idType:"string", allowBlank:false});
		me.cmbLinkType.store.loadData(me.model["linkTypesList"],false);
		me.cmbLinkType.setValue(linkTypeWithDirection);
		me.btnApply=Ext.create('Ext.button.Button', {
			overflowText: getText('linking.lbl.search'),
			text:getText('linking.lbl.search'),
			margin:'5 5 5 155',
			//iconCls: 'itemAction_downward16',
			//cls:'toolbarItemAction-noText',
			handler: me.applyHandler,
			scope: me
		});
		me.northPanel=Ext.create('Ext.panel.Panel',{
			layout:'anchor',
			region:'north',
			border:false,
			margin:'10 0 5 0',
			bodyBorder:false,
			items:[rowPanel, columnPanel, me.cmbLinkType, me.btnApply]
		});
	},
	applyHandler:function(){
		var me=this;
		var columnFilterID=me.cmbColumFilter.getValue();
		var columnLinkedFlag = CWHF.getSelectedRadioButtonValue(me.radioColumnGroup);
		var rowFilterID=me.cmbRowFilter.getValue();
		var rowLinkedFlag = CWHF.getSelectedRadioButtonValue(me.radioRowGroup);
		var linkTypeWithDirection=me.cmbLinkType.getValue();
		if(CWHF.isNull(columnFilterID)||CWHF.isNull(rowFilterID)){
			return false;
		}
		var urlStr="linking!search.action";
		borderLayout.setLoading(true);
		me.linkTypeWithDirection=linkTypeWithDirection;
		Ext.Ajax.request({
			url: urlStr,
			params:{
				columnFilterID:columnFilterID,
				columnLinkedFlag:columnLinkedFlag,
				rowFilterID:rowFilterID,
				rowLinkedFlag:rowLinkedFlag,
				linkTypeWithDirection:linkTypeWithDirection
			},
			disableCaching:true,
			success: function(response){
				var dataAJAX=Ext.decode(response.responseText);
				me.emptyCols=null;
				if(dataAJAX.success===true){
					var itemsRows=dataAJAX.data.itemsRows
					var itemsColumns=dataAJAX.data.itemsColumns;
					var links=dataAJAX.data.links;
					var linksDescription=dataAJAX.data.linksDescription;
					var data=new Array();
					var emptyRows=new Array();
					var emptyCols=new Array();
					me.readOnly=dataAJAX.data.readOnly;
					for(var i=0;i<itemsRows.length;i++){
						var row=new Object();
						row['f']=itemsRows[i].title;
						row['id']=itemsRows[i].id;
						row['workItemID']=itemsRows[i].objectID;
						var hasLinks=false;
						if(links) {
							for (var j = 0; j < itemsColumns.length; j++) {
								var rowData = '';
								var key = itemsRows[i].objectID + '_' + itemsColumns[j].objectID;
								if (links[key] ) {
									rowData = links[key];
									hasLinks=true;
								}
								row['f' + itemsColumns[j].objectID] = rowData;
								var found=false;
								for(var x in links){
									if(x.indexOf('_'+itemsColumns[j].objectID)!==-1){
										found=true;
									}
								}
								if(found===false){
									emptyCols.push(j);
								}
							}
						}
						if(hasLinks===false){
							emptyRows.push(itemsRows[i].objectID);
						}
						data.push(row);
					}
					var model={
						itemsColumns:itemsColumns,
						itemsRows:itemsRows,
						linksDescription:linksDescription,
						data:data
					};
					me.emptyRows=emptyRows;
					me.emptyCols=emptyCols;
					me.createGrid(model);
					me.centerPanel.removeAll(true);
					me.centerPanel.add(me.gridView);
					borderLayout.setLoading(false);
				}else{
					me.centerPanel.removeAll(true);
					var  message=dataAJAX.errorMessage;
					if(message==='tooManyItems'){
						message=getText('itemov.err.tooManyItems');
					}
					var pan=Ext.create('Ext.Component',{
						html:message,
						border:false,
						cls:'infoBox1'
					});
					me.centerPanel.add(pan);
					borderLayout.setLoading(false);
				}
			},
			failure: function(){
				borderLayout.setLoading(false);
				CWHF.showMsgError('Failure');
			},
			method:'POST'
		});
	},
	createGrid:function(model){
		var me=this;
		var itemsColumns=model.itemsColumns;
		me.itemsColumns=itemsColumns;
		var fields=me.createFields(itemsColumns);
		var store=Ext.create('Ext.data.Store',{
			fields:fields,
			data:model.data
		});
		me.gridView=Ext.create('Ext.grid.Panel',{
			margins: '0 0 0 0',
			border:false,
			bodyBorder:false,
			columnLines :true,
			cls:'linkingGrid simpleGridView gridNoBorder',
			viewConfig: {
				stripeRows: true
			},
			store:store,
			columns:me.createColumnModel(model),
			plugins:[Ext.create('GeneralLearning.ux.VerticalHeader',{})]
		});
		me.gridView.addListener('cellcontextmenu',me.onCellContextMenu,me);
		me.gridView.addListener('celldblclick',me.onItemDblClick,me);
		return me.gridView;
	},
	createFields:function(itemsColumns){
		var me=this;
		var fields=new Array();
		fields.push({name:'f'});
		fields.push({name:'id'});
		fields.push({name:'workItemID',type:'int',allowNull:true});
		if(itemsColumns){
			for(var i=0;i<itemsColumns.length;i++){
				fields.push({name:'f'+itemsColumns[i].objectID});
			}
		}
		return fields;
	},
	createColumnModel:function(model){
		var me=this;
		var itemsColumns=model.itemsColumns;
		var columnModel=new Array();
		columnModel.push(Ext.create('Ext.grid.column.Column',{
			header:'',
			draggable :false,
			menuDisabled:true,
			sortable:false,
			width:200,
			dataIndex:'f',
			locked:true,
			resizable:true,
			renderer:function(value,metaData,record,rowIndex,colIndex,store,view){
				var tooltip=record.data.id+"<b> : </b>"+record.data.f;
				metaData.tdAttr = 'data-qtip="' + tooltip+ '"';
				return value;
			}
		}));
		for(var i=0;i<itemsColumns.length;i++){
			var item=itemsColumns[i];
			var header=item.title;
			if(header.length>17){
				header=header.substring(0,17)+"...";
			}
			var col=Ext.create('Ext.grid.column.Column',{
				text:header,
				tooltip :item.id+"<B> : </B>"+ item.title,
				draggable :false,
				menuDisabled:true,
				sortable:false,
				width:25,
				dataIndex:'f'+item.objectID,
				resizable:false,
				align:'center',
				renderer:function(value,metaData,record,rowIndex,colIndex,store,view){
					if(colIndex===0){
						if(me.emptyRows){
							var workItemID=record.data.workItemID;
							if(Ext.Array.contains(me.emptyRows, workItemID)){
								metaData.tdCls = 'linkingEmptyRow';
							}
						}
					}
					if(rowIndex===0){
						if(me.emptyCols){
							if(Ext.Array.contains(me.emptyCols, colIndex)){
								metaData.tdCls =metaData.tdCls+ ' linkingEmptyCol';
							}
						}
					}
					if(value&&value!=='') {
						var imgName = "arrow_bent.png";
						var tooltip=model.linksDescription[value];
						if(tooltip){
							metaData.tdAttr = 'data-qtip="' + tooltip+ '"';
						}
						metaData.tdCls =metaData.tdCls+ ' linkingCell';
						return '<img src="' + com.trackplus.TrackplusConfig.icon16Path + imgName + '">';
					}
					return value;
				}
			});
			columnModel.push(col);
		}
		return columnModel;
	},
	onCellContextMenu:function(gridView,td, cellIndex, record, tr, rowIndex, e, eOpts){
		var me=this;
		var workItemID=record.data.workItemID;
		if(workItemID&&workItemID!==-1){
			me.lastTDOriginaClass=td.className;
			td.className = td.className + " linkCellFocus";
			me.lastTD=td;
			var popupMenu=me.createPopupCell(record.data,gridView,cellIndex);
			if(popupMenu){
				popupMenu.addListener('hide',function(){
					me.lastTD.className=me.lastTDOriginaClass;
				})
				popupMenu.showAt(e.getXY());
			}
		}
		e.stopEvent();
		return true;
	},
	onItemDblClick:function(view, td,cellIndex,record, tr, rowIndex,e){
		var me=this;
		var workItemID=record.data.workItemID;
		if(workItemID&&workItemID!==-1){
			var me=this;
			var actionID=-2;//PRINT
			var itemAction=Ext.create('com.trackplus.item.ItemActionDialog',{
				workItemID:workItemID,
				actionID:actionID,
				parentID:null,
				//successHandler:me.itemActionSuccessHandler,
				//scope:me,
				modal:false/*,
				navigatorHandler:me.navigatorHandler,
				navigatorScope:me*/
			});
			itemAction.execute.call(itemAction);
		}
	},
	createPopupCell:function(rowData,grid,cellIndex){
		var me=this;
		if(me.popupMenu){
			me.popupMenu.destroy();
			me.popupMenu=null;
			delete me.popupMenu;
		}
		me.popupMenu = Ext.create('Ext.menu.Menu',{
			floating:true,
			items:me.getPopupMenuItems.call(me,rowData,grid,cellIndex),
			closeAction:'destroy'
		});
		return me.popupMenu;
	},
	getPopupMenuItems:function(rowData,grid,cellIndex){
		var me=this;
		var workItemID=rowData.workItemID;
		var targetWorkItemID=me.itemsColumns[cellIndex].objectID;
		var linkData=rowData['f'+targetWorkItemID];
		var items=[];
		var editable=rowData["editable"];
		var linkable=rowData["linkable"];
		if(!me.readOnly){
			if(CWHF.isNull(linkData)||linkData==='') {
				items.push({
					text: getText('common.btn.addLink'),
					iconCls: 'links16',
					handler: function () {
						borderLayout.setLoading(true);
						var urlStr = 'itemLink!saveItemLink.action';
						var params = {
							linkTypeWithDirection: me.linkTypeWithDirection,
							linkedWorkItemID: targetWorkItemID,
							workItemID: workItemID
						}
						Ext.Ajax.request({
							url: urlStr,
							params: params,
							success: function (response) {
								borderLayout.setLoading(false);
								var data=Ext.decode(response.responseText);
								if(data.success===true){
									me.applyHandler();
								} else {
									var errors = data.errors;
									if (errors) {
										linkedWorkItemTitle = errors.linkedWorkItemTitle;
										if (linkedWorkItemTitle) {
											Ext.MessageBox.show({
												title: getText('common.err.failure'),
												msg: linkedWorkItemTitle,
												buttons: Ext.Msg.OK,
												icon: Ext.MessageBox.ERROR
											});
										}
									}
								}
							},
							failure: function (response) {
								borderLayout.setLoading(false);
							}
						});
					}
				});
			}else{
				items.push({
					text: getText('common.btn.delete'),
					iconCls: 'delete16',
					handler: function () {
						borderLayout.setLoading(true);
						var urlStr = 'itemLink!deleteLinks.action';
						var params = {
							deletedItems:linkData,
							workItemID: workItemID
						}
						Ext.Ajax.request({
							url: urlStr,
							params: params,
							success: function (response) {
								borderLayout.setLoading(false);
								me.applyHandler();
							},
							failure: function (response) {
								borderLayout.setLoading(false);
							}
						});
					}
				});
			}
			items.push('-');
		}
		items.push({
			text: getText('item.action.viewInNewTab'),
			iconCls:'itemAction_viewAll16',
			handler: function(){
				var urlStr='printItem.action?key='+workItemID;
				window.open(urlStr,'printItem'+workItemID);
			}
		});
		return items;
	}
});
Ext.define('com.trackplus.layout.LinkingLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	selectedGroup:'linking',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("linking");
	},
	createCenterPanel:function(){
		var me=this;
		var  linkingController=Ext.create('com.trackplus.linking.LinkingController',{
			model:me.initData
		});
		return linkingController.createView();
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.CustomFrameLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.selectedGroup=me.initData.pluginID;
		me.borderLayoutController.setHelpContext("customFrame");
		me.onReady(function(){
			var data=me.initData;
		});
	},
	createCenterPanel:function(){
		var me=this;
		var url=me.initData.url;
		var cmp= {
			xtype:'component',
			border:false,
			autoEl : {
				tag : "iframe",
				src : url
			}
		};
		document.title=me.initData.title;
		return cmp;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.DeleteController',{
	extend:'Ext.Base',
	config: {},
	/**
	 * Whether by deleting an entity should be asked for a confirmation, independently of any dependency
	 */
	confirmDeleteEntity:true,
	/**
	 * Whether to ask for extra confirmation if the entity to be deleted has dependencies
	 */
	confirmDeleteNotEmpty:false,
	/**
	 * Whether the deletion of a not empty entity was already confirmed
	 * This is also the name of the request parameter
	 * Makes sense only if confirmDeleteNotEmpty is true
	 */
	deleteConfirmed:false,
	/**
	 * Width of the replacement window
	 */
	replacementWidth: 500,
	/**
	 * Height of the replacement window
	 */
	replacementHeight: 200,
	ERROR_CODE_NEED_REPLACE: 1,
	NOT_EMPTY_WARNING: 3,
	constructor: function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	/**
	 * The title for a failure message
	 */
	failureTitle:getText('common.err.failure'),
	/**
	 * Creates a context menu based on an array of actions
	 */
	/*public*/createContextMenu: function(record, actions) {
		var contextMenu = new Ext.menu.Menu({
			items: []
		});
		if (actions) {
			for(var i=0;i<actions.length;i++){
				var action=actions[i];
				if (action) {
					var contextMenuItemCfg = {
						text:action.getText(),
						iconCls:action.getIconCls()+"16",
						//scope is the viewController
						scope:this,
						//Ext.Action does not have tooltip field: take from initialConfig
						tooltip:action.initialConfig.tooltip,
						//the handler is not the name as in view but the function object from the viewController
						handler: this[action.initialConfig.handler],
						itemId: action.itemId};
					contextMenu.add(contextMenuItemCfg);
					if (action.itemId) {
						var contextMenuItem = contextMenu.getComponent(action.itemId);
						contextMenuItem.tooltipKey = action.initialConfig.tooltipKey;
					}
				}
			}
		}
		return contextMenu;
	},
	/**********************************************label, tooltip, icon values***********************************************/
	/**
	 * The iconCls for the add button
	 */
	/*protected*/getAddIconCls: function() {
		return 'add';
	},
	/**
	 * The key for "add" button text
	 */
	/*protected*/getAddButtonKey: function() {
		return 'common.btn.add';
	},
	/**
	 * The title for "add" popup and "add" action tooltip
	 */
	/*protected*/getAddTitleKey: function() {
		return 'common.lbl.add';
	},
	/**
	 * The iconCls for the edit button
	 */
	/*protected*/getEditIconCls: function() {
		return 'edit';
	},
	/**
	 * The key for "edit" button text
	 */
	/*protected*/getEditButtonKey: function() {
		return 'common.btn.edit';
	},
	/**
	 * The title for "edit" popup and "edit" action tooltip
	 */
	/*protected*/getEditTitleKey: function() {
		return 'common.lbl.edit';
	},
	/**
	 * The iconCls for the copy button
	 */
	/*protected*/getCopyIconCls: function() {
		return 'copy';
	},
	/**
	 * The key for "copy" button text
	 */
	/*protected*/getCopyButtonKey: function() {
		return 'common.btn.copy';
	},
	/**
	 * The title for "copy" popup and "copy" action tooltip
	 */
	/*protected*/getCopyTitleKey: function() {
		return 'common.lbl.copy';
	},
	/**
	 * The iconCls for the delete button
	 */
	/*protected*/getDeleteIconCls: function() {
		return 'delete';
	},
	/**
	 * The key for "delete" button text
	 */
	/*protected*/getDeleteButtonKey: function() {
		return 'common.btn.delete';
	},
	/**
	 * The title for "delete" popup and "delete" action tooltip
	 */
	/*protected*/getDeleteTitleKey: function() {
		return 'common.lbl.delete';
	},
	/**
	 * The delete confirmation text (if it will be asked for confirmation)
	 */
	/*protected*/getRemoveWarningKey: function() {
		return 'common.lbl.removeWarning';
	},
	/*protected*/getReplacementKey: function() {
		return 'common.lbl.replacement';
	},
	/**
	 * Parameters for reloading after a delete operation
	 * By delete the reload and select parameters are known before
	 */
	/*protected abstract*/getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		return responseJson;
	},
	/**
	 * The struts action for delete/replace
	 */
	/*protected*/getDeleteUrlBase: function(extraConfig) {
		return this.getNodeBaseAction(extraConfig);
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getDeleteUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!delete.action';
	},
	/**
	 * Parameter name for the submitted id(s) by delete
	 * If allowMultipleSelections===false then the same this.entityID (simple grid) or
	 * 	node (tree with grid) can be used on the server side for both delete and edit submits
	 * If allowMultipleSelections===true this should return another name
	 * 	the submitted value will be stored on the server typically
	 * 	in an Integer[] (simple grid) or String[] (tree with grid) variable
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 * Must be overridden if allowMultipleSelections===true
	 */
	/*protected abstract*/getDeleteParamName: function(extraConfig) {
		return this.entityID;
	},
	/**
	 * Parameters for deleting entity
	 * recordData: the selected entity data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getDeleteParams: function(selectedRecords, extraConfig) {
		var params=new Object();
		var selectionParam = this.getSelectedIDs(selectedRecords, extraConfig);
		params[this.getDeleteParamName(extraConfig)]=selectionParam;
		if (this.confirmDeleteNotEmpty) {
			params['deleteConfirmed'] = this.deleteConfirmed;
		}
		return params;
	},
	/**
	 * Url for preparing the replacement data rendering
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getRenderReplaceUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!renderReplace.action';
	},
	/**
	 * Parameters for preparing the replacement data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getRenderReplaceParams: function(selectedRecords, extraConfig) {
		return this.getDeleteParams(selectedRecords, extraConfig);
	},
	/**
	 * Url for replacing and deleting of an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getReplaceAndDeleteUrl: function(extraConfig){
		return this.getDeleteUrlBase(extraConfig)+'!replaceAndDelete.action';
	},
	/**
	 * Parameters for replacing and deleting of an entity
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected*/getReplaceAndDeleteParams: function(selectedRecords, extraConfig) {
		return this.getDeleteParams(selectedRecords, extraConfig);
	},
	/**
	 * The label for the delete button
	 */
	/*protected*/getDeleteLabel: function() {
		return getText('common.btn.delete');
	},
	/************************************delete related fields ***************************************/
	/**
	 * The localized entity name to be deleted
	 * Should be implemented only if differs from entity name
	 * (for example in field configuration: entity label is "field configuration" but delete label is "field")
	 */
	/*protected*//*getDeleteEntityLabel:function(extraConfig) {
		return this.getEntityLabel(extraConfig);
	},*/
	/**
	 * The a message patameterized with the deleteEntityLabel
	 */
	getMessage: function(titleKey, entityLabel) {
		return getText(titleKey, entityLabel);
	},
	/**
	 * Handler for deleting the selected data.
	 * It can be single or multiple selection
	 * title:
	 */
	/*private*/deleteHandler: function(entityLabel, selectedRecords, extraConfig){
		var me=this;
		if (CWHF.isNull(selectedRecords)) {
			return true;
		}
		this.deleteConfirmed = false;
		if (me.confirmDeleteEntity) {
			Ext.MessageBox.confirm(me.getMessage(me.getDeleteTitleKey(), entityLabel),
				me.getMessage(me.getRemoveWarningKey(), entityLabel),
					function(btn){
						if (btn==="no") {
							return false;
						} else {
							me.deleteSelected.call(me, entityLabel, selectedRecords, extraConfig);
						}
					});
		} else {
			me.deleteSelected(entityLabel, selectedRecords, extraConfig);
		}
	},
	/**
	 * Delete handler
	 * selectedRecords the selected data (node(s)/row(s)) to be deleted
	 * extraConfig implementation specific extra configuration object
	 */
	/*private*/deleteSelected: function(entityLabel, selectedRecords, extraConfig) {
		var me=this;
		var deleteParams = me.getDeleteParams(selectedRecords, extraConfig);
		Ext.Ajax.request({
			url: me.getDeleteUrl(extraConfig),
			params: deleteParams,
			disableCaching:true,
			scope: me,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success===true) {
					//delete done (no replacement were needed)
					me.reload.call(me, me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson));
				} else {
					var errorCode = responseJson.errorCode;
					if (errorCode) {
						if (errorCode===me.ERROR_CODE_NEED_REPLACE) {
							//render dialog for selecting the replacement
							var windowItems = me.getReplacementItems(entityLabel, responseJson, selectedRecords);
							var title = me.getMessage(me.getDeleteTitleKey(), entityLabel);
							var load = {loadUrl:me.getRenderReplaceUrl(extraConfig),
									loadUrlParams:me.getRenderReplaceParams(selectedRecords, extraConfig)};
							var submit = {	submitUrl:me.getReplaceAndDeleteUrl(extraConfig),
											submitUrlParams:me.getReplaceAndDeleteParams(selectedRecords, extraConfig),
											submitButtonText:me.getDeleteLabel(),
											//deleting more users can be a lengthy operation
	                                        timeout:300,
											refreshAfterSubmitHandler:me.reload,
											refreshParametersBeforeSubmit:me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson)
										};
							var windowConfig = Ext.create('com.trackplus.util.WindowConfig',
									{postDataProcess:me.replaceOptionPostDataProcess, extraConfig:{entityLabel:entityLabel}});
							windowConfig.showWindow(me, title, me.replacementWidth, me.replacementHeight, load, submit, /*refresh,*/ windowItems);
						} else {
							//the entity to be deleted is not empty an extra confirmation box is shown
							if (errorCode===me.NOT_EMPTY_WARNING) {
								var errorMessage = responseJson.errorMessage;
								Ext.MessageBox.confirm(me.getMessage(me.getDeleteTitleKey(), entityLabel),
									errorMessage,
									function(btn){
										if (btn==="no") {
											return false;
										} else {
											this.deleteConfirmed = true;
											me.deleteSelected.call(me, selectedRecords, extraConfig);
										}
									}, this);
							} else {
								Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
							}
						}
					} else {
						//no right to delete (for ex. with fake URL-Params)
						me.errorHandlerDelete(responseJson, selectedRecords);
					}
				}
			},
			failure: function(response){
				com.trackplus.util.requestFailureHandler(response);
			},
			method:"POST"
		});
	},
	/**
	 * Error handler for delete. In the overridden versions depending on error code
	 * the deleteSelected() might be called again with extra/modified submit parameters
	 */
	/*protected*/errorHandlerDelete: function(result, selectedRecords){
		com.trackplus.util.showError(result);
	},
	/**
	 * The replacement items for the deleted entity
	 * (The replacement panel will be created with on this items)
	 */
	/*protected*/getReplacementItems: function(entityLabel, responseJson, selectedRecords, extraConfig) {
		return [{xtype : 'label',
				itemId: 'replacementWarning'},
				CWHF.createCombo('Replacement',
						'replacementID',
						{itemId:"replacementID",
						labelWidth:200,
						allowBlank:false,
						blankText: this.getMessage('common.err.replacementRequired',
								entityLabel)})];
	},
	/**
	 * Load the data in the replacement panel when it arrives from server
	 * the complete replacementWarning could be composed on the server
	 * If not, it will be composed on the client, but at least
	 * the label of the entity to be deleted should be specified
	 */
	/*private*/replaceOptionPostDataProcess: function(data, panel, extraConfig) {
		var replacementWarning = panel.getComponent('replacementWarning');
		var replacementWarningText = data['replacementWarning'];
		if (CWHF.isNull(replacementWarningText)) {
			var label = data['label'];
			replacementWarningText = getText("common.lbl.replacementWarning", extraConfig.entityLabel, label);
			replacementWarningText = replacementWarningText + getText("common.lbl.cancelDeleteAlert");
		}
		replacementWarning.setText(replacementWarningText, false);
		var replacementList = panel.getComponent('replacementID');
		this.loadReplacementOptionData(replacementList, data);
		var replacementListLabel = data.replacementListLabel;
		if (CWHF.isNull(replacementListLabel)) {
			replacementListLabel = this.getMessage('common.lbl.replacement', extraConfig.entityLabel);
		}
		replacementList.labelEl.dom.innerHTML = replacementListLabel;
	},
	/**
	 * Load the data source and value for the replacement options combo
	 * Override this for different tree based pickers
	 */
	/*protected*/loadReplacementOptionData: function(replacementControl, data) {
		replacementControl.store.loadData(data["replacementList"]);
		replacementControl.setValue(null);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.GridBase",{
	extend:"Ext.grid.Panel",
	mixins:{
		actionsBase: "com.trackplus.admin.ActionBase"
	},
	//autoLoadGrid:true,
	fields:null,
	storeUrl: null,
	autoLoadStore: true,
	enableColumnHide: false,
	enableColumnMove: false,
	//general CRUD actions in grid
	actionAdd:null,
	actionEdit:null,
	actionCopy:null,
	actionDelete:null,
	actions:null,
	confirmDeleteEntity:true,
	confirmDeleteNotEmpty:true,
	//has Edit action
	useEdit: true,
	//has copy action
	useCopy:true,
	initComponent : function() {
		var me = this;
		me.initBase();
		this.store = Ext.create('Ext.data.Store', {
			fields:this.fields,
			proxy: {
				type: 'ajax',
				url: this.storeUrl,
				extraParams:this.getLoadGridParams(),
				reader: {
					type: 'json'
				}
			},
			listeners: {
				//this event is not dispatched to viewController (store is not Ext.Component?) only in view
				load: {fn: me.onGridStoreLoad, scope:me}
			},
			autoLoad:this.autoLoadStore
		});
		this.plugins = ["gridfilters"];
		this.selModel = this.getGridSelectionModel();
		this.region = "center";
		this.border = false;
		this.bodyBorder = false;
		this.cls = "gridNoBorder";
		this.columnLines = true;
		this.viewConfig = this.getViewConfig();
		this.dockedItems = this.getDockedItems();
		/*this.listeners = {	
			itemdblclick: {fn:me.onItemDblClick, scope:me},
			itemcontextmenu: {fn:me.onGridRowCtxMenu, scope:me},
			selectionchange: {fn:me.onGridSelectionChange, scope:me}	 
		};*/
		this.callParent();
	},
	/**
	 * Initialization method
	 */
	/*protected*/initBase: function() {
		this.initActions();
	},
	/**********************************************action/context menu related methods***********************************************/
	/**
	 * Get the title for add/edit/copy/delete window used also as tooltip for toolbar buttons
	 */
	/*protected*/getActionTooltip: function(tooltipKey) {
		return getText(tooltipKey, this.getEntityLabel());
	},
	/**
	 * The localized entity name based on the localization key: should be implemented
	 */
	/*protected abstract*/getEntityLabel: function() {
		return "";
		//return getText('...');
	},
	/**
	 * Initialize all possible actions
	 */
	/*protected*/initActions:function() {
		this.actionAdd = CWHF.createAction(this.getAddButtonKey(), this.getAddIconCls(), "onAdd", {tooltip:this.getActionTooltip(this.getAddTitleKey())});
		this.actions = [this.actionAdd];
		if (this.useEdit===true) {
			this.actionEdit = CWHF.createAction(this.getEditButtonKey(), this.getEditIconCls(), "onEdit", {tooltip:this.getActionTooltip(this.getEditTitleKey()), disabled:true});
			this.actions.push(this.actionEdit);
		}
		this.actionDelete = CWHF.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(), "onDelete", {tooltip:this.getActionTooltip(this.getDeleteTitleKey()), disabled:true});
		this.actions.push(this.actionDelete);
		if (this.useCopy===true) {
			this.actionCopy = CWHF.createAction(this.getCopyButtonKey(), this.getCopyIconCls(), "onCopy", {tooltip:this.getActionTooltip(this.getCopyTitleKey()), disabled:true});
			this.actions.push(this.actionCopy);
		}
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	/*protected*/getGridContextMenuActions: function(selectedRecords, selectionIsSimple) {
		var actions = [];
		if (selectionIsSimple) {
			if (this.useEdit && this.actionEdit) {
				actions.push(this.actionEdit);
			}
			if (this.useCopy && this.actionCopy) {
				actions.push(this.actionCopy);
			}
		}
		if (this.actionDelete) {
			actions.push(this.actionDelete);
		}
		return actions;
	},
	/**
	 * The url to load the grid this should be overridden
	 */
	getLoadStoreUrl:function() {
		return this.baseAction + ".action";
	},
	/**
	 * Get extra parameters for grid load
	 * (like "defaultSettings" for "my" and "default" automail settings)
	 */
	/*protected*/getLoadGridParams:function() {
		return null;
	},
	/**
	 * Handler to execute after loading the store
	 */
	/*protected*/onGridStoreLoad: function(store, records) {
	},
	/**
	 * Defined typically if there is no "classic" toolbar available (like grid is in a popup)
	 */
	/*protected*/getDockedItems: function() {
		return [{
			xtype: 'toolbar',
			dock: 'top',
			items: this.getToolbarActionButtons(this.actions) 
		}]
	},
	getToolbarActionButtons:function(actionList){
		var me=this;
		var toolbarList=[];
		if(actionList){
			for(var i=0;i<actionList.length;i++) {
				toolbarList.push(new Ext.button.Button(actionList[i]));
			}
		}
		return toolbarList;
	},
	/*protected*/getViewConfig: function() {
		return {
			forceFit: true,
			stripeRows: true,
			listeners: {
					//although these event listeners could be attached to the gridPanel directly but then the corresponding listeners of the viewController are not called
					itemdblclick: "onItemDblClick",
					itemcontextmenu: "onItemContextMenu",
					selectionchange: "onSelectionChange"
				}
		};
	},
	/**
	 * Get the configuration for selection model
	 */
	/*protected*/getGridSelectionModel: function() {
		var selectionModelConfig = new Object();
		if (this.allowMultipleSelections) {
			selectionModelConfig.mode="MULTI";
		} else {
			selectionModelConfig.mode="SINGLE";
			if (this.allowDeselect) {
				selectionModelConfig.allowDeselect=this.allowDeselect;
			}
		}
		if (CWHF.isNull(this.gridSelectionModel)) {
			return Ext.create("Ext.selection.RowModel", selectionModelConfig);
		} else {
			return this.gridSelectionModel;
		}
	},
	/**
	 * Whether the selection is simple or multiple
	 */
	/*public*/selectionIsSimple: function() {
		if (this.allowMultipleSelections) {
			var selectedRecords = this.getGridSelection();
			return selectedRecords && selectedRecords.length===1;
		} else {
			var selectedRecord = this.getLastSelectedGridRow();
			return selectedRecord!==null;
		}
	},
	/**
	 * The the selected grid rows (possibly more than one)
	 */
	/*public*/getGridSelection: function() {
		return this.getSelectionModel().getSelection();
	},
	/**
	 * The the last selected grid row (only one row)
	 */
	getLastSelectedGridRow: function() {
		return this.getSelectionModel().getLastSelected();
	},
	/**
	 * Gets the selected data
	 * it can be simple or multiple selection
	 */
	/*public*/getSelectedRecords: function() {
		var me=this;
		if (me.allowMultipleSelections) {
			return me.getGridSelection();
		} else {
			return me.getLastSelectedGridRow();
		}
	},
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 * param: typically fromTree
	 */
	/*private*/getSingleSelectedRecordData: function(param) {
		var selectedRecord = this.getSingleSelectedRecord(param);
		if (selectedRecord) {
			return selectedRecord.data;
		}
		return null;
	},
	/**
	 * Get the data of the single selected record
	 * For no selection or multiple selection return null
	 */
	/*private*/getSingleSelectedRecord: function(param) {
		var selectedRecords = this.getSelectedRecords(param);
		if (selectedRecords) {
			if (this.allowMultipleSelections) {
				if (selectedRecords && selectedRecords.length===1) {
					return selectedRecords[0];
				} else {
					return null;
				}
			} else {
				return selectedRecords;
			}
		} else {
			return null;
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Base for all ViewControllers used for GridBase implementations
 */
Ext.define("com.trackplus.admin.GridBaseController",{
	extend:"com.trackplus.admin.DeleteController",
	/**
	 * The following parameters must be specified for a derived GridBaseController
	 */
	//the base action name
	//baseAction:null,
	//the name of the request parameter the selected record's ID will be sent to the server 
	//entityID:null,
	//the with of the edit dialog
	//editWidth:800,
	//the height of the edit dialog
	//editHeight:600,
	getBaseAction:function() {
		return this.baseAction;
	},
	getNodeBaseAction: function() {
		return this.getBaseAction();
	},
	onAdd: function(button, event) {
		var recordData=new Object();
	 	this.openEditEntity.call(this, this.getView().getActionTooltip(this.getView().getAddTitleKey()), recordData,"add");
	},
	onEdit: function(button, event) {
		var recordData = this.getView().getSingleSelectedRecordData();
		if(CWHF.isNull(recordData)){
			return true;
		}
		this.openEditEntity.call(this, this.getView().getActionTooltip(this.getView().getEditTitleKey()), recordData,"edit");
	},
	onCopy: function(button, event) {
		var recordData = this.getView().getSingleSelectedRecordData();
		if(CWHF.isNull(recordData)){
			return true;
		}
	 	this.openEditEntity.call(this, this.getView().getActionTooltip(this.getView().getCopyTitleKey()), recordData,"copy");
	},
	onDelete: function(button, event) {
		var selectedRecords = this.getView().getSelectedRecords();
		if (selectedRecords) {
			var entityLabel = this.getView().getEntityLabel();
			this.deleteHandler(entityLabel,  selectedRecords);
		}
	},
	/**
	 *  Handler for double click
	 */
	/*protected*/onItemDblClick: function(view, record){
		this.onEdit();
	},
	/**
	 * Handler for grid selection change: enable/disable actions based on the actual selection
	 */
	/*protected*/onSelectionChange: function(selectionModel, selections) {
		if (CWHF.isNull(selections) || selections.length===0){
			//no selection: disable edit/copy/delete
			if (this.getView().actionDelete) {
				this.getView().actionDelete.setDisabled(true);
			}
			if (this.getView().actionEdit) {
				this.getView().actionEdit.setDisabled(true);
			}
			if (this.getView().actionCopy) {
				this.getView().actionCopy.setDisabled(true);
			}
		} else {
			//activate delete for any selection
			if (this.getView().actionDelete) {
				this.getView().actionDelete.setDisabled(false);
			}
			if (selections.length===1) {
				//activate edit/copy only if there is exactly one selection
				if (this.getView().actionEdit) {
					this.getView().actionEdit.setDisabled(false);
				}
				if (this.getView().actionCopy) {
					this.getView().actionCopy.setDisabled(false);
				}
			} else {
				//disable edit/copy only if there is more than one selection
				if (this.getView().actionEdit) {
					this.getView().actionEdit.setDisabled(true);
				}
				if (this.getView().actionCopy) {
					this.getView().actionCopy.setDisabled(true);
				}
			}
		}
	},
	/**
	 * Show the context menu in grid
	 */
	/*private*/onItemContextMenu: function(view, record, item, index, evtObj) {
		evtObj.stopEvent();
		view.getSelectionModel().select(record);
		var selectedRecords = this.getView().getSelectedRecords();
		var selectionIsSimple = this.getView().selectionIsSimple();
		var actions=this.getView().getGridContextMenuActions(selectedRecords, selectionIsSimple);
		var gridRowCtxMenu = this.createContextMenu(record, actions);
		gridRowCtxMenu.showAt(evtObj.getXY());
		return false;
	},
	openEditEntity: function(title, recordData, operation) {
		var me=this;
		var load = {loadUrl:this.getEditUrl(recordData, operation), loadUrlParams:this.getLoadParams(recordData, operation), loadHandler:this.loadHandler};
		var submitParams = this.getSaveParams(recordData, operation);
		var submit = {	submitUrl:this.getSaveUrl(),
						submitUrlParams:submitParams,
						submitButtonText:this.getSaveLabel(operation),
						submitHandler:this.submitHandler,
						submitAction:operation,
						refreshAfterSubmitHandler:this.reload,
						refreshParametersBeforeSubmit:this.getReloadParamsAfterSave(),
						refreshParametersAfterSubmit:this.getReloadParamsAfterSaveFromResult()
					};
		var additionalActions = this.getAdditionalActions(recordData, submitParams, operation);
		if (additionalActions) {
			additionalActions.push(submit);
			submit = additionalActions;
		}
		//either formPanel or items should be set
		var formEdit = this.createEditForm(recordData, operation);
		var items = this.getEditPanelItems(recordData, operation);
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig',
			{title:title, width:this.editWidth, height:this.editHeight,
				load:load, submit:submit,
				formPanel: formEdit, items:items,
				postDataProcess:this.afterLoadForm, preSubmitProcess:this.preSubmitProcess});
		windowConfig.showWindowByConfig(me);
	},
	/**
	 * Get the ID based from the recordData and extra config
	 *  Should be overridden
	 */
	/*protected*/getRecordID: function(recordData, extraConfig) {
		if (recordData) {
			return recordData.id;
		}
		return null;
	},
	/**
	 * Url for editing an entity
	 * We suppose that add/edit/copy use the same edit method on server side
	 * Differentiation is made based on this.entityID and copy request parameter
	 * add: this.entityID===null
	 * edit: this.entityID && copy===false
	 * copy: this.entityID && copy===true
	 */
	/*protected*/getEditUrl: function(recordData, operation){
		return this.getBaseAction()+'!edit.action';
	},
	/**
	 * Parameters for adding a new entity
	 * Specify extra parameters if needed
	 * (like "defaultSettings" for "my" and "default" automail settings)
	 */
	/*protected*/getAddParams: function() {
		return null;
	},
	/**
	 * Parameters for editing an existing entity
	 * recordData: the selected entity data
	 */
	/*protected*/getEditParams: function(recordData) {
		var result=new Object();
		result[''+this.entityID]=this.getRecordID(recordData);
		return result;
	},
	/**
	 * Parameters for editing a copy of an existing entity
	 * recordData: the selected entity data
	 */
	/*protected*/getCopyParams: function(recordData) {
		var result=this.getEditParams(recordData);
		result['copy']=true;
		return result;
	},
	/**
	 * Parameters for loading the edited entity
	 * recordData: the selected entity data
	 * action: the submit action
	 */
	/*private*/getLoadParams: function(recordData, action) {
		if (CWHF.isNull(action)){
			action="add";
		}
		if (action==="add") {
			return this.getAddParams();
		}
		if (action==="edit") {
			return this.getEditParams(recordData);
		}
		if (action==="copy") {
			return this.getCopyParams(recordData);
		}
		//for extra actions default to editParams
		return this.getEditParams(recordData);
	},
	/**
	 * Url for saving of an entity
	 */
	/*protected*/getSaveUrl: function(){
		return this.getBaseAction()+'!save.action';
	},
	/**
	 * Parameters for saving an entity (extra parameters additionally to submit parameters)
	 */
	/*protected*/getSaveParams: function(recordData, action) {
		var params = null;
		if (CWHF.isNull(action)){
			action="add";
		}
		if (action==="add"){
			params=this.getAddParams();
		}
		if (action==="edit"){
			params=this.getEditParams(recordData);
		}
		if (action==="copy"){
			params=this.getCopyParams(recordData);
		}
		if (CWHF.isNull(params)) {
			//should not be null because dynamic parameters might be added right before submit
			//(in either submitHandler()  or preSubmitProcess() implementations)
			params = new Object();
		}
		return params;
	},
	/**
	 * Get extra parameters for grid load
	 * (like "defaultSettings" for "my" and "default" automail settings)
	 */
	/*protected*/getLoadGridParams:function() {
		return null;
	},
	/**
	 * Reload the grid
	 */
	reload:function(refreshParametersObject) {
		this.getView().getStore().load({
			scope:this,
			callback:function(){
				if (refreshParametersObject) {
					var rowToSelect = refreshParametersObject.rowToSelect;
					if (rowToSelect) {
						var row = this.getView().getStore().getById(rowToSelect);
						if (row) {
							var gridSelectionModel = this.getView().getSelectionModel();
							gridSelectionModel.select(row);
						}
					}
				}
			}
		})
	},
	/**
	 * Parameters for reload/select after a save operation (following an add/edit/copy)
	 * which are known before the save operation is executed.
	 * Typically same as getLoadGridParams();
	 */
	/*protected abstract*/getReloadParamsAfterSave:function() {
		return this.getLoadGridParams();
	},
	/**
	 * Get parameters for reload/select after a save operation (following an add/edit/copy)
	 * which are known only after the save operation is executed.
	 * These parameter values are extracted form the JSON object resulting from save
	 * The format of the expected object is:
	 * {parameterName:'<parameterName>', fieldNameFromResult:'<fieldNameFromResult>'}
	 * For save after edit the parameters are probably known even before save
	 * (supposed that the edit does not modify the record id)
	 * but for save after add/copy not (the new id is needed for selection).
	 * It is not differentiated for add/edit/copy because all use the same edit method on the server side
	 */
	/*protected abstract*/getReloadParamsAfterSaveFromResult:function() {
		return {parameterName:'rowToSelect', fieldNameFromResult:'id'};
	},
	/**
	 * The label for the save button
	 */
	/*protected*/getSaveLabel: function(operation) {
		return getText('common.btn.save');
	},
	/**
	 * The label for the cancel button
	 */
	/*protected*/getCancelLabel: function() {
		return getText('common.btn.cancel');
	},
	/**
	 * Handler for loading the form data
	 * Should be implemented only when panel is not form panel (for ex. a grid)
	 * and the load is made "manually"
	 */
	/*protected*/loadHandler:null,
	/**
	 * Handler for sending the form data to the sever
	 * Should be implemented only when panel is not form panel (for ex. a grid)
	 * and the save is made "manually"
	 */
	/*protected*/submitHandler:null,
	/**
	 * An array of of additional actions are needed beyond save and cancel
	 * The objects in the array should be composed in the same manner as the submit object for save
	 * the submit object contains:
	 * submitUrl: url the submit is sent to
	 * submitUrlParams: extra parameters for submit
	 * submitButtonText: the label for submit button (defaults to the label keyed by 'common.btn.save')
	 * refreshAfterSubmit: true if not specified, if false the refresh is not called in the submit handler
	 * closeAfterSubmit: true if not specified, if false the window is not closed in the submit handler
	 * submitHandler: an alternative submit handler used when isFormPanel is false (probably manual submit of a grid)
	 * 	refreshAfterSubmit and closeAfterSubmit has no relevance if submitHandler is specified
	 * submitAction: the action for submit ("add", "edit", "copy", "overwrite"). Not required
	 * if there are more actions which need a submit the submit object can be an array of such submit objects
	 *
	 */
	/*protected*/getAdditionalActions: function(recordData, submitParams, operation) {
		return null;
	},
	createEditForm:function(entityJS,type){
		return null;
	},
	/**
	 * The items in the popup window.
	 * Either this or getEditFormItems() should be implemented
	 * recordData: the selected entity data
	 * action: the submit action
	 */
	getEditPanelItems:function(recordData, action){
		return null;
	},
	/**
	 * Gather selected ID as a comma separated string
	 * selectedRecords - the selected record(s): simple or multiple selection:
	 * 	if simple the selection the record, if multiple an array of records
	 * getIDFormEntityFunction - function for getting the ID from an entity JSON
	 * extraConfig
	 */
	/*private*/getSelectedIDs: function(selectedRecords, extraConfig) {
		if (this.getView().allowMultipleSelections) {
			var idArray = [];
			Ext.Array.forEach(selectedRecords, function(record) {
				idArray.push(this.getRecordID(record.data, extraConfig));
			}, this);
			return idArray.join();
		} else {
			return this.getRecordID(selectedRecords.data, extraConfig);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
Ext.define('com.trackplus.admin.SimpleAssignment',{
	extend:'Ext.Base',
	config: {
		//the id of the selected object to assign to
		objectID: null,
		//the request parameter name to submit objectID
		objectIDParamName: null,
		//the type to identify the assigned entity type: used only if more than one assignment type may exist, and they are handled by the same struts action
		assignmentType: null,
		//the request parameter name to submit assignmentType
		assignmentTypeParameterName: null,
		dynamicIcons: false
	},
	leafDetailByFormLoad: false,
	assignedGrid: null,
	availableGrid: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
	},
	/**
	 * Gets the base struts action
	 */
	getBaseAction: function() {
		return this.baseAction;
	},
	getDetailUrl: function() {
		return this.getBaseAction() + ".action";
	},
	/**
	 * Gets the parameters for loading the assignment details
	 */
	getDetailParams: function(node) {
		var params = new Object();
		params[this.getObjectIDParamName()] = this.getObjectID();
		if (this.getAssignmentType() && this.getAssignmentTypeParameterName()) {
			params[this.getAssignmentTypeParameterName()] = this.getAssignmentType();
		}
		return params;
	},
	getToolbarActions: function() {
		return [];
	},
	getToolbarActionChangesForTreeNodeSelect: function(node) {
	},
	adjustToolbarButtonsTooltip: function(node) {
	},
	getDetailPanel: function(node) {
		var panel = Ext.create("Ext.Panel", {
			layout: "border",
			region: "center",
			border:false,
			items: [],
			autoScroll: true
		});
		Ext.Ajax.request({
			url: this.getDetailUrl(),
			params: this.getDetailParams(node),
			scope: this,
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				var items = this.getDetailItems(node, false, responseJson);
				panel.add(items);
			},
			failure: function(result){
				Ext.MessageBox.alert(this.failureTitle, result.responseText);
			},
			method:"POST"
		});
		return panel;
	},
	getDetailItems: function(record, add, responseJson){
		var northPanel = {
			region:"north",
			xtype:'component',
			cls: 'infoBox1',
			border:true,
			html: responseJson["assignmentInfo"]
		};
		var panelGrids = this.createAssignmentGrids(record, responseJson);
		return [northPanel, panelGrids];
	},
	reloadAssigned: function(urlStr,params) {
		Ext.Ajax.request({
			url:urlStr,
			params:params,
			disableCaching:true,
			scope: this,
			success: function(result) {
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===true) {
					this.assignedGrid.store.loadData(jsonData['assigned'], false);
					this.availableGrid.store.loadData(jsonData['unassigned'], false);
				} else {
					com.trackplus.util.requestFailureHandler(result);
				}
			},
			failure: function(result){
				com.trackplus.util.requestFailureHandler(result);
			}
		});
	},
	getIconField: function() {
		if (this.getDynamicIcons()) {
			return "icon";
		} else {
			return "iconCls";
		}
	},
	getGridFields: function(record) {
		return [{name:'id', type:'int'},
				{name:'text', type:'string'},
				{name:this.getIconField(), type:'string'}];
	},
	iconClsRenderer: function(value, metadata, record) {
		metadata.tdCls = value;
		return null;
	},
	iconRenderer: function(value, metadata, record) {
		return '<img src="' + value + '"/>';
	},
	getColumnModel: function() {
		var renderer;
		if (this.getDynamicIcons()) {
			renderer = this.iconRenderer;
		} else {
			renderer = this.iconClsRenderer;
		}
		return [{text: getText('admin.customize.list.lbl.icon'), width:28,
				sortable: true, dataIndex: this.getIconField(), renderer: renderer},
			{text: getText('common.lbl.name'), flex: 1, sortable: true, dataIndex: 'text'}];
	},
	createAssignmentGrids: function(record, response) {
		var items = [];
		if (response['assigned']) {
			var assignedGridStore = Ext.create('Ext.data.Store', {
				fields:this.getGridFields(record),
				data: response['assigned']
			});
			this.assignedGrid = Ext.create('Ext.grid.Panel', {
				itemId:'assignedGrid',
				title: getText('common.lbl.assigned'),
				hideHeaders:true,
				store: assignedGridStore,
				columns: this.getColumnModel(),
				stripeRows:	true,
				multiSelect: true,
				enableColumnHide: false,
				enableColumnMove: false,
				border:false,
				bodyBorder:false,
				cls:'gridNoBorder',
				viewConfig: {
					plugins: {
						ptype: 'gridviewdragdrop',
						dragGroup: 'secondGridDDGroup',
						dropGroup: 'firstGridDDGroup'
					},
					listeners: {
						drop: {scope:this,
							fn: function(node, data, dropRec, dropPosition) {
								if(data && data.records && data.records.length>0){
									var idsArray = new Array();
									for ( var i = 0; i < data.records.length; i++) {
										idsArray[i] = data.records[i].data.id;
									}
									var params=this.getDetailParams();
									if (CWHF.isNull(params)) {
										params=new Object();
									}
									params['assign']=idsArray.join();
									this.reloadAssigned(this.getBaseAction()+"!assign.action", params);
								}
							}
						}
					}
				}
			});
			items.push(this.assignedGrid);
		}
		if (response['unassigned']) {
			var availableGridStore = Ext.create('Ext.data.Store', {
				fields:this.getGridFields(record),
				data: response['unassigned']
			});
			this.availableGrid =  Ext.create('Ext.grid.Panel', {
				itemId:'availableGrid',
				title: getText('common.lbl.unassigned'),
				hideHeaders:true,
				store: availableGridStore,
				columns: this.getColumnModel(),
				stripeRows:	true,
				multiSelect: true,
				enableColumnHide: false,
				enableColumnMove: false,
				border:false,
				bodyBorder:false,
				cls:'gridNoBorder',
				style:{
					borderLeft:'1px solid #D0D0D0'
				},
				viewConfig: {
					plugins: {
						ptype: 'gridviewdragdrop',
						dragGroup: 'firstGridDDGroup',
						dropGroup: 'secondGridDDGroup'
						},
					listeners: {
						drop: {scope:this,
							fn: function(node, data, dropRec, dropPosition) {
								if(data && data.records && data.records.length>0){
									var idsArray = new Array();
									for ( var i = 0; i < data.records.length; i++) {
										idsArray[i] = data.records[i].data.id;
									}
									var params=this.getDetailParams();
									if (CWHF.isNull(params)) {
										params=new Object();
									}
									params['unassign']=idsArray.join();
									this.reloadAssigned(this.getBaseAction()+"!unassign.action", params);
								}
							}
						}
					}
				}
			});
			items.push(this.availableGrid);
		}
		//Simple 'border layout' panel to house both grids
		var displayPanel = Ext.create('Ext.Panel', {
			region: 'center',
			margin:'0 0 0 0',
			border: false,
			bodyBorder: false,
			layout: {
				type: 'hbox',
				align: 'stretch'
			},
			defaults: { flex: 1 },
			items: items
		});
		return displayPanel;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
Ext.define('com.trackplus.admin.TreeDetailAssignment',{
	extend:'com.trackplus.admin.TreeDetail',
	config: {
		rootID: null,
		rootMessage: null,
		dynamicIcons: false,
		//whether to reload the grids after drag and drop:
		//if yes the sort order is enforced but the user filters set on grid fields are not applied after refresh
		//if no the sort order is not enforced (the item remains where it was dropped)
		//so set to yes only if no filter is defined for grids
		reloadGrids: false
	},
	leafDetailByFormLoad: false,
	gridPlugins:["gridfilters"],
	assignedGrid: null,
	availableGrid: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	/**
	 * Show the node detail based on  responseJson
	 */
	loadSimpleDetailPanel: function(node, add) {
		Ext.Ajax.request({
			url: this.getDetailUrl(node, add),
			params: this.getDetailParams(node, add),
			scope: this,
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (this.centerPanel) {
					this.mainPanel.remove(this.centerPanel, true);
				}
				var northPanel = {
						region:'north',
						xtype:'component',
						cls: 'infoBox1',
						border:true,
					 	html: responseJson['assignmentInfo']
					};
				var panelGrids = this.createAssignmentGrids(node.id, responseJson);
				this.centerPanel = Ext.create('Ext.panel.Panel', {
					layout: 'border',
					region:'center',
					cls:'gridNoBorder',
					border: false,
					bodyBorder:false,
					bodyPadding:0,
					autoScroll: false,
					items:[northPanel, panelGrids]
				});
				this.mainPanel.add(this.centerPanel);
			},
			failure: function(result){
				Ext.MessageBox.alert(this.failureTitle, result.responseText);
			},
			method:"POST"
		});
	},
	getDetailUrl: function() {
		return this.getBaseAction() + ".action";
	},
	reloadAssigned: function(urlStr,params) {
		params['node'] = this.selectedNodeID;
		Ext.Ajax.request({
			url:urlStr,
			params:params,
			disableCaching:true,
			scope: this,
			success: function(result){
				var jsonData=Ext.decode(result.responseText);
				if(jsonData.success===true) {
					var nodeIdToReload = jsonData['nodeToReload'];
					//var nodeIdToSelect = jsonData['nodeToSelect'];
					var treeStore = this.tree.getStore();
					var nodeToReload=treeStore.getNodeById(nodeIdToReload);
					var params = {node:nodeIdToReload};
					var oldParentsToReload = jsonData["parentsToReload"];
					if (oldParentsToReload && oldParentsToReload.length>0) {
						//old parents for department: the persons added to the departments should be automatically removed from other departments
						//for persons in groups or persons in roles parentsToReload will be null
						//(should not actualize old parents because a person can me in more groups/roles at the same time)
						params["oldParentIDs"] = oldParentsToReload.join();
					}
					Ext.Ajax.request({
						url: this.getBaseAction() + "!refreshParent.action",
						params: params,
						scope: this,
						disableCaching:true,
						success: function(response){
							var parents = Ext.decode(response.responseText);
							if (parents && parents.length>0) {
								Ext.Array.forEach(parents, function(parent, index, allItems) {
									var parentNode=treeStore.getNodeById(parent["id"]);
									if (parentNode) {
										parentNode.set("text", parent["label"]);
										parentNode.commit();
										if (parentNode.isLoaded()) {
											var options = this.getTreeExpandExtraParams(nodeToReload);
											treeStore.proxy.extraParams = options;
											treeStore.load({node:parentNode});
										}
									}
								}, this);
							}
						},
						failure: function(result){
							Ext.MessageBox.alert(this.failureTitle, result.responseText);
						},
						method:"POST"
					});
					//the assignment node was not yet expanded: refresh only the grids, the tree remains unmodified
					if (this.getReloadGrids()) {
						this.assignedGrid.store.loadData(jsonData["assigned"], false);
						this.availableGrid.store.loadData(jsonData["unassigned"], false);
					}
				} else {
					com.trackplus.util.requestFailureHandler(result);
				}
			},
			failure: function(result){
				com.trackplus.util.requestFailureHandler(result);
			}
		});
	},
	getIconField: function() {
		if (this.getDynamicIcons()) {
			return "icon";
		} else {
			return "iconCls";
		}
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields: function() {
		var iconField = this.getIconField();
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
				{ name : iconField, mapping : iconField, type: 'string'}];
	},
	getGridFields: function(record) {
		return [{name:'id', type:'int'}, {name:'text', type:'string'},{name:this.getIconField(), type:'string'}];
	},
	iconClsRenderer: function(value, metadata, record) {
		metadata.tdCls = value;
		return null;
	},
	iconRenderer: function(value, metadata, record) {
		return '<img src="' + value + '"/>';
	},
	getColumnModel: function() {
		var renderer;
		if (this.getDynamicIcons()) {
			renderer = this.iconRenderer;
		} else {
			renderer = this.iconClsRenderer;
		}
		return [{text: getText('admin.customize.list.lbl.icon'), width:28, sortable: true,
				dataIndex: this.getIconField(), renderer: renderer},
			{text: getText('common.lbl.name'), flex: 1, sortable: true, dataIndex: 'text'}];
	},
	hideGridHeaders: function() {
		return true;
	},
	enableColumnHide: function() {
		return false;
	},
	enableColumnMove: function() {
		return false;
	},
	getGridFeatures: function() {
		return null;
	},
	getGroupingFeature:function(features){
		return null;
	},
	createAssignmentGrids: function(record, response) {
		var items = [];
		if (response['assigned']) {
			var assignedGridStore = Ext.create('Ext.data.Store', {
				fields:this.getGridFields(record),
				data: response['assigned']
			});
			var assignedFeatures=this.getGridFeatures();
			this.assignedGrid =  Ext.create('Ext.grid.Panel', {
				itemId:'assignedGrid',
				title: getText('common.lbl.assigned'),
				hideHeaders: this.hideGridHeaders(),
				store: assignedGridStore,
				plugins: this.gridPlugins,
				columns: this.getColumnModel(),
				stripeRows:	true,
				multiSelect: true,
				enableColumnHide: this.enableColumnHide(),
				enableColumnMove: this.enableColumnMove(),
				border:false,
				bodyBorder:false,
				cls:'gridNoBorder',
				features:assignedFeatures,
				viewConfig: {
					plugins: {
						ptype: 'gridviewdragdrop',
						dragGroup: 'secondGridDDGroup',
						dropGroup: 'firstGridDDGroup'
					},
					listeners: {
						drop: {scope:this,
							fn: function(node, data, dropRec, dropPosition) {
								if(data && data.records && data.records.length>0){
									var idsArray = new Array();
									for ( var i = 0; i < data.records.length; i++) {
										idsArray[i] = data.records[i].data.id;
									}
									var params=new Object();
									params['assign']=idsArray.join();
									this.reloadAssigned(this.getBaseAction()+"!assign.action", params);
								}
							}
						}
					}
				}
			});
			var assignedGroupingFeature=this.getGroupingFeature(assignedFeatures);
			if(assignedGroupingFeature){
				this.assignedGrid.addListener('afterrender', function(){
					assignedGroupingFeature.disable();
				});
			}
			items.push(this.assignedGrid);
		}
		if (response['unassigned']) {
			var availableGridStore = Ext.create('Ext.data.Store', {
				fields:this.getGridFields(record),
				data: response['unassigned']
			});
			var availableGridFeatures=this.getGridFeatures();
			this.availableGrid =  Ext.create('Ext.grid.Panel', {
				itemId:'availableGrid',
				title: getText('common.lbl.unassigned'),
				hideHeaders:this.hideGridHeaders(),
				store: availableGridStore,
				plugins: this.gridPlugins,
				columns: this.getColumnModel(),
				stripeRows:	true,
				multiSelect: true,
				enableColumnHide: this.enableColumnHide(),
				enableColumnMove: this.enableColumnMove(),
				border:false,
				bodyBorder:false,
				cls:'gridNoBorder',
				style:{
					borderLeft:'1px solid #D0D0D0'
				},
				features:availableGridFeatures,
				viewConfig: {
					plugins: {
						ptype: 'gridviewdragdrop',
						dragGroup: 'firstGridDDGroup',
						dropGroup: 'secondGridDDGroup'
						},
					listeners: {
						drop: {scope:this,
							fn: function(node, data, dropRec, dropPosition) {
								if(data && data.records && data.records.length>0){
									var idsArray = new Array();
									for ( var i = 0; i < data.records.length; i++) {
										idsArray[i] = data.records[i].data.id;
									}
									var params=new Object();
									params['unassign']=idsArray.join();
									this.reloadAssigned(this.getBaseAction()+"!unassign.action", params);
								}
							}
						}
					}
				}
			});
			var availableGroupingFeature=this.getGroupingFeature(availableGridFeatures);
			if(availableGroupingFeature){
				this.availableGrid.addListener('afterrender', function(){
					availableGroupingFeature.disable();
				});
			}
			items.push(this.availableGrid);
		}
		//Simple 'border layout' panel to house both grids
		var displayPanel = Ext.create('Ext.Panel', {
			region: 'center',
			margin:'0 0 0 0',
			border: false,
			bodyBorder: false,
			layout: {
				type: 'hbox',
				align: 'stretch'
			},
			defaults: { flex : 1 },
			items: items
		});
		return displayPanel;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/* Copyright (C) 2011 Trackplus
 * $Id: screenListView.js 3978 2012-09-27 16:09:05Z friedj $
 */
Ext.define('com.trackplus.admin.ScreenListGridConfig',{
	extend:'com.trackplus.admin.GridBase',
	fields:[
		{name: 'id',type:'int'},
		{name: 'name',type:'string'},
		{name: 'tagLabel',type:'string'},
		{name: 'description', type: 'string'},
		{name: 'owner', type: 'string'}
	],
	columnModel:[
		{text: getText('common.lbl.name'),
			width:220, dataIndex: 'name', id:'name', sortable:true,
			filter: {type: "string"}},
		{text: getText('common.lbl.tagLabel'),
			width:220, dataIndex: 'tagLabel', id:'tagLabel', sortable:true,
			filter: {type: "string"}},
		{text: getText('common.lbl.description'), flex:1,
			dataIndex: 'description', id:'description', sortable:true,
			filter: {type: "string"}},
		{text: getText('admin.customize.form.config.owner'),
			width:220, dataIndex: 'owner', id:'owner', sortable:true,
			filter: {type: "string"}}
	],
	getLoadStoreUrl:function() {
		return this.baseAction + '.action';
	},
	confirmDeleteEntity:true,
	baseAction:'indexScreens',
	entityID:'screenID',
	editWidth:500,
	editHeight:300,
	useCopy:true,
	getEntityLabel:function(){
		//getText
		return 'Form';
	},
	/*errorHandlerDelete:function(entityJS,errorCode,errorMessage){
		var me=this;
		if(errorCode===1){
			//ERROR_NEED_REPLACE
			me.replaceDeletedLinkType(entityJS);
		}else{
			alert("error delete: code:"+errorCode+" message="+errorMessage);
		}
	},*/
	createEditForm:function(entityJS,type){
		var me=this;
		var panelForm= new Ext.form.FormPanel({
			url:'indexScreens!save.action',
			fieldDefaults: {
				labelWidth: 150
			},
			region:'center',
			layout:'anchor',
			border:false,
			bodyBorder:false,
			autoScroll: true,
			bodyStyle: 'padding:10px',
			defaultType: 'textfield',
			items: [{
					fieldLabel: getText('common.lbl.name'),
					name: 'screen.name',
					anchor:'100%',
					allowBlank:false
				},{
					fieldLabel: getText('common.lbl.tagLabel'),
					name: 'screen.tagLabel',
					anchor:'100%',
					allowBlank:true
				},{
					xtype:'textareafield',
					fieldLabel:getText('common.lbl.description'),
					name: 'screen.description',
					anchor:'100%-75',//anchor width by percentage
					allowBlank:false
				}
			]
		});
		return panelForm;
	},
	initActions:function(){
		var me=this;
		me.callParent();
		var designAction=me.createAction(getText('common.btn.config'), 'btnConfig', me.onConfig, false);
		me.actions.push(designAction);
	},
	onConfig:function(){
		var me=this;
		var recordData=me.getSingleSelectedRecordData();
		if(CWHF.isNull(recordData)){
			return false;
		}
		var id=recordData.id;
		window.location.href='screenEdit.action?componentID='+id+'&backAction=cockpit.action';
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.projectType.ProjectType',{
	extend:'com.trackplus.admin.TreeDetail',
	config: {
	},
	baseAction: 'projectType',
	leafDetailByFormLoad: true,
	folderDetailByFormLoad: true,
	replaceToolbarOnTreeNodeSelect: true,
	entityID:'node',
	//actions
	actionAdd: null,
	actionSave: null,
	actionDelete: null,
	actionImport: null,
	actionExport: null,
	fieldConfig: null,
	screenConfig: null,
	workflowConfig: null,
	issueTypeAssignment: null,
	childProjectTypeAssignment: null,
	roleAssignment: null,
	assignment: null,
	labelWidth:250,
	textFieldWidth:250+300,
	textFieldWidthShort:250+70,
	alignR:"right",
	FieldSetWidth:250+300+150,
	PROJECT_TYPE: 0,
	STATUS_ASSIGNMENT: 1,
	ISSUE_TYPE_ASSIGNMENT: 2,
	PRIORITY_ASSIGNMENT: 3,
	SEVERITY_ASSIGNMENT: 4,
	FIELD_CONFIGURATION: 5,
	SCREEN_ASSIGNMENT: 6,
	WORKFLOW_ASSIGNMENT: 7,
	CHILD_PROJECT_TYPE_ASSIGNMENT: 8,
	ROLE_ASSIGNMENT: 9,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.myInit();
	},
	myInit: function() {
		this.initActions();
	},
	/********************Methods for projectType-associated entities*****************/
	/**
	 * Handler for selecting a node in the tree
	 */
	treeNodeSelect: function(rowModel, node, index, opts) {
		//this.centerPanel.removeAll(true);
		var noOfSelectedNodes = 0;
		var leaf = false;
		if (node) {
			//typical: called for the select event from the tree
			leaf = node.data['leaf'];
			this.selectedNodeID = node.data['id'];
			this.selectedNode = node;
		}
		var selectedNodeClass = this.getSelectedNodeClass(node);
		if (this.getSelectedNodeIsTreeBased(node)) {
			node = this.loadTreeWithGrid(selectedNodeClass, node);
			//call the actualizeToolbarOnTreeSelect as the rootNode of the new tree would be selected
			this.actualizeToolbarOnTreeSelect.call(selectedNodeClass, node);
		} else {
			if (this.getSelectedNodeIsDetailBased(node)) {
				if (this.centerPanel) {
					this.mainPanel.remove(this.centerPanel, true);
				}
				this.centerPanel = selectedNodeClass.getDetailPanel(node, leaf, opts);
				this.mainPanel.add(this.centerPanel);
				borderLayout.setActiveToolbarActionList([]);
			} else {
				selectedNodeClass.loadDetailPanel(node, leaf, opts);
				this.actualizeToolbarOnTreeSelect(node);
				//borderLayout.setActiveToolbarActionList(selectedNodeClass.getToolbarActions());
			}
		}
	},
	loadTreeWithGrid: function(treeWithGridConfig, node) {
		var projectTypeID = null;
	    if (node) {
	       projectTypeID = node.data["projectTypeID"];
	    }
		if (this.centerPanel) {
			this.mainPanel.remove(this.centerPanel, true);
		}
		//for workflow config
		treeWithGridConfig.projectOrProjectTypeID = projectTypeID;
		this.centerPanel = treeWithGridConfig.createCenterPanel();
		this.mainPanel.add(this.centerPanel);
		var rootNode = treeWithGridConfig.tree.getRootNode();
	    treeWithGridConfig.selectedNode = rootNode;
	    borderLayout.setActiveToolbarActionList(treeWithGridConfig.getToolbarActions());
		return rootNode;
	},
	/**
	 * Whether the node specific class is a treeBase implementation
	 */
	getSelectedNodeIsTreeBased: function(node) {
		var configType = node.data['configType'];
		switch (configType) {
		case this.STATUS_ASSIGNMENT:
		case this.PRIORITY_ASSIGNMENT:
		case this.SEVERITY_ASSIGNMENT:
		case this.FIELD_CONFIGURATION:
		case this.SCREEN_ASSIGNMENT:
		case this.WORKFLOW_ASSIGNMENT:
			return true;
		}
		return false;
	},
	/**
	 * Whether the node specific class is a wizard implementation
	 */
	getSelectedNodeIsDetailBased: function(node) {
		var projectConfigType = node.data['configType'];
		return projectConfigType===this.ISSUE_TYPE_ASSIGNMENT ||
			projectConfigType===this.CHILD_PROJECT_TYPE_ASSIGNMENT ||
			projectConfigType===this.ROLE_ASSIGNMENT;
	},
	/**
	 * Implement this method only if the tree contains heterogeneous data (like project/project type assignments)
	 * The specific methods on tree node selection should be called in the scope of the specific implementation
	 * Return the scope of the node specific implementation
	 * Additionally the locale tree and centerPanel objects are borrowed by the specific implementations
	 * (we do not initialize own tree for each specific implementation.
	 * An initialized (not null) tree is needed for the selection methods in tree in the context of a specific implementation
	 * and the centerPanel for rendering the data corresponding to the selected node
	 */
	getSelectedNodeClass: function(node) {
		var configType = node.data["configType"];
		var id = node.data["id"];
		var branchRoot = node.data["branchRoot"];
		var projectTypeID = node.data["projectTypeID"];
		if (CWHF.isNull(configType)) {
			return this;
		}
		switch (configType) {
		case this.PROJECT_TYPE:
			return this;
		case this.STATUS_ASSIGNMENT:
		case this.PRIORITY_ASSIGNMENT:
		case this.SEVERITY_ASSIGNMENT:
			if (CWHF.isNull(this.assignment)) {
				this.assignment = Ext.create("com.trackplus.admin.TreeDetailAssignment",
					{rootID:id,
					dynamicIcons:true, reloadGrids:true});
				this.assignment.baseAction = "projectTypeListAssignments";
			}
			this.assignment.setRootID(id);
			var rootMessageKey = null;
			if (configType===this.STATUS_ASSIGNMENT) {
				rootMessageKey = "admin.customize.projectType.lbl.assignmentInfoStatusGeneral";
			} else {
				if (configType===this.PRIORITY_ASSIGNMENT) {
					rootMessageKey = "admin.customize.projectType.lbl.assignmentInfoPriorityGeneral";
				} else {
					rootMessageKey = "admin.customize.projectType.lbl.assignmentInfoSeverityGeneral";
				}
			}
			this.assignment.setRootMessage(getText(rootMessageKey));
			return this.assignment;
		case this.ISSUE_TYPE_ASSIGNMENT:
			if (CWHF.isNull(this.issueTypeAssignment)) {
				this.issueTypeAssignment = Ext.create("com.trackplus.admin.SimpleAssignment",
					{assignmentType: this.ISSUE_TYPE_ASSIGNMENT,
					assignmentTypeParameterName: "configType",
					objectIDParamName: "projectTypeID",
					dynamicIcons:true});
				this.issueTypeAssignment.baseAction = "projectTypeSimpleAssignment";
			}
			this.issueTypeAssignment.setObjectID(node.parentNode.data['id']);
			return this.issueTypeAssignment;
		case this.CHILD_PROJECT_TYPE_ASSIGNMENT:
			if (CWHF.isNull(this.childProjectTypeAssignment)) {
				this.childProjectTypeAssignment = Ext.create("com.trackplus.admin.SimpleAssignment",
					{assignmentType: this.CHILD_PROJECT_TYPE_ASSIGNMENT,
					assignmentTypeParameterName: "configType",
					objectIDParamName: "projectTypeID"});
				this.childProjectTypeAssignment.baseAction = "projectTypeSimpleAssignment";
			}
			this.childProjectTypeAssignment.setObjectID(node.parentNode.data['id']);
			return this.childProjectTypeAssignment;
		case this.ROLE_ASSIGNMENT:
			if (CWHF.isNull(this.roleAssignment)) {
				this.roleAssignment = Ext.create("com.trackplus.admin.SimpleAssignment",
					{assignmentType: this.ROLE_ASSIGNMENT,
					assignmentTypeParameterName: "configType",
					objectIDParamName: "projectTypeID"});
				this.roleAssignment.baseAction = "projectTypeSimpleAssignment";
			}
			this.roleAssignment.setObjectID(node.parentNode.data['id']);
			return this.roleAssignment;
		case this.FIELD_CONFIGURATION:
			if (CWHF.isNull(this.fieldConfig)) {
				var branchRoot = node.data['branchRoot'];
				this.fieldConfig = Ext.create("com.trackplus.admin.customize.treeConfig.FieldConfig",
						{rootID:branchRoot});
			}
			return this.fieldConfig;
		case this.SCREEN_ASSIGNMENT:
			if (CWHF.isNull(this.screenConfig)) {
				var branchRoot = node.data['branchRoot'];
				this.screenConfig = Ext.create("com.trackplus.admin.customize.treeConfig.ScreenConfig",
						{rootID:branchRoot});
			}
			return this.screenConfig;
		case this.WORKFLOW_ASSIGNMENT:
			if (CWHF.isNull(this.workflowConfig)) {
				var branchRoot = node.data['branchRoot'];
				this.workflowConfig = Ext.create("com.trackplus.admin.customize.treeConfig.WorkflowConfig",
						{rootID:branchRoot, projectOrProjectTypeID:projectTypeID});
			}
			return this.workflowConfig;
		}
	},
	/**
	 * Gets the tree's fields: all fields for all possible config types
	 */
	getTreeFields: function() {
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
				{ name : 'iconCls', mapping : 'iconCls', type: 'string'},
				{ name : 'icon', mapping : 'icon', type: 'string'},
				{ name : 'configType', mapping : 'configType', type: 'int'},
				{ name : 'projectTypeID', mapping : 'projectTypeID', type: 'int'},
				{ name : 'branchRoot', mapping : 'branchRoot', type: 'string'}];
	},
	/******************Methods strictly for project type CRUD*********************/
	getWrappedControl: function() {
		return CWHF.getWrappedControl.apply(this.centerPanel, arguments);
	},
	getHelpWrapper: function() {
		return CWHF.getHelpWrapper.apply(this.centerPanel, arguments);
	},
	/**
	 * The localized entity name
	 */
	getEntityLabel: function(extraConfig) {
		return getText('common.lbl.projectType');
	},
	/**
	 * The iconCls for the save button
	 */
	getSaveIconCls: function() {
		return 'save';
	},
	initActions: function() {
		this.actionAdd = this.createLocalizedAction(this.getTitle(this.getAddTitleKey()),
				this.getAddIconCls(), this.onAdd, this.getTitle(this.getAddTitleKey()));
		this.actionSave = this.createLocalizedAction(getText('common.btn.save'),
				this.getSaveIconCls(), this.onSave, this.getTitle('common.lbl.save'), true);
		this.actionDelete = this.createLocalizedAction(getText('common.btn.delete'),
				this.getDeleteIconCls(), this.onDelete, this.getTitle('common.lbl.delete'), true);
		this.actionImport = this.createLocalizedAction(getText('common.btn.import'), 'import', this.onImport,
			getText("common.lbl.import", getText("menu.admin.custom.projectType")),false);
		this.actionExport = this.createLocalizedAction(getText('common.btn.export'), 'export', this.onExport,
			getText("common.lbl.export", getText("menu.admin.custom.projectType")),true);
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
		    return [this.actionAdd, this.actionSave, this.actionDelete, this.actionImport,this.actionExport];
		} else {
			return [this.actionSave, this.actionExport];
		}
	},
	/**
	 * Prepare the form for adding a new projectType
	 */
	onAdd: function() {
		this.tree.getSelectionModel().deselectAll(true);
		var node = this.getSingleSelectedRecord(true);
		this.loadDetailPanelWithFormLoad(node, true);
		this.actionSave.setDisabled(false);
	},
	/**
	 * Save the detail part
	 */
	onSave: function() {
		this.centerPanel.getForm().submit({
			url: this.getBaseAction() + '!save.action',
			params: this.getSubmitParams(true),
			scope: this,
			success: function(form, action) {
				var result = action.result;
				if (result.success) {
					CWHF.showMsgInfo(getText('admin.customize.projectType.successSave'));
					//this.actionSave.setDisabled(true);
					this.reload(result);
				} else {
					CWHF.showMsgError(getText('admin.customize.projectType.errorSave'));
					errorHandlerSave(result);
				}
			},
			failure: function(form, action) {
				CWHF.showMsgError(getText('admin.customize.projectType.errorSave'));
				//com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	},
	/**
	 * Extra parameters for editing a project type
	 */
	getSubmitParams: function(fromTree) {
		var record = this.getSingleSelectedRecord(fromTree);
		var recordData = null;
		var nodeID = null;
		if (record) {
			recordData = record.data;
			if (fromTree) {
				nodeID = recordData['id'];
			} else {
				nodeID = recordData['node'];
			}
		}
		//var params = this.getTypeParam(record, fromTree);
		var params = new Object();
		if (nodeID) {
			params['node']=nodeID;
		}
		return params;
	},
	onDelete: function() {
		var selectedRecords = this.getSelectedRecords(true);
		if (selectedRecords) {
			var extraConfig = {fromTree:true, isLeaf:false};
			this.deleteHandler(selectedRecords, extraConfig);
		}
	},
	onImport: function() {
		var submit = [{submitUrl:"projectType!importProjectTypes.action",
			submitButtonText:getText('common.btn.upload'),
			validateHandler: Upload.validateUpload,
			expectedFileType: /^.*\.(xml)$/,
			refreshAfterSubmitHandler:this.reload}];
		var title = getText('common.lbl.upload', getText('admin.customize.mailTemplate.lbl.uploadFile'));
		var windowParameters = {title:title,
			width:500,
			height:200,
			submit:submit,
			formPanel: this.getImportPanel(),
			cancelButtonText: getText('common.btn.done')};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	onExport: function() {
		var selectedRecords = this.getSelectedRecords(true);
		if (selectedRecords) {
			var projectTypeID = selectedRecords.data['id'];
			var submit = [{
				submitHandler:this.doExport,
				submitButtonText:getText('common.btn.export')
			}];
			var title = getText("common.lbl.export", getText("menu.admin.custom.projectType"));
			var windowParameters = {
				title:title,
				width:500,
				height:200,
				submit:submit,
				formPanel: this.getExportPanel(),
				cancelButtonText: getText('common.btn.cancel')};
			var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
			windowConfig.showWindowByConfig(this);
			return true;
		}
	},
	doExport:function(win, submitUrl, submitUrlParams, extraConfig){
		var selectedRecords = this.getSelectedRecords(true);
		var projectTypeID = selectedRecords.data['id'];
		var includeGlobal=this.checkIncludeGlobal.getInputComponent().getValue();
		win.close();
		var urlStr=this.getBaseAction() + '!export.action?projectTypeID='+projectTypeID+'&includeGlobal='+includeGlobal;
		window.open(urlStr);
	},
	getImportPanel:function() {
		var me=this;
		this.formPanel= new Ext.form.FormPanel({
			region:'center',
			border:false,
			bodyStyle: 'padding:5px',
			defaults: {
				labelStyle:'overflow: hidden;',
				margin:"5 5 0 0",
				msgTarget:	'under',
				anchor:	'-20'
			},
			method: 'POST',
			fileUpload: true,
			items: [
				CWHF.createCheckbox('common.lbl.overwriteExisting', 'overwriteExisting', {labelWidth:200}),
				CWHF.createFileField('common.lbl.attachment.file', 'uploadFile',
					{itemId:"uploadFile", allowBlank:false, labelWidth:200})]
		});
		return this.formPanel;
	},
	getExportPanel:function(){
		var me=this;
		var selectedRecords = this.getSelectedRecords(true);
		this.checkIncludeGlobal=CWHF.createCheckboxWithHelp('admin.customize.projectType.lbl.includeGlobal', 'includeGlobal', {labelWidth:200,width:250});
		this.formPanelExport= new Ext.form.FormPanel({
			region:'center',
			border:false,
			bodyStyle: 'padding:5px',
			defaults: {
				labelStyle:'overflow: hidden;',
				margin:"5 5 0 0",
				msgTarget:	'under',
				anchor:	'-20'
			},
			method: 'POST',
			items: [
				CWHF.createLabelComponent('common.lbl.projectType', null,{labelWidth:200,value:selectedRecords.data['text']}),
				this.checkIncludeGlobal
			]
		});
		return this.formPanelExport;
	},
	reload: com.trackplus.util.RefreshAfterSubmit.refreshSimpleTree,/*function(refreshParamsObject) {
		var nodeID = refreshParamsObject.node;
		var reloadTree = refreshParamsObject.reloadTree;
		if (reloadTree) {
			//tree reload is needed: after delete, add and edit with label change
			var treeStore = this.tree.getStore();
			var options = {};
			if (CWHF.isNull(nodeID) && treeStore.getRootNode().hasChildNodes()) {
				var firstNode = treeStore.getRootNode().getChildAt(0);
				if (firstNode) {
					var selectedNodeID = null;
					if (this.selectNode) {
						selectedNodeID = this.selectedNode.get("id");
					}
					nodeID = firstNode.get("id");
					if (nodeID===selectedNodeID) {
						var secondNode = treeStore.getRootNode().getChildAt(1);
						if (secondNode) {
							nodeID = secondNode.get("id");
						}
					}
				}
			}
			if (nodeID) {
				options.callback = this.selectNode;
				options.scope = {tree:this.tree, nodeIdToSelect:nodeID}
			} else {
				//no node to select disable save and delete
				this.actualizeToolbarOnTreeSelect();
			}
			treeStore.load(options);
		} else {
			//edit without label change
			this.selectNode.call({tree:this.tree, nodeIdToSelect:nodeID});
		}
	},*/
	getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		return {reloadTree:true}
	},
	/**
	 * Get the array of toolbar actions for a tree node select
	 * Implement only if replaceToolbarOnTreeNodeSelect is true
	 */
	getToolbarActionsForTreeNodeSelect: function(selectedNode) {
		if (selectedNode) {
			this.actionSave.setDisabled(false);
			var projectTypeID = selectedNode.data['projectTypeID'];
			if (projectTypeID && projectTypeID<0) {
				//do not delete the private project type
				this.actionDelete.setDisabled(true);
				this.actionExport.setDisabled(true);
			} else {
				this.actionDelete.setDisabled(false);
				this.actionExport.setDisabled(false);
			}
		} else {
			this.actionSave.setDisabled(true);
			this.actionDelete.setDisabled(true);
			this.actionExport.setDisabled(true);
		}
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			return [this.actionAdd, this.actionSave, this.actionDelete, this.actionImport, this.actionExport];
		} else {
			return [this.actionSave,this.actionExport];
		}
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	getDetailUrl: function(node, add) {
		return this.getBaseAction() + '!edit.action';
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	getDetailParams: function(node, add) {
		var params = new Object();
		if (node) {
			nodeID = node.data['id'];
			params['node']=nodeID;
		}
		params['add'] = add;
		return params;
	},
	/**
	 * Gets the project type items
	 */
	getDetailItems: function(node, add) {
		var projectTypeID = null;
		if (node) {
			projectTypeID = node.data['projectTypeID'];
		}
		var hideDetail = !add && projectTypeID && projectTypeID<0;
		var items = [CWHF.createTextField('common.lbl.name', 'projectTypeTO.label',
			{allowBlank:false, labelWidth:this.labelWidth, width:this.textFieldWidth})];
		if (!hideDetail) {
			items.push(CWHF.createComboWithHelp('admin.customize.projectType.lbl.projectTypeFlag',
					'projectTypeTO.projectTypeFlag', {itemId: 'projectTypeFlag', labelWidth:this.labelWidth}));
			items.push(CWHF.createCheckboxWithHelp('admin.customize.projectType.lbl.enableRelease', 'projectTypeTO.useReleases'));
			items.push(CWHF.createCheckboxWithHelp('admin.customize.projectType.lbl.enableVersionControl','projectTypeTO.useVersionControl'));
		}
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			items.push(CWHF.createCheckboxWithHelp('admin.customize.projectType.lbl.enableAccounting', 'projectTypeTO.useAccounts',
					null, {change: {fn: this.onAccountingChange, scope:this}}));
			items.push(CWHF.createNumberFieldWithHelp('common.lbl.hoursPerWorkday',
					'projectTypeTO.hoursPerWorkday', 2, 0, 24,
					{labelWidth:this.labelWidth, width:this.textFieldWidthShort, itemId:'projectTypeTOHoursPerWorkday'}));
			items.push(CWHF.createComboWithHelp('admin.project.lbl.defaultWorkUnit',
					'projectTypeTO.defaultWorkUnit', {itemId: 'defaultWorkUnit',labelWidth:this.labelWidth}));
			items.push(CWHF.createTextFieldWithHelp("admin.project.lbl.currencyName", "projectTypeTO.currencyName",
					{labelWidth:this.labelWidth, width:this.textFieldWidthShort,itemId:'projectTypeTOCurrencyName'}));
			items.push(CWHF.createTextFieldWithHelp("admin.project.lbl.currencySymbol", "projectTypeTO.currencySymbol",
					{labelWidth:this.labelWidth, width:this.textFieldWidthShort,itemId:'projectTypeTOCurrencySymbol'}));
			if (com.trackplus.TrackplusConfig.appType !== APPTYPE_DESK) {
				items.push(CWHF.createCheckboxWithHelp("admin.customize.projectType.lbl.enableMsProjectExportImport",
						"projectTypeTO.useMsProjectExportImport", {labelWidth:this.labelWidth, width:this.textFieldWidthShort}));
			}
		}
		return [//preserve the add flag through a hidden parameter
		        {xtype:'hidden',
				name: 'add',
				value: add
				},
				{xtype: 'fieldset',
				itemId: 'projectTypeFS',
				width: this.FieldSetWidth,
				style:{marginTop: '6px'},
				title: getText('admin.customize.projectType.fieldset'),
				items:items
				}];
		},
		onAccountingChange: function(field, newValue, oldValue, options) {
			var enableAccounting = field.getValue();
			this.enableAccountingFields(enableAccounting);
		},
		enableAccountingFields: function(enableAccounting) {
			this.getHelpWrapper("projectTypeFS", "projectTypeTOHoursPerWorkday").setDisabled(!enableAccounting);
			this.getHelpWrapper("projectTypeFS", "defaultWorkUnit").setDisabled(!enableAccounting);
			this.getHelpWrapper("projectTypeFS", "projectTypeTOCurrencyName").setDisabled(!enableAccounting);
			this.getHelpWrapper("projectTypeFS", "projectTypeTOCurrencySymbol").setDisabled(!enableAccounting);
		},
		/**
		 * The method to process the data to be loaded arrived from the server
		 */
		getEditPostDataProcess: function(record, isLeaf, add) {
			return this.postDataLoadCombo;
		},
		/**
		 * Load the combos after the result has arrived containing also the combo data sources
		 */
		postDataLoadCombo: function(data, panel) {
			var projectTypeFlag = this.getWrappedControl("projectTypeFS", "projectTypeFlag");
			if (projectTypeFlag) {
				projectTypeFlag.store.loadData(data['projectTypeFlagList']);
				projectTypeFlag.setValue(data['projectTypeTO.projectTypeFlag']);
			}
			var projectTypeFlag = this.getWrappedControl("projectTypeFS", "defaultWorkUnit");
			if (projectTypeFlag) {
				projectTypeFlag.store.loadData(data['workUnitList']);
				projectTypeFlag.setValue(data['projectTypeTO.defaultWorkUnit']);
			}
			//if (CWHF.isNull(data["forPrivateProjects"]) || data["forPrivateProjects"]===false) {
				this.enableAccountingFields(data["projectTypeTO.useAccounts"]);
			//}
		}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.customize.role.Role", {
	extend : "com.trackplus.admin.GridBase",
	xtype: "role",
    controller: "role",
	columns : [
	        {
	            text : getText('admin.customize.role.lbl.role'),
	            width : 175,
	            dataIndex : 'name',
	            id : 'name',
	            sortable : true,
	            filter: {
		            type: "string"
		        }
	        },
	        {
	            xtype : 'templatecolumn',
	            text : getText('admin.customize.role.lbl.accessFlags'),
	            tpl : new Ext.XTemplate(
	                    '<table><tr>',
	                    '<td valign="top">',
	                    '<tpl for="accessFlags.fullAccessFlags">',
	                    '<div><input type="checkbox" disabled="disabled"  style="vertical-align: middle; margin: 0px;" ',
	                    '<tpl if="selected">', 'checked="true"', '</tpl>',
	                    'value="true"/> {label}</div>', '</tpl>', '</td>', '</tr></table>'),
	            width : 175,
	            sortable : false
	        },
	        {
	            xtype : 'templatecolumn',
	            text : getText('admin.customize.role.lbl.inSelections'),
	            tpl : new Ext.XTemplate(
	                    '<table><tr>',
	                    '<td valign="top">',
	                    '<tpl for="accessFlags.raciRoles">',
	                    '<div><input type="checkbox" disabled="disabled"  style="vertical-align: middle; margin: 0px;" ',
	                    '<tpl if="selected">', 'checked="true"', '</tpl>',
	                    'value="true"/> {label}</div>', '</tpl>', '</td>', '</tr>', '</table>'),
	            width : 175,
	            sortable : false
	        },
	        {
	            xtype : 'templatecolumn',
	            text : getText('admin.customize.role.lbl.allowedListTypes'),
	            tpl : new Ext.XTemplate('<table>', '<tpl for="issueTypesAssigned">',
	                    '<tr><td><img src="optionIconStream.action?fieldID=-2&optionID={id}"></td>',
	                    '<td style="padding:2px">{label}</td></tr>', '</tpl>', '</table>'
	            ),
	            width : 175,
	            sortable : false
	        },
	        {
	            xtype : 'templatecolumn',
	            text : getText('admin.customize.role.fieldsRestrictions.lbl.hiddenFields'),
	            tpl : new Ext.XTemplate('<table>', '<tpl for="noReadFields">',
	                    '<td style="padding:2px">{label}</td></tr>', '</tpl>', '</table>'),
	            width : 175,
	            sortable : false
	        },
	        {
	            xtype : 'templatecolumn',
	            text : getText('admin.customize.role.fieldsRestrictions.lbl.readOnlyFields'),
	            tpl : new Ext.XTemplate('<table>', '<tpl for="noEditFields">',
	                    '<td style="padding:2px">{label}</td></tr>', '</tpl>', '</table>'),
	            width : 175,
	            sortable : false
	        }
	],
	initComponent : function() {
		this.fields = [{
				    name : 'id',
				    type : 'int'
					}, {
				    name : 'name',
				    type : 'string'
					}, {
				    name : 'accessFlags'
					}, {
				    name : 'issueTypesAssigned'
					}, {
				    name : 'noReadFields'
					}, {
				    name : 'noEditFields'
					}],
		this.storeUrl = "roleView!loadRoles.action";
		this.callParent();
	},
	actionIssueTypes : null,
	actionFieldsRestictions : null,
	//chekListPanel : null,
	checkList : null,
	panelGrids : null,
	gridNoAccessSelected : null,
	gridAssignedSelected : null,
	getEntityLabel : function() {
	    return getText("admin.customize.role.lbl");
	},
	initActions : function() {
	    this.callParent();
	    var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	        this.actionIssueTypes = CWHF.createAction("common.btn.issueType", "issueTypeLock",
	                "onAssignIssueType", {tooltip:getText("admin.customize.role.issueTypeToRole.lbl.explanation"), disabled:true});
	        this.actionFieldsRestictions = CWHF.createAction(
	                "admin.customize.role.lbl.fieldsRestrictions", "fieldsRestrictions",
	                "onFieldsRestrictions", {tooltip:getText("admin.customize.role.fieldsRestrictions.lbl.explanation"), disabled:true});
	        this.actions = [ this.actionAdd, this.actionEdit, this.actionCopy, this.actionIssueTypes,
	                this.actionFieldsRestictions, this.actionDelete ];
	    } else {
	        // the project admins have read only right on roles
	        this.actions = [];
	    }
	},
	/**
	 * Handler for double click
	 */
	onItemDblClick : function(view, record) {
	    var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	        return this.callParent(arguments);
	    } else {
	        return [];
	    }
	},
	onGridSelectionChange : function(view, selections) {
	    var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	        if (CWHF.isNull(selections) || selections.length === 0) {
	            // no selection
	            this.actionDelete.setDisabled(true);
	            this.actionEdit.setDisabled(true);
	            this.actionCopy.setDisabled(true);
	            this.actionIssueTypes.setDisabled(true);
	            this.actionFieldsRestictions.setDisabled(true);
	        } else {
	            this.actionDelete.setDisabled(false);
	            this.actionEdit.setDisabled(false);
	            this.actionCopy.setDisabled(false);
	            this.actionIssueTypes.setDisabled(false);
	            this.actionFieldsRestictions.setDisabled(false);
	        }
	    }
	},
	/**
	 * Get the actions available in context menu depending on
	 * the currently selected row
	 */
	getGridContextMenuActions : function(selectedRecords, selectionIsSimple) {
	    var sys = com.trackplus.TrackplusConfig.user.sys;
	    var actions = [];
	    if (sys) {
	        if (selectionIsSimple) {
	            actions.push(this.actionEdit);
	            actions.push(this.actionCopy);
	            actions.push(this.actionIssueTypes);
	            actions.push(this.actionFieldsRestictions);
	        }
	        actions.push(this.actionDelete);
	    }
	    return actions;
	},
	/**
	 * The iconCls for the add button, overwrites base class
	 * icon
	 */
	/* protected */getAddIconCls : function() {
	    return 'rolesAdd';
	},
	/**
	 * The iconCls for the edit button, overwrites base class
	 * icon
	 */
	/* protected */getEditIconCls : function() {
	    return 'rolesEdit';
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.customize.role.RoleController", {
	extend: "Ext.app.ViewController",
	alias: "controller.role",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction:"roleView",
	entityID:"roleID", 
	editWidth : 520,
	editHeight : 335,
	checkListPanel : null,
	panelGrids : null,
	gridNoAccessSelected : null,
	gridAssignedSelected : null,
	createEditForm : function(entityJS, type) {
	    this.checkListPanel = Ext.create('Ext.panel.Panel', {
	        border : false,
	        bodyBorder : false,
	        autoScroll : true,
	        style : {
	            border : 'none',
	            background : 'none'
	        },
	        layout : {
	            type : 'table',
	            columns : 2,
	            tableAttrs : {
	                style : {
	                    width : '100%'
	                }
	            },
	            tdAttrs : {
	                width : '50%',
	                style : {
	                    'vertical-align' : 'top'
	                }
	            }
	        },
	        defaults : {
	            frame : false,
	            border : false
	        },
	        anchor : '100%',
	        items : []
	    });
	    return new Ext.form.FormPanel({
	        url : 'roleSave.action',
	        labelWidth : 130,
	        region : 'center',
	        border : false,
	        autoScroll : true,
	        margin : '0 0 0 0',
	        bodyStyle : {
	            padding : '10px'
	        },
	        /*
			 * style:{ borderBottom:'1px solid #D0D0D0' },
			 */
	        defaultType : 'textfield',
	        items : [ CWHF.createTextField("admin.customize.role.lbl.role", "label", {
	            anchor : '100%',
	            allowBlank : false,
	            labelWidth : 80,
	            labelAlign : "left"
	        }), this.checkListPanel ]
	    });
	},
	afterLoadForm : function(data) {
	    var me = this;
	    me.checkListPanel.removeAll();
	    me.chekList = new Array();
	    var chekListFull = new Array();
	    for (var i = 0; i < data.fullAccessFlags.length; i++) {
	        var flag = data.fullAccessFlags[i];
	        chekListFull.push(Ext.create('Ext.form.field.Checkbox', {
	            boxLabel : flag.label,
	            checked : flag.selected,
	            name : 'f' + flag.id,
	            inputValue : 'true'
	        }));
	    }
	    var fieldSetFullAccess = Ext.create('Ext.form.FieldSet', {
	        title : getText('admin.customize.role.lbl.generalAccess'),
	        defaultType : 'checkbox', // each item will be a
										// checkbox
	        layout : 'anchor',
	        items : chekListFull,
	        margin : '5 15 5 0'
	    });
	    var chekListRaciRole = new Array();
	    for (var i = 0; i < data.raciRoles.length; i++) {
	        var flag = data.raciRoles[i];
	        chekListRaciRole.push(Ext.create('Ext.form.field.Checkbox', {
	            boxLabel : flag.label,
	            checked : flag.selected,
	            name : 'f' + flag.id,
	            inputValue : 'true'
	        }));
	    }
	    var fieldSetRaciRoles = Ext.create('Ext.form.FieldSet', {
	        title : getText('admin.customize.role.lbl.raci'),
	        defaultType : 'checkbox', // each item will be a
										// checkbox
	        layout : 'anchor',
	        items : chekListRaciRole,
	        margin : '5 0 5 0'
	    });
	    for (var i = 0; i < chekListFull.length; i++) {
	        me.chekList.push(chekListFull[i]);
	    }
	    for (var i = 0; i < chekListRaciRole.length; i++) {
	        me.chekList.push(chekListRaciRole[i]);
	    }
	    me.checkListPanel.add(fieldSetFullAccess);
	    me.checkListPanel.add(fieldSetRaciRoles);
	    me.checkListPanel.updateLayout();
	},
	preSubmitProcess : function(submitUrlParams, panel) {
	    var me = this;
	    var NUMBER_OF_ACCESS_FLAGS = 21;
	    var accessFlags = new Array(21);
	    for (var i = 0; i < accessFlags.length; i++) {
	        accessFlags[i] = 0;
	    }
	    if (me.chekList ) {
	        for (var i = 0; i < me.chekList.length; i++) {
	            var index = me.chekList[i].getName().substring(1);
	            if (me.chekList[i].getRawValue() === true) {
	                accessFlags[index] = 1;
	                // extendedAccessKey+='1';
	            } else {
	                accessFlags[index] = 0;
	                // extendedAccessKey+='0';
	            }
	        }
	    }
	    var extendedAccessKey = "";
	    for (var i = 0; i < accessFlags.length; i++) {
	        if (accessFlags[i] === 1) {
	            extendedAccessKey += '1';
	        } else {
	            extendedAccessKey += '0';
	        }
	    }
	    submitUrlParams['extendedAccessKey'] = extendedAccessKey;
	    return submitUrlParams;
	},
	createFieldRestrictionsForm : function(roleID) {
	    var explanation = {
	        region : 'north',
	        xtype : 'component',
	        cls : 'infoBox_bottomBorder',
	        border : true,
	        html : getText('admin.customize.role.fieldsRestrictions.lbl.explanation')
	    };
	    // grid fields
	    var roleFields = [ {
	        name : 'id',
	        mapping : 'id',
	        type : 'string'
	    }, {
	        name : 'objectID',
	        mapping : 'objectID',
	        type : 'int'
	    }, {
	        name : 'fieldLabel',
	        mapping : 'fieldLabel',
	        type : 'string'
	    }, {
	        name : 'hidden',
	        mapping : 'hidden',
	        type : 'boolean'
	    }, {
	        name : 'forcedReadOnly',
	        mapping : 'forcedReadOnly',
	        type : 'boolean'
	    }, {
	        name : 'configuredReadOnly',
	        mapping : 'configuredReadOnly',
	        type : 'boolean'
	    } ];
	    // grid columns
	    var roleFieldColumns = [
	            {
	                text : getText('common.lbl.field'),
	                menuDisabled : true,
	                dataIndex : 'fieldLabel',
	                flex : 3
	            },
	            {
	                text : getText('admin.customize.role.fieldsRestrictions.lbl.hide')
	                        + '&nbsp;<input type="checkbox" id="hidden">',
	                menuDisabled : true,
	                dataIndex : 'hidden',
	                flex : 2,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.role.fieldsRestrictions.lbl.readOnly')
	                        + '&nbsp;<input type="checkbox" id="configuredReadOnly">',
	                menuDisabled : true,
	                dataIndex : 'configuredReadOnly',
	                flex : 2,
	                xtype : 'checkcolumn',
	                renderer : function(val, m, rec) {
	                    if (rec.get('forcedReadOnly')) {
	                        return "";
	                    } else {
	                        return (new Ext.ux.CheckColumn()).renderer(val, m, rec);
	                    }
	                }
	            } ];
	    // detail store
	    this.roleFieldGridStore = new Ext.data.Store({
	        proxy : {
	            type : 'ajax',
	            api : {
	                read : 'fieldsRestrictionsToRole!edit.action',
	                update : 'fieldsRestrictionsToRole!save.action'
	            },
	            extraParams : {
	                // extraParams by read
	                roleID : roleID
	            },
	            reader : {
	                type : 'json',
	                rootProperty : 'records'
	            },
	            writer : {
	                type : 'json',
	                allowSingle : false,
	                writeAllFields : true,
	                root : 'records',
	                encode : true
	            }
	        },
	        fields : roleFields,
	        remoteSort : true,
	        idProperty : 'id',
	        successProperty : 'success',
	        autoSync : false,
	        listeners : {
	            /*load : {
	                scope : this,
	                fn : function(store, records) {
	                    var rawData = store.getProxy().getReader().rawData;
	                    var toolbar = this.win.getDockedItems('toolbar[dock="bottom"]');
	                    // the first one is the save button
	                    toolbar[0].getComponent(0).setDisabled(rawData.disabled);
	                    for (i = 1; i <= 2; i++) {
	                        var column = this.getColumnByIndex(i);
	                        var checkBox = document.getElementById(column);// Ext.get(column);
	                        checkBox.checked = rawData[column];
	                    }
	                }
	            },*/
	            beforesync : function() {
	                // Grid data is changed.
	                // Label might be changed or not, anyway
					// send it to the server
	                this.getProxy().extraParams = {
	                    // extraParams by update
	                    roleID : roleID
	                }
	            },
	            datachanged : {
	                scope : this,
	                fn : function(store, opts) {
	                    // Grid data is changed
	                    // Label might be changed or not: to be
						// sure load the store again
	                    this.reload.call(this);
	                }
	            }
	        }
	    });
	    var roleFieldsGrid = {
	        xtype : 'grid',
	        itemId : 'detailGrid',
	        columns : roleFieldColumns,
	        sortableColumns : false,
	        draggable : false,
	        store : this.roleFieldGridStore,
	        border : false,
	        bodyBorder : false,
	        loadMask : true,
	        stripeRows : true,
	        region : 'center',
	        style : {
	            borderTop : '1px solid #D0D0D0'
	        },
	        viewConfig : {
	            forceFit : true
	        },
	        listeners : {
	            afterrender : {
	                fn : function() {
	                    for (i = 1; i <= 2; i++) {
	                        var column = this.getColumnByIndex(i);
	                        var checkBox = Ext.get(column);
	                        checkBox.addListener('click', this.headerChkHandler, this, {
	                            column : column
	                        });
	                    }
	                },
	                scope : this
	            }
	        },
	        plugins : [ Ext.create('Ext.grid.plugin.CellEditing', {
	            clicksToEdit : 1
	        }) ]
	    };
	    // detailGridStore.load();
	    return new Ext.panel.Panel({
	        border : false,
	        layout : 'border',
	        autoScroll : true,
	        margin : '0 0 0 0',
	        bodyStyle : {
	            padding : '0px'
	        },
	        /*
			 * style:{ borderBottom:'1px solid #D0D0D0' },
			 */
	        items : [ explanation, roleFieldsGrid ]
	    });
	},
	getColumnByIndex : function(index) {
	    switch (index) {
	    case 1:
	        return "hidden";
	    case 2:
	        return "configuredReadOnly";
	    }
	},
	headerChkHandler : function(event, chkBox, options) {
	    var checked = chkBox.checked;
	    var numberOfRecords = this.roleFieldGridStore.getTotalCount();
	    var column = options.column;
	    for (i = 0; i < numberOfRecords; i++) {
	        var record = this.roleFieldGridStore.getAt(i);
	        record.set(column, checked);
	    }
	},
	onFieldsRestrictions : function() {
	    var entityJS = null;
	    var selections = this.getView().getSelectionModel().getSelection();
	    if (selections.length === 1) {
	        entityJS = selections[0].data;
	    }
	    if (CWHF.isNull(entityJS)) {
	        return true;
	    }
	    var roleID = entityJS.id;
	    var load = {
	        loadHandler : this.loadRoleFieldsHandler
	    };
	    var submit = {
	        submitHandler : this.submitRoleFieldsHandler
	    };
	    var title = getText('admin.customize.role.fieldsRestrictions.lbl.header') + ' "'
	            + entityJS.name + '"';
	    var windowConfig = Ext.create('com.trackplus.util.WindowConfig', {
	        title : title,
	        width : 400,
	        height : 500,
	        load : load,
	        submit : submit,
	        formPanel : this.createFieldRestrictionsForm(roleID)
	    /*
		 * , postDataProcess:me.afterLoadForm,
		 * preSubmitProcess:me.preSubmitProcess
		 */});
	    windowConfig.showWindowByConfig(this);
	},
	/**
	 * Not a form panel load
	 */
	loadRoleFieldsHandler : function() {
	    this.roleFieldGridStore.load();
	},
	/**
	 * Not a form panel submit
	 */
	submitRoleFieldsHandler : function(win, submitUrl, submitUrlParams) {
	    var records = this.roleFieldGridStore.getUpdatedRecords();
	    if (records  && records.length > 0) {
	        // at least a record was changed
	        // the label might be changed or not
	        this.roleFieldGridStore.sync();
	    }
	    this.win.close();
	},
	onAssignIssueType : function(entityJS) {
	    var me = this;
	    var entityJS = null;
	    var selections = me.getView().getSelectionModel().getSelection();
	    if (selections.length === 1) {
	        entityJS = selections[0].data;
	    }
	    if (CWHF.isNull(entityJS)) {
	        return true;
	    }
	    var title = getText('admin.customize.role.issueTypeToRole.lbl.header') + ' "' + entityJS.name
	            + '"';
	    var northPanel = {
	        region : 'north',
	        xtype : 'component',
	        cls : 'infoBox_bottomBorder',
	        border : true,
	        html : getText('admin.customize.role.issueTypeToRole.lbl.explanation')
	    };
	    me.panelGrids = me.createPanelIssueTypeAssign(entityJS.id);
	    var issueTypeWin = Ext.create('Ext.window.Window', {
	        layout : 'border',
	        width : 500,
	        height : 350,
	        minWidth : 425,
	        closeAction : 'destroy',
	        title : title,
	        modal : true,
	        items : [ northPanel, me.panelGrids ],
	        cls : 'bottomButtonsDialog',
	        border : false,
	        bodyBorder : false,
	        margin : '0 0 0 0',
	        style : {
	            padding : '0px'
	        },
	        bodyPadding : '0px',
	        buttons : [ {
	            text : getText('common.btn.done'),
	            handler : function() {
	                issueTypeWin.hide();
	                issueTypeWin.destroy();
	                me.getView().store.load();
	            }
	        } ]
	    });
	    issueTypeWin.show();
	    me.reloadAssigned('issueTypeToRole.action?roleID=' + entityJS.id);
	},
	reloadAssigned : function(urlStr, params, loading) {
	    var me = this;
	    var useLoading = true;
	    if (loading === false) {
	        useLoading = false;
	    }
	    me.panelGrids.setLoading(useLoading);
	    Ext.Ajax.request({
	        url : urlStr,
	        params : params,
	        disableCaching : true,
	        success : function(result) {
	            var jsonData = Ext.decode(result.responseText);
	            if (jsonData.success === true) {
	                me.gridNoAccessSelected.store.loadData(jsonData.data["noAccess"], false);
	                me.gridAssignedSelected.store.loadData(jsonData.data["assiged"], false);
	            } else {
	                var errorCode = jsonData.errorCode;
	                var errorMessage = jsonData.errorMessage;
	                alert("failure" + errorMessage);
	            }
	            me.panelGrids.setLoading(false);
	        },
	        failure : function(result) {
	            var jsonData = Ext.decode(result.responseText);
	            var errorCode = jsonData.errorCode;
	            var errorMessage = jsonData.errorMessage;
	            alert("failure" + errorMessage);
	            me.panelGrids.setLoading(false);
	        }
	    // method:
	    // form:addItemConfig.addFormName
	    });
	},
	renderFieldTypeIcon : function(val) {
	    return "";
	},
	renderIssueTypeIcon : function(val) {
	    if (CWHF.isNull(val) || val === "") {
	        return "";
	    }
	    return '<img src="optionIconStream.action?fieldID=-2&optionID=' + val + '">';
	},
	createPanelIssueTypeAssign : function(roleID) {
	    var me = this;
	    var firstGridStore = Ext.create('Ext.data.Store', {
	        fields : [ {
	            name : 'id',
	            type : 'int'
	        }, {
	            name : 'label',
	            type : 'string'
	        }, {
	            name : 'symbol',
	            type : 'string'
	        } ],
	        data : []
	    });
	    var columns = [ {
	        text : "symbol",
	        width : 30,
	        sortable : true,
	        dataIndex : 'id',
	        renderer : me.renderIssueTypeIcon
	    }, {
	        text : "Name",
	        flex : 1,
	        sortable : true,
	        dataIndex : 'label'
	    } ];
	    me.gridNoAccessSelected = Ext.create('Ext.grid.Panel', {
	        viewConfig : {
	            plugins : {
	                ptype : 'gridviewdragdrop',
	                dragGroup : 'firstGridDDGroup',
	                dropGroup : 'secondGridDDGroup'
	            },
	            listeners : {
	                drop : function(node, data, dropRec, dropPosition) {
	                    if (data  && data.records  && data.records.length > 0) {
	                        var id = data.records[0].data.id;
	                        var params = new Object();
	                        params['assignedSelected'] = id;
	                        me.reloadAssigned('issueTypeToRole!unassign.action?roleID=' + roleID,
	                                params, false);
	                    }
	                }
	            }
	        },
	        store : firstGridStore,
	        columns : columns,
	        stripeRows : true,
	        title : getText('admin.customize.role.issueTypeToRole.lbl.unassigned'),
	        hideHeaders : true,
	        border : false,
	        bodyBorder : false,
	        cls : 'gridNoBorder',
	        style : {
	            borderBottom : '1px solid #D0D0D0'
	        }
	    });
	    var secondGridStore = Ext.create('Ext.data.Store', {
	        fields : [ {
	            name : 'id',
	            type : 'int'
	        }, {
	            name : 'label',
	            type : 'string'
	        }, {
	            name : 'symbol',
	            type : 'string'
	        } ],
	        data : []
	    });
	    // create the destination Grid
	    me.gridAssignedSelected = Ext.create('Ext.grid.Panel', {
	        viewConfig : {
	            plugins : {
	                ptype : 'gridviewdragdrop',
	                dragGroup : 'secondGridDDGroup',
	                dropGroup : 'firstGridDDGroup'
	            },
	            listeners : {
	                drop : function(node, data, dropRec, dropPosition) {
	                    if (data  && data.records  && data.records.length > 0) {
	                        var id = data.records[0].data.id;
	                        var params = new Object();
	                        params['noAccessSelected'] = id;
	                        me.reloadAssigned('issueTypeToRole!assign.action?roleID=' + roleID, params,
	                                false);
	                    }
	                }
	            }
	        },
	        store : secondGridStore,
	        columns : columns,
	        stripeRows : true,
	        title : getText('admin.customize.role.issueTypeToRole.lbl.assigned'),
	        hideHeaders : true,
	        border : false,
	        bodyBorder : false,
	        cls : 'gridNoBorder',
	        style : {
	            borderLeft : '1px solid #D0D0D0',
	            borderBottom : '1px solid #D0D0D0'
	        }
	    });
	    // Simple 'border layout' panel to house both grids
	    var displayPanel = Ext.create('Ext.Panel', {
	        region : 'center',
	        margin : '0 0 0 0',
	        border : false,
	        bodyBorder : false,
	        layout : {
	            type : 'hbox',
	            align : 'stretch'
	        },
	        defaults : {
	            flex : 1
	        }, // auto stretch
	        items : [ me.gridNoAccessSelected, me.gridAssignedSelected ]
	    });
	    return displayPanel;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.admin.server={};
com.trackplus.admin.adminEntityWin=null;
com.trackplus.admin.sections=new Object();
com.trackplus.admin.lastSelectedSection=null;
com.trackplus.admin.lastSelectedNode=null;
com.trackplus.admin.createAdminWestPanel=function(initData){
	var admin_westPanel= new Ext.create('Ext.panel.Panel', {
		region:'west',
		layout: 'accordion',
		width:200,
		border: false,
		split:true,
		//collapsible: true,
		collapseMode : 'mini',
		//baseCls:'x-plain',
		//margins: '0 0 0 0',
		//margins:'0 -5 0 0',
		defaults:{
			border:false
		},
		cls:'west-accordion'
	});
	var items=new Array();
	//myPreferencesSection always present even for external user
	items.push(com.trackplus.admin.getMyPreferencesSection());
	if (com.trackplus.TrackplusConfig.user.projectAdmin ||
			com.trackplus.TrackplusConfig.user.privateWorkspace) {
		//projects section allowed project administrators and end users with private workspace
		items.push(com.trackplus.admin.getProjectsSection(initData, false));
	}
	if (com.trackplus.TrackplusConfig.user.sys) {
		//users section visible only for system administrators
		items.push(com.trackplus.admin.getUsersSection());
	}
	//
	var customizationSection = com.trackplus.admin.getCustomizationSection();
	if (customizationSection) {
		//customization section is available for each non-external user
		//but not all customization items are available to all users
		items.push(customizationSection);
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
			com.trackplus.TrackplusConfig.user.actions) {
		//action section
		items.push(com.trackplus.admin.getActionSection());
	}
	if (com.trackplus.TrackplusConfig.user.sysAdmin) {
		//server section available only for system administrators
		items.push(com.trackplus.admin.getServerSection());
	}
	admin_westPanel.add(items);
	return admin_westPanel;
};
com.trackplus.admin.sectionSelectHandler=function(p,treeComponent){
	var sectionSelected=p.id;
	var lastSelectedSection=com.trackplus.admin.lastSelectedSection;
	var lastSelectedNode=com.trackplus.admin.lastSelectedNode;
	var treeCmp=null;
	if(treeComponent){
		treeCmp=treeComponent;
	}else{
		treeCmp=Ext.getCmp('tree-'+sectionSelected);
	}
	var jsonData={};
	var selectedNodeID=null;
	var selectedNodeID=null;
	var selections = treeCmp.getSelectionModel().getSelection();
	if(selections&&selections.length>0){
		selectedNodeID=selections[0].data.id;
		jsonData=selections[0].data;
	}
	if(CWHF.isNull(selectedNodeID)){
		var rootNode=treeCmp.getStore().getRootNode();
		if(rootNode&&rootNode.hasChildNodes()){
			var node=rootNode.getChildAt(0);
			treeCmp.getSelectionModel().select(node);
			jsonData=node.data;
			selectedNodeID=jsonData.id;
		}
	}
	if(lastSelectedSection===sectionSelected&&lastSelectedNode===selectedNodeID){
		//same node
		return;
	}
	//borderLayout.borderLayoutController.abortOldRequests.call(borderLayout.borderLayoutController);
	com.trackplus.admin.replaceCenterContent(sectionSelected,selectedNodeID,jsonData);
};
com.trackplus.admin.myClick=function(view,record,item,index,e){
	var jsonData=record.data;
	var treeCmp=view.ownerCt;
	var sectionSelected=treeCmp.id.substring(5);//'tree-XXXX';
	var selectedNodeID=record.data.id;
	com.trackplus.admin.replaceCenterContent(sectionSelected,selectedNodeID,jsonData);
};
com.trackplus.admin.replaceCenterContent=function(sectionSelected,selectedNodeID,jsonData){
	com.trackplus.admin.storeLastSelectedNode(sectionSelected,selectedNodeID);
	borderLayout.borderLayoutController.replaceCenterContent.call(borderLayout.borderLayoutController,jsonData);
	var helpCtx="admin."+sectionSelected;
	if(sectionSelected!=='projectTreePanel' &&
			sectionSelected!=='projectTemplateTreePanel'&&selectedNodeID){
		helpCtx+="."+selectedNodeID;
	}
	var historyToken=sectionSelected+":"+selectedNodeID;
	borderLayout.addHistoryToken(historyToken);
	borderLayout.setHelpContext(helpCtx);
};
com.trackplus.admin.storeLastSelectedNode=function(sectionSelected,selectedNodeID){
	com.trackplus.admin.lastSelectedSection=sectionSelected;
	com.trackplus.admin.lastSelectedNode=selectedNodeID;
	Ext.Ajax.request({
		fromCenterPanel:true,
		url: "admin!storeLastSelectedNode.action",
		params:{
			sectionSelected:sectionSelected,
			selectedNodeID:selectedNodeID
		}
	});
};
com.trackplus.admin.createSectionTree=function(sectionID,sectionTreeData,title,tt,iconCls){
	this.sections[sectionID]=sectionTreeData;
	var store = Ext.create('Ext.data.TreeStore', {
		fields: ['id','text','tt','menuPath','url', 'useAJAX','script', 'iconCls'],
		root: {
			expanded: true,
			text:"",
			user:"",
			status:"",
			children:sectionTreeData
		}
	});
	var tree=Ext.create('Ext.tree.Panel', {
		id:'tree-'+sectionID,
		useArrows: true,
		autoScroll: true,
		store: store,
		rootVisible: false,
		border: false,
		margins: '0 0 0 0',
		//baseCls:'x-plain',
		//bodyStyle:{border:'none'},
		cls:'westTreeNavigator'
	});
	tree.on('itemclick',com.trackplus.admin.myClick);
	return new Ext.create('Ext.panel.Panel', {
		id:sectionID,
		title:title,
		layout:'fit',
		margins: '0 0 0 0',
		iconCls:iconCls,
		//bodyStyle:{border:'none'},
		cls:'accordionSection',
		listeners:{
			expand:{
				fn: function(p) {
					p.addCls('accordionSection-active');
					com.trackplus.admin.sectionSelectHandler(p);
				}
			},
			collapse:{
				fn: function(p) {
					p.removeCls('accordionSection-active');
				}
			},
			afterrender : function(panel) {
			/*var header = panel.header;
				header.setHeight(27);*/
			}
		},
		items:[tree]
	});
};
com.trackplus.admin.createProjectTree=function(initData, isTemplate) {
	var treeStore = Ext.create('Ext.data.TreeStore', {
		root: {
			expanded: true,
			id: null
		},
		fields: [{name : 'id', mapping : 'id', type: 'string'},
			{name : 'text', mapping : 'text', type: 'string'},
			{name : 'tt', mapping : 'tt', type: 'string'},
			{name : 'menuPath', mapping : 'menuPath', type: 'string'},
			{name : 'url', mapping : 'url', type: 'string'},
			{name : 'useAJAX', mapping : 'useAJAX', type: 'boolean'},
			{name : 'script', mapping : 'script', type: 'boolean'},
			{name : 'iconCls', mapping : 'iconCls', type: 'string'}
		],
		autoLoad:false,
		proxy: {
			type: 'ajax',
			url: 'project!projects.action',
			extraParams: {
				isTemplate: isTemplate
			}
		}
	});
	if(initData.sectionSelected==='projectTreePanel' ||
		initData.sectionSelected==='projectTemplateTreePanel'){
		treeStore.on('load', function(treeStore, records, successful, operation, node, eOpts) {
			if (node.isRoot()) {
				var selectedNode=null;
				if(initData.selectedNodeID){
					selectedNode=treeStore.getNodeById(initData.selectedNodeID);
				}
				if(CWHF.isNull(selectedNode)){
					selectedNode = node.firstChild;
				}
				if (CWHF.isNull(selectedNode)) {
					//no project exists at all
					/*borderLayout.setCenterContent(null);
					var treeWithGridConfig=Ext.create('com.trackplus.admin.project.ProjectConfig',{});
					borderLayout.setActiveToolbarActionList(
							treeWithGridConfig.getToolbarActions.call(treeWithGridConfig, true, true));*/
				} else {
					var tmpTreeID = "tree-projectTreePanel";
					var tree=Ext.getCmp(tmpTreeID);//selectedNode.getOwnerTree();
					tree.getSelectionModel().select(selectedNode);
					var jsonData=selectedNode.data;
					com.trackplus.admin.replaceCenterContent(initData.sectionSelected,selectedNode,jsonData);
				}
			}
		},treeStore);
	}
	var treeItemID = 'projectTree';
	var treeID = 'tree-projectTreePanel';
	var treeConfig = {
		xtype: 'treepanel',
		itemId: treeItemID,
		id:treeID,
		useArrows: true,
		autoScroll: true,
		store: treeStore,
		rootVisible: false,
		border:false,
		margins:'0 0 0 0',
		baseCls:'x-plain',
		bodyStyle:{border:'none'},
		cls:'westTreeNavigator',
		listeners:{
			itemcontextmenu:{
				fn:function(tree, record, item, index, evtObj) {
					evtObj.stopEvent();
					var treeNodeCtxMenu = com.trackplus.admin.createCtxMenuProject(record,treeStore);
					treeNodeCtxMenu.showAt(evtObj.getXY());
					return false;
				}
			}
		},
		viewConfig:{
			plugins:  {
				ptype: 'treeviewdragdrop',
				dragGroup: 'projectAdminDDGroup',
				dropGroup: 'projectAdminDDGroup',
				appendOnly: true,
				enableDrag: true,
				enableDrop: true
			},
			listeners: {
				beforedrop: {
					fn: function(node, data, overModel, dropPosition) {
						var nodeToDrag = data.records[0];
						if (nodeToDrag.data.leaf===true) {
							return false;
						}
						if(overModel.data.leaf===true) {
							return false;
						}
						return true;
					}
				},
				drop: {
					fn: function(node, data, overModel, dropPosition) {
						var copy = data.copy;
						if (CWHF.isNull(copy)) {
							//move by default
							copy=false;
						}
						com.trackplus.admin.dropAdminProject(data.records[0], overModel, treeStore);
					}
				}
			}
		}
	};
	var tree = Ext.create('Ext.tree.Panel', treeConfig);
	var sectionKey = 'projects';
	this.sections[sectionKey]=tree;
	var treeWithGridConfig=Ext.create('com.trackplus.admin.project.ProjectConfig',
			{projectTree:this.sections[sectionKey],
			sys:com.trackplus.TrackplusConfig.user.sys,isTemplate:isTemplate});
	//not itemclick like for other sections because
	//the selection is possible also after add/delete without item click
	//select to automatically actualize the details after add/delete without item click
	tree.on('itemclick',com.trackplus.admin.myClick);
	var itemID = 'projectTreePanel';
	var title = getText('menu.admin.project');
	return new Ext.create('Ext.panel.Panel', {
		id:itemID,
		title:title,
		layout:'fit',
		margins: '0 0 0 0',
		iconCls:'projects-ticon',
		cls:'accordionSection',
		listeners:{
			expand:{
				fn: function(p) {
					p.addCls('accordionSection-active');
					var tmpTreeID = "projectTree";
					var projectTree = p.getComponent(tmpTreeID);
					if (projectTree) {
						rootNode = projectTree.getRootNode();
						if (rootNode && !rootNode.hasChildNodes()) {
							//if there is no project at all for this user: set the center content to null and the toolbar with addProject (if system admin)
							borderLayout.borderLayoutController.setCenterContent(null);
							borderLayout.setActiveToolbarActionList(
								this.getToolbarActions.call(this, false));
						}
						com.trackplus.admin.sectionSelectHandler(p,projectTree);
					}
				},
				scope: treeWithGridConfig
			},
			collapse:{
				fn: function(p) {
					p.removeCls('accordionSection-active');
				}
			},
			afterrender : function(panel) {
				/*var header = panel.header;
				header.setHeight(27);*/
			}
		},
		items:[tree]
	});
};
com.trackplus.admin.dropAdminProject=function(nodeFrom, nodeTo, treeStore) {
	var projectID=nodeFrom.data.id;
	var parent=nodeTo.data.id;
	Ext.Ajax.request({
		url: 'project!updateParent.action',
		params: {
			projectID:projectID,
			parentID:parent
		},
		disableCaching:true,
		success: function(response){
		}
	});
};
com.trackplus.admin.clearProjectParent=function(projectID,treeStore){
	Ext.Ajax.request({
		url: 'project!clearParent.action',
		params: {
			projectID:projectID
		},
		disableCaching:true,
		success: function(response){
			treeStore.load({
				callback:function(){
					var tmpTreeID = "tree-projectTreePanel";
					var tree=Ext.getCmp(tmpTreeID);
					var selectedNode=treeStore.getNodeById(projectID);
					tree.getSelectionModel().select(selectedNode);
					com.trackplus.admin.myClick(tree.getView,selectedNode);
				}
			});
		}
	});
};
com.trackplus.admin.deleteProject=function(projectID,projectName,deleteConfirmed){
	var title=getText('common.lbl.delete',getText('admin.project.lbl.projectForOp'));
	var msg=getText('common.lbl.removeWarning',getText('admin.project.lbl.projectForOp'));
	Ext.MessageBox.confirm(title,msg,
		function(btn){
			if (btn==="no") {
				return false;
			} else {
				Ext.Ajax.request({
					url: 'project!delete.action',
					params: {
						projectID:projectID,
						deleteConfirmed:deleteConfirmed
					},
					disableCaching:true,
					success: function(response){
						var responseJson = Ext.decode(response.responseText);
						if (responseJson.success===true) {
							window.location.href='admin.action';
						}else{
							var errorMessage = responseJson.errorMessage;
							Ext.MessageBox.confirm(title,
								errorMessage,
								function(btn){
									if (btn==="no") {
										return false;
									} else {
										com.trackplus.admin.deleteProject(projectID, projectName, true);
									}
								}
							);
						}
					}
				});
			}
		}
	);
};
com.trackplus.admin.createCtxMenuProject=function(record,treeStore){
	var projectID=record.data.id;
	var projectName=record.data.text;
	var items = [{
		text:getText('common.btn.delete'),
		iconCls:'delete16',
		handler:function(){
			com.trackplus.admin.deleteProject(projectID, projectName, false);
		}
	}];
	if (record && record.parentNode && !record.parentNode.isRoot()) {
		items.push({
			text:getText('menu.admin.project.removeFromParent'),
			iconCls:'clear16',
			handler:function(){
				com.trackplus.admin.clearProjectParent(projectID,treeStore);
			}
		});
	}
	var contextMenu = new Ext.menu.Menu({
		items: items
	});
	return contextMenu;
};
com.trackplus.admin.getMyPreferencesSection=function(){
	var menuPathPrefix=getText('menu.admin')+">"+getText('menu.admin.myProfile')+">";
	var myPreferenceData=[{
			id:'myProfile',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.myProfile.myProfile'),
			tooltip:getText('menu.admin.myProfile.myProfile.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.myProfile.myProfile'),
			url:'com.trackplus.admin.myProfile()',
			useAJAX:true,leaf:true,iconCls:'userprefs-ticon'
		},{
			id:'myAutomail',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.automail'),
			tooltip:getText('menu.admin.custom.automail.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.automail'),
			url:'com.trackplus.admin.notify(false)',
			useAJAX:true,leaf:true,iconCls:'automailc-ticon'
		},{
			id:'iCalendarURL',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.myProfile.iCalendar'),
			tooltip:getText('menu.admin.myProfile.iCalendar.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.myProfile.iCalendar'),
			url:'com.trackplus.admin.iCalendarURL()',
			useAJAX:true,leaf:true,iconCls:'calendar-ticon'
		}
	];
	return com.trackplus.admin.createSectionTree('myPreferenceSection',myPreferenceData,getText('menu.admin.myProfile'),getText('menu.admin.myProfile.tt'),'userprefs-ticon');
};
com.trackplus.admin.getProjectsSection=function(initData, isTemplate) {
	return com.trackplus.admin.createProjectTree(initData, isTemplate);
};
com.trackplus.admin.getUsersSection=function(){
	var menuPathPrefix=getText('menu.admin')+">"+getText('menu.admin.user')+">";
	var str = "tmp";
	var userNavigator=[{
			id:'users',
			script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.users.users'),
			tooltip:getText('menu.admin.users.users.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.users.users'),
			url:'com.trackplus.admin.user.person(true)',
			useAJAX:true,leaf:true,iconCls:'user-ticon'
		}];
	if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
		userNavigator.push({
			id:'clients',
			script:true,
			cls:'treeItem-level-1',
			text: getText('menu.admin.users.clients'),
			tooltip:getText('menu.admin.users.clients.tt'),
			menuPath: menuPathPrefix+getText('menu.admin.users.clients'),
			url:'com.trackplus.admin.user.person(false)',
			useAJAX:true,leaf:true,iconCls:'user-ticon'
		});
	}
	userNavigator.push({
		id:'groups',script:true,
		cls:'treeItem-level-1',
		text:getText('menu.admin.users.groups'),
		tooltip:getText('menu.admin.users.groups.tt'),
		menuPath:menuPathPrefix+getText('menu.admin.users.groups'),
		url:'com.trackplus.admin.user.group()',
		useAJAX:true,leaf:true,iconCls:'group-ticon'
	});
	userNavigator.push({
		id:'departments',script:true,
		cls:'treeItem-level-1',
		text:getText('menu.admin.users.departments'),
		tooltip:getText('menu.admin.users.departments.tt'),
		menuPath:menuPathPrefix+getText('menu.admin.users.departments'),
		url:'com.trackplus.admin.user.department()',
		useAJAX:true,leaf:true,iconCls:'department-ticon'
	});
	return com.trackplus.admin.createSectionTree('usersSection',userNavigator,getText('menu.admin.user'),getText('menu.admin.user.tt'),'users-ticon');
};
com.trackplus.admin.getActionSection=function(){
	var menuPathPrefix=getText('menu.admin')+">"+getText('menu.admin.action')+">";
	var actionNavigator=[
		{
			id:'importTrackplus',script:true,
			text:getText('menu.admin.action.importTrackplus'),
			tooltip:getText('menu.admin.action.importTrackplus.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.action.importTrackplus'),
			url:'com.trackplus.admin.action.importTrackplus()',
			useAJAX:true,leaf:true,iconCls:'trackPlus-ticon'
		},{
			id:'broadcastEmail',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.sendEmail'),
			tooltip:getText('menu.admin.manServer.sendEmail.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.sendEmail'),
			url:'com.trackplus.admin.sendEmail()',
			useAJAX:false,leaf:true,iconCls:'broadcast-ticon'
		}
	];
	return com.trackplus.admin.createSectionTree('actionSection',actionNavigator,getText('menu.admin.action'),getText('menu.admin.action.tt'),'action-ticon');
};
com.trackplus.admin.getCustomizationSection=function(){
	var menuPathPrefix=getText('menu.admin')+">"+getText('menu.admin.custom')+">";
	var customizationData=[];
	if (com.trackplus.TrackplusConfig.user.manageFilters) {
		customizationData.push({
			id:'queryFilters',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.queryFilters'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.queryFilters'),
			url:'com.trackplus.admin.categoryConfig("issueFilter")',
			useAJAX:true,leaf:true,iconCls:'filter-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.reportTemplates) {
		customizationData.push({
			id:'reportTemplates',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.reportTemplates'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.reportTemplates'),
			url:'com.trackplus.admin.categoryConfig("report")',
			useAJAX:true,leaf:true,iconCls:'report-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
		(com.trackplus.TrackplusConfig.user.projectAdmin &&
			com.trackplus.TrackplusConfig.user.userRoles)) {
		customizationData.push({
			id:'roles',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.roles'),
			tooltip:getText('menu.admin.custom.roles.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.roles'),
			url:'com.trackplus.admin.refreshRoles()',
			useAJAX:true,leaf:true,iconCls:'roles-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
			(com.trackplus.TrackplusConfig.user.projectAdmin &&
				com.trackplus.TrackplusConfig.user.userLevels)) {
		customizationData.push({
			id:'userLevels',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.userLevels'),
			tooltip:getText('menu.admin.custom.userLevels.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.userLevels'),
			url:'com.trackplus.admin.userLevelConfig()',
			useAJAX:true,leaf:true,iconCls:'personSystemAdmin'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys) {
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			customizationData.push({
				id:'accounts',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.account'),
				tooltip:getText('menu.item.account.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.account'),
				url:'com.trackplus.admin.accountConfig()',
				useAJAX:true,leaf:true,iconCls:'account-ticon'
			});
		}
		customizationData.push({
			id:'defaultAutomail',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.automail'),
			tooltip:getText('menu.admin.custom.automail.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.automail'),
			url:'com.trackplus.admin.notify(true)',
			useAJAX:true,leaf:true,iconCls:'automailc-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys) {
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			customizationData.push({
				id:'linkTypes',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.linkType'),
				tooltip:getText('menu.admin.custom.linkType'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.linkType'),
				url:'com.trackplus.admin.refreshLinkTypes()',
				useAJAX:true,leaf:true,iconCls:'links-ticon'
			});
		}
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
		(com.trackplus.TrackplusConfig.user.projectAdmin &&
			com.trackplus.TrackplusConfig.user.forms)) {
		customizationData.push({
			id:'customForms',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.customForms'),
			tooltip:getText('menu.admin.custom.customForms'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.customForms'),
			url:'com.trackplus.admin.screenConfig()',
			useAJAX:true,leaf:true,iconCls:'forms-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
			(com.trackplus.TrackplusConfig.user.projectAdmin &&
				com.trackplus.TrackplusConfig.user.fields)) {
		customizationData.push({
			id:'customFields',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.customField'),
			tooltip:getText('menu.admin.custom.customField.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.customField'),
			url:'com.trackplus.admin.fieldConfig()',
			useAJAX:true,leaf:true,iconCls:'fields-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys ||
			(com.trackplus.TrackplusConfig.user.projectAdmin &&
				com.trackplus.TrackplusConfig.user.lists)) {
		customizationData.push({
			id:'pickLists',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.list'),
			tooltip:getText('menu.admin.custom.list.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.list'),
			url:'com.trackplus.admin.listConfig()',
			useAJAX:true,leaf:true,iconCls:'picklists-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.user.sys) {
		customizationData.push({
				id:'objectStatus', script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.objectStatus'),
				tooltip:getText('menu.admin.custom.objectStatus.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.objectStatus'),
				url:'com.trackplus.admin.objectStatusConfig()',
				useAJAX:true,leaf:true,iconCls:'objectStatus-ticon'
			});
		customizationData.push({
			id:'projectTypes',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.custom.projectType'),
			tooltip:getText('menu.admin.custom.projectType.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.custom.projectType'),
			url:'com.trackplus.admin.projectTypes()',
			useAJAX:true,leaf:true,iconCls:'projecttypes-ticon'
		});
	}
	if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
		if (com.trackplus.TrackplusConfig.user.sys ||
				(com.trackplus.TrackplusConfig.user.projectAdmin &&
				com.trackplus.TrackplusConfig.user.workflows)) {
			customizationData.push({
				id:'workflows',script:true,
				text:getText('menu.admin.custom.workflow'),
				tooltip:getText('menu.admin.custom.workflow.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.workflow'),
				url:'com.trackplus.admin.workflowConfig()',
				useAJAX:false,leaf:true,iconCls:'workflow-ticon'
			});
		}
	}
	if (com.trackplus.TrackplusConfig.user.sys) {
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			customizationData.push({
				id:'scripts',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.script'),
				tooltip:getText('menu.admin.custom.script.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.script'),
				url:'com.trackplus.admin.refreshScript()',
				useAJAX:true,leaf:true,iconCls:'scripts-ticon'
			});
			customizationData.push({
				id:'localization',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.localeEditor'),
				tooltip:getText('menu.admin.custom.localeEditor.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.localeEditor'),
				url:'com.trackplus.admin.localeEditor()',
				useAJAX:true,leaf:true,iconCls:'localize-ticon'
			});
		}
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
			customizationData.push({
				id:'mailTemplates',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.custom.mailTemplate'),
				tooltip:getText('menu.admin.custom.mailTemplate.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.custom.mailTemplate'),
				url:'com.trackplus.admin.mailTemplateConfig()',
				useAJAX:true,leaf:true,iconCls:'mailTemplate-ticon'
			});
			customizationData.push({
				id:'dashboardAssign',script:true,
				cls:'treeItem-level-1',
				text:getText('menu.admin.users.cockpitDefault'),
				tooltip:getText('menu.admin.users.cockpitDefault.tt'),
				menuPath:menuPathPrefix+getText('menu.admin.users.cockpitDefault'),
				url:'com.trackplus.admin.user.dashboardAssign()',
				useAJAX:true,leaf:true,iconCls:'cockpit-ticon'
			});
		}
	}
	if (customizationData.length>0) {
		return com.trackplus.admin.createSectionTree('customizationSection', customizationData, getText('menu.admin.custom'), getText('menu.admin.custom.tt'),'customize-ticon');
	} else {
		return null;
	}
};
com.trackplus.admin.getServerSection=function(){
	var menuPathPrefix=getText('menu.admin')+">"+getText('menu.admin.manServer')+">";
	var serverData=[{
			id:'serverConfiguration',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.serverConfig'),
			tooltip:getText('menu.admin.manServer.serverConfig.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.serverConfig'),
			url:'com.trackplus.admin.serverConfiguration()',
			useAJAX:true,leaf:true,iconCls:'server-ticon'
		},{
			id:'logonPageText',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.logonText'),
			tooltip:getText('menu.admin.manServer.logonText.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.logonText'),
			url:'com.trackplus.admin.logonPageText()',
			useAJAX:false,leaf:true,iconCls:'motd-ticon'
		},{
			id:'serverStatus',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.serverStatus'),
			tooltip:getText('menu.admin.manServer.serverStatus.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.serverStatus'),
			url:'com.trackplus.admin.serverStatus()',
			useAJAX:false,leaf:true,iconCls:'serverStatus-ticon'
		},{
			id:'loggingConfiguration',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.loggingConfig'),
			tooltip:getText('menu.admin.manServer.loggingConfig.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.loggingConfig'),
			url:'com.trackplus.admin.loggingConfiguration()',
			useAJAX:false,leaf:true,iconCls:'logging-ticon'
		},{
			id:'dataBackup',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.databaseBackup'),
			tooltip:getText('menu.admin.manServer.databaseBackup.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.databaseBackup'),
			url:'com.trackplus.admin.databaseBackup()',
			useAJAX:false,leaf:true,iconCls:'backup-ticon'
		},{
			id:'dataRestore',script:true,
			cls:'treeItem-level-1',
			text:getText('menu.admin.manServer.databaseRestore'),
			tooltip:getText('menu.admin.manServer.databaseRestore.tt'),
			menuPath:menuPathPrefix+getText('menu.admin.manServer.databaseRestore'),
			url:'com.trackplus.admin.databaseRestore()',
			useAJAX:false,leaf:true,iconCls:'restore-ticon'
		}
	];
	return com.trackplus.admin.createSectionTree('serverSection',serverData,getText('menu.admin.manServer'),getText('menu.admin.manServer.tt'),'server-ticon');
};
com.trackplus.admin.getNodeJsonData=function(sectionID,nodeID){
	var sectionNodes=this.sections[sectionID];
	if(sectionNodes){
		for(var i=0;i<sectionNodes.length;i++){
			if(sectionNodes[i].id===nodeID){
				return sectionNodes[i];
			}
		}
	}
	return null;
};
com.trackplus.admin.myProfile=function(){
	var myProfile=Ext.create('com.trackplus.admin.user.Profile',{context:1});
	borderLayout.setActiveToolbarList([myProfile.createSaveButton()]);
	var component=myProfile.loadProfile();
	borderLayout.setCenterContent(component);
};
/**
 * Called not from here, but from dynamic projects json
 */
com.trackplus.admin.projectConfig=function(projectID, isTemplate) {
	borderLayout.setLoading(true);
	var sectionKey = 'projects';
	Ext.Ajax.request({
		fromCenterPanel:true,
		url: 'project!loadLasSelections.action',
		disableCaching:true,
		scope: this,
		success: function(response) {
			var responseJson = Ext.decode(response.responseText);
			var treeWithGridConfig=Ext.create('com.trackplus.admin.project.ProjectConfig',{
				projectTree:this.sections[sectionKey],
				sys:com.trackplus.TrackplusConfig.user.sys,
				rootID:projectID,
				treeWidth:200,
				lastSelections:responseJson,
				isTemplate:isTemplate
			});
			borderLayout.borderLayoutController.setCenterContent(treeWithGridConfig.createCenterPanel());
			borderLayout.setLoading(false);
		},
		failure: function(response){
			var treeWithGridConfig=Ext.create('com.trackplus.admin.project.ProjectConfig',{
				projectTree:this.sections[sectionKey], rootID:projectID,
				sys:com.trackplus.TrackplusConfig.user.sys,
				treeWidth:200,
				lastSelections:{}
			});
			borderLayout.borderLayoutController.setCenterContent(treeWithGridConfig.createCenterPanel());
			borderLayout.setLoading(false);
		}
	});
};
com.trackplus.admin.user.person=function(isUser){
	//var gridConfig=Ext.create("com.trackplus.admin.user.Person",{isUser: isUser});
	//com.trackplus.admin.replaceGridConfig(gridConfig);
	Ext.Ajax.request({
		url: "person!getUserConfigs.action",
		scope: this,
		success: function(response) {
			var result = Ext.decode(response.responseText);
			var userLevels = result.userLevelList;
			var featureList = result.featureList;
			var gridConfig=Ext.create("com.trackplus.admin.user.Person", {isUser: isUser, userLevels:userLevels, featureList:featureList});
			com.trackplus.admin.replaceGridConfig(gridConfig);
		},
		failure: function(response) {
			Ext.MessageBox.alert(this.failureTitle, response.responseText);
		}
	});
};
com.trackplus.admin.user.group=function(){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.user.Group', {});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.user.department=function(){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.user.Department', {rootID:'_', reloadGrids:true});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.user.dashboardAssign=function(){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.user.DashboardAssignment', {rootID:'_'});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
/*com.trackplus.admin.action.exportForm=function() {
	var exportForms=Ext.create('com.trackplus.admin.action.ExportForm',{});
	borderLayout.borderLayoutController.setActiveToolbarList([exportForms.createExportButton()]);
	//var component=exportForms.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(null);
};*/
com.trackplus.admin.action.importExcel=function() {
	var importExcel=Ext.create('com.trackplus.admin.action.ImportExcel');
	com.trackplus.admin.replaceWizardConfig(importExcel);
};
com.trackplus.admin.action.importDocx=function() {
	var importDocx=Ext.create('com.trackplus.admin.action.ImportDocx');
	com.trackplus.admin.replaceWizardConfig(importDocx);
};
com.trackplus.admin.action.importMsProject=function() {
	var importMsProject=Ext.create('com.trackplus.admin.action.ImportMsProject');
	com.trackplus.admin.replaceWizardConfig(importMsProject);
};
com.trackplus.admin.action.importTrackplus=function() {
	var importTrackplus=Ext.create('com.trackplus.admin.action.ImportTrackplus');
	//com.trackplus.admin.replaceWizardConfig(importTrackplus);
	borderLayout.borderLayoutController.setActiveToolbarList(importTrackplus.createToolbar());
	var component=importTrackplus.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(component);
	//importTrackplus.renderImport();
};
/*com.trackplus.admin.action.importForm=function() {
	var importForms=Ext.create('com.trackplus.admin.action.ImportForm',{});
	borderLayout.borderLayoutController.setActiveToolbarList([importForms.createImportButton()]);
	var component=importForms.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(component);
};*/
com.trackplus.admin.serverConfiguration=function(){
	var siteConfig=Ext.create('com.trackplus.admin.server.SiteConfig',{});
	borderLayout.borderLayoutController.setActiveToolbarList([siteConfig.createSaveButton()]);
	var component=siteConfig.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(component);
	siteConfig.loadMyForm.call(siteConfig);
};
com.trackplus.admin.logonPageText=function(){
	var logonPage=Ext.create('com.trackplus.admin.server.LogonPageText',{});
	borderLayout.borderLayoutController.setActiveToolbarList([logonPage.createSaveButton()]);
	var component=logonPage.createMainComponent();
	logonPage.reload();
	borderLayout.borderLayoutController.setCenterContent(component);
};
com.trackplus.admin.sendEmail=function(){
	var sendEmail=Ext.create('com.trackplus.admin.server.SendEmail',{});
	borderLayout.borderLayoutController.setActiveToolbarList(sendEmail.getToolbar());
	var component=sendEmail.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(component);
};
com.trackplus.admin.serverStatus=function(){
	var serverStatus=Ext.create('com.trackplus.admin.server.ServerStatus',{});
	borderLayout.borderLayoutController.setActiveToolbarList(serverStatus.createToolbar());
	serverStatus.reloadAndReplaceComp();
};
com.trackplus.admin.loggingConfiguration=function(){
	var loggingConfig=Ext.create('com.trackplus.admin.server.LoggingConfig',{});
	borderLayout.borderLayoutController.setActiveToolbarList([]);
	var component=loggingConfig.createMainComponent();
	loggingConfig.reload();
	borderLayout.borderLayoutController.setCenterContent(component);
};
com.trackplus.admin.databaseBackup=function(){
	var databaseBackup=Ext.create('com.trackplus.admin.server.DatabaseBackup',{});
	borderLayout.borderLayoutController.setActiveToolbarList(databaseBackup.createToolbar());
	var component=databaseBackup.createMainComponent();
	borderLayout.borderLayoutController.setCenterContent(component);
};
com.trackplus.admin.databaseRestore=function(){
	var databaseRestore=Ext.create('com.trackplus.admin.server.DatabaseRestore',{});
	borderLayout.borderLayoutController.setActiveToolbarList(databaseRestore.createToolbar());
	var component=databaseRestore.createMainComponent();
	databaseRestore.reload();
	borderLayout.borderLayoutController.setCenterContent(component);
};
com.trackplus.admin.refreshLinkTypes=function(){
	var gridConfig=Ext.create('com.trackplus.admin.customize.linkType.LinkType',{});
	com.trackplus.admin.replaceGridConfig(gridConfig);
};
com.trackplus.admin.projectTypes=function(){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.projectType.ProjectType', {treeWidth: 250});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.refreshScript=function(){
	var gridConfig=Ext.create('com.trackplus.admin.customize.script.Script',{});
	com.trackplus.admin.replaceGridConfig(gridConfig);
};
com.trackplus.admin.workflowConfig=function(){
	var workflowConfig=Ext.create('com.trackplus.admin.customize.treeConfig.WorkflowConfig', {rootID:'workflow', treeWidth:300});
	com.trackplus.admin.replaceTreeWithGridConfig(workflowConfig);
};
com.trackplus.admin.refreshRoles=function(){
	var gridConfig=Ext.create('com.trackplus.admin.customize.role.Role',{});
	com.trackplus.admin.replaceGridConfig(gridConfig);
};
com.trackplus.admin.accountConfig=function() {
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.account.AccountConfig',{rootID:"_false"});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.replaceTreeWithGridConfig=function(treeWithGridConfig){
	borderLayout.borderLayoutController.setCenterContent(treeWithGridConfig.createCenterPanel());
	borderLayout.borderLayoutController.setActiveToolbarActionList(treeWithGridConfig.getToolbarActions());
};
com.trackplus.admin.notify=function(defaultSettings){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.NotifyConfig',{defaultSettings:defaultSettings});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.iCalendarURL=function(){
	var iCalendar=Ext.create('com.trackplus.admin.ICalendarURL',{data:{}});
	borderLayout.setActiveToolbarList(iCalendar.getToolbarButtons.call(iCalendar));
	var component=iCalendar.createView.call(iCalendar);
	borderLayout.setCenterContent(component);
};
com.trackplus.admin.fieldConfig=function(){
	var fieldConfig=Ext.create('com.trackplus.admin.customize.treeConfig.FieldConfig', {rootID:'field', treeWidth:250});
	com.trackplus.admin.replaceTreeWithGridConfig(fieldConfig);
};
com.trackplus.admin.screenConfig=function(){
	var screenConfig=Ext.create('com.trackplus.admin.customize.treeConfig.ScreenConfig', {rootID:'screen', treeWidth:250});
	com.trackplus.admin.replaceTreeWithGridConfig(screenConfig);
};
com.trackplus.admin.mailTemplateConfig=function(){
	var mailTemplateConfig=Ext.create('com.trackplus.admin.customize.treeConfig.MailTemplateConfig', {rootID:'mailTemplate', treeWidth:250});
	com.trackplus.admin.replaceTreeWithGridConfig(mailTemplateConfig);
};
com.trackplus.admin.localeEditor=function(){
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.locale.LocaleEditor');
//	treeWithGridConfig.initLocaleEditor();
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.userLevelConfig=function() {
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.userLevel.UserLevel',{rootID:""});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.listConfig= function() {
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.list.ListConfig');
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.objectStatusConfig= function() {
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.objectStatus.ObjectStatus');
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.categoryConfig=function(rootNode) {
	var treeWithGridConfig=Ext.create('com.trackplus.admin.customize.category.CategoryConfig',
			{rootID:rootNode});
	com.trackplus.admin.replaceTreeWithGridConfig(treeWithGridConfig);
};
com.trackplus.admin.replaceGridConfig=function(gridConfig){
	var grid=gridConfig;//.getGrid();
	borderLayout.borderLayoutController.setCenterContent(grid);
	//gridConfig.reload();
	//borderLayout.borderLayoutController.setActiveToolbarActionList(gridConfig.getToolbarActions());
};
com.trackplus.admin.replaceWizardConfig= function(wizardConfig){
	var wizardPanel=wizardConfig.getWizardPanel();
	borderLayout.borderLayoutController.setCenterContent(wizardPanel);
	borderLayout.borderLayoutController.setActiveToolbarActionList(wizardConfig.getToolbarActions());
};
Ext.define('com.trackplus.layout.AdminLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:true,
	sectionSelected:null,
	selectedNodeID:null,
	selectedGroup:'admin',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
//		me.reportsConfig===Ext.create('com.trackplus.admin.customize.category.CategoryConfig',{
//			rootID:'report'
//		});
		me.reportsConfig=Ext.create('com.trackplus.admin.customize.ReportConfig',{
			rootID:'report'
		});
		var sysAdmin=com.trackplus.TrackplusConfig.user.sysAdmin;
		var data=me.initData;
		if(sysAdmin){
			me.sectionSelected='serverSection';
			me.selectedNodeID="serverConfiguration";
		}else{
			me.sectionSelected='myPreferenceSection';
			me.selectedNodeID='myProfile';
		}
		if(data.sectionSelected){
			me.sectionSelected=data.sectionSelected;
		}
		if(data.selectedNodeID){
			me.selectedNodeID=data.selectedNodeID;
		}
		me.onReady(function(){
			if(me.sectionSelected){
				me.setSelectedContext(me.sectionSelected,me.selectedNodeID);
				/*Ext.getCmp(me.sectionSelected).expand();
				var treeCmp=Ext.getCmp('tree-'+me.sectionSelected);
				if(treeCmp){
					var node=treeCmp.getStore().getNodeById(me.selectedNodeID);
					if(node){
						treeCmp.getSelectionModel().select(node);
						treeCmp.expandPath(node.getPath());
						var jsonData=node.data;
						com.trackplus.admin.replaceCenterContent(me.sectionSelected,me.selectedNodeID,jsonData);
					}
				}*/
			}
		});
	},
	createWestPanel:function(){
		return com.trackplus.admin.createAdminWestPanel(this.initData);
	},
	historyChange:function(token){
		var me=this;
		var parts = token.split(":");
		var section=parts[0];
		var nodeID=parts[1];
		me.setSelectedContext(section,nodeID);
	},
	setSelectedContext:function(sectionSelected,selectedNodeID){
		var me=this;
		if(com.trackplus.admin.lastSelectedSection===sectionSelected&&com.trackplus.admin.lastSelectedNode===selectedNodeID){
			return true;
		}
		me.sectionSelected=sectionSelected;
		me.selectedNodeID=selectedNodeID;
		if(me.sectionSelected){
			Ext.getCmp(me.sectionSelected).expand();
			var treeCmp=Ext.getCmp('tree-'+me.sectionSelected);
			if(treeCmp){
				var node=treeCmp.getStore().getNodeById(me.selectedNodeID);
				if(node){
					treeCmp.getSelectionModel().select(node);
					treeCmp.expandPath(node.getPath());
					var jsonData=node.data;
					com.trackplus.admin.replaceCenterContent(me.sectionSelected,me.selectedNodeID,jsonData);
				}
			}
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.user.Profile',{
	extend:'Ext.Base',
	config: {
		context: 1,
		isUser: false  //this flag is set in case of adding new user from person.js. If true this is a real user otherwise this is a client user.
	},
	personId: null,
	constructor: function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	CONTEXT:{
			SELFREGISTRATION: 0,
			PROFILEEDIT: 1,
			USERADMINADD: 2,
			USERADMINEDIT: 3
	},
	mainForm:null,
	btnSave:null,
	//originalUserName:null,
	labelWidth:250,
	textFieldWidth:250+300,
	textFieldWidthShort:250+70,
	alignR:"right",
	FieldSetWidth:250+300+150,
	context:1, // this.CONTEXT.PROFILEEDIT,
	//tabPanel:null,
	reqTpl:'<span class="required">&nbsp;</span>',
	/**
	 * Create a Save button
	 * @return {Ext.button.Button} The save button
	 */
	createSaveButton:function(){
		if(CWHF.isNull(this.btnSave)){
			this.btnSave=new Ext.button.Button({
				overflowText:getText('common.btn.save'),
				tooltip:getText('common.btn.save'),
				text: getText('common.btn.save'),
				iconCls: 'save',
				disabled: true,
				scope:this,
				handler:function(){
					this.save.call(this);
				}
			});
		}
		return this.btnSave;
	},
	getTabPanel: function() {
		return this.mainForm.getComponent(0);
	},
	/**
	 * Gets a control by the path according to the "arguments" starting form the main tab panel
	 */
	getControl: function() {
		return CWHF.getControl.apply(this.getTabPanel(), arguments);
	},
	getHelpWrapper: function() {
		return CWHF.getHelpWrapper.apply(this.getTabPanel(), arguments);
	},
	getWrappedControl: function() {
		return CWHF.getWrappedControl.apply(this.getTabPanel(), arguments);
	},
	changeLdap:function() {
		var ldapCmp = this.getWrappedControl("tab_main", "fslogin", "mainLdapUser");
		var ldapChecked = ldapCmp.getValue();
		this.getControl("tab_main", "fslogin", "mainPasswd").setDisabled(ldapChecked);
		this.getControl("tab_main", "fslogin", "mainPasswd2").setDisabled(ldapChecked);
	},
	changeLdapSelReg:function(check, newValue, oldValue){
	  	var me=this;
		var ldapChecked = check.getValue();
		me.selfRegForm.getComponent("mainPasswd").setDisabled(ldapChecked);
		me.selfRegForm.getComponent("mainPasswd2").setDisabled(ldapChecked);
	},
	/**
	 * Creates the main tab for the user profile.
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabMain:function() {
		var panel=new Ext.form.Panel({
			itemId:'tab_main',
			title:getText('admin.user.profile.lbl.tabMain'),
			layout: {
				type: 'anchor'
			},
			padding:'0 0 0 0',
			bodyPadding:'5 0 0 0',
			items: [{
				xtype: 'label',
				html: '<div style="width:' + this.FieldSetWidth+'px;"><span class=requiredHint><span class="requiredHintBar">&nbsp;</span> = ' + getText("common.lbl.requiredInfo") +'</span></div>',
				margin:'8 0 0 0',
				width: this.FieldSetWidth},
				{
				xtype: 'fieldset',
				itemId: 'fslogin',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.basic'),
				collapsible: false,
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [
				        CWHF.createTextFieldWithHelp('admin.user.profile.lbl.userName','main.userName',
								{itemId:'mainUserName', enableKeyEvents:true,allowBlank:false,maxLength:60,afterLabelTextTpl:this.reqTpl},
								//listeners:
								{
									//keyup: {
									blur: {
											element: 'el',
											scope: this,
											fn: function() {
												this.validateLoginName.call(this);
											}
										}
									}
								//}
						),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.ldapUser', 'main.ldapUser', {itemId:'mainLdapUser'},
								{change:{
										fn: this.changeLdap,
										scope: this
									}
								}
						),
						CWHF.createTextField('admin.user.profile.lbl.passwd','main.passwd',
										{inputType:'password',minLength:5, id:'mainPasswd',afterLabelTextTpl:this.reqTpl}),
						CWHF.createTextField('admin.user.profile.lbl.passwd2','main.passwd2',
										{itemId:'mainPasswd2',inputType:'password',vtype:'password',initialPassField:'main.passwd',afterLabelTextTpl:this.reqTpl})
					]
			}, {
				xtype: 'fieldset',
				itemId: 'fsname',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.nameLang'),
				collapsible: false,
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createTextField('admin.user.profile.lbl.lastName','main.lastName', {allowBlank:false, maxLength:25,afterLabelTextTpl:this.reqTpl},
						//{listeners:
						{
							blur: {
								element: 'el',
								fn: function() {
									this.validateUser.call(this);
								},
								scope: this
							}
						}
					),
					CWHF.createTextField('admin.user.profile.lbl.firstName','main.firstName',  {allowBlank:false, maxLength:25,afterLabelTextTpl:this.reqTpl},
						//{listeners:
							{
								blur: {
									element: 'el',
									fn: function() {
										this.validateUser.call(this);
									},
									scope: this
								}
						 //}
						}),
					CWHF.createComboWithHelp('admin.user.profile.lbl.locale',
							'main.locale',{itemId:'mainLocale', idType:'string'}),
					CWHF.createComboWithHelp('admin.user.profile.lbl.usertz',
							'main.userTz',{itemId:'mainUserTz', idType:'string'})]
			}]
		});
		return panel;
	},
	/**
	 * Creates the reminder e-mail configuration tab for the user profile
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	changeNoEmail:function() {
		var noEmailCmp =this.getWrappedControl("tab_remail", "fsremail1", "remailNoEmail");
		var noEmailChecked = noEmailCmp.getValue();
		// Get all components to disable or enable
		this.getControl("tab_remail", "fsremail1", "remailPrefEmailType").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail2", "remailRemindMeAsOriginator").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail2", "remailRemindMeAsManager").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail2", "remailRemindMeAsResponsible").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail3", "remailRemindPriorityLevel").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail3", "remailRemindSeverityLevel").setDisabled(noEmailChecked);
		//this.getHelpWrapper("tab_remail", "fsremail3", "remailEmailLead").setDisabled(noEmailChecked);
		this.getHelpWrapper("tab_remail", "fsremail3", "remailRemindMeOnDays").setDisabled(noEmailChecked);
	},
	/**
	 * Creates the e-mail tab of the user profile.
	 * @return {Ext.form.Panel} A panel for this tab.
	 */
	createTabEmail:function(){
		var panel=new Ext.Panel({
			id:'tab_remail',
			title:getText('admin.user.profile.lbl.tabEmail'),
			layout: {
				type: 'anchor'
			},
			padding:'0 0 0 0',
			bodyPadding:'5 0 0 0',
			items: [{
				xtype: 'fieldset',
				itemId: 'fsremail1',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.generalEmail'),
				collapsible: false,
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createCheckboxWithHelp('admin.user.profile.lbl.noEmail','remail.noEmail', {itemId:'remailNoEmail'},
							{change: {fn: this.changeNoEmail, scope:this}}
						),
						CWHF.getRadioGroup('admin.user.profile.lbl.prefEmailType',
								400,
								[{boxLabel:"HTML", name:"remail.prefEmailType", inputValue:"HTML", checked:true},
								 {boxLabel:"Plain", name:"remail.prefEmailType", inputValue:"Plain"}],{itemId:'remailPrefEmailType'})
					]
			}, {
				xtype: 'fieldset',
				itemId:'fsremail2',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.rrole'),
				collapsible: false,
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createCheckboxWithHelp('admin.user.profile.lbl.remindMeAsOriginator','remail.remindMeAsOriginator', {itemId:'remailRemindMeAsOriginator'}),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.remindMeAsManager', 'remail.remindMeAsManager', {itemId:'remailRemindMeAsManager'}),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.remindMeAsResponsible','remail.remindMeAsResponsible', {itemId:'remailRemindMeAsResponsible'})]
			}, {
				xtype: 'fieldset',
				itemId:'fsremail3',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.rlevelLead'),
				collapsible: false,
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createComboWithHelp('admin.user.profile.lbl.remindPriorityLevel','remail.remindPriorityLevel',
												{itemId:'remailRemindPriorityLevel'},null),
						CWHF.createComboWithHelp('admin.user.profile.lbl.remindSeverityLevel','remail.remindSeverityLevel',
												{itemId:'remailRemindSeverityLevel'},null),
						CWHF.createNumberFieldWithHelp('admin.user.profile.lbl.emailLead', 'remail.emailLead',
												0, -100, 100,{width:this.labelWidth+30,hideTrigger:true,itemId:'remailEmailLead'}),
						CWHF.createComboWithHelp('admin.user.profile.lbl.remindMeOnDays','remail.remindMeOnDays',
												{multiSelect:true,itemId:'remailRemindMeOnDays'},null)]
			}]
		});
		return panel;
	},
	/**
	 * Creates the remaining configuration options tab for the user profile.
	 * @return {Ext.form.Panel} A panel for this tab.
	 */
	createTabOther:function(){
		var options=[
				{'id':'UTF-8','label':'Unicode UTF-8'},
				{'id':'ISO-8859-1','label':'Western (ISO-8859-1)'},
				{'id':'ISO-8859-2','label':'Central Europe (ISO-8859-2)'},
				{'id':'ISO-8859-3','label':'Southern Europe (ISO-8859-3)'},
				{'id':'ISO-8859-4','label':'Northern Europe (ISO-8859-4)'},
				{'id':'ISO-8859-6','label':'Arabic (ISO-8859-6)'},
				{'id':'ISO-8859-7','label':'Greek (ISO-8859-7)'},
				{'id':'ISO-8859-8','label':'Hebrew (ISO-8859-8)'},
				{'id':'ISO-8859-9','label':'Turkish (ISO-8859-9)'},
				{'id':'ISO-8859-10','label':'Nordic (ISO-8859-10)'},
				{'id':'ISO-8859-11','label':'Thai (ISO-8859-11)'},
				{'id':'ISO-8859-13','label':'Baltic (ISO-8859-13)'},
				{'id':'ISO-8859-14','label':'Celtic (ISO-8859-14)'},
				{'id':'ISO-8859-16','label':'S.E. Europe (ISO-8859-16)'},
				{'id':'KOI8-R','label':'Russian (KOI8-R)'},
				{'id':'KOI8-U','label':'Ukraine (KOI8-U)'},
				{'id':'Shift-JIS','label':'Japanese (Shift-JIS)'},
				{'id':'ISO-2022-JP','label':'Japanese (ISO-2022-JP)'},
				{'id':'GB18030','label':'Chinese (simplified)'},
				{'id':'Big5','label':'Chinese (traditional)'},
				{'id':'UTF-16','label':'Unicode UTF-16'}];
	    var icon = Ext.create('Ext.Img', {
	        src: Ext.BLANK_IMAGE_URL,
	        width:100,
	        height:100,
	        itemId: "avatarIcon"
	    });
	    var modifyBtn={xtype:'button',
	        style:{ marginBottom: '5px', marginLeft: '5px'},
	        enableToggle:false,
	        //margin:  '0 0 0 20',
	        itemId:'modifyBtn',
	        text:getText('common.btn.modify'),
	        scope:this,
	        handler:function(targetEl){
	            this.modifyIcon(targetEl);
	        }
	    };
	    iconWrapperItems =  [icon,  modifyBtn];
	    if (this.context===2) {
	        //add user: although the icon file is saved in the db, can't be saved directly into person because it does not exist yet
	        //after saving the person the iconKey and iconName should be set on the new personBean
	        iconWrapperItems.push(CWHF.createHiddenField("iconKey",{itemId:"iconKey"}));
	        iconWrapperItems.push(CWHF.createHiddenField("iconName",{itemId:"iconName"}));
	    }
		var iconWrapper=Ext.create('Ext.form.FieldContainer',{
			combineErrors: true,
			itemId: 'iconPanel',
			fieldLabel:getText('admin.user.profile.lbl.avatar'),
			labelWidth:this.labelWidth,
			labelAlign:this.alignR,
			labelStyle:{overflow:'hidden'},
			layout: 'hbox',
			items :iconWrapperItems
		});
		//If new user is normal user then the home page is itemNavigator,
		//If new user is client  user then the home page is cockpit,
		var userHomePageCockpit = false;
		var userHomePageItemNavigator = true;
		//if (this.isUser) {
			if(!this.getIsUser()) {
				userHomePageCockpit = true;
				userHomePageItemNavigator = false;
			}
		//}
		var panel=new Ext.Panel({
			id:'tab_other',
			title:getText('admin.user.profile.lbl.tabOther'),
			layout: {
				type: 'anchor'
			},
			padding:'0 0 0 0',
			bodyPadding:'5 0 0 0',
			items: [{
				xtype: 'fieldset',
				itemId: 'fsother1',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.organization'),
				collapsible: false,
				defaultType: 'textfield',
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createLabelComponent('admin.user.profile.lbl.lastLogin','other.lastLogin'),
	                CWHF.createSingleTreePickerWithHelp("admin.user.profile.lbl.department",
	                    "other.department", [], null,
	                    {//allowBlank:false,
	                     labelWidth: this.labelWidth,
	                     width: 550,
	                     itemId: 'otherDepartment'
	                    }),
						CWHF.createTextField('admin.user.profile.lbl.phone','other.phone'),
						CWHF.createTextField('admin.user.profile.lbl.employeeId', 'other.employeeId'),
	                    iconWrapper,
						CWHF.createNumberField('admin.user.profile.lbl.workingHours','other.workingHours',2,0,24,
								{labelWidth:this.labelWidth, width:this.labelWidth+80,itemId:'otherWorkingHours'}),
						CWHF.createNumberField('admin.user.profile.lbl.hourlyWage','other.hourlyWage',2,0,null,
								{labelWidth:this.labelWidth, width:this.labelWidth+80,itemId:'otherHourlyWage'}),
						CWHF.createNumberField('admin.user.profile.lbl.extraHourWage','other.extraHourWage',2,0,null,
								{labelWidth:this.labelWidth, width:this.labelWidth+80,itemId:'otherExtraHourWage'})]
			}, {
				xtype: 'fieldset',
				itemId: 'fsother2',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.behaviour'),
				collapsible: false,
				defaultType: 'textfield',
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createComboWithHelp('admin.user.profile.lbl.csvEncoding','other.csvEncoding',{itemId:'otherCsvEncoding', data:options, idType:'string'}),
						CWHF.createTextFieldWithHelp('admin.user.profile.lbl.csvSeparator','other.csvSeparator',
								{width:this.labelWidth+20,enforceMaxLength:true,maxLength:1}),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.saveAttachments','other.saveAttachments'),
						CWHF.createComboWithHelp('admin.user.profile.lbl.designPath',
								'other.designPath',{itemId:'otherDesignPath', idType:'string'}),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.activateInlineEdit', 'other.activateInlineEdit'),
						CWHF.createCheckboxWithHelp('admin.user.profile.lbl.activateLayout', 'other.activateLayout'),
						CWHF.getRadioGroupWithHelp('admin.user.profile.lbl.homePage', this.textFieldWidth,
							[{boxLabel: getText('menu.cockpit'), name: 'other.homePage', inputValue: 'cockpit', checked:userHomePageCockpit},
							 {boxLabel: getText('menu.findItems'), name: 'other.homePage', inputValue: 'itemNavigator', checked:userHomePageItemNavigator}],{itemId:"otherHomePage"}),
						CWHF.createComboWithHelp('admin.user.manage.lbl.userLevel','other.userLevel',{itemId:'otherUserLevel'})
					]
			}, {
				xtype: 'fieldset',
				itemId: 'fsother3',
				width: this.FieldSetWidth,
				title: getText('admin.user.profile.fieldset.timer'),
				collapsible: false,
				defaultType: 'textfield',
				//defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createNumberFieldWithHelp('admin.user.profile.lbl.sessionTimeout',
							'other.sessionTimeout', 0, 1, 99999, {width:this.labelWidth+40,hideTrigger:true,disabled:true,itemId:'otherSessionTimeout'})]
			}, {
	                xtype: 'fieldset',
	                itemId: 'fsother4',
	                width: this.FieldSetWidth,
	                title: getText('admin.user.profile.fieldset.substitute'),
	                collapsible: false,
	                defaultType: 'textfield',
	                //defaults: {anchor: '100%'},
	                layout: 'anchor',
	                items: [CWHF.createComboWithHelp('admin.user.profile.lbl.substitutePerson','other.substituteID', {itemId:'otherSubstituteID'})]
	            }
	        ]
		});
		return panel;
	},
	modifyIcon: function(targetEl) {
	    var width = 550;
	    var height = 250;
	    var loadUrl = 'avatar.action';
	    var loadParams = {personID:this.personId, context:this.context};
	    if (this.context===2) {
	        var hiddenIconKey = targetEl.ownerCt.getComponent("iconKey");
	        if (hiddenIconKey) {
	            loadParams["iconKey"] = hiddenIconKey.getValue();
	        }
	        var hiddenIconName = targetEl.ownerCt.getComponent("iconName");
	        if (hiddenIconName) {
	            loadParams["iconName"] = hiddenIconName.getValue();
	        }
	    }
	    var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
	    var submitParams = {personID:this.personId, context:this.context};
	    var submit = [{
	        submitUrl:'avatar!upload.action',
	        submitUrlParams:submitParams,
	        submitButtonText:getText('common.btn.upload'),
	        submitHandler:this.uploadFileHandler
	    },
	    {
	        submitUrl:'avatar!delete.action',
	        submitUrlParams:submitParams,
	        submitButtonText:getText('common.btn.delete'),
	        submitHandler:this.deleteUploadedFileHandler
	    }];
	    var title = getText('common.lbl.upload', getText('admin.customize.list.lbl.icon'));
	    var windowParameters = {title:title,
	        width:width,
	        height:height,
	        load:load, submit:submit,
	        formPanel: this.getFormPanel(),
	        postDataProcess:this.renderUploadPostDataProcess,
	        cancelButtonText: getText('common.btn.done'),
	        refreshAfterCancel:true,
	        extraConfig: {avatarIcon: targetEl.ownerCt.getComponent("avatarIcon")}
	    };
	    var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
	    windowConfig.showWindowByConfig(this);
	},
	getFormPanel: function(fromTree, selectedEntryID) {
	    var icon = Ext.create('Ext.Img', {
	        src: Ext.BLANK_IMAGE_URL,
	        width: 100,
	        height:100,
	        itemId: "avatarIcon"
	    });
	    var iconWrapper=Ext.create('Ext.form.FieldContainer',{
		    combineErrors: true,
		    itemId: 'iconPanel',
		    fieldLabel:getText('admin.user.profile.lbl.avatarActual'),
		    labelWidth:this.labelWidth,
		    labelAlign:this.alignR,
		    labelStyle:{overflow:'hidden'},
		    layout: 'hbox',
		    items :[icon]
	    });
	    var picFiles = [
	        iconWrapper,
	        CWHF.createLabelComponent('admin.user.profile.lbl.avatarName',
	            'avatarName', {itemId:'avatarName',labelWidth:this.labelWidth}),
	        CWHF.createFileField('admin.user.profile.lbl.avatarNew', 'iconFile',
	            {itemId:"iconFile",
	        	 allowBlank:false,
	             labelWidth:this.labelWidth})
	    ];
	    return Ext.create('Ext.form.Panel', {
	            bodyStyle: 'padding:5px',
	            url: 'avatar!upload.action',
	            defaults: {
	                labelStyle:'overflow: hidden;',
	                margin:"5 5 0 0",
	                msgTarget:	'under',
	                anchor:	'-20'
	            },
	            method: 'POST',
	            fileUpload: true,
	            items: picFiles
	        }
	    );
	},
	uploadFileHandler: function(window, submitUrl, submitUrlParams, extraConfig) {
	    var theForm = this.formEdit.getForm();
	    if (!theForm.isValid()) {
	        Ext.MessageBox.alert(getText("admin.customize.list.title.upload", getText("admin.user.profile.lbl.avatar")),
	            getText("admin.customize.list.lbl.iconFileNotSpecified"));
	        return;
	    }
	    var iconFile = this.formEdit.getComponent('iconFile');
	    if (!this.validateFileExtension(iconFile.getRawValue())) {
	        Ext.MessageBox.alert(getText("admin.customize.list.title.upload", "icon"),
	            getText("admin.customize.list.lbl.iconFileWrongType"));
	        return;
	    }
	    theForm.submit({
	        scope: this,
	        params: submitUrlParams,
	        success: function(form, action) {
	            this.renderUploadPostDataProcess(action.result.data, this.formEdit, extraConfig);
	        },
	        failure: function(form, action) {
	            com.trackplus.util.submitFailureHandler(form, action);
	        }
	    })
	},
	validateFileExtension: function(fileName) {
	    var exp = /^.*\.(jpg|JPG|png|PNG|gif|GIF)$/;
	    return exp.test(fileName);
	},
	deleteUploadedFileHandler : function(window, submitUrl, submitUrlParams, extraConfig) {
	    var pictUploadForm = this.formEdit;
	    Ext.Ajax.request({
	        url : submitUrl,
	        scope: this,
	        params: submitUrlParams,
	        success : function(response) {
	            var result = Ext.decode(response.responseText);
	            this.renderUploadPostDataProcess(result.data, pictUploadForm, extraConfig);
	        }
	    })
	},
	renderUploadPostDataProcess: function(data, formPanel, extraConfig) {
	    //actualize the local avatar icon
	    var avatarIcon = formPanel.getComponent("iconPanel").getComponent("avatarIcon");
	    avatarIcon.setSrc(data.icon);
	    //actualize the local avatar name
	    var avatarName =  formPanel.getComponent("avatarName");
	    avatarName.setValue(data.iconName);
	    //empty the file upload component (after either upload or delete)
	    formPanel.getComponent('iconFile').setValue('');
	    var toolbars = this.win.getDockedItems('toolbar[dock="bottom"]');
	    if (toolbars) {
	        //disable delete button if no icon is specified
	        toolbars[0].getComponent(1).setDisabled(CWHF.isNull(data.iconName) || data.iconName==="");
	    }
	    if (extraConfig) {
	        //actualize the avatar icon on the user profile
	        var avatarIcon = extraConfig.avatarIcon;
	        if (avatarIcon) {
	            avatarIcon.setSrc(data.icon);
	            if (this.context===2) {
	                var iconKey = avatarIcon.ownerCt.getComponent("iconKey");
	                if (iconKey) {
	                    iconKey.setValue(data.iconKey);
	                }
	                var hiddenIconName = avatarIcon.ownerCt.getComponent("iconName");
	                if (hiddenIconName) {
	                    hiddenIconName.setValue(data.iconName);
	                }
	            }
	        }
	    }
	},
	/**
	 * Creates the full text search configuration tab
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	/*createTabWatchlist:function(){
		var panel=new Ext.Panel({
			title:getText('admin.user.profile.lbl.tabWatchlist'),
			id: 'tab.watchlist',
			layout: {
				type: 'anchor',
			},
			items: [{
				xtype: 'fieldset',
				width: this.FieldSetWidth,
				title: '',
				collapsible: false,
				defaultType: 'textfield',
				defaults: {anchor: '100%'},
				layout: 'anchor',
				items: []
			}]
		});
		return panel;
	},*/
	getEditUrl: function(context) {
		switch (context) {
		case this.CONTEXT.SELFREGISTRATION:
			return "userProfile!loadSelfRegistration.action";
		case this.CONTEXT.PROFILEEDIT:
			return "userProfile!loadEditMyProfile.action";
		case this.CONTEXT.USERADMINADD:
			return "userProfile!loadAddUser.action";
		case this.CONTEXT.USERADMINEDIT:
			return "userProfile!loadEditUser.action";
		}
	},
	loadProfile: function() {
		var me=this;
		this.createMainForm();
		var theUrl = this.getEditUrl(this.context);
		borderLayout.setLoading(true);
		this.mainForm.getForm().load({url: theUrl,
			params:{context:this.context},
			scope: this,
			clientValidation:false,
			success: function(form, action) {
				try{
					if(CWHF.isNull(this.btnSave)){
						this.createSaveButton();
					}
					this.btnSave.setDisabled(false);
					this.jsonData=action.result.data;
					this.postDataLoadCombos(this.jsonData, this.mainForm);
				}catch(ex){}
				borderLayout.setLoading(false);
			},
			failure:function(form, action){
				borderLayout.setLoading(false);
				com.trackplus.util.submitFailureHandler(form, action);
			}
		});
		return this.mainForm;
	},
	createMainForm: function(extraCfg) {
		var tabPanel = this.createTabPanel();
		var formCfg={
			url:'userProfile!save.action',
			border: false,
			margin: '3 0 0 0',
			baseCls:'x-plain',
			layout:'fit',
			items:[tabPanel]
		};
		if (extraCfg) {
			//add extra panel configuration
			for (propertyName in extraCfg) {
				formCfg[propertyName] = extraCfg[propertyName];
			}
		}
		this.mainForm = Ext.create('Ext.form.Panel',formCfg);
		return this.mainForm;
	},
	/**
	 * Create the main component here.
	 * @param {Object} jsonData The data required for this component
	 * @return {Ext.form.Panel} The user profile configuration form
	 */
	createTabPanel:function(){
		this.applyPasswordVType();
		var tabPanel = new Ext.TabPanel({
			itemId: 'tabPanel',
			plain:true,
			border:false,
			bodyBorder:false,
			defaults:{
				border:false,
				autoScroll:true,
				bodyStyle:{
					border:'none'
					//padding:'10px'
				}
			}
		});
		tabPanel.add(this.createTabMain());
		if (this.context !== this.CONTEXT.SELFREGISTRATION) {
			tabPanel.add(this.createTabEmail());
			tabPanel.add(this.createTabOther());
			//tabPanel.add(this.createTabWatchlist());
		}
		return tabPanel;
	},
	/**
	 * The save function to submit the modified user profile
	 * to the server.
	 */
	save:function(){
		borderLayout.setLoading(true);
		var tabBar=this.getTabPanel().getTabBar();
		for(var i=0;i<tabBar.items.length;i++){
			var headerCm=tabBar.getComponent(i);
			headerCm.removeCls("errorTab");
		}
		if(!this.mainForm.getForm().isValid()){
			var invalidFields = this.mainForm.getForm().getFields().filterBy(function(field) {
				return !field.validate();
			});
			var tabErrors=new Array();
			for(var i=0;i<invalidFields.items.length;i++){
				var field=invalidFields.items[i];
				var id=field.getItemId();
				var prefix=id.substring(0,id.indexOf('.'));
				if(!Ext.Array.contains(tabErrors,prefix)){
					tabErrors.push(prefix);
				}
			}
			this.markErrorTabs(tabErrors);
			borderLayout.setLoading(false);
			CWHF.showMsgError(getText('admin.user.profile.err.errorSave'));
			return false;
		}
		borderLayout.setLoading(true);
		this.mainForm.getForm().submit({
			url:'userProfile!save.action',
			params: {context: this.context},
			scope: this,
			success: function(form, action) {
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('admin.user.profile.lbl.successSave'));
				var result = action.result;
				if (result.localeChange) {
					window.location.href = com.trackplus.TrackplusConfig.contextPath + "/admin.action";
				}
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				if (action.failureType!=='client') {
					this.handleErrors(action.result.errors);
				}
				CWHF.showMsgError(getText('admin.user.profile.err.errorSave'));
			}
		});
	},
	validateLoginName:function(selfRegForm){
		this.validateUser(selfRegForm,'userProfile!validateLoginName.action');
	},
	validateUser:function(selfRegForm,url){
		var urlStr='userProfile!validateUser.action';
		if(url){
			urlStr=url;
		}
		var form=this.mainForm;
		if(selfRegForm===true){
			form=this.selfRegForm;
		}else{
			var tabBar=this.getTabPanel().getTabBar();
			for(var i=0;i<tabBar.items.length;i++){
				var headerCm=tabBar.getComponent(i);
				headerCm.removeCls("errorTab");
			}
		}
		form.getForm().submit({
			url:urlStr ,
			params: {context: this.context, personId:this.personId},
			clientValidation: false,
			scope: this,
			success: function(form, action) {
			},
			failure: function(form, action) {
				if (action.failureType!=='client') {
					if(selfRegForm===true){
						this.handleErrorsSelfReg(action.result.errors);
					}else{
						this.handleErrors(action.result.errors);
					}
				}
			}
		});
	},
	/**
	 * Load the combos and some other data after the result has arrived.
	 *
	 */
	postDataLoadCombos: function(lData, form) {
		tabPanel = form.getComponent(0);
		var mainTab = tabPanel.getComponent('tab_main');
		var emailTab = tabPanel.getComponent('tab_remail');
		var otherTab = tabPanel.getComponent('tab_other');
		if (lData['main.adminOrGuest']===true) {
			this.getWrappedControl("tab_main", "fslogin", "mainUserName").setReadOnly(true);
		}
		var locale = this.getWrappedControl("tab_main", "fsname", "mainLocale");
		locale.store.loadData(lData['main.locales']);
		var selectedLocale = lData['main.locale'];
		if(selectedLocale === '') {
			selectedLocale = 'browser';
		}
		locale.setValue(selectedLocale);
		var timezones = this.getWrappedControl("tab_main", "fsname", "mainUserTz");
		timezones.store.loadData(lData['main.timeZones']);
		timezones.setValue(lData['main.userTz']);
		this.getHelpWrapper("tab_main", "fslogin", "mainLdapUser").setDisabled(!lData['main.ldapOn'] || lData['main.forceLdap']);
		if (lData['context'] === this.CONTEXT.SELFREGISTRATION) {
			if (emailTab ) {
				emailTab.setDisabled(true);
			}
			if (otherTab ) {
				otherTab.setDisabled(true);
			}
		}
		var prios = this.getWrappedControl("tab_remail", "fsremail3", "remailRemindPriorityLevel");
		prios.store.loadData(lData['remail.remindPriorityLevels']);
		prios.setValue(lData['remail.remindPriorityLevel']);
		var sevs = this.getWrappedControl("tab_remail", "fsremail3", "remailRemindSeverityLevel");
		sevs.store.loadData(lData['remail.remindSeverityLevels']);
		sevs.setValue(lData['remail.remindSeverityLevel']);
		var days = this.getWrappedControl("tab_remail", "fsremail3", "remailRemindMeOnDays");
		days.store.loadData(lData['remail.remindMeOnDaysList']);
		days.setValue(lData['remail.remindMeOnDays']);
		var deps = this.getWrappedControl("tab_other", "fsother1", "otherDepartment");
		deps.updateMyOptions(lData['departmentTree']);
		deps.setValue(lData['department']);
		var des = this.getWrappedControl("tab_other", "fsother2", "otherDesignPath");
		des.store.loadData(lData['other.designPaths']);
		des.setValue(lData['other.designPath']);
		if (lData['context'] === this.CONTEXT.USERADMINEDIT || lData['context'] === this.CONTEXT.USERADMINADD ) {
			this.getHelpWrapper("tab_other", "fsother3", "otherSessionTimeout").setDisabled(false);
		} else {
			this.getHelpWrapper("tab_other", "fsother3", "otherSessionTimeout").setDisabled(true);
		}
		tabPanel.setActiveTab(mainTab);
		//this.applyMyDomainVType(lData['main.domainPat']);
		//add userEmail only now bacause of the vtype
		this.getControl("tab_main", "fslogin").add(CWHF.createTextFieldWithHelp('admin.user.profile.lbl.userEmail','main.userEmail',
				{vtype:'email',vtypeText:getText('admin.user.profile.err.emailAddress.format'), allowBlank:false, maxLength:60,afterLabelTextTpl:this.reqTpl,value:lData["main.userEmail"],
					listeners: {
						blur: {
							element: 'el',
							scope: this,
							fn: function() {
								this.validateUser.call(this);
							}
						}
					}
				}
			)
		);
		//this.validateUser();
	    var avatarIcon = this.getControl("tab_other", "fsother1", "iconPanel", "avatarIcon")
	    var iconUrl = lData["other.iconUrl"];
	    if (iconUrl)  {
	        avatarIcon.setSrc(iconUrl);
	    }
		var userLevel = this.getWrappedControl("tab_other", "fsother2", "otherUserLevel");
	    if (userLevel) {
	        userLevel.store.loadData(lData['userLevelList']);
	        userLevel.setValue(lData['other.userLevel']);
			userLevel.setDisabled(lData['readOnly']);
	    }
	    var substitutePerson = this.getWrappedControl("tab_other", "fsother4", "otherSubstituteID");
	    if (substitutePerson) {
	        substitutePerson.store.loadData(lData['other.substituteList']);
	        substitutePerson.setValue(lData['other.substituteID']);
	    }
	},
	applyMyDomainVType: function(domainPattern) {
		// Add the additional 'advanced' VTypes
		Ext.apply(Ext.form.field.VTypes, {
			myDomain: function(val) {
				var domainExp1=/\b[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,4}\b/;
				var tst=domainExp1.test(val.toLowerCase());
				if (!tst) {
					Ext.form.field.VTypes["myDomainText"] = getText('admin.user.profile.err.emailAddress.format');
					return tst;
				}
				var domainExp2=new RegExp(domainPattern);
				tst=domainExp2.test(val.toLowerCase());
				if (!tst) {
					Ext.form.field.VTypes["myDomainText"]=getText('admin.user.profile.err.emailAddress.domain');
					return tst;
				}
				return tst;
			},
			myDomainText:'' // will be substituted, see above
		});
	},
	applyPasswordVType: function() {
		// Add the additional 'advanced' VTypes
		Ext.apply(Ext.form.field.VTypes, {
			password: function(val, field) {
				if (field.initialPassField) {
					// var pwd = field.up('form').down('#' + field.initialPassField);
					var pwd = Ext.getCmp('mainPasswd');
					return (val === pwd.getValue());
				}
				return true;
			},
			passwordText: getText('admin.user.profile.err.password.match')
		});
	},
	handleErrorsSelfReg:function(errors){
		var me=this;
		var errStr='';
		if (errors && errors.length>0) {
			for(var i=0;i<errors.length;i++){
				var error=errors[i];
				var id=error.id;
				var inputComp=null;
				if(id){
					inputComp=CWHF.getWrappedControl.apply(me.selfRegForm, [id]);
				}
				if(inputComp){
					inputComp.markInvalid(error.label);
				}else{
					errStr+=error.label+"</br>";
				}
			}
			if(errStr!==''){
				CWHF.showMsgError(error.label);
			}
		}
	},
	handleErrors:function(errors){
		var errStr='';
		var tabErrors=new Array();
		if (errors && errors.length>0) {
			for(var i=0;i<errors.length;i++){
				var error=errors[i];
				var id=error.id;
				var inputComp=null;
				if(id){
					inputComp=Ext.getCmp(id);
					var prefix=id.substring(0,id.indexOf('.'));
					if(!Ext.Array.contains(tabErrors,prefix)){
						tabErrors.push(prefix);
					}
				}
				if(inputComp){
					inputComp.markInvalid(error.label);
				}else{
					errStr+=error.label+"</br>";
				}
			}
			if(errStr!==''){
				CWHF.showMsgError(error.label);
			}
			this.markErrorTabs(tabErrors);
		}
	},
	markErrorTabs:function(tabErrors){
		var tabErrorsCmp=new Array();
		if (tabErrors.length>0) {
			for(var i=0;i<tabErrors.length;i++){
				var tabID='tab.'+tabErrors[i];
				var tabComp=this.getControl(tabID);
				if(tabComp){
					tabErrorsCmp.push(tabComp);
				}
			}
			if (tabErrorsCmp.length>0) {
				var selectedTab=this.getTabPanel().getActiveTab();
				if(!Ext.Array.contains(tabErrorsCmp,selectedTab)){
					this.getTabPanel().setActiveTab(tabErrorsCmp[0])
				}
				var tabBar=this.getTabPanel().getTabBar();
				for(var i=0;i<tabErrorsCmp.length;i++){
					var index=this.getTabPanel().items.findIndex('id', tabErrorsCmp[i].id);
					var headerCm=tabBar.getComponent(index);
					headerCm.addCls("errorTab");
				}
			}
		}
	},
	createSelfRegFormPanel:function(){
		var me=this;
		me.applyPasswordVType();
		var form=Ext.create('Ext.form.Panel', {
			layout:'anchor',
			border	: false,
			autoScroll:true,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			itemId: 'panel_selfreg',
			/*style:{
				borderBottom:'1px solid #D0D0D0'
			}, */
			items:[
			CWHF.createTextFieldWithHelp('admin.user.profile.lbl.userName','main.userName',
						{itemId:'mainUserName',enableKeyEvents:true,allowBlank:false},
						{listeners:
						{
							//keyup: {
							blur: {
//									element: 'el',
									scope: this,
									fn: function() {
										this.validateLoginName.call(this,true);
									}
								}
							}
						}
				),
				CWHF.createCheckboxWithHelp('admin.user.profile.lbl.ldapUser', 'main.ldapUser', {},
						{change:{
								fn: this.changeLdapSelReg,
								scope: this
							}
						}
				),
				CWHF.createTextField('admin.user.profile.lbl.passwd','main.passwd',
								{inputType:'password',minLength:5, itemId: 'mainPasswd', id:'mainPasswd'}),
				CWHF.createTextField('admin.user.profile.lbl.passwd2','main.passwd2',
								{inputType:'password',vtype:'password', itemId: 'mainPasswd2', initialPassField:'main.passwd'}),
				CWHF.createTextFieldWithHelp('admin.user.profile.lbl.userEmail','main.userEmail',{vtype:'email',allowBlank:false}),
				CWHF.createTextField('admin.user.profile.lbl.lastName','main.lastName',  {allowBlank:false},
					//{listeners:
					{
						blur: {
							element: 'el',
							fn: function() {
								this.validateUser.call(this,true);
							},
							scope: this
						}
					 }
				),
				CWHF.createTextField('admin.user.profile.lbl.firstName','main.firstName',  {allowBlank:false},
					//{listeners:
						{
							blur: {
								element: 'el',
								fn: function() {
									this.validateUser.call(this,true);
								},
								scope: this
							}
					 //}
					}),
				CWHF.createComboWithHelp('admin.user.profile.lbl.locale','main.locale',{itemId:'mainLocale', idType:'string'}),
				CWHF.createComboWithHelp('admin.user.profile.lbl.usertz','main.userTz',{itemId:'mainUserTz', idType:'string'})
			]
		});
		me.selfRegForm=form;
		return form;
	}
});
com.trackplus.admin.user.selfRegistrationAfterSubmit=function(params, result){
	var title=getText("logon.lbl.register");
	var emailSent=result.emailSent;
	var email=result.email;
	var message="";
	if(emailSent===true){
		message=getText("logon.register.msg.registeredWithEmailSent",email);
	}else{
		message=getText("logon.register.msg.registeredNoEmailSent");
	}
	Ext.MessageBox.show({
		title: title,
		msg: message,
		width: 400,
		buttons: Ext.Msg.OK,
		icon: Ext.MessageBox.INFO
	});
}
com.trackplus.admin.user.createSelfRegistrationDialog=function(){
	var context={
		selfRegistration:0
	};
	var profile=Ext.create('com.trackplus.admin.user.Profile',{
		context:context
	});
	var submit = {
		submitUrl:'userProfile!save.action?context=0',
		refreshAfterSubmitHandler: com.trackplus.admin.user.selfRegistrationAfterSubmit
	};
	var formPanel=profile.createSelfRegFormPanel();
	var windowParameters = {
		title:getText('admin.user.profile.title.create'),
		width:640,
		height:350,
		submit:submit,
		submitButtonText:getText('logon.lbl.register'),
		formPanel:formPanel
	};
	formPanel.getForm().load({
		url: 'userProfile!loadSelfRegistration.action',
		params:{
			context:context
		},
		scope: this,
		clientValidation:false,
		success: function(form, action) {
			try{
				profile.jsonData=action.result.data;
				var lData=action.result.data;
				var locale =CWHF.getWrappedControl.call(formPanel,"mainLocale");
				locale.store.loadData(lData['main.locales']);
				locale.setValue(lData['main.locale']);
				var timezones = CWHF.getWrappedControl.call(formPanel, "mainUserTz");
				if(timezones){
					timezones.store.loadData(lData['main.timeZones']);
					timezones.setValue(lData['main.userTz']);
				}
				CWHF.getWrappedControl.call(formPanel, "mainLdapUser").setDisabled(!lData['main.ldapOn'] || lData['main.forceLdap']);
			}catch(ex){}
		},
		failure:function(form, action){
			com.trackplus.util.submitFailureHandler(form, action);
		}
	});
	var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
	windowConfig.showWindowByConfig(profile);
	// windowConfig.disableSubmitButton(profile.win,true,0);
	return {
		profile:profile,
		windowConfig:windowConfig
	};
};

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.user.Person", {
	extend:	"com.trackplus.admin.GridBase",
	xtype: "person",
    controller: "person",
	config: {
		context: null,
		isUser: null,
		userLevels:null,
		featureList: null
	},
	enableColumnHide: true,
	enableColumnMove: true,
	allowMultipleSelections:true,
	profile:null,
	actionActivate:null,
	actionDeactivate:null,
	actionUserLevel:null,
	actionRoleAssignments: null,
	actionFilterAssignments: null,
	actionCokpitAssignment:null,
	actionSyncLdap: null,
	initComponent : function() {
		this.fields = this.getGridFields();
		this.columns = this.getColumnModel();
		var param = "?isUser=" + this.getIsUser();
		this.storeUrl = "person.action" + param;
		this.callParent();
		this.profile=Ext.create("com.trackplus.admin.user.Profile",{context:this.getContext(), isUser: this.getIsUser()});
		this.initPerson();
	},
	getEntityLabel: function() {
		return getText("admin.user.lbl.user");
	},
	initPerson:function(){
		//this.initActions();
		Ext.Ajax.request({
			url: "person!getLdapIsOn.action",
			scope: this,
			success: function(response) {
				var result = Ext.decode(response.responseText);
				var ldapIsDisabled;
				if (result.value) {
					ldapIsDisabled = false;
				} else {
					ldapIsDisabled = true;
				}
				this.actionSyncLdap.setDisabled(ldapIsDisabled);
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
		});
	},
	initActions:function() {
		this.actionAdd = CWHF.createAction(this.getAddButtonKey(), this.getAddIconCls(), "onAdd", {tooltip:this.getActionTooltip(this.getAddTitleKey())});
		this.actionEdit = CWHF.createAction(this.getEditButtonKey(), this.getEditIconCls(), "onEdit", {tooltip:this.getActionTooltip(this.getEditTitleKey()), disabled:true});
		this.actionDelete = CWHF.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(), "onDelete", {tooltip:this.getActionTooltip(this.getDeleteTitleKey()), disabled:true});
		this.actionActivate = CWHF.createAction("common.btn.activate", this.getActivateIconCls(), "onActivate", {tooltip:this.getActionTooltip("common.lbl.activate"), disabled:true});
		this.actionDeactivate = CWHF.createAction("common.btn.deactivate", this.getDeactivateIconCls(), "onDeactivate", {tooltip:this.getActionTooltip("common.lbl.deactivate"), disabled:true});
		this.actionUserLevel = CWHF.createAction("common.btn.userLevel", "personSystemAdmin", "onUserLevel", {tooltip:getText("common.btn.userLevel"), disabled:true});
		this.actionRoleAssignments = CWHF.createAction("admin.user.manage.lbl.roleAssignments",
				this.getRoleAssignCls(), "onShowAssignments", {tooltip:getText("admin.user.manage.lbl.roleAssignments"), disabled:true});
	    this.actionFilterAssignments = CWHF.createAction("admin.user.manage.lbl.filterAssignments",
	        this.getFilterAssignCls(), "onFilterAssignments", {tooltip:getText("admin.user.manage.lbl.filterAssignments"), disabled:true});
		this.actionCokpitAssignment=CWHF.createAction("admin.user.manage.lbl.cokpitAssignment", this.getCokpitAssignmentIconCls(), "onCokpitAssignment",
				{tooltip:getText("admin.user.manage.lbl.cokpitAssignment"), disabled:true});
		this.actionSyncLdap = CWHF.createAction("common.btn.syncLdap", this.getAddIconCls(), "onSyncLdap", {tooltip:getText("common.btn.syncLdap.tt")});
		this.actions=[this.actionAdd, this.actionEdit, this.actionDelete,
					this.actionActivate, this.actionDeactivate,
					this.actionUserLevel];
		if(this.getIsUser()) {
			this.actions.push(this.actionRoleAssignments);
		}
	    this.actions.push(this.actionFilterAssignments);
	    if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
	    	this.actions.push(this.actionCokpitAssignment);
	    }
		if(this.getIsUser()) {
			this.actions.push(this.actionSyncLdap);
		}
	},
	getGridFields: function() {
		var gridFields = [{name: "id", type: "int"},
			{name: "userName", type: "string"},
			{name: "name", type: "string"},
			{name: "userEmail",	type: "string"},
			{name: "active", type: "boolean"},
			{name: "activeLabel", type: "string"},
			{name: "userLevelLabel", type: "string"},
			{name: "locale", type: "string"},
			{name: "phone", type: "string"},
			{name: "employeeId", type: "string"},
			{name: "lastLogin",	type: "date", dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat},
			{name: "department", type: "string"},
			{name: "substituteName", type: "string"}];
		if (this.getIsUser() && this.getFeatureList()) {
			Ext.Array.forEach(this.getFeatureList(), function(feature) {
				var featureID = feature["featureID"];
				gridFields.push({name: featureID, type:"boolean"});
				}, this);
		}
		return gridFields;
	},
	getViewConfig: function() {
		return {
			forceFit: true,
			markDirty: false,
			stripeRows: true,
			listeners: {
				//although these event listeners could be attached to the gridPanel directly but then the corresponding listeners of the viewController are not called
				itemdblclick: "onItemDblClick",
				itemcontextmenu: "onItemContextMenu",
				selectionchange: "onSelectionChange"
			}
		};
	},
	/**
	 * The iconCls for the add button, overwrites base class icon
	 */
	getAddIconCls: function() {
		return "personAdd";
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getEditIconCls: function() {
		return "personEdit";
	},
	/**
	 * The iconCls for the activate button
	 */
	getActivateIconCls: function() {
		return "personActivate";
	},
	/**
	 * The iconCls for the deactivate button
	 */
	getDeactivateIconCls: function() {
		return "personDeactivate";
	},
	getRoleAssignCls: function() {
		return "roleAssign";
	},
	getFilterAssignCls: function() {
	    return "filter";
	},
	getCokpitAssignmentIconCls: function() {
		return "cockpitReset";
	},
	/**
	 * Specify the columnModel implementing the getColumnModel() instead of columnModel config parameter
	 * because "this" is not available in config
	 */
	getColumnModel:function() {
		var userLevelLabels = [];
		if (this.getUserLevels()) {
			Ext.Array.forEach(this.getUserLevels(), function(userLevel) {
				var label = userLevel["label"];
				userLevelLabels.push(label);
				}, this);
		}
		var columnModel = [{text: getText("admin.user.profile.lbl.userName"),
				flex:2, dataIndex: "userName", sortable:true, renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("common.lbl.name"),
				flex:2, dataIndex: "name", sortable:true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.profile.lbl.userEmail"),
				flex:2, dataIndex: "userEmail", sortable:true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.manage.lbl.userLevel"),
				flex:1, dataIndex: "userLevelLabel", sortable:true,
				renderer:this.renderer,
				filter: {
					type: "list",
					options: userLevelLabels
				}
			}, {
				text: getText("admin.user.profile.lbl.department"),
				flex:2, dataIndex: "department", sortable:true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.manage.lbl.activ"),
				flex:1, dataIndex: "activeLabel", sortable:true, hidden: true,
				renderer:this.renderer,
				filter: {
					type: "list",
					options: [getText("common.boolean.Y"),
								getText("common.boolean.N")]
				}
			}, {
				text: getText("admin.user.profile.lbl.locale"),
				flex:1, dataIndex: "locale", sortable:true, hidden: true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.profile.lbl.phone"),
				flex:1, dataIndex: "phone", sortable:true, hidden: true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.profile.lbl.employeeId"),
				flex:1, dataIndex: "employeeId", sortable:true, hidden: true,
				renderer:this.renderer,
				filter: {
		            type: "string"
		        }
			}, {
				text: getText("admin.user.profile.lbl.lastLogin"),
				flex:1, dataIndex: "lastLogin", sortable:true, hidden: true,
				renderer:this.dateRenderer,
				filter: {
		            type: "date"
		        }
			}, {
	            text: getText("admin.user.profile.lbl.substitutePerson"),
	            flex:2, dataIndex: "substituteName", sortable:true, hidden: true,
	            renderer:this.renderer,
				filter: {
		            type: "string"
		        }
	          }];
		if (this.getIsUser() && this.getFeatureList()) {
			Ext.Array.forEach(this.getFeatureList(), function(feature) {
				var featureID = feature["featureID"];
				var featureName = feature["featureName"];
				columnModel.push({
		          	  text: featureName,
		        	  xtype: "checkcolumn",
		        	  flex:1,
		        	  dataIndex: featureID,
		        	  sortable:true,
		        	  hidden: false,
		        	  listeners: {"checkchange": {fn: this.onCheckChange, scope:this, feature:feature},
		  		  				"beforecheckchange": {fn: this.onBeforeCheckChange, scope:this, feature:feature}}
				});
				}, this);
		}
		return columnModel;
	},
	onCheckChange: function(checkBox, rowIndex, checked, eOpts) {
		var record = this.grid.getStore().getAt(rowIndex);
		var feature = eOpts.feature;
		var featureID = feature.featureID;
		if (record && feature) {
			var params = {personID:record.data["id"], featureID:featureID, featureValue:checked};
			Ext.Ajax.request({
				url: this.getBaseAction() + "!changeFeature.action",
				params: params,
				scope: this,
				success: function(response) {
					var result = Ext.decode(response.responseText);
					if (result.success) {
						feature["activeWithFeature"] = result["activeWithFeature"];
					} else {
						com.trackplus.util.showError(result);
					}
				},
				failure: function(response) {
					Ext.MessageBox.alert(this.failureTitle, response.responseText);
				}
			});
		}
	},
	onBeforeCheckChange: function(checkBox, rowIndex, checked, eOpts) {
		var feature = eOpts.feature;
		var record = this.grid.getStore().getAt(rowIndex);
		var featureName = feature["featureName"];
		var maxWithFeature = feature["maxWithFeature"];
		var activeWithFeature = feature["activeWithFeature"];
		if (checked===true && activeWithFeature >= maxWithFeature && record.data["active"]) {
			Ext.MessageBox.alert(this.failureTitle, getText("admin.user.manage.err.featureExceeded", maxWithFeature, activeWithFeature, featureName));
			return false;
		}
	},
	dateRenderer: function(value, metadata, record) {
		if (!record.data["active"]) {
			metadata.style = 'color:#909090';
		}
		return Ext.util.Format.date(value, com.trackplus.TrackplusConfig.DateTimeFormat);
	},
	/**
	 * Render the inherited rows as grey
	 */
	renderer: function(value, metadata, record) {
		if (!record.data["active"]) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	getGridSelectionModel: function() {
		return Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"});
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	getGridContextMenuActions: function(selectedRecords, selectionIsSimple) {
		var actions = [];
		if (selectionIsSimple) {
			actions.push(this.actionEdit);
		}
		actions.push(this.actionDelete);
		actions.push(this.actionActivate);
		actions.push(this.actionDeactivate);
		actions.push(this.actionUserLevel);
	    actions.push(this.actionFilterAssignments);
		if (selectionIsSimple) {
			actions.push(this.actionRoleAssignments);
		}
		return actions;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.user.PersonController", {
	extend: "Ext.app.ViewController",
	alias: "controller.person",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction:"person",
	entityID:"objectID", 
	editWidth : 780,
	editHeight : 500,
	getSelectedPersonIDs: function() {
		var selectedRecords = this.getView().getSelectedRecords();
		return this.getSelectedIDs(selectedRecords);
	},
	/**
	 * Enable change only if not inherited
	 */
	onSelectionChange: function(view, arrSelections) {
		if (CWHF.isNull(arrSelections) || arrSelections.length===0){
			this.getView().actionDelete.setDisabled(true);
			this.getView().actionEdit.setDisabled(true);
			this.getView().actionActivate.setDisabled(true);
			this.getView().actionDeactivate.setDisabled(true);
			this.getView().actionUserLevel.setDisabled(true);
			this.getView().actionRoleAssignments.setDisabled(true);
	        this.getView().actionFilterAssignments.setDisabled(true);
			this.getView().actionCokpitAssignment.setDisabled(true);
		} else {
			if (arrSelections.length===1) {
				this.getView().actionEdit.setDisabled(false);
				this.getView().actionRoleAssignments.setDisabled(false);
			} else {
				this.getView().actionEdit.setDisabled(true);
				this.getView().actionRoleAssignments.setDisabled(true);
	        }
	        this.getView().actionDelete.setDisabled(false);
			this.getView().actionActivate.setDisabled(false);
			this.getView().actionDeactivate.setDisabled(false);
			this.getView().actionUserLevel.setDisabled(false);
	        this.getView().actionFilterAssignments.setDisabled(false);
			this.getView().actionCokpitAssignment.setDisabled(false);
		}
	},
	/*protected*/getDeleteParamName: function() {
	    return "selectedPersonIDs";
	},
	onActivate: function() {
		Ext.Ajax.request({
			url: this.getBaseAction() + "!activate.action",
			params: {selectedPersonIDs: this.getSelectedPersonIDs()},
			scope: this,
			success: function(response) {
				var result = Ext.decode(response.responseText);
				if (result.success) {
					this.reload();
				} else {
					com.trackplus.util.showError(result);
				}
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
		});
	},
	onDeactivate: function() {
		Ext.Ajax.request({
			url: this.getBaseAction() + "!deactivate.action",
			params: {selectedPersonIDs: this.getSelectedPersonIDs()},
			scope: this,
			success: function(response) {
				var result = Ext.decode(response.responseText);
				if (result.success) {
					this.reload();
				} else {
					com.trackplus.util.showError(result);
				}
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
		})
	},
	onUserLevel: function(userLevel) {
		var submitUrl = this.getBaseAction() + "!userLevel.action";
		var submitParams = {selectedPersonIDs: this.getSelectedPersonIDs()}
		var submit = {submitUrl:submitUrl,
					submitUrlParams:submitParams,
					submitButtonText:getText("common.btn.save"),
					refreshAfterSubmitHandler:this.reload
					};
		var items = this.getUserLevelItems();
		var windowParameters = {title:getText("common.btn.userLevel"),
			width:300,
			height:120,
			submit:submit,
			items:items};
		var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	getUserLevelItems: function() {
		var sysAdmin=com.trackplus.TrackplusConfig.user.sysAdmin;
		var data = null;
		if (sysAdmin) {
			data = this.getView().getUserLevels();
		} else {
			//a system manager might not set new system admins
			data = [];
			Ext.Array.forEach(this.getView().getUserLevels(), function(record) {
					var userLevelID = record["id"];
					if (userLevelID && userLevelID!==2) {
						data.push(record);
					}
					},
					this);
		}
		return [CWHF.createCombo("admin.user.manage.lbl.userLevel", "userLevel",
				{data:data, labelWidth:100, allowBlank:false})];
	},
	onShowAssignments: function() {
		var title = getText("admin.user.manage.lbl.roleAssignments");
		var submitParams = this.getEditParams();
		var load = {loadHandler: this.showAssignmentsLoadHandler};
		var personID = null;
		var recordData = this.getView().getSingleSelectedRecordData();
		if (recordData) {
			personID = recordData["id"];
		}
		var windowParameters = {title:title,
			width:500,
			height:350,
			load:load,
			//submit:submit, no submit
			cancelButtonText: getText("common.btn.done"),
			layout:"border",
			formPanel: this.getRoleAssignmentGrid(personID)};
		var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	onFilterAssignments: function() {
	    var title = getText("admin.user.manage.lbl.filterAssignments");
	    var submitParams = this.getEditParams();
	    var load = {loadHandler: this.showAssignmentsLoadHandler};
	    var personIDs = this.getSelectedPersonIDs();
	    var windowParameters = {title:title,
	        width:500,
	        height:350,
	        load:load,
	        //submit:submit, no submit
	        cancelButtonText: getText("common.btn.done"),
	        layout:"border",
	        formPanel: this.getFilterAssignmentGrid(personIDs)};
	    var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
	    windowConfig.showWindowByConfig(this);
	},
	onCokpitAssignment: function() {
		var me=this;
		com.trackplus.dashboard.resetDashboard(this.getBaseAction() + "!cokpitAssignment.action",
			{selectedPersonIDs: this.getSelectedPersonIDs()}, me.cokpitAssignmentSuccess,me);
	},
	cokpitAssignmentSuccess: function() {
		this.reload();
	},
	/**
	 * Empty (but not null) function to avoid the calling of getForm().load() in windowConfig
	 * loadUrl and loadParams is not specified because the data will be loaded through the grid's store
	 */
	showAssignmentsLoadHandler: function(loadUrl, loadParams) {
	},
	getRoleAssignmentGrid: function(personID) {
		var gridComponent = Ext.create("com.trackplus.admin.user.UserRolesInProject",
				{personID:personID, group:false});
		//var grid = gridComponent.getGrid();
		//grid.store.load();
		return [gridComponent];
	},
	getFilterAssignmentGrid: function(personIDs) {
	    var gridComponent = Ext.create("com.trackplus.admin.user.FiltersInUserMenu",
	        {personIDs:personIDs});
	    //var grid = gridComponent.getGrid();
	    return [gridComponent];
	},
	onSyncLdap: function() {
		Ext.Ajax.request({
			url: this.getBaseAction() + "!syncldap.action",
			scope: this,
			success: function(response) {
				var result = Ext.decode(response.responseText);
				if (result.success) {
					this.reload();
				} else {
					com.trackplus.util.showError(result);
				}
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
		})
	},
	/**
	 * Parameters for loading the edited entity
	 * recordData: the selected entity data
	 * action: the submit action
	 */
	getLoadParams: function(recordData, operation) {
		return {context:this.getContext(recordData, operation),
			personId: recordData['id']};
	},
	getSaveParams: function(recordData, operation){
		return {isUser:this.getView().getIsUser(), context:this.getContext(recordData, operation),
			personId: recordData['id']};
	},
	getContext: function(recordData, operation) {
		var objectID = recordData['id'];
		if (CWHF.isNull(objectID)) {
			return this.getView().profile.CONTEXT.USERADMINADD;
		} else {
			return this.getView().profile.CONTEXT.USERADMINEDIT
		}
	},
	/**
	 * Url for editing an entity
	 * We suppose that add/edit/copy use the same edit method on server side
	 * Differentiation is made based on this.entityID and copy request parameter
	 * add: this.entityID===null
	 * edit: this.entityID && copy===false
	 * copy: this.entityID && copy===true
	 */
	getEditUrl: function(recordData, operation) {
		var context = this.getContext(recordData, operation);
		return this.getView().profile.getEditUrl(context);
	},
	/**
	 * Url for editing an entity
	 * We suppose that add/edit/copy use the same edit method on server side
	 * Differentiation is made based on this.entityID and copy request parameter
	 * add: this.entityID===null
	 * edit: this.entityID && copy===false
	 * copy: this.entityID && copy===true
	 */
	getSaveUrl: function(recordData, operation) {
		return "userProfile!save.action";
	},
	/**
	 * Create the form to edit
	 */
	createEditForm: function(recordData, operation) {
		var context = this.getContext(recordData, operation);
		this.getView().profile.context = context;
		this.getView().profile.personId = recordData['id'];
		return this.getView().profile.createMainForm();
	},
	/**
	 * Extra processing that should be done in the edit panel after the data is loaded from the server
	 * like load combo data, show/hide contols
	 */
	afterLoadForm: function(data, panel) {
		this.getView().profile.postDataLoadCombos(data, panel);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
Ext.define('com.trackplus.admin.user.Group',{
	extend:'com.trackplus.admin.TreeDetailAssignment',
	config: {
		rootID: '_'
	},
	baseAction:"group",
	editWidth: 475,
	editHeight: 305,
	labelWidth:145,
	allowMultipleNodeSelections: true,
	/**
	 * Whether the tree has double click listener
	 */
	treeHasItemdblclick: true,
	/**
	 * actions
	 */
	actionAddGroup: null,
	actionEditGroup: null,
	actionShowAssignments: null,
	actionDeleteGroup: null,
	actionRemovePerson: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	getEntityLabel: function(extraConfig) {
		return getText("admin.user.group.lbl.group");
	},
	getAddIconCls: function() {
		return "groupAdd";
	},
	getEditIconCls: function() {
		return "groupEdit";
	},
	getRoleAssignCls: function() {
		return "roleAssign";
	},
	/**
	 * Initialize all possible actions
	 */
	initActions: function(){
		this.actionAddGroup = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {isLeaf:false}),
				this.getAddIconCls(), this.onAddGroup, this.getTitle(this.getAddTitleKey(), {isLeaf:false}));
		this.actionEditGroup = this.createLocalizedAction(this.getTitle(this.getEditTitleKey(), {isLeaf:false}),
				this.getEditIconCls(), this.onEditGroup, this.getTitle(this.getEditTitleKey(), {isLeaf:false}), true);
		this.actionShowAssignments = this.createLocalizedAction(getText("admin.user.group.lbl.roleAssignments"),
				this.getRoleAssignCls(), this.onShowAssignments, getText("admin.user.group.lbl.roleAssignments"), true);
		this.actionDeleteGroup = this.createLocalizedAction(this.getTitle(this.getDeleteTitleKey(), {isLeaf:false}),
				this.getDeleteIconCls(), this.onDeleteGroup, this.getTitle(this.getDeleteTitleKey(), {isLeaf:false}), true);
		this.actionRemovePerson = this.createLocalizedAction(getText("common.lbl.remove", getText("admin.user.lbl.user")),
				this.getDeleteIconCls(), this.onRemovePerson, getText("common.lbl.remove", getText("admin.user.lbl.user")));
		this.actions=[this.actionAddGroup, this.actionEditGroup, this.actionDeleteGroup, this.actionShowAssignments];
	},
	/**
	 * Context menu for tree
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectionIsSimple) {
			if (selectedRecord.isLeaf()) {
				return [this.actionRemovePerson];
			} else {
				return [this.actionEditGroup, this.actionShowAssignments, this.actionDeleteGroup];
			}
		} else {
			return [this.actionDeleteGroup];
		}
	},
	/**
	 * Create the edit
	 */
	onTreeNodeDblClick: function(view, record) {
		var leaf = record.isLeaf();
		if (!leaf) {
			this.onEditGroup();
		}
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 * Implement only if replaceToolbarOnTreeNodeSelect is false
	 */
	getToolbarActionChangesForTreeNodeSelectionChange: function(selectedNodes) {
		var noSelection = false;
		var multipleSelection = false;
		if (CWHF.isNull(selectedNodes)) {
			noSelection = true;
		} else {
			multipleSelection = selectedNodes.length>1;
		}
		this.actionEditGroup.setDisabled(noSelection || multipleSelection);
		this.actionShowAssignments.setDisabled(noSelection || multipleSelection);
		this.actionDeleteGroup.setDisabled(noSelection);
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function() {
		return getText("menu.admin.users.groups.tt");
	},
	/**
	 * Handler for adding a new screen
	 */
	onAddGroup: function() {
		var title = this.getTitle(this.getAddTitleKey(), {isLeaf:false});
		return this.onAddEdit(title, {add:true}, {add:true});
	},
	/**
	 * Handler for editing a screen
	 */
	onEditGroup: function() {
		var title = this.getTitle(this.getEditTitleKey(), {isLeaf:false});
		var loadParams = this.getEditParams();
		var submitParams = this.getEditParams();
		return this.onAddEdit(title, loadParams, submitParams);
	},
	onShowAssignments: function() {
		var title = getText("admin.user.group.lbl.roleAssignments");
		var submitParams = this.getEditParams();
		var load = {loadHandler: this.showAssignmentsLoadHandler};
		var personID = null;
		var recordData = this.getSingleSelectedRecordData(true);
		if (recordData) {
			personID = recordData['id'];
		}
		var windowParameters = {title:title,
			width:500,
			height:500,
			load:load,
			//submit:submit, no submit
			cancelButtonText: getText("common.btn.done"),
			formPanel: this.getAssignmentGrid(personID)};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	/**
	 * Empty (but not null) function to avoid the calling of getForm().load() in windowConfig
	 * loadUrl and loadParams is not specified because the data will be loaded through the grid's store
	 */
	showAssignmentsLoadHandler: function(loadUrl, loadParams) {
	},
	getAssignmentGrid: function(personID) {
		var gridComponent = Ext.create("com.trackplus.admin.user.UserRolesInProject",
				{personID:personID, group:true});
		//var grid = gridComponent.getGrid();
		//grid.store.load();
		return [gridComponent];
	},
	/**
	 * Parameters for editing an existing entity
	 * recordData: the selected entity data
	 */
	getEditParams: function() {
		var recordData = this.getSingleSelectedRecordData(true);
		if (recordData) {
			var nodeID = recordData['id'];
			if (nodeID) {
				return {node:nodeID};
			}
		}
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * isLeaf: whether to add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	onAddEdit: function(title, loadParams, submitParams) {
		var loadUrl = this.getBaseAction() + '!edit.action';
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = this.getBaseAction() + '!save.action';
		var submit = {submitUrl:submitUrl,
					submitUrlParams:submitParams,
					submitButtonText:getText('common.btn.save'),
					refreshAfterSubmitHandler:com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit,
					refreshParametersBeforeSubmit:{nodeIDToReload: this.getRootID()},
					refreshParametersAfterSubmit:[{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
												{parameterName:'reloadTree', fieldNameFromResult:'reloadTree'}]};
		var items = this.getPanelItems();
		var windowParameters = {title:title,
			width:this.editWidth,
			height:this.editHeight,
			load:load,
			submit:submit,
			items:items};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	getPanelItems: function() {
		return [CWHF.createTextField('common.lbl.name','name',
				{anchor:'95%', allowBlank:false, labelWidth:this.labelWidth, maxLength:60, enforceMaxLength:true}),
				{xtype: 'fieldset',
				title: getText('admin.user.group.lbl.groupFlags'),
					collapsible: false,
					layout: 'anchor',
					anchor:'95%',
					height: 145,
					items: [CWHF.createCheckbox("admin.user.group.lbl.groupFlagOriginator", "originator", {labelWidth:this.labelWidth}),
							CWHF.createCheckbox("admin.user.group.lbl.groupFlagManager", "manager", {labelWidth:this.labelWidth}),
							CWHF.createCheckbox("admin.user.group.lbl.groupFlagResponsible", "responsible", {labelWidth:this.labelWidth}),
							CWHF.createCheckbox("admin.user.group.lbl.groupFlagJoinNewUserToThisGroup", "joinNewUserToThisGroup", {labelWidth:this.labelWidth})]}];
	},
	onRemovePerson: function() {
		this.reloadAssigned(this.getBaseAction()+"!unassign.action", {})
	},
	reload: com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit,
	getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
	    var reloadParams = {reloadTree:true};
	    if (selectedRecords && selectedRecords.length>0) {
	        //we suppose that only one selection is allowed in tree
	    	var selNode = selectedRecords[0];
	    	reloadParams["nodeIDToReload"] = selNode.parentNode.data.id;
	    	if (selectedRecords.length===1) {
	    		//one group was deleted: select the previous or next if exist
	            if (selNode) {
	                var previousSibling = selNode.previousSibling;
	                if (previousSibling) {
	                    reloadParams["nodeIDToSelect"] = previousSibling.data.id;
	                } else {
	                    var nextSibling = selNode.nextSibling;
	                    if (nextSibling) {
	                        reloadParams["nodeIDToSelect"] = nextSibling.data.id;
	                    } else {
	                        reloadParams["resetDetail"] = true;
	                    }
	                }
	            } else {
	            }
	    	} else {
	    		//more than one group was selected to delete
	    		reloadParams["resetDetail"] = true;
	    	}
	    }
	    return reloadParams;
	},
	/**
	 * Get the detail part after selecting a tree node
	 */
	/*protected*/loadDetailPanel: function(node, leaf, opts) {
		if (this.selectionIsSimple(true)) {
			this.loadSimpleDetailPanel(node, false);
		} else {
			this.resetDetailPanel();
		}
	},
	onDeleteGroup: function() {
		var selectedRecords = this.getSelection(true);
		if (selectedRecords) {
			this.deleteHandler(selectedRecords, {fromTree:true});
		}
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	getDeleteUrl: function(extraConfig){
		return this.getBaseAction() + '!delete.action';
	},
	/*getDeleteParams: function(selectedRecords, extraConfig) {
		return this.getEditParams();
	},*/
	getDeleteParamName: function() {
	    return "selectedGroupIDs";
	},
	getGridFields: function(record) {
		return [{name:'id', type:'int'},
				{name:'userName', type:'string'},
				{name:'name', type:'string'},
				{name:'active', type:'boolean'},
				{name:'activeLabel', type:'string'},
				{name:'employeeId', type:'string'},
				{name:'department', type:'string'}];
	},
	getColumnModel: function() {
		return [{text:getText('admin.user.profile.lbl.userName'),
			flex:2, dataIndex:'userName', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('common.lbl.name'),
			flex:2, dataIndex:'name', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.department'),
			flex:2, dataIndex:'department', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.employeeId'),
			flex:1, dataIndex:'employeeId', sortable:true,
			renderer:this.renderer, hidden: true,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.manage.lbl.activ'),
			flex:1, dataIndex:'activeLabel', sortable:true,
			renderer:this.renderer, hidden: true,
			filter: {
				type: "list",
				options: [getText("common.boolean.Y"),
							getText("common.boolean.N")]
			}
		}];
	},
	/**
	 * Render the inherited rows as grey
	 */
	renderer: function(value, metadata, record) {
		if (!record.data["active"]) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	hideGridHeaders: function() {
		return false;
	},
	enableColumnHide: function() {
		return true;
	},
	getDetailWidth: function() {
		return 800;
	},
	getDetailHeight: function() {
		return 600;
	},
	getMinWidth: function() {
		return 425;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.user.UserRolesInProject',{
	extend:"com.trackplus.admin.GridBase",
	xtype: "userRolesInProject",
    controller: "userRolesInProject",
    config: {
		//person or group ID
		personID: null,
		//whether it is group or person
		group: null
		},
	columns:[{text: getText('admin.project.lbl.project'), flex:1,
				dataIndex: 'projectLabel', sortable:true, renderer:"projectRenderer",
		        filter: {
		            type: "string"
		        }},
			{text: getText('admin.customize.role.lbl.role'),
				flex:1, dataIndex:'roleLabel', sortable:false, renderer:"roleRenderer"}],
	allowMultipleSelections:true,
	useEdit:false,
	useCopy:false,
	initComponent : function() {
		this.fields = [{name: 'projectID',type:'int'},
		   			{name: 'projectLabel',type:'string'},
					{name: 'roleID',type:'int'},
					{name: 'roleLabel', type: 'string'},
					{name: 'direct', type: 'boolean'},
					{name: 'first', type: 'boolean'}];
		this.storeUrl = "rolesInProjects.action";
		this.style = {
				borderTop:'1px solid #D0D0D0',
				borderBottom:'1px solid #D0D0D0'
			};
		this.callParent();
	},
	getEntityLabel:function(){
		return getText("admin.user.group.lbl.roleAssignment");
	},
	getGridSelectionModel: function() {
		return Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"});
	},
	/**
	 * Get extra parameters for grid load
	 */
	getLoadGridParams:function() {
		return {personID:this.getPersonID(), group:this.getGroup()};
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.user.UserRolesInProjectController',{
	extend: "Ext.app.ViewController",
	alias: "controller.userRolesInProject",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction: "rolesInProjects",
	labelWidth: 100,
	editWidth:400,
	editHeight:175,
	getEntityLabel:function(){
		return getText("admin.user.group.lbl.roleAssignment");
	},
	getAddIconCls: function() {
		return "add16";
	},
	getDeleteIconCls: function() {
		return "delete16";
	},
	/**
	 * Render the inherited rows as grey
	 */
	projectRenderer: function(value, metadata, record) {
		if (!record.data["first"]) {
			return "";
		}
		return value;
	},
	roleRenderer:function(value, metadata, record) {
		if (!record.data["direct"]) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	/**
	 * Parameters for adding a new entity
	 * Specify extra parameters if needed
	 * (like "defaultSettings" for "my" and "default" automail settings)
	 */
	getAddParams: function() {
		return {personID:this.getView().getPersonID(), add:true};
	},
	getEditParams: function(recordData) {
		return {personID:this.getView().getPersonID(), projectID:recordData["projectID"], roleID:recordData["roleID"]};
	},
	/**
	 * Get the ID based from the recordData
	 *  No objectID primary key in tacl table
	 */
	getRecordID: function(recordData) {
		if (recordData) {
			return recordData["projectID"] + "|" + recordData["roleID"];
		}
		return null;
	},
	/**
	 * Parameters for deleting entity
	 * recordData: the selected entity data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	getDeleteParams: function(selectedRecords, extraConfig) {
		var params=new Object();
		var selectionParam = this.getSelectedIDs(selectedRecords, extraConfig);
		params["unassign"]= selectionParam;
		params["personID"] = this.getView().getPersonID();
		return params;
	},
	createEditForm:function(entityJS,operation){
		var disabled = false;
		if (operation!=="add" && !entityJS["direct"]) {
			disabled = true;
		}
		var roleCombo = CWHF.createCombo("admin.customize.role.lbl.role", "roleID",
				{itemId:"roleID", allowBlank:false, labelWidth:this.labelWidth, disabled:disabled});
		return Ext.create('Ext.form.FormPanel',{
			url:this.getBaseAction() + '!save.action',
			autoScroll: true,
			border: false,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			style:{
				borderBottom:'1px solid #D0D0D0'
			},
			defaults : {
				labelStyle:'overflow: hidden;',
				msgTarget : 'side',
				anchor : '100%'
			},
			items: [CWHF.createSingleTreePicker("admin.project.lbl.project",
					"projectID", [], null,
					{itemId:'projectID',
					allowBlank:false,
					disabled:disabled,
	                margin:'0 0 5 0'},
	                {select:{fn: this.onProjectSelect, scope:this, roleCombo:roleCombo}}),
	            roleCombo,
				CWHF.createHiddenField("projectIDOld", {value: entityJS["projectID"]}),
				CWHF.createHiddenField("roleIDOld", {value: entityJS["roleID"]})]
		});
	},
	afterLoadForm:function(data, panel) {
		projectControl = panel.getComponent("projectID");
	    projectControl.updateMyOptions(data["projects"]);
	    projectControl.setValue(data["projectID"]);
		roleControl = panel.getComponent("roleID");
		if (roleControl) {
			roleControl.store.loadData(data["roles"]);
		}
		roleControl.setValue(data["roleID"]);
	},
	/**
	 * Change event handler
	 * @param projectPicker
	 * @param selectedProjects
	 * @param options
	 */
	onProjectSelect: function(projectPicker, selectedProject, options) {
	    var roleCombo = options["roleCombo"];
	    Ext.Ajax.request({
	        url: "rolesInProjects!projectChange.action",
	        params:{projectID: projectPicker.getValue(), roleID: roleCombo.getValue()},
	        scope:this,
	        success: function(response){
	            var responseJSON = Ext.decode(response.responseText);
	            roleCombo.store.loadData(responseJSON["roles"]);
	            roleCombo.setValue(responseJSON["roleID"]);
	        },
	        failure: function(response){
	            com.trackplus.util.requestFailureHandler(response);
	        }
	    })
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.user.FiltersInUserMenu",{
	extend:"com.trackplus.admin.GridBase",
	xtype: "filtersInUserMenu",
    controller: "filtersInUserMenu",
	config: {
			//person or group IDs
			personIDs: null
	},
	columns: [{text: getText('common.lbl.filter'), flex:1,
				dataIndex: 'filterLabel', sortable:true, renderer:"filterRenderer",
				filter: {
		            type: "string"
		        }},
			{text:getText('admin.user.manage.lbl.filterAssignments.user'),
				flex:1, dataIndex:'personName', sortable:false}],
	allowMultipleSelections:true,
	useEdit:false,
	useCopy:false,
	initComponent : function() {
		this.fields = [{name: 'filterID',type:'int'},
		   			{name: 'filterLabel',type:'string'},
					{name: 'personID',type:'int', allowNull:true},
					{name: 'personName', type: 'string'},
					{name: 'first', type: 'boolean'}];
		this.storeUrl = "filtersInMenu.action";
		this.style = {
				borderTop:'1px solid #D0D0D0',
				borderBottom:'1px solid #D0D0D0'
			};
		this.callParent();
	},
	getEntityLabel:function(){
		return getText("admin.user.manage.lbl.filterAssignments");
	},
	getGridSelectionModel: function() {
		return Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"});
	},
	/**
	 * Get extra parameters for grid load
	 */
	getLoadGridParams:function() {
		return {personIDs:this.getPersonIDs()};
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.user.FiltersInUserMenuController",{
	extend: "Ext.app.ViewController",
	alias: "controller.filtersInUserMenu",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction: "filtersInMenu",
	editWidth: 400,
	editHeight: 125,
	/**
	 * Render the inherited rows as grey
	 */
	filterRenderer: function(value, metadata, record) {
	    if (!record.data["first"]) {
	        return "";
	    }
	    return value;
	},
	/**
	 * Parameters for adding a new entity
	 * Specify extra parameters if needed
	 * (like "defaultSettings" for "my" and "default" automail settings)
	 */
	getAddParams: function() {
		return {personIDs:this.getView().getPersonIDs()};
	},
	/**
	 * Get the ID based from the recordData
	 *  No objectID primary key in tacl table
	 */
	getRecordID: function(recordData) {
		if (recordData) {
	        var filterID = recordData["filterID"];
	        var personID = recordData["personID"];
	        if (CWHF.isNull(personID)) {
	            return filterID;
	        } else {
	            return filterID + "|" + personID;
	        }
		}
		return null;
	},
	/**
	 * Parameters for deleting entity
	 * recordData: the selected entity data
	 * Even if there is more than one entity selected for delete
	 * this method is called for each selected entity separately
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	getDeleteParams: function(selectedRecords, extraConfig) {
		var params=new Object();
		var selectionParam = this.getSelectedIDs(selectedRecords, extraConfig);
		params["unassign"] = selectionParam;
	    params["personIDs"] = this.getView().getPersonIDs();
		return params;
	},
	createEditForm:function(entityJS,operation){
		var disabled = false;
		if (operation!=="add" && !entityJS["direct"]) {
			disabled = true;
		}
		return Ext.create('Ext.form.FormPanel',{
			url:this.getBaseAction() + '!save.action',
			autoScroll: true,
			border: false,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			style:{
				borderBottom:'1px solid #D0D0D0'
			},
			defaults : {
				labelStyle:'overflow: hidden;',
				msgTarget : 'side',
				anchor : '100%'
			},
			items: [CWHF.createMultipleTreePicker(null,
					"filterIDs", [], null,
					{itemId:'filterIDs', allowBlank:false,
					disabled:disabled,
	                margin:'0 0 5 0',
	                useRemoveBtn:false,
						allowNull:true,
	                useTooltip:false,
	                fieldLabel:getText("common.lbl.filter")
				})]
		});
	},
	afterLoadForm:function(data, panel) {
		var filterControl = panel.getComponent("filterIDs");
	    filterControl.updateMyOptions(data["filterTree"]);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
Ext.define('com.trackplus.admin.user.Department',{
	extend:'com.trackplus.admin.TreeDetailAssignment',
	config: {
		rootID: '_'
	},
	baseAction:"department",
	editWidth: 400,
	editHeight: 150,
	/**
	 * Whether the tree has double click listener
	 */
	treeHasItemdblclick: true,
	dragAndDropOnTree: true,
	/**
	 * actions
	 */
	actionAddDepartment: null,
	actionAddSubdepartment: null,
	actionEditDepartment: null,
	actionDeleteDepartment: null,
	actionDetachFromParentDepartment: null,
	actionRemovePerson: null,
	constructor: function(cfg) {
		var config = cfg || {};
		this.initConfig(config);
		this.initBase();
	},
	getEntityLabel: function(extraConfig) {
		return getText("admin.user.department.lbl.department");
	},
	getAddIconCls: function() {
		return "departmentAdd";
	},
	getEditIconCls: function() {
		return "departmentEdit";
	},
	/**
	 * Add "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getAddSubdepartmentLabel: function() {
		return getText(this.getAddTitleKey(), getText("admin.user.department.lbl.subdepartment"));
	},
	/**
	 * Initialize all possible actions
	 */
	initActions: function(){
		this.actionAddDepartment = this.createLocalizedAction(this.getTitle(this.getAddTitleKey(), {isLeaf:false}),
				this.getAddIconCls(), this.onAddMainDepartment, this.getTitle(this.getAddTitleKey(), {isLeaf:false}));
		this.actionAddSubdepartment = this.createLocalizedAction(this.getAddSubdepartmentLabel(),
				this.getAddIconCls(), this.onAddSubdepartment, this.getAddSubdepartmentLabel());
		this.actionEditDepartment = this.createLocalizedAction(this.getTitle(this.getEditTitleKey(), {isLeaf:false}),
				this.getEditIconCls(), this.onEditDepartment, this.getTitle(this.getEditTitleKey()));
		this.actionDeleteDepartment = this.createLocalizedAction(this.getTitle(this.getDeleteTitleKey(), {isLeaf:false}),
				this.getDeleteIconCls(), this.onDeleteDepartment, this.getTitle(this.getDeleteTitleKey(), {isLeaf:false}));
		this.actionDetachFromParentDepartment = this.createLocalizedAction(getText("menu.admin.users.departments.removeFromParent"),
				"clear", this.onDetachFromParentDepartment, getText("menu.admin.users.departments.removeFromParent"));
		this.actionRemovePerson = this.createLocalizedAction(getText("common.lbl.remove", getText("admin.user.lbl.user")),
				this.getDeleteIconCls(), this.onRemovePerson, getText("common.lbl.remove", getText("admin.user.lbl.user")));
		this.actions=[this.actionAddDepartment, this.actionAddSubdepartment];
	},
	/**
	 * Context menu for tree
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectedRecord.isLeaf()) {
			return [this.actionRemovePerson];
		} else {
			var actions = [this.actionAddSubdepartment, this.actionEditDepartment, this.actionDeleteDepartment];
			if (selectedRecord && selectedRecord.parentNode && !selectedRecord.parentNode.isRoot()) {
				actions.push(this.actionDetachFromParentDepartment);
			}
			return actions;
		}
	},
	/**
	 * Create the edit
	 */
	onTreeNodeDblClick: function(view, record) {
		var leaf = record.isLeaf();
		if (!leaf) {
			this.onEditDepartment();
		}
	},
	/**
	 * Return false if dragging this node is not allowed
	 */
	canDragDropNode: function(nodeToDrag, copy, overModel) {
		return !nodeToDrag.isAncestor(overModel);
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function() {
		return getText("menu.admin.users.departments.tt");
	},
	/**
	 * Handler for adding a new screen
	 */
	onAddMainDepartment: function() {
		return this.onAddDepartment(false);
	},
	onAddSubdepartment: function() {
		return this.onAddDepartment(true);
	},
	onAddDepartment: function(addAsSubdepartment) {
		var title = this.getTitle(this.getAddTitleKey(), {isLeaf:false});
		var loadParams = this.getEditParams();
		loadParams["add"] = true;
		var submitParams = this.getEditParams();
		submitParams["addAsSubdepartment"] = addAsSubdepartment;
		submitParams["add"] = true;
		var nodeIDToReload;
		if (addAsSubdepartment) {
			nodeIDToReload = this.selectedNodeID;
		} else {
			nodeIDToReload = this.getRootID();
		}
		return this.onAddEdit(title, loadParams, submitParams, nodeIDToReload);
	},
	/**
	 * Handler for editing a screen
	 */
	onEditDepartment: function() {
		var title = this.getTitle(this.getEditTitleKey(), {isLeaf:false});
		var loadParams = this.getEditParams();
		var submitParams = this.getEditParams();
		return this.onAddEdit(title, loadParams, submitParams, this.getParentNodeId());
	},
	/**
	 * Parameters for editing an existing entity
	 * recordData: the selected entity data
	 */
	getEditParams: function() {
		var recordData = this.getSingleSelectedRecordData(true);
		if (recordData) {
			var nodeID = recordData['id'];
			if (nodeID) {
				return {node:nodeID};
			}
		}
		return {};
	},
	getTreeExpandExtraParams: function() {
		//also include the persons in department by expanding a department node
		return {includePersons:true};
	},
	/**
	 * Get the node to reload after save after edit operation
	 */
	getParentNodeId: function() {
		if (this.selectedNode) {
				//edited/copied from tree
				var parentNode = this.selectedNode.parentNode;
				if (parentNode) {
					//the parent of the edited node should be reloaded
					return {nodeIDToReload: parentNode.data['id']}
				}
		}
		return {nodeIDToReload: this.getRootID()};
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * isLeaf: whether to add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	onAddEdit: function(title, loadParams, submitParams, nodeIDToReload) {
		var loadUrl = this.getBaseAction() + '!edit.action';
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = this.getBaseAction() + '!save.action';
		var submit = {	submitUrl:submitUrl,
						submitUrlParams:submitParams,
						submitButtonText:getText('common.btn.save'),
						refreshAfterSubmitHandler:com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit,
						refreshParametersBeforeSubmit:{nodeIDToReload: nodeIDToReload},
						refreshParametersAfterSubmit:[{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
													{parameterName:'reloadTree', fieldNameFromResult:'reloadTree'}]};
		var items = this.getPanelItems();
		var windowParameters = {title:title,
			width:this.editWidth,
			height:this.editHeight,
			load:load,
			submit:submit,
			items:items};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	getPanelItems: function() {
		return [CWHF.createTextField('common.lbl.name','name',
				{anchor:'100%', allowBlank:false, labelWidth:80, maxLength:255, enforceMaxLength:true})]
	},
	onRemovePerson: function() {
		this.reloadAssigned(this.getBaseAction()+"!unassign.action", {})
	},
	reload: com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit,
	getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
	    var reloadParams = {reloadTree:true};
	    if (selectedRecords) {
	        //we suppose that only one selection is allowed in tree
	        var selNode = selectedRecords;
	        if (selNode) {
	            reloadParams["nodeIDToReload"] = selNode.parentNode.data.id;
	            var previousSibling = selNode.previousSibling;
	            if (previousSibling) {
	                reloadParams["nodeIDToSelect"] = previousSibling.data.id;
	            } else {
	                var nextSibling = selNode.nextSibling;
	                if (nextSibling) {
	                    reloadParams["nodeIDToSelect"] = nextSibling.data.id;
	                } else {
	                    reloadParams["resetDetail"] = true;
	                }
	            }
	        }
	    }
	    return reloadParams;
	},
	onDeleteDepartment: function() {
		var selectedRecords = this.getSelectedRecords(true);
		if (selectedRecords) {
			this.deleteHandler(selectedRecords, {fromTree:true});
		}
	},
	onDetachFromParentDepartment: function() {
		var selectedRecord = this.getLastSelected(true);
		if (selectedRecord) {
			var nodeID = selectedRecord.data["id"];
			Ext.Ajax.request({
				url: this.getBaseAction()+"!clearParent.action",
				params: {
					node:nodeID
				},
				disableCaching:true,
				scope:this,
				success: function(response){
					com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit.call(this, {nodeIDToSelect:nodeID, reloadTree:true});
				}
			});
		}
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	getDeleteUrl: function(extraConfig){
		return this.getBaseAction() + '!delete.action';
	},
	getDeleteParams: function(selectedRecords, extraConfig) {
		return this.getEditParams();
	},
	/**
	 * The replacement items for the deleted entity
	 * (The replacement panel will be created with on this items)
	 */
	getReplacementItems: function(responseJson, selectedRecords, extraConfig) {
		return [{xtype : 'label',
				itemId: 'replacementWarning'},
	            CWHF.createSingleTreePicker("Replacement",
	            "replacementID", responseJson["replacementTree"], null,
	            {itemId: "replacementID",
	            allowBlank:false,
	            blankText: getText('common.err.replacementRequired',
	            this.getEntityLabel(extraConfig)),
	            labelWidth:200,
	            margin:'5 0 0 0'
	            })
			    ];
	},
	/**
	 * Load the data source and value for the replacement options tree
	 * Override this for different tree based pickers
	 */
	loadReplacementOptionData: function(replacementControl, data) {
	    replacementControl.updateMyOptions(data["replacementTree"]);
	},
	getGridFields: function(record) {
		return [{name:'id', type:'int'},
				{name:'userName', type:'string'},
				{name:'name', type:'string'},
				{name:'active', type:'boolean'},
				{name:'activeLabel', type:'string'},
				{name:'employeeId', type:'string'},
				{name:'department', type:'string'}];
	},
	getColumnModel: function() {
		return [{text:getText('admin.user.profile.lbl.userName'),
			flex:2, dataIndex:'userName', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('common.lbl.name'),
			flex:2, dataIndex:'name', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.department'),
			flex:2, dataIndex:'department', sortable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.employeeId'),
			flex:1, dataIndex:'employeeId', sortable:true,
			renderer:this.renderer, hidden: true,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.manage.lbl.activ'),
			flex:1, dataIndex:'activeLabel', sortable:true,
			renderer:this.renderer, hidden: true,
			filter: {
				type: "list",
				options: [getText("common.boolean.Y"),
							getText("common.boolean.N")]
			}
		}];
	},
	/**
	 * Render the inherited rows as grey
	 */
	renderer: function(value, metadata, record) {
		if (!record.data["active"]) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	hideGridHeaders: function() {
		return false;
	},
	enableColumnHide: function() {
		return true;
	},
	getDetailWidth: function() {
		return 800;
	},
	getDetailHeight: function() {
		return 600;
	},
	getMinWidth: function() {
		return 425;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for  dashboard assigment
 */
Ext.define('com.trackplus.admin.user.DashboardAssignment',{
	extend:'Ext.Base',
	baseAction:'dashboardAssignment',
	entityName:getText('menu.admin.users.cockpitDefault'),
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.myInit();
	},
	myInit:function(){
		var me=this;
		me.initActions();
		me.initGrid();
	},
	createCenterPanel: function() {
		var me=this;
		return me.grid;
	},
	getGridFields: function() {
		return [
			{name: 'id',type:'int'},
			{name: 'name',type:'string'},
			{name: 'description', type: 'string'},
			{name: 'owner',type:'string'}
		]
	},
	getGridColumns: function() {
		return [{
				text: getText('common.lbl.name'), width:300,
				dataIndex: 'name',sortable:true,
				filter: {
		            type: "string"
		        }
			},{
				text: getText('common.lbl.description'),flex:1,
				dataIndex: 'description',sortable:true,
				filter: {
		            type: "string"
		        }
			},{
				text: getText('admin.customize.form.config.owner'), width:200,
				dataIndex: 'owner',sortable:true,
				filter: {
		            type: "string"
		        }
			}
		];
	},
	initGrid: function() {
		var store = Ext.create('Ext.data.Store', {
			fields: this.getGridFields(),
			proxy: {
				type: 'ajax',
				url: 'dashboardAssign.action',
				reader: {
					type: 'json'
				}
			},
			autoLoad: true
		});
		var gridConfig = {
			xtype: 'grid',
			region:'center',
			store: store,
			selModel: Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"}), //for screen export
			columns: this.getGridColumns(),
			plugins: ["gridfilters"],
			autoWidth: true,
			border: false,
			bodyBorder:false,
			cls:'gridNoBorder',
			stripeRows: true
		};
		var gridListeners = {selectionchange: {fn:this.onGridSelectionChange, scope:this}};
		gridListeners.itemcontextmenu = {fn:this.onGridRowCtxMenu, scope:this};
		gridListeners.itemdblclick = {fn:this.editDashboard, scope:this};
		gridConfig.listeners = gridListeners;
		//create the grid
		this.grid = Ext.create('Ext.grid.Panel', gridConfig);
	},
	onGridSelectionChange: function (view, selections) {
		this.enableDisableToolbarButtons(view, selections);
		var selectedRow = null;
		if (selections && selections.length>0) {
			selectedRow = selections[0];
		}
	},
	enableDisableToolbarButtons: function (view, selections) {
		if (CWHF.isNull(selections) || selections.length===0) {
			this.actionEdit.setDisabled(true);
			this.actionCopy.setDisabled(true);
			this.actionDelete.setDisabled(true);
			this.actionConfig.setDisabled(true);
		} else {
			this.actionEdit.setDisabled(false);
			this.actionCopy.setDisabled(false);
			this.actionDelete.setDisabled(false);
			this.actionConfig.setDisabled(false);
		}
	},
	/**
	 * Show the context menu in grid
	 */
	onGridRowCtxMenu: function(grid, record, item, index, evtObj) {
		this.onCtxMenu(false, record, evtObj);
		return false;
	},
	initActions: function(){
		var me=this;
		me.actions=new Array();
		me.actionAdd=Ext.create('Ext.Action',{
			text: getText('common.btn.add'),
			overflowText: getText('common.btn.add'),
			iconCls: "add",
			scope: me,
			handler: me.addDashboard
		});
		me.actions.push(me.actionAdd);
		me.actionEdit=Ext.create('Ext.Action',{
			text: getText('common.btn.edit'),
			overflowText: getText('common.btn.edit'),
			iconCls: "edit",
			scope: me,
			handler: me.editDashboard
		});
		me.actions.push(me.actionEdit);
		me.actionDelete=Ext.create('Ext.Action',{
			text: getText('common.btn.delete'),
			overflowText: getText('common.btn.delete'),
			iconCls: "delete",
			scope: me,
			handler: me.deleteItems
		});
		me.actions.push(me.actionDelete);
		me.actionCopy=Ext.create('Ext.Action',{
			text: getText('common.btn.copy'),
			overflowText: getText('common.btn.copy'),
			iconCls: "copy",
			scope: me,
			handler: me.copyDashboard
		});
		me.actions.push(me.actionCopy);
		me.actionConfig=Ext.create('Ext.Action',{
			text: getText('common.btn.config'),
			overflowText: getText('common.btn.config'),
			iconCls: "btnConfig",
			scope: me,
			handler: me.configDashboard
		});
		me.actions.push(me.actionConfig);
	},
	getToolbarActions: function(){
		return this.actions;
	},
	addDashboard:function(){
		var me=this;
		var title = getText('common.lbl.add',me.entityName);
		//var reloadParamsFromResult = this.getReloadParamsFromResult();
		return this.onAddEdit(title, true,null, null);
	},
	editDashboard:function(){
		var me=this;
		var title = getText('common.lbl.edit',me.entityName);
		var objectID = this.getSelectedId();
		if(CWHF.isNull(objectID)){
			return null;
		}
		var loadParams = {
			copy:false,
			objectID:objectID
		};
		var submitParams = {
			objectID:objectID,
			copy:false
		};
		return this.onAddEdit(title, false,loadParams, submitParams);
	},
	deleteItems:function(){
		var me=this;
		var urlDeleteItems="dashboardAssign!deleteCockpitTemplate.action";
		var selections=me.grid.getSelectionModel().getSelection();
		var titleNotSelected=getText("common.lbl.messageBox.title.notSelected");
		var messageConfirmDelete=getText("common.lbl.messageBox.removeSelected.confirm");
		var messageNoSelection=getText("common.lbl.messageBox.removeSelected.notSelected");
		var titleDelete=getText("common.btn.delete");
		var okLabel=getText("common.btn.ok");
		if(CWHF.isNull(selections)||selections.length===0){
			Ext.MessageBox.show({
				title:titleNotSelected,
				msg:messageNoSelection ,
				buttons:{ok : okLabel},
				icon: Ext.MessageBox.WARNING
			});
			return;
		}
		Ext.MessageBox.show({
			title:titleDelete,
			msg: messageConfirmDelete,
			//buttons:{yes : yesLabel, no : noLabel},
			buttons: Ext.MessageBox.YESNO,
			fn: function(btn){
				if(btn==="yes"){
					var selections=me.grid.getSelectionModel().getSelection();
					var deletedItems="";
					var row;
					var i;
					for(i=0;i<selections.length;i++){
						//row=selections[i];
						row=selections[i].data;
						deletedItems=deletedItems+row.id+";";
					}
					Ext.Ajax.request({
						url: urlDeleteItems,
						disableCaching:true,
						success : function(result) {
							var jsonData = Ext.decode(result.responseText);
						    if(!jsonData.success) {
						    	Ext.MessageBox.show({
						    		title : getText('common.warning'),
								    msg : jsonData.errorMessage,
								    width : 200,
								    buttons : Ext.MessageBox.OK,
								    icon : Ext.MessageBox.WARNING
								});
						    }
							me.refresh.call(me);
						},
						failure: function(){
						},
						method:'POST',
						params:{"deletedItems":deletedItems}
					});
				}
			},
			//animEl: 'mb4',
			icon: Ext.MessageBox.QUESTION
		});
	},
	copyDashboard:function(){
		var me=this;
		var title = getText('common.lbl.copy',me.entityName);
		var objectID = this.getSelectedId();
		if(CWHF.isNull(objectID)){
			return null;
		}
		var loadParams = {
			copy:true,
			objectID:objectID
		};
		var submitParams = {
			objectID:objectID,
			copy:true
		};
		return this.onAddEdit(title, false,loadParams, submitParams, null);
	},
	getSelectedId:function(){
		var me=this;
		var sel=this.grid.getSelectionModel().getSelection();
		if(sel&&sel.length>0){
			return sel[0].data['id'];
		}
		return null;
	},
	configDashboard:function(){
		var objectID = this.getSelectedId();
		if(CWHF.isNull(objectID)){
			return null;
		}
		var urlEditScreen="dashboardEdit.action?backAction=admin.action&componentID="+objectID;
		window.location.href=urlEditScreen;
	},
	onAddEdit: function(title, add, loadParams, submitParams,
						refreshParamsFromResult) {
		var load = {
			loadUrl:'dashboardAssign!edit.action',
			loadUrlParams:loadParams
		};
		var submit = {
			submitUrl:'dashboardAssign!save.action',
			submitUrlParams:submitParams,
			submitButtonText:getText('common.btn.save'),
			refreshAfterSubmitHandler:com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit,
			refreshParametersAfterSubmit:refreshParamsFromResult
		};
		var items = this.getPanelItems();
		var windowParameters = {title:title,
			width:500,
			height:300,
			load:load,
			submit:submit,
			items:items
		};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	refresh:function(){
		this.grid.getStore().load();
	},
	getPanelItems: function() {
		return  [CWHF.createTextField('common.lbl.name','name',
			{anchor:'100%', allowBlank:false, labelWidth:this.labelWidth, width:this.textFieldWidth}),
			CWHF.createTextAreaField('common.lbl.description','description',
				{anchor:'100%', labelWidth:this.labelWidth, width:this.textFieldWidth})];
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.customize.script.Script",{
	extend:"com.trackplus.admin.GridBase",
	xtype: "script",
    controller: "script",
	columns:[
		{text:getText("admin.customize.script.lbl.className"),
			width:400,dataIndex: "name", sortable:true,
			filter: {
	            type: "string"
	        }},
		{text:getText("admin.customize.script.lbl.scriptType"),
			width:150,dataIndex: "typeLabel", sortable:true}
	],
	initComponent : function() {
		this.fields = [{name: 'id',type:'int'},
		   	        {name: 'name',type:'string'},
			        {name: 'scriptType', type: 'int'},
			        {name: 'typeLabel', type: 'string'}];
		this.storeUrl = "script!loadScripts.action";
		this.callParent();
	},
	getEntityLabel:function(){
		return getText("admin.customize.script.lbl");
	},
	/**
	 * The iconCls for the add button, overwrites base class icon
	 */
	getAddIconCls: function() {
		return 'scriptAdd';
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getEditIconCls: function() {
		return 'scriptEdit';
	}	
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.customize.script.ScriptController",{
	extend: "Ext.app.ViewController",
	alias: "controller.script",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction:'script',
	entityID:'scriptID', 
	editWidth:800,
	editHeight:600,
	labelWidth: 120,	
	/**
	 * Additional execute compile method for script
	 */
	getAdditionalActions: function(recordData, submitParams, operation) {
	    var disabled = false;
	    if (recordData) {
	        disabled = this.compileIsDisabled(recordData["scriptType"]);
	    }
		//only for "edit", not for "add" or "instant"
		return [{submitUrl:this.getBaseAction() + '!compile.action',
				submitUrlParams:submitParams,
				submitButtonText:getText('common.btn.compile'),
	            disabled: disabled,
				closeAfterSubmit: false,
				refreshAfterSubmitHandler:this.showCompileResult}];
	},
	/**
	 * Whether the filter contains parameter(s)
	 */
	showCompileResult: function(refreshParameters, result) {
		Ext.MessageBox.show({
			title: result.title,
			msg: result.message,
			buttons: Ext.Msg.OK,
			icon: Ext.MessageBox.INFO
		});
	},
	compileIsDisabled: function(scriptType) {
	    if (scriptType && scriptType===3) {
	        return true;
	    }
	    return false;
	},
	createEditForm:function(entityJS,type){
		var me=this;
		return new Ext.form.FormPanel({
			url:'script!save.action',
			border:false,
			autoScroll: true,
			margin: '0 0 0 0',
			bodyStyle:{
				padding:'10px'
			},
			items: [CWHF.createTextField("admin.customize.script.lbl.className", "clazzName",
						{allowBlank:false, labelWidth:this.labelWidth, anchor:'100%',itemId:'clazzName'}),
				CWHF.createCombo("admin.customize.script.lbl.scriptType", "scriptType",
					{itemId:"scriptType", width:300, allowBlank:false, labelWidth:this.labelWidth},
	                {select: {fn: this.scriptTypeChange, scope:this}}),
				CWHF.createTextAreaField('admin.customize.script.lbl.sourceCode', "sourceCode",
						{labelWidth:this.labelWidth,anchor: '100% -60'})
			]
		});
	},
	/**
	 * Handler for changing a default value
	 */
	scriptTypeChange: function(combo, records, options) {
	    var scriptType = combo.getValue();
	    var toolbars = this.win.getDockedItems('toolbar[dock="bottom"]');
	    if (toolbars) {
	        toolbars[0].getComponent(0).setDisabled(this.compileIsDisabled(scriptType));
	    }
	},
	afterLoadForm:function(data, panel) {
		var scriptTypeCombo = panel.getComponent("scriptType");
		scriptTypeCombo.store.loadData(data["scriptTypeList"]);
		scriptTypeCombo.setValue(data["scriptType"]);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.SiteConfig',{
	extend:'Ext.Base',
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
	},
	SECURITY_CONNECTIONS_MODES:{
		NEVER:0,
		TLS_IF_AVAILABLE:1,
		TLS:2,
		SSL :3
	},
	mainForm:null,
	btnSave:null,
	jsonData:null,
	mainComponent:null,
	labelWidth:250,
	textFieldWidth:250+300,
	textFieldWidthShort:250+70,
	alignR:"right",
	FieldSetWidth:250+300+150,
	/**
	 * Create a Save button
	 * @return {Ext.button.Button} The save button
	 */
	createSaveButton:function(){
		var me=this;
		if(CWHF.isNull(me.btnSave)){
			me.btnSave=new Ext.button.Button({
				overflowText:getText('common.btn.save'),
				tooltip:getText('common.btn.save'),
				text: getText('common.btn.save'),
				iconCls: 'save',
				disabled: true,
				handler:function(){
					me.save.call(me);
				}
			});
		}
		return me.btnSave;
	},
	/**
	 * Gets a control by the path according to the "arguments" starting form the main tab panel
	 */
	getControl: function() {
		return CWHF.getControl.apply(this.mainForm.getComponent(0), arguments);
	},
	getHelpWrapper: function() {
		return CWHF.getHelpWrapper.apply(this.mainForm.getComponent(0), arguments);
	},
	getWrappedControl: function() {
		return CWHF.getWrappedControl.apply(this.mainForm.getComponent(0), arguments);
	},
	/**
	 * Creates the outgoing e-mail server (SMTP) configuration tab
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabEmailOutgoing:function(){
		var me=this;
		me.emailOutgoingController=Ext.create('com.trackplus.admin.server.EmailOutgoingController',{
			labelWidth:me.labelWidth,
			textFieldWidth:me.textFieldWidth,
			textFieldWidthShort:me.textFieldWidthShort,
			alignR:me.alignR,
			FieldSetWidth:me.FieldSetWidth,
			siteCfgController:me
		});
		return me.emailOutgoingController.createView.call(me.emailOutgoingController);
	},
	/**
	 * Enable or disable input elements for full text search panel
	 */
	changeFtsOn:function() {
		var me=this;
		// Get the main enable/disable check box
		var fts = this.getWrappedControl("tab_fullTextSearch",
				"fsFullTextSearch", "fullTextSearchUseLucene");
		var ftsEnabled = fts.getValue();
		// Get all components to disable or enable
		var reindexOnStartup = this.getHelpWrapper("tab_fullTextSearch",
				"fsFullTextSearch", "fullTextSearchReindexOnStartup");
		reindexOnStartup.setDisabled(!ftsEnabled);
		var indexAttachments = this.getHelpWrapper("tab_fullTextSearch",
				"fsFullTextSearch", "fullTextSearchIndexAttachments");
		indexAttachments.setDisabled(!ftsEnabled);
		var indexPath = this.getHelpWrapper("tab_otherSiteConfig",
				"fsDirectories", "fullTextSearchIndexPath");
		indexPath.setDisabled(!ftsEnabled);
		var analyzer = this.getHelpWrapper("tab_fullTextSearch",
				"fsFullTextSearch", "fullTextSearchAnalyzer");
		analyzer.setDisabled(!ftsEnabled);
	},
	/**
	 * Creates the full text search configuration tab
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabTextSearch:function(){
		var me=this;
		var panel=new Ext.Panel({
			itemId:'tab_fullTextSearch',
			title:getText('admin.server.config.tabTextSearch'),
			layout: {
				type: 'anchor'
			},
			items: [{
				xtype: 'fieldset',
				itemId: 'fsFullTextSearch',
				width: me.FieldSetWidth,
				title: '',//if title not empty remove the margin and padding
				margin:'8 0 0 6',
				style:{
					paddingLeft:'13px',
					paddingTop:'18px'
				},
				collapsible: false,
				defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createCheckboxWithHelp('admin.server.config.useLucene',
							'fullTextSearch.useLucene', {itemId:'fullTextSearchUseLucene'},
							{change:function(){
								me.changeFtsOn.call(me);
							}}),
						CWHF.createCheckboxWithHelp('admin.server.config.reindexOnStartup',
							'fullTextSearch.reindexOnStartup',{itemId:'fullTextSearchReindexOnStartup'}),
						CWHF.createCheckboxWithHelp('admin.server.config.indexAttachments',
						'fullTextSearch.indexAttachments',{itemId:'fullTextSearchIndexAttachments'}),
						CWHF.createComboWithHelp('admin.server.config.analyzer',
								'fullTextSearch.analyzer',{idType:'string', itemId:"fullTextSearchAnalyzer"})]
			}]
		});
		return panel;
	},
	/**
	 * Creates the LDAP and SSO configuration tab
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabLdap:function() {
		var me=this;
		me.ldapController=Ext.create('com.trackplus.admin.server.LdapController',{
			labelWidth:me.labelWidth,
			textFieldWidth:me.textFieldWidth,
			textFieldWidthShort:me.textFieldWidthShort,
			alignR:me.alignR,
			FieldSetWidth:me.FieldSetWidth,
			siteCfgController:me
		});
		return me.ldapController.createView.call(me.ldapController);
	},
	/**
	 * Creates the remaining items configuration tab
	 * @param {Object} jsonData The data required for this and other tabs
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabOther:function(){
		var me=this;
		var panel=new Ext.Panel({
			itemId:'tab_otherSiteConfig',
			title:getText('admin.server.config.tabOther'),
			layout: {
				type: 'anchor'
			},
			items: [{
				xtype: 'fieldset',
				itemId: 'fsDirectories',
				width: me.FieldSetWidth,
				title: getText('admin.server.config.tabOther.paths'),
				collapsible: false,
				defaultType: 'textfield',
				defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createTextFieldWithHelp('admin.server.config.attachmentRootDir',
							'otherSiteConfig.attachmentRootDir'),
						CWHF.createTextFieldWithHelp('admin.server.config.backupDir',
								'otherSiteConfig.backupDir'),
						CWHF.createTextFieldWithHelp('admin.server.config.indexPath',
								'fullTextSearch.indexPath', {itemId:"fullTextSearchIndexPath"}),
						CWHF.createTextFieldWithHelp('admin.server.config.serverURL',
								'otherSiteConfig.serverURL')]
			}, {
				xtype: 'fieldset',
				width: me.FieldSetWidth,
				title: getText('admin.server.config.tabOther.limits'),
				collapsible: false,
				defaultType: 'textfield',
				defaults: {anchor: '100%'},
				layout: 'anchor',
				items: [CWHF.createNumberFieldWithHelp('admin.server.config.attachmentMaxSize',
							'otherSiteConfig.maxAttachmentSize', 2, 0, 9999, {hideTrigger:true,itemId:'otherSiteConfigMaxAttachmentSize'})]
//						CWHF.createNumberFieldWithHelp('admin.server.config.descriptionLength',
//							'otherSiteConfig.descriptionLength', 0, 0, 9999, {hideTrigger:true})]
			},
			{
				xtype: 'fieldset',
				width: me.FieldSetWidth,
				title: getText('admin.server.config.tabOther.various'),
				collapsible: false,
				defaultType: 'textfield',
				defaults: {anchor: '100%'},
				layout: 'anchor',
				items: this.getVariousSettings()
			}]
		});
		return panel;
	},
	getVariousSettings:function() {
		var settingsItems = [CWHF.createCheckboxWithHelp('admin.server.config.isSelfRegisterAllowed', 'otherSiteConfig.selfRegisterAllowed'),
			CWHF.createCheckboxWithHelp('admin.server.config.projectSpecificIDsOn', 'otherSiteConfig.projectSpecificIDsOn')];
		if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS
				&& com.trackplus.TrackplusConfig.appType !== APPTYPE_DESK) {
			//although forced to be set for Genji and Teamdesk (on server side), do not show the checkbox for them
			settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.summaryItemsBehavior', 'otherSiteConfig.summaryItemsBehavior'));
			//not set for Genji and Teamdesk
			settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.budgetActive', 'otherSiteConfig.budgetActive'));
			settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.isDemoSite', 'otherSiteConfig.demoSite'));
		}
		settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.isVersionReminderOn', 'otherSiteConfig.versionReminder'));
		settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.isWSOn', 'otherSiteConfig.webserviceEnabled'));
		settingsItems.push(CWHF.createCheckboxWithHelp('admin.server.config.isDatabaseBackupJobOn', 'otherSiteConfig.automatedDatabaseBackup'));
		return settingsItems;
	},
	/**
	 * Create the main component here.
	 * @param {Object} jsonData The data required for this component
	 * @return {Ext.form.Panel} The site configuration form
	 */
	createMainComponent:function(){
		var me=this;
		var tabItems=new Array();
		tabItems.push(me.createTabEmailOutgoing());
		tabItems.push(me.createTabTextSearch());
		tabItems.push(me.createTabLdap());
		tabItems.push(me.createTabOther());
		me.tabPanel = Ext.create('Ext.tab.Panel',{
			plain:true,
			border:false,
			bodyBorder:false,
			defaults:{
				border:false,
				autoScroll:true,
				bodyStyle:{
					border:'none',
					padding:'0px'
				}
			},
			items:tabItems
		});
		var form=Ext.create('Ext.form.Panel', {
			url:'saveAdminSiteConfig!save.action',
			margin: '3 0 0 0',
			//standardSubmit:true,
			border: false,
			baseCls:'x-plain',
			layout:'fit',
			items:[me.tabPanel]
		});
		me.mainForm=form;
		//me.tabPanel.setActiveTab(0);
		return form;
	},
	loadMyForm:function(){
		var me=this;
		borderLayout.setLoading(true);
		me.mainForm.getForm().load({
			url : "editAdminSiteConfig!load.action",
			scope: this,
			success: function(form, action) {
				borderLayout.setLoading(false);
				try{
					//call postDataProcess only after window is rendered because
					//some fields (like labelEl) are available only after the window is rendered
					me.btnSave.setDisabled(false);
					if (me.postDataProcess) {
						me.postDataProcess.call(this, action.result.data, me.formPanel, me.extraConfig);
					}
				}catch(ex){}
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				Ext.MessageBox.alert(this.failureTitle, action.response.responseText);
			}
		});
	},
	postDataProcess: function(data, panel) {
		//license tab
		var me=this;
		//outgoingEmail tab
		me.emailOutgoingController.postDataProcess.call(me.emailOutgoingController,data);
		//incomingEmail tab
		//fullTextSearch tab
		var analyzer = this.getWrappedControl("tab_fullTextSearch", "fsFullTextSearch", "fullTextSearchAnalyzer");
		analyzer.store.loadData(data["fullTextSearch.analyzers"]);
		analyzer.setValue(data["fullTextSearch.analyzer"]);
		this.changeFtsOn();
		//ldap tab
		me.ldapController.postDataProcess.call(me.ldapController,data);
	},
	clearErrorTabs:function(){
		var me=this;
		var tabBar=me.tabPanel.getTabBar();
		for(var i=0;i<tabBar.items.length;i++){
			var headerCm=tabBar.getComponent(i);
			headerCm.removeCls("errorTab");
		}
		if(me.ldapController){
			me.ldapController.clearErrorTabs.call(me.ldapController);
		}
	},
	save:function(){
		var me=this;
		me.clearErrorTabs();
		me.emailOutgoingController.beforeSave.call(me.emailOutgoingController);
		if(!me.isValidForm()){
			this.handleInvalidForm();
			return false;
		}
		borderLayout.setLoading(true);
		me.mainForm.getForm().submit({
			scope:this,
			timeout:60000,// 60s
			success: function(form, action) {
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('admin.server.config.successSave'));
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				me.handleErrors(action.result.errors);
			}
		});
	},
	handleErrors:function(errors){
		var me=this;
		var errStr='';
		var tabErrors=new Array();
		if (errors && errors.length>0){
			for(var i=0;i<errors.length;i++){
				var error=errors[i];
				var controlPath = error.controlPath;
				var inputComp=null;
				if(controlPath&&controlPath.length>0){
					inputComp=this.getControl.apply(this, controlPath);
					var tabId = controlPath[0];
					if(!Ext.Array.contains(tabErrors,tabId)){
						tabErrors.push(tabId);
					}
				}
				if(inputComp){
					inputComp.markInvalid(error.errorMessage);
				}
				errStr+=error.label+"</br>";
			}
			me.markErrorTabs(tabErrors);
		}
		CWHF.showMsgError(getText('admin.server.config.errorSave'));
	},
	markErrorTabs:function(tabErrors){
		var me=this;
		var tabErrorsCmp=new Array();
		if(tabErrors.length>0){
			for(var i=0;i<tabErrors.length;i++){
				var tabComp=this.getControl(tabErrors[i]);
				if(tabComp){
					tabErrorsCmp.push(tabComp);
				}
			}
			if(tabErrorsCmp.length>0){
				var selectedTab=me.tabPanel.getActiveTab();
				if(!Ext.Array.contains(tabErrorsCmp,selectedTab)){
					me.tabPanel.setActiveTab(tabErrorsCmp[0])
				}
				var tabBar=me.tabPanel.getTabBar();
				for(var i=0;i<tabErrorsCmp.length;i++){
					var index=me.tabPanel.items.findIndex('itemId', tabErrorsCmp[i].getItemId());
					var headerCm=tabBar.getComponent(index);
					headerCm.addCls("errorTab");
				}
			}
		}
	},
	testLdap:function(){
		var me=this;
		me.emailOutgoingController.beforeSave.call(me.emailOutgoingController);
		var urlStr='saveAdminSiteConfig!testLdap.action';
		me.test.call(me,urlStr,me.ldapController.failureHandler,me.ldapController);
	},
	isValidForm:function(){
		var me=this;
		return me.mainForm.getForm().isValid();
	},
	handleInvalidForm:function(){
		var me=this;
		CWHF.showMsgError(getText('admin.server.config.errorSave'));
		var invalidFields = this.mainForm.getForm().getFields().filterBy(function(field) {
			return !field.validate();
		});
		var tabErrors=new Array();
		for(var i=0;i<invalidFields.items.length;i++){
			var field=invalidFields.items[i];
			var id=field.getItemId();
			var prefix='tab.'+id.substring(0,id.indexOf('.'));
			if(!Ext.Array.contains(tabErrors,prefix)){
				tabErrors.push(prefix);
			}
		}
		this.markErrorTabs(tabErrors);
	},
	test:function(urlStr,failureHandler,failureScope){
		var me=this;
		me.clearErrorTabs();
		if(!me.isValidForm()){
			this.handleInvalidForm();
			return false;
		}
		borderLayout.setLoading(true);
		me.mainForm.getForm().submit({
			url:urlStr,
			timeout:70,//seconds
			success: function(form, action) {
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText("admin.server.config.mailReceivingTestSuccess"));
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				if(action.result&&action.result.errors){
					me.handleErrors(action.result.errors);
				}else{
					CWHF.showMsgError(getText("admin.server.config.mailReceivingTestFailure"));
				}
				if(failureHandler){
					failureHandler.call(CWHF.isNull(failureScope)?me:failureScope,form, action);
				}
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.EmailOutgoingController',{
	extend:'Ext.Base',
	portSMTP:25,
	portSMTP_SSL:465,
	SECURITY_CONNECTIONS_MODES:{
		NEVER:0,
		TLS_IF_AVAILABLE:1,
		TLS:2,
		SSL :3
	},
	SMTP_AUTHENTICATION_MODES:{
		CONNECT_USING_SMTP_SETTINGS:1,
		CONNECT_WITH_SAME_SETTINGS_AS_INCOMING_MAIL_SERVER: 2,
		CONNECT_TO_INCOMING_MAIL_SERVER_BEFORE_SENDING:3
	},
	config:{
		labelWidth:250,
		textFieldWidth:550,
		textFieldWidthShort:320,
		alignR:"right",
		FieldSetWidth:600,
		siteCfgController:null
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	view:null,
	createView:function(){
		var me=this;
		me.view=Ext.create('com.trackplus.admin.server.EmailOutgoingView',{
			labelWidth:me.labelWidth,
			textFieldWidth:me.textFieldWidth,
			textFieldWidthShort:me.textFieldWidthShort,
			alignR:me.alignR,
			FieldSetWidth:me.FieldSetWidth,
			emailController:me
		});
		return me.view;
	},
	postDataProcess: function(data) {
		var me=this;
		var userPasswordDisabled = !data["outgoingEmail.reqAuth"] || data["outgoingEmail.authMode"]!==1;
		var outgoingEmailUserControl = CWHF.getControl.call(this.view, "fsSmtpAuth", "outgoingEmailUser");
		outgoingEmailUserControl.setDisabled(userPasswordDisabled);
		var outgoingEmailPasswordControl = CWHF.getControl.call(this.view, "fsSmtpAuth",
				"passwPanel", "outgoingEmailPassword");
		outgoingEmailPasswordControl.setDisabled(userPasswordDisabled);
		var outgoingEmailSecurityConnectionModes=data["outgoingEmail.securityConnectionsModes"];
		var outgoingEmailSecurityConnection=data["outgoingEmail.securityConnection"];
		var outgoingEmailSecurityConnectionModesRadioButtons = CWHF.getRadioButtonItems(outgoingEmailSecurityConnectionModes,
				"outgoingEmail.securityConnection", "id", "label", outgoingEmailSecurityConnection, false, true);
		var outgoingEmailSecurityConnectionControl = CWHF.getWrappedControl.call(this.view, "fsSmtpServer", "outgoingEmailSecurityConnection");
		outgoingEmailSecurityConnectionControl.add(outgoingEmailSecurityConnectionModesRadioButtons);
		var authenticationModes = data["outgoingEmail.authenticationModes"];
		var authMode = data["outgoingEmail.authMode"];
		var authenticationModesRadioButtons = CWHF.getRadioButtonItems(authenticationModes,
				"outgoingEmail.authMode", "id", "label", authMode, !data["outgoingEmail.reqAuth"], true);
		 var authModeControl = CWHF.getWrappedControl.call(this.view, "fsSmtpAuth", "outgoingEmailAuthMode");
		 authModeControl.add(authenticationModesRadioButtons);
		var sendFromModes=data["outgoingEmail.sendFromModes"];
		var sendFromModeValue=data["outgoingEmail.sendFromMode"];
		var sendFromModesRadioButtons = CWHF.getRadioButtonItems(sendFromModes,
				"outgoingEmail.sendFromMode", "id", "label", sendFromModeValue, false, true);
		var sendFromModeControl = CWHF.getWrappedControl.call(this.view, "fsSmtpMore", "outgoingEmailSendFromMode");
		sendFromModeControl.add(sendFromModesRadioButtons);
		var mailEncodingControl = CWHF.getWrappedControl.call(this.view, "fsSmtpMore", "outgoingEmailMailEncoding");
			mailEncodingControl.setValue(data["outgoingEmail.mailEncoding"]);
	},
	changeSecurityMode:function(radioGroup, newValue, oldValue, options){
		var useSSL = CWHF.getSelectedRadioButtonValue(CWHF.getWrappedControl.call(this.view,
				"fsSmtpServer", "outgoingEmailSecurityConnection"));
		var portValue;
		if(useSSL===this.SECURITY_CONNECTIONS_MODES.SSL){
			portValue=this.portSMTP_SSL;
		}else{
			portValue=this.portSMTP;
		}
		var portControl=CWHF.getWrappedControl.call(this.view, "fsSmtpMore", "outgoingEmailPort");
		portControl.setValue(portValue);
	},
	changeRequireAuthentication:function() {
		var smtpReqAuth = CWHF.getWrappedControl.call(this.view, "fsSmtpAuth", "outgoingEmailReqAuth");
		var smtpReqAuthChecked = smtpReqAuth.getValue();
		var authModeWrapper=CWHF.getHelpWrapper.call(this.view, "fsSmtpAuth", "outgoingEmailAuthMode");
		authModeWrapper.setDisabled(!smtpReqAuthChecked);
		var authMode = authModeWrapper.getInputComponent();
		for(var i=0; i<3; i++){
			var item = authMode.getComponent(i);
			if (item) {
				item.setDisabled(!smtpReqAuthChecked);
			}
		}
		var clrbtn=CWHF.getControl.call(this.view, "fsSmtpAuth", "passwPanel", "ClearBtn");
		clrbtn.setDisabled(!smtpReqAuthChecked);
		if (smtpReqAuthChecked) {
			this.changeAuthenticationMode();
		} else {
			CWHF.getControl.call(this.view, "fsSmtpAuth", "outgoingEmailUser").setDisabled(true);
			CWHF.getControl.call(this.view, "fsSmtpAuth", "passwPanel", "outgoingEmailPassword").setDisabled(true);
		}
	},
	changeAuthenticationMode:function(radioGroup, newValue, oldValue, options){
		var authMode=CWHF.getWrappedControl.call(this.view, "fsSmtpAuth", "outgoingEmailAuthMode");
		var usingSMTPselected = CWHF.getSelectedRadioButtonValue(authMode)===1;
		CWHF.getControl.call(this.view, "fsSmtpAuth", "outgoingEmailUser").setDisabled(!usingSMTPselected);
		CWHF.getControl.call(this.view, "fsSmtpAuth", "passwPanel", "outgoingEmailPassword").setDisabled(!usingSMTPselected);
	},
	clearSMTPPassword:function() {
		var me=this;
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: 'editAdminSiteConfig!clearSMTPPassword.action',
			success: function(response){
				borderLayout.setLoading(false);
				CWHF.showMsgInfo(getText('admin.server.config.smtpPasswordCleared'));
			},
			failure:function(response){
				borderLayout.setLoading(false);
				CWHF.showMsgError(getText('admin.server.config.err.smtpPasswordClearFailed'));
			}
		});
	},
	beforeSave:function(){
		var me=this;
		me.view.checkEmailTest.setValue(false);
	},
	changeEmailTest:function(){
		var me=this;
		var testEmail = me.view.checkEmailTest.getValue();
		me.view.txtEmailTestTo.setDisabled(!testEmail);
		var btnEnabled=testEmail&&me.view.txtEmailTestTo.isValid();
		Ext.apply(me.view.btnEmailTest,{formBind:testEmail},{});
		me.view.btnEmailTest.setDisabled(!btnEnabled);
		if(testEmail){//&&!me.view.txtEmailTestTo.isValid()
			me.view.txtEmailTestTo.focus(false,100);
		}
	},
	testOutgoingEmail:function(){
		var me=this;
		var urlStr='saveAdminSiteConfig!testOutgoingEmail.action';
		borderLayout.setLoading(true);
		if(me.siteCfgController){
			me.siteCfgController.test.call(me.siteCfgController,urlStr);
		}
	},
	onTxtEmailTestInputKeyPressed:function(field, e){
		var me=this;
		if (e.getKey() === e.ENTER&&me.view.txtEmailTestTo.isValid()) {
			me.testOutgoingEmail();
		}
	}
});
Ext.define('com.trackplus.admin.server.EmailOutgoingView',{
	extend:'Ext.form.Panel',
	config:{
		labelWidth:250,
		textFieldWidth:550,
		textFieldWidthShort:320,
		alignR:"right",
		FieldSetWidth:600,
		emailController:null
	},
	itemId:'tab_outgoingEmail',
	title:getText('admin.server.config.tabEmailOut'),
	checkEmailTest:null,
	txtEmailTestTo:null,
	layout: {
		type: 'anchor'
	},
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var options=[{'id':'UTF-8','label':'Unicode UTF-8'},
				 {'id':'ISO-8859-1','label':'Western (ISO-8859-1)'},
				 {'id':'ISO-8859-2','label':'Central Europe (ISO-8859-2)'},
				 {'id':'ISO-8859-3','label':'Southern Europe (ISO-8859-3)'},
				 {'id':'ISO-8859-4','label':'Northern Europe (ISO-8859-4)'},
				 {'id':'ISO-8859-6','label':'Arabic (ISO-8859-6)'},
				 {'id':'ISO-8859-7','label':'Greek (ISO-8859-7)'},
				 {'id':'ISO-8859-8','label':'Hebrew (ISO-8859-8)'},
				 {'id':'ISO-8859-9','label':'Turkish (ISO-8859-9)'},
				 {'id':'ISO-8859-10','label':'Nordic (ISO-8859-10)'},
				 {'id':'ISO-8859-11','label':'Thai (ISO-8859-11)'},
				 {'id':'ISO-8859-13','label':'Baltic (ISO-8859-13)'},
				 {'id':'ISO-8859-14','label':'Celtic (ISO-8859-14)'},
				 {'id':'ISO-8859-16','label':'S.E. Europe (ISO-8859-16)'},
				 {'id':'KOI8-R','label':'Russian (KOI8-R)'},
				 {'id':'KOI8-U','label':'Ukraine (KOI8-U)'},
				 {'id':'Shift-JIS','label':'Japanese (Shift-JIS)'},
				 {'id':'ISO-2022-JP','label':'Japanese (ISO-2022-JP)'},
				 {'id':'GB18030','label':'Chinese (simplified)'},
				 {'id':'Big5','label':'Chinese (traditional)'},
				 {'id':'UTF-16','label':'Unicode UTF-16'}];
		var inputCompPwd=CWHF.createTextField('admin.server.config.smtpPassWord',
				'outgoingEmail.password', {inputType:'password', itemId:"outgoingEmailPassword"});
		var clearBtn={xtype:'button',
				style:{ marginBottom: '5px', marginLeft: '5px'},
				enableToggle:false,
				itemId:'ClearBtn',
				text:getText('common.btn.clear'),
				handler:function(){
					me.emailController.clearSMTPPassword.call(me.emailController);
				}
		};
		var inputCompPwdWrapper={
				xtype: 'panel',
				itemId: 'passwPanel',
				border:false,
				bodyBorder:false,
				layout: 'hbox',
				items: [inputCompPwd,clearBtn]
		};
		var testBtn={xtype:'button',
			style:{marginTop:'10px', marginBottom: '5px', marginLeft: (me.labelWidth+5)+'px'},
			enableToggle:false,
			iconCls: 'check16',
			text:'Test',
			handler:function(){
				me.testEmailOutgoing.call(me);
			}
		};
		return [{
			xtype: 'fieldset',
			itemId: 'fsTrackEmail',
			width: me.FieldSetWidth,
			title: getText('admin.server.config.smtpUser'),
			collapsible: false,
			defaults: {anchor: '100%'},
			layout: 'anchor',
			items: [CWHF.createTextFieldWithHelp('admin.server.config.trackEmailPersonalName',
					'outgoingEmail.emailPersonalName'),
					CWHF.createTextFieldWithHelp('admin.server.config.trackEmail',
							'outgoingEmail.trackEmail',{allowBlank:false,vtype: 'email'})]
		}, {
			xtype: 'fieldset',
			itemId: 'fsSmtpServer',
			width: me.FieldSetWidth,
			title: getText('admin.server.config.smtpServer'),
			collapsible: false,
			defaultType: 'textfield',
			defaults: {anchor: '100%'},
			layout: 'anchor',
			items: [CWHF.createTextFieldWithHelp('admin.server.config.smtpServerName',
						'outgoingEmail.serverName'),
					CWHF.getRadioGroupWithHelp('admin.server.config.smtpSecurityConnection',
						me.textFieldWidth, null, {itemId:"outgoingEmailSecurityConnection"},
						{change: function(radioGroup, newValue, oldValue, options) {
								me.emailController.changeSecurityMode.call(me.emailController,radioGroup, newValue, oldValue, options)}
						})
					]
		}, {
			xtype: 'fieldset',
			itemId: 'fsSmtpAuth',
			width: me.FieldSetWidth,
			title: getText('admin.server.config.smtpAuthentication'),
			collapsible: false,
			defaultType: 'textfield',
			layout: 'anchor',
			items: [CWHF.createCheckboxWithHelp('admin.server.config.smtpReqAuth',
					'outgoingEmail.reqAuth', {itemId:'outgoingEmailReqAuth',height:40}, {change:function(){
						me.emailController.changeRequireAuthentication.call(me.emailController);
					}}),
					CWHF.getRadioGroupWithHelp('admin.server.config.smtpAuthMode',
							me.textFieldWidth, null, {itemId:'outgoingEmailAuthMode',layout: 'vbox'},
							{change: function(radioGroup, newValue, oldValue, options) {
									me.emailController.changeAuthenticationMode.call(me.emailController,radioGroup, newValue, oldValue, options);
							}}),
					CWHF.createTextField('admin.server.config.smtpUser', 'outgoingEmail.user', {itemId:"outgoingEmailUser"}),
					inputCompPwdWrapper]
		}, {
			xtype: 'fieldset',
			itemId: 'fsSmtpMore',
			width: me.FieldSetWidth,
			title: getText('admin.server.config.smtpMoreOptions'),
			collapsible: true,
			collapsed: true,
			defaultType: 'textfield',
			layout: 'anchor',
			items: [CWHF.getRadioGroupWithHelp(me.textFieldWidth,null, [], {itemId:'outgoingEmailSendFromMode',layout: 'vbox'}),
					CWHF.createComboWithHelp('admin.server.config.mailEncoding',
							'outgoingEmail.mailEncoding',{itemId:'outgoingEmailMailEncoding', data:options, idType:'string'}),
					CWHF.createNumberFieldWithHelp('admin.server.config.smtpPort',
						'outgoingEmail.port', 0, 1, 9999, {width:me.textFieldWidth, hideTrigger: true,itemId:'outgoingEmailPort'})]
		},
		me.createTestPanel()
		];
	},
	createTestPanel:function(){
		var me=this;
		me.checkEmailTest=CWHF.createCheckbox('admin.server.config.trackEmailTest', 'outgoingEmail.emailTest',null,
			{
				change:function(){
					me.emailController.changeEmailTest.call(me.emailController);
				}
			}
		);
		me.txtEmailTestTo=CWHF.createTextField('admin.server.config.trackEmailTestTo','emailTestTo',{disabled:true,allowBlank:false,vtype: 'email'});
		me.txtEmailTestTo.addListener('specialkey',me.emailController.onTxtEmailTestInputKeyPressed,me.emailController);
		me.btnEmailTest=Ext.create('Ext.button.Button',{
			style:{marginTop:'10px', marginBottom: '5px', marginLeft: (me.labelWidth+5)+'px'},
			disabled:true,
			iconCls: 'check16',
			text: getText('admin.server.config.trackEmailTestButton'),
			handler:function(){
				me.emailController.testOutgoingEmail.call(me.emailController);
			}
		});
		var testArea={
			xtype: 'fieldset',
			itemId: 'fsSmtpTest',
			//title:getText('admin.server.config.trackEmailTest'),
			title: '',//if title not empty remove the margin and padding
			margin:'8 0 0 6',
			style:{
				paddingLeft:'13px',
				paddingTop:'18px'
			},
			width: me.FieldSetWidth,
			layout: 'anchor',
			items:[me.checkEmailTest,me.txtEmailTestTo,me.btnEmailTest]
		};
		return testArea;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.LdapController',{
	extend:'Ext.Base',
	config:{
		labelWidth:250,
		textFieldWidth:550,
		textFieldWidthShort:320,
		alignR:"right",
		FieldSetWidth:600,
		siteCfgController:null
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	view:null,
	createView:function(){
		var me=this;
		me.view=Ext.create('com.trackplus.admin.server.LdapView',{
			labelWidth:me.labelWidth,
			textFieldWidth:me.textFieldWidth,
			textFieldWidthShort:me.textFieldWidthShort,
			alignR:me.alignR,
			FieldSetWidth:me.FieldSetWidth,
			ldapController:me
		});
		return me.view;
	},
	postDataProcess: function(data) {
		this.changeLDAPon();
	},
	/**
	 * Enable or disable input elements for LDAP panel
	 */
	changeLDAPon:function() {
		// Get the main enable/disable check box
		var ldap = CWHF.getWrappedControl.call(this.view,"fsLdap", "ldapEnabled");
		var ldapEnabled = ldap.getValue();
		// Get all components to disable or enable
		var serverURL = CWHF.getHelpWrapper.call(this.view, "fsLdap", "ldapServerURL");
		serverURL.setDisabled(!ldapEnabled);
		var attributeLoginName = CWHF.getHelpWrapper.call(this.view, "fsLdap", "ldapAttributeLoginName");
		attributeLoginName.setDisabled(!ldapEnabled);
		var bindDN = CWHF.getHelpWrapper.call(this.view, "fsLdap", "ldapBindDN");
		bindDN.setDisabled(!ldapEnabled);
		var password = CWHF.getControl.call(this.view, "fsLdap", "ldapPassword");
		password.setDisabled(!ldapEnabled);
		var forceLdap = CWHF.getHelpWrapper.call(this.view, "fsLdap", "ldapForce");
		forceLdap.setDisabled(!ldapEnabled);
		var btnTest = CWHF.getControl.call(this.view,"fsLdapTest", "ldapTestConnection");
		var txtLoginNameTest = CWHF.getControl.call(this.view,"fsLdapTest", "ldapLoginNameTest");
		var txtPasswordTest = CWHF.getControl.call(this.view,"fsLdapTest", "ldapPasswordTest");
		btnTest.setDisabled(!ldapEnabled);
		txtLoginNameTest.setDisabled(!ldapEnabled);
		txtPasswordTest.setDisabled(!ldapEnabled);
	},
	testLdap:function(){
		var me=this;
		if(me.siteCfgController){
			me.siteCfgController.testLdap.call(me.siteCfgController);
		}
	},
	clearErrorTabs:function(){
		var me=this;
		me.view.errorBox.setVisible(false);
	},
	failureHandler:function(form, action){
		var me=this;
		if(action.result&&action.result.errors){
			for(var i=0;i<action.result.errors.length;i++){
				if(CWHF.isNull(action.result.errors[i].controlPath)||action.result.errors[i].controlPath.length===0){
					me.view.errorBox.update(action.result.errors[i].errorMessage);
					me.view.errorBox.setVisible(true);
					break;
				}
			}
		}
	}
});
Ext.define('com.trackplus.admin.server.LdapView',{
	extend:'Ext.form.Panel',
	config:{
		labelWidth:250,
		textFieldWidth:550,
		textFieldWidthShort:320,
		alignR:"right",
		FieldSetWidth:600,
		ldapController:null
	},
	itemId:'tab_ldap',
	title:getText('admin.server.config.tabLDAP'),
	checkEmailTest:null,
	txtEmailTestTo:null,
	layout: {
		type: 'anchor'
	},
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var testBtn={xtype:'button',
			style:{marginTop:'10px', marginBottom: '5px', marginLeft: (me.labelWidth+5)+'px'},
			iconCls: 'check16',
			itemId: 'ldapTestConnection',
			text:getText('admin.server.config.ldapTest'),
			handler:function(){
				me.ldapController.testLdap.call(me.ldapController);
			}
		};
		var txtLoginNameText=CWHF.createTextField('admin.server.config.ldapLoginNameTest','ldap.loginNameTest',{disabled:true, itemId:"ldapLoginNameTest"});
		var txtPasswordTest=CWHF.createTextField('admin.server.config.ldapPasswordTest','ldap.passwordTest',{inputType:'password', itemId:"ldapPasswordTest"});
		me.errorBox=Ext.create('Ext.Component',{
			html: '',
			margin:'5 5 5 5',
			border:true,
			anchor:'100%',
			hidden:true,
			cls:'errBox2'
		});
		var testArea={
			xtype: 'fieldset',
			itemId: 'fsLdapTest',
			//title:getText('admin.server.config.trackEmailTest'),
			title: '',//if title not empty remove the margin and padding
			margin:'8 0 0 6',
			style:{
				paddingLeft:'13px',
				paddingTop:'18px'
			},
			width: me.FieldSetWidth,
			layout: 'anchor',
			items:[txtLoginNameText,txtPasswordTest,testBtn,me.errorBox]
		};
		return [{
			xtype: 'fieldset',
			itemId: 'fsLdap',
			width: me.FieldSetWidth,
			title: '',//if title not empty remove the margin and padding
			margin:'8 0 0 6',
			style:{
				paddingLeft:'13px',
				paddingTop:'18px'
			},
			collapsible: false,
			//defaults: {anchor: '100%'},
			layout: 'anchor',
			items: [CWHF.createCheckboxWithHelp('admin.server.config.isCbaAllowed',
						'otherSiteConfig.cbaAllowed'),
					CWHF.createCheckboxWithHelp('admin.server.config.automaticGuestLogin',
							'otherSiteConfig.automaticGuestLogin'),
					CWHF.createCheckboxWithHelp('admin.server.config.isLDAPOn',
							'ldap.enabled', {itemId:"ldapEnabled"},
							{change:function(){
								me.ldapController.changeLDAPon.call(me.ldapController);
							}}),
					CWHF.createTextFieldWithHelp('admin.server.config.ldapServerURL',
							'ldap.serverURL', {itemId:"ldapServerURL"}),
					CWHF.createTextFieldWithHelp('admin.server.config.ldapLoginName',
							'ldap.attributeLoginName', {itemId:"ldapAttributeLoginName"}),
					CWHF.createTextFieldWithHelp('admin.server.config.ldapBindDn',
							'ldap.bindDN', {itemId:"ldapBindDN"}),
					CWHF.createTextField('admin.server.config.ldapBindPass',
						'ldap.password',{inputType:'password', itemId:"ldapPassword"}),
					CWHF.createCheckboxWithHelp('admin.server.config.isForceLdap',
						'ldap.force', {itemId:"ldapForce"})]
		},testArea
		];
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.ServerStatus',{
	extend:'Ext.Base',
//	config: {
//	},
	constructor: function(config) {
	},
	btnSave:null,
	formPanel:null,
	jsonData:null,
	labelWidth:290,
	alignR:"right",
	createToolbar:function(){
		var me=this;
		if(CWHF.isNull(me.btnSave)){
			me.btnSave=new Ext.Button({
				overflowText:getText('common.btn.save'),
				tooltip:getText('common.btn.save'),
				text: getText('common.btn.save'),
				iconCls: 'save',
				disabled:true,
				handler:function(){
					me.save.call(me);
				}
			});
		}
		return [me.btnSave];
	},
	reloadAndReplaceComp:function(){
		var me=this;
		borderLayout.setLoading(true);
		Ext.Ajax.request({
			url: 'editAdminSiteStatus!load.action',
			success: function(response){
				var jsonData=Ext.decode(response.responseText);
				borderLayout.setLoading(false);
				if(jsonData.success===true){
					var component=me.createComp.call(me,jsonData.data);
					borderLayout.setCenterContent(component);
					me.btnSave.setDisabled(false);
				}else{
					alert("failed:"+jsonData.errorMessage);
				}
			},
			failure:function(response){
				borderLayout.setLoading(false);
			}
		});
	},
	createCountActiveInactiveLabel: function(userCount) {
		var me=this;
		var label = userCount["label"];
		var total = userCount["total"];
		var active = userCount["active"];
		var inactive = userCount["inactive"];
		return CWHF.createLabelComponent(label, null,
				{labelIsLocalized:true,
				labelWidth:me.labelWidth,
				value:total + " (" + active + "/" + inactive + ")"});
	},
	createLabelComponent:function(fieldLabelKey,value){
		var me=this;
		var fieldLabel='';
		if(fieldLabelKey&&fieldLabelKey!==''){
			fieldLabel=getText(fieldLabelKey);
		}
		var labelComp={
				xtype:'displayfield',
				fieldLabel:fieldLabel,
				labelStyle:{overflow:'hidden'},
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				value: value,
				htmlEncode :false,
				fieldStyle : {
					height:'auto'
				},
				anchor:'100%'
		};
		return labelComp;
	},
	createLabelPercentComponent:function(fieldLabelKey,value,percent){
		var me=this;
		var barWidth = 80;
		var fieldLabel='';
		if(fieldLabelKey&&fieldLabelKey!==''){
			fieldLabel=getText(fieldLabelKey);
		}
		if (CWHF.isNull(percent)) {
			percent = 0;
		}
		var rwidth = barWidth * percent / 100;
		var gwidth = barWidth - rwidth;
		var labelComp={
				xtype:'displayfield',
				fieldLabel:fieldLabel,
				labelStyle:{overflow:'hidden'},
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				value: value,
				width: me.labelWidth+100,
				htmlEncode :false
				//anchor:'50%'
		};
		var divComp={
				xtype: 'container',
				layout: {
					type: 'hbox'
				},
				id: 'MYIMAGE',
				items: [
				        labelComp,
				        {
				        	xtype:'component',
				        	cls:'barWrapper',
				        	style: {
				        		right: '40px',
								marginLeft: '10px',
								marginTop: '7px'
							},
				        	html:'<img width="'+rwidth+'" height="10" alt="RedBar" src="'+
	                             				com.trackplus.TrackplusConfig.iconsPath+'RedBar.gif"/>'+
	                             '<img width="'+gwidth+'" height="10" alt="GreenBar" src="'+
	                             				com.trackplus.TrackplusConfig.iconsPath+'GreenBar.gif"/>'
				        }
				        ]
		};
		return divComp;
	},
	createComp:function(jsonData){
		var me=this;
		me.jsonData=jsonData;
		var ipString=jsonData.serverIPAddress;
		var index = ipString.indexOf(",");
		while(index !== -1){
			ipString = ipString.replace(",","<br>");
			index = ipString.indexOf(",");
		}
		var generalInformation=Ext.create('Ext.form.FieldSet',{
			// frame: true,
			title: getText('admin.server.status.generalInfo'),
			layout: {
				type: 'anchor'
			},
			items:[
			       me.createLabelComponent("common.version",jsonData.version),
			       me.createLabelComponent("admin.server.status.ipNumber",ipString)
                   ],
			 margin:'0 0 5 0'
		});
		var dsPerson= Ext.create('Ext.data.Store', {
			data	:jsonData.usersLoggedIn,
			fields	: [{name:'value', type:'string'}, {name:'label', type:'string'}],
			autoLoad: true
		});
		var cmbPerson = Ext.create('Ext.ux.form.MultiSelect',{
			fieldLabel	: ' ',
			labelSeparator:'',
			hideLabel :false,
			labelWidth:me.labelWidth,
			labelAlign:me.alignR,
			width: (me.labelWidth+230),
			height:140,
			margin:'0 5 5 0',
			store	:dsPerson,
			displayField: 'label',
			valueField	: 'value',
			value: ''
		});
		var dsClusterNodes= Ext.create('Ext.data.Store', {
			data	:jsonData.clusterNodes,
			fields	: [{name:'value', type:'string'}, {name:'label', type:'string'}],
			autoLoad: true
		});
		var cmbClusterNodes = Ext.create('Ext.ux.form.MultiSelect',{
			fieldLabel	: getText('admin.server.status.nodes'),
			labelWidth:me.labelWidth,
			labelAlign:me.alignR,
			width: (me.labelWidth+230),
			height:50,
			margin:'0 5 5 0',
			store	:dsClusterNodes,
			displayField: 'label',
			valueField	: 'value',
			value: ''
		});
		var statisticItems = [me.createLabelComponent("admin.server.status.numberOfProjects",jsonData.numberOfProjects),
	       					me.createLabelComponent("admin.server.status.numberOfIssues",jsonData.numberOfIssues)];
		var userCountList = jsonData.userCountList;
		if (userCountList) {
				Ext.Array.forEach(userCountList, function(userCount) {
					statisticItems.push(me.createCountActiveInactiveLabel(userCount));
					}, this);
		}
		statisticItems.push(cmbPerson);
		statisticItems.push(cmbClusterNodes);
		var statistics=Ext.create('Ext.form.FieldSet',{
			// frame: true,
			title: getText('admin.server.status.statistics'),
			// height:485, // that does not work
			layout: {
				type: 'anchor'
			},
			items: statisticItems,
			margin:'0 0 5 0'
		});
		var javaVMMemory=Ext.create('Ext.form.FieldSet',{
			// frame: true,
			title: getText('admin.server.status.jvmmem'),
			layout: {
				type: 'anchor'
			},
			anchor: '50%',
			items:[
			       me.createLabelComponent("admin.server.status.maxMemory",jsonData.javaVMmaxMemory+" Mbyte"),
			       me.createLabelComponent("admin.server.status.totalMemory",jsonData.javaVMtotalMemory+" Mbyte"),
			       me.createLabelPercentComponent("admin.server.status.usedMemory",jsonData.javaVMusedMemory+" Mbyte", (100*jsonData.javaVMusedMemory)/jsonData.javaVMtotalMemory),
			       me.createLabelComponent("admin.server.status.freeMemory",jsonData.javaVMfreeMemory+" Mbyte")
			       ],
			       margin:'0 0 5 0'
		});
		var javaInformation=Ext.create('Ext.form.FieldSet',{
			frame: true,
			title: getText('admin.server.status.javaInfo'),
			layout: {
				type: 'anchor'
			},
			items:[
			       me.createLabelComponent("admin.server.status.javaVersion",jsonData.javaVersion),
			       me.createLabelComponent("admin.server.status.javaVendor",jsonData.javaVendor),
			       me.createLabelComponent("admin.server.status.javaHome",jsonData.javaHome),
			       me.createLabelComponent("admin.server.status.javaVmVersion",jsonData.javaVMVersion),
			       me.createLabelComponent("admin.server.status.javaVmVendor",jsonData.javaVMVendor),
			       me.createLabelComponent("admin.server.status.javaVmName",jsonData.javaVMName)
			       ],
			       margin:'0 0 5 0'
		});
		var systemInformation=Ext.create('Ext.form.FieldSet',{
			frame: true,
			title: getText('admin.server.status.sysinfo'),
			layout: {
				type: 'anchor'
			},
			items:[
			       me.createLabelComponent("admin.server.status.osName",jsonData.operatingSystem),
			       me.createLabelComponent("admin.server.status.userName",jsonData.userName),
			       me.createLabelComponent("admin.server.status.userDir",jsonData.currentUserDir),
			       me.createLabelComponent("admin.server.status.systemLocale",jsonData.systemLocale),
			       me.createLabelComponent("admin.server.status.userTz",jsonData.userTimezone),
			       me.createLabelComponent("admin.server.status.jasperVersion",jsonData.jasperVersion)
			       ],
			       margin:'0 0 5 0'
		});
		var radioGroupOpMode={
				xtype: 'radiogroup',
				fieldLabel:getText('admin.server.status.opstate'),
				labelStyle:{overflow:'hidden'},
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				anchor:'100%',
				layout: 'hbox',
				defaults:{margin:'0 5 0 0'},
				items:[
				       {
				    	   name:'opState',
				    	   inputValue: 'Running',
				    	   boxLabel:getText("admin.server.status.opstate.running"),
				    	   checked:(CWHF.isNull(jsonData.operationalStatus)||jsonData.operationalStatus==="Running")
				       },{
				    	   name:'opState',
				    	   inputValue: 'Maintenance',
				    	   boxLabel:getText("admin.server.status.opstate.maintenance"),
				    	   checked:(jsonData.operationalStatus==="Maintenance")
				       }
				       ]
		};
		var checkUserMsg={
				xtype: 'checkboxfield',
				fieldLabel	: getText('admin.server.status.userMsg'),
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				inputValue:'true',
				name:'hasUserMsg',
				checked:(jsonData.isUserInfo===true)
		};
		var txtUserMsg={
				xtype:'textarea',
				fieldLabel	: ' ',
				labelSeparator:'',
				labelWidth:me.labelWidth,
				labelAlign:me.alignR,
				name:'userMsg',
				width: (me.labelWidth+200),
				value:jsonData.userInfo,
				height:120
		};
		var operation=Ext.create('Ext.form.FieldSet',{
			// frame: true,
			title: getText('admin.server.status.opstateInfo'),
			layout: {
				type: 'anchor'
			},
			items:[
			       radioGroupOpMode,
			       checkUserMsg,txtUserMsg
			       ],
			       margin:'0 0 5 0'
		});
		var databaseInformation=Ext.create('Ext.form.FieldSet',{
			// frame: true,
			title: getText('admin.server.status.dbInfo'),
			layout: {
				type: 'anchor'
			},
			items:[
			       me.createLabelComponent("admin.server.status.dbInfo",jsonData.database),
			       me.createLabelComponent("admin.server.status.jdbcDriverInfo",jsonData.jdbcDriver),
			       me.createLabelComponent("admin.server.status.jdbcUrl",jsonData.jdbcUrl),
			       me.createLabelComponent("admin.server.status.pingTime",jsonData.pingTime)
			       ],
			       margin:'0 0 5 0'
		});
		me.formPanel=Ext.create('Ext.form.Panel', {
			title:getText('admin.server.status.status'),
			url: 'editAdminSiteStatus!save.action',
			border	: false,
			bodyBorder:false,
			autoScroll:true,
			margins: '0 0 0 0',
			width: '100%',
			layout: {
				type: 'table',
				columns: 2,
				tableAttrs: {
					style: {
						width: '100%'
					}
				},
				tdAttrs:{
					width:'50%',
					style:{
						'vertical-align':'top'
					}
				}
			},
			defaults: {
				frame:false,
				border: false
			},
			items:[
			       {
			    	   margin:'5 5 5 5',
			    	   items:[generalInformation, statistics, databaseInformation]
			       },{
			    	   margin:'5 5 5 5',
			    	   items:[javaVMMemory,javaInformation,systemInformation,operation]
			       }
//			       ,{
//			       margin:'5 5 5 5',
//			       colspan: 2,
//			       items:[databaseInformation]
//			       }
			       ]
		});
		var logArray=jsonData['logMessages'];
		var logMessages = '';
		if (logArray  && logArray.length > 0) {
			for (i=0; i < logArray.length; ++i) {
				pre = '<div class="logMessage">';
				post = '</div>';
				if (logArray[i].indexOf(' ERROR ') !== -1) {
					pre = '<div class="logMessageError">'
				}
				if (logArray[i].indexOf(' WARN ') !== -1) {
					pre = '<div class="logMessageWarn">'
				}
				logMessages = logMessages + pre + logArray[i] + post;
			}
		}
		var logMessagesTab=Ext.create('Ext.form.Panel',{
			// frame: true,
			title: getText('admin.server.status.logMessages'),
			layout: {
				type: 'anchor'
			},
			html: logMessages,
			bodyPadding:10
		});
		me.tabPanel = new Ext.TabPanel({
			plain:true,
			border:false,
			bodyBorder:false,
			padding: '3 0 0 0',
			defaults:{
				border:false,
				autoScroll:true,
				bodyStyle:{
					border:'none',
					padding:'0px'
				}
			},
			items:[me.formPanel,logMessagesTab],
			activeTab:0
		});
		return me.tabPanel;
	},
	save:function(){
		var me=this;
		me.formPanel.setLoading(true);
		me.formPanel.getForm().submit({
			success: function(form, action) {
				me.formPanel.setLoading(false);
			},
			failure: function(form, action) {
				me.formPanel.setLoading(false);
				var errorCode=action.result.errorCode;
				var errorMessage=action.result.errorMessage;
				alert(errorMessage);
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.LoggingConfig',{
	extend:'Ext.Base',
	constructor: function(config) {
	},
	grid:null,
	storeLevel:null,
	cmbLevel:null,
	filter:null,
	jsonData:null,
	levelsMap:null,
	createMainComponent:function(){
		var me=this;
		var store = Ext.create('Ext.data.Store', {
			autoLoad: false,
			fields: [
			         {name:'className', type:'string'},
			         {name:'level', type:'string'},
			         {name:'value', type:'int'}
			         ],
			         groupField: 'level',
			         data:[]
		});
		me.storeLevel=Ext.create('Ext.data.Store', {
			autoLoad: false,
			fields: [{name:'id',type:'int'},{name:'label',type:'string'}],
			data:[]
		});
		me.cmbValue=Ext.create('Ext.form.ComboBox', {
			store: me.storeLevel,
			name: name,
			queryMode: 'local',
			displayField: 'label',
			valueField: 'id',
			editable:false
		});
		var cellEditing = Ext.create('Ext.grid.plugin.CellEditing', {
			clicksToEdit: 1
		});
		var groupingFeature = Ext.create('Ext.grid.feature.Grouping', {
			groupHeaderTpl: '{name} ({rows.length} {[values.rows.length > 1 ? getText("admin.server.logging.items") : getText("admin.server.logging.item")]})',
			startCollapsed: false // start all groups collapsed
		});
		var txtSubject=Ext.create('Ext.form.field.Text',{
			name:'filterBox',
			fieldLabel:getText('admin.server.logging.filter'),
			width:515
		});
		var filterBox = Ext.create("Ext.form.field.Text", {
			fieldLabel:getText('admin.server.logging.filter'),
			width: 300,
			labelWidth: 80,
			labelAlign: 'right',
			enableKeyEvents:true,
			listeners: {
				keyup: {
					element: 'el',
					fn: function() {
						var callme = false;
						if (filterBox.getRawValue().length > 3) callme=true;
						if (filterBox.getRawValue().length < me.filter.length) callme = true;
						if (filterBox.getRawValue().length <= 3) {
							me.filter="";
						} else {
							me.filter = filterBox.getRawValue();
						}
						if (callme) {
							me.reload.call(me);
						}
					}
				}
			}
		});
		var topPanel = Ext.create("Ext.panel.Panel",  {
			bodyPadding: 5,
			margin: '0 0 0 0',
			border: false,
			bodyBorder:false,
			width: '100%',
			region:'north',
			id: 'topLogPanel',
			layout: 'hbox',
			items: [filterBox,
				{
					xtype:'button',
					style:{ marginBottom: '5px', marginLeft: '5px'},
					enableToggle:false,
					id:'ClearBtn',
					text:com.trackplus.TrackplusConfig.getText('common.btn.clear'),
					handler:function(){
						filterBox.setRawValue("");
						me.filter=filterBox.getRawValue();
						me.reload.call(me);
					}
				}
			]
		});
		me.filter="aurel";
		me.grid = Ext.create('Ext.grid.Panel', {
			store: store,
			id: 'logGrid',
			region:'center',
			style:{
				borderTop:'1px solid #D0D0D0'
			},
			bodyBorder:false,
			cls:'gridNoBorder',
			columns: [
			          {text: getText('admin.server.logging.className'), width: 400, dataIndex: 'className',
			        	  sortable: true, hideable:false, groupable:false},
			        	  {text: getText('admin.server.logging.level'), width: 100, dataIndex: 'value',
			        		  sortable: true, hideable:false, editor:me.cmbValue,
			        		  renderer : function(value){
			        			  if(me.levelsMap){
			        				  return me.levelsMap[''+value];
			        			  }
			        			  return value;
			        		  }
			        	  }
			        	  ],
			        	  margin:'0 0 0 0',
			        	  border:false,
			        	  scroll: false,
			        	  viewConfig: {
			        		  style: { overflow: 'auto', overflowX: 'hidden' }
			        	  },
			        	  region:'center',
			        	  width:'100%',
			        	  autoheight:true,
			        	  plugins: [cellEditing],
			        	  features:[groupingFeature]
		});
		me.grid.on('edit', function(editor, e) {
			e.record.commit();
			var className=e.record.data['className'];
			var value=e.value;
			var oldValue=e.originalValue;
			if(value!==oldValue){
				me.changeLevel.call(me,className,value);
			}
		});
		/*me.grid.on('validateedit', function(editor, e) {
		e.record.data[e.field] = e.value;
		e.cancel = true;
	});*/
		var mainPanel = Ext.create("Ext.panel.Panel",  {
			bodyPadding: 0,
			id: 'mainPanel',
			margin: '0 0 0 0',
			border: false,
			width: '100%',
			layout:'border',
			items: [topPanel, me.grid]
		});
		return mainPanel;
	},
	changeLevel:function(className,value){
		var me=this;
		me.grid.setLoading(true);
		Ext.Ajax.request({
			url: "editAdminLoggingConfig!save.action",
			params:{className:className,level:value},
			disableCaching:true,
			scope: me,
			success: function(response){
				me.grid.setLoading(false);
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success === false) {
					Ext.MessageBox.alert(getText('common.err.failure'), response.responseText);
				}
			},
			failure: function(response){
				me.grid.setLoading(false);
				Ext.MessageBox.alert(getText('common.err.failure'), response.responseText);
			},
			method:"POST"
		});
	},
	reload:function(){
		var me=this;
		Ext.Ajax.request({
			url: "editAdminLoggingConfig!load.action",
			params: {filter: me.filter},
			disableCaching:true,
			scope: me,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success === true) {
					me.jsonData=responseJson.data;
					me.levelsMap=new Object();
					var levels=responseJson.data.levels;
					for(var i=0;i<levels.length;i++){
						me.levelsMap[''+levels[i].id]=levels[i].label;
					}
					me.grid.store.loadData(responseJson.data.loggers);
					me.storeLevel.loadData(responseJson.data.levels);
				}else {
					if (responseJson.errorMessage) {
						var errorCode=responseJson.errorCode;
						var errorMessage=responseJson.errorMessage;
					}
				}
			},
			failure: function(response){
				Ext.MessageBox.alert(getText('common.err.failure'), response.responseText);
			},
			method:"POST"
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.LogonPageText',{
	extend:'Ext.Base',
//	config: {
//	},
	constructor: function(config) {
	},
	btnSave:null,
	panelForm:null,
	cmbLocale:null,
	//htmlEditor:null,
	createSaveButton:function(){
		var me=this;
		if(CWHF.isNull(me.btnSave)){
			me.btnSave=new Ext.Button({
				text:getText('common.btn.save'),
				tooltip:getText('common.btn.save'),
				iconCls: 'save',
				disabled:false,
				handler:function(){
					me.save.call(me);
				}
			});
		}
		return me.btnSave;
	},
	save:function(){
		var me=this;
		me.panelForm.setLoading(true);
		me.panelForm.getForm().submit({
			method :'POST',
			scope:me,
			success: function(form, action) {
				me.panelForm.setLoading(false);
				//me.reload(me.cmbLocale.getValue());
			},
			failure: function(form, action) {
				me.panelForm.setLoading(false);
				Ext.Msg.alert('Failure',action.result.errorMessage);
				var errorCode=action.result.errorCode;
				var errorMessage=action.result.errorMessage;
			}
		});
	},
	createMainComponent:function(){
		var me=this;
		me.cmbLocale=CWHF.createCombo("admin.server.motd.locale", "theLocale",
				{idType:"string", labelWidth:120, allowBlank:false},
				{select: function(field,record) {
					var theLocale=field.getValue();
					me.reload(theLocale);
				}});
		var txtEditorTeaser =CWHF.createTextField("admin.server.motd.teaserText", "teaserText",
				{anchor:'100%', labelWidth:120});
		var htmlEditor = CWHF.createHtmlEditorField("admin.server.motd.message", "theMessage",
				{itemId:'theMessage',padding: '20 0 0 0', anchor:'100% 80%', labelWidth:120});
		me.panelForm= new Ext.form.FormPanel({
			url:'logonPageText!save.action',
			fieldDefaults: {
				// labelWidth: 100
			},
			region:'center',
			border:false,
			autoScroll: true,
			bodyStyle: 'padding:10px',
			defaultType: 'textfield',
			items: [me.cmbLocale, txtEditorTeaser, htmlEditor]
		});
		return me.panelForm;
	},
	reload:function(theLocale){
		var me=this;
		var url="logonPageText.action";
		me.panelForm.setLoading(true);
		me.panelForm.getForm().load({
			url : url,
			params:{
				'theLocale':theLocale
			},
			success : function(form, action) {
				try{
					me.afterLoadForm.call(me,action.result.data);
					me.panelForm.setLoading(false);
				}catch(ex){}
			}
		});
	},
	afterLoadForm:function(data){
		var me=this;
		me.cmbLocale.store.loadData(data["localeList"],false);
		me.cmbLocale.setValue(data["theLocale"]);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.SendEmail',{
	extend:'Ext.Base',
	constructor: function(config) {
	},
//	static
	ERROR_NEED_PERSON:3,
	ERROR_NEED_SUBJECT:6,
	ERROR_NEED_BODY:7,
	ERROR_EMAIL_NOT_SEND:4,
	ERROR_NEED_MORE_TIME:5,
	instance:null,
//	end static
	btnCC:null,
	btnBCC:null,
	btnSend:null,
	win:null,
	formPanel:null,
	txtSubject:null,
	txtBody:null,
	txtTo:null,
	txtCC:null,
	txtBCC:null,
	visibleCC:false,
	visibleBCC:false,
	containerCC:null,
	containerBCC:null,
	getToolbar:function(){
		var me=this;
		if(CWHF.isNull(me.btnSend)){
			me.initButtons();
		}
		return [me.btnCC,me.btnBCC,me.btnSend];
	},
	initButtons:function(){
		var me=this;
		me.btnCC=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.cc'),me.showHideCC,'user16',true);
		me.btnBCC=me.createToolbarBtn(getText('item.action.sendItemEmail.lbl.bcc'),me.showHideBCC,'user16',true);
		me.btnSend=new Ext.Button({
			text:getText('item.action.sendItemEmail.lbl.send'),
			tooltip:getText('item.action.sendItemEmail.lbl.send'),
			iconCls: 'buttonEmailSend',
			disabled:false,
			handler:function(){
				me.sendEmail.call(me);
			}
		});
	},
	createToolbarBtn:function(label,handler,cssClass,enableToggle){
		var me=this;
		return new Ext.Button({
			overflowText:label,
			tooltip:label,
			iconCls:cssClass,
			text:label,
			handler:handler,
			enableToggle:enableToggle?enableToggle===true:false,
			scope:me
		});
	},
	showHideCC:function(){
		var me=this;
		me.visibleCC=!me.visibleCC;
		me.containerCC.setVisible(me.visibleCC);
	},
	showHideBCC:function(){
		var me=this;
		me.visibleBCC=!me.visibleBCC;
		me.containerBCC.setVisible(me.visibleBCC);
	},
	createMainComponent:function(){
		var me=this;
		me.initView();
		return me.formPanel;
	},
	initView:function(){
		var me=this;
		me.linkTo=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.to'),
			width:55,
			handler:me.openLinkTo,
			scope:me
		});
		me.txtTo=Ext.create('Ext.form.field.Text',{
			name:'toCustom',
			margin:'0 0 0 5',
			flex:1
		});
		me.btnChooseTo=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.to')),
			iconCls:'addressBook',
			handler:me.openLinkTo,
			margin:'0 0 0 5',
			scope:me
		})
		var containerTo={
			xtype:'container',
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			items:[me.linkTo,me.txtTo,me.btnChooseTo]
		};
		me.linkCC=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.cc'),
			width:55,
			handler:me.openLinkCC,
			scope:me
		});
		me.txtCC=Ext.create('Ext.form.field.Text',{
			name:'ccCustom',
			margin:'0 0 0 5',
			flex:1
		});
		me.btnChooseCC=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.cc')),
			iconCls:'addressBook',
			handler:me.openLinkCC,
			margin:'0 0 0 5',
			scope:me
		})
		me.containerCC=Ext.create('Ext.container.Container',{
			xtype:'container',
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			hidden:true,
			items:[me.linkCC,me.txtCC,me.btnChooseCC]
		});
		me.linkBCC=Ext.create('Ext.ux.LinkComponent',{
			clsLink:'link_blue',
			style:{
				textAlign:'right',
				paddingTop:'4px'
			},
			suffix:':',
			label:getText('item.action.sendItemEmail.lbl.bcc'),
			width:55,
			handler:me.openLinkBCC,
			scope:me
		});
		me.txtBCC=Ext.create('Ext.form.field.Text',{
			margin:'0 0 0 5',
			flex:1,
			name:'bccCustom',
			anchor: '100%'
		});
		me.btnChooseBCC=Ext.create('Ext.button.Button',{
			tooltip:getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.bcc')),
			iconCls:'addressBook',
			handler:me.openLinkBCC,
			margin:'0 0 0 5',
			scope:me
		})
		me.containerBCC=Ext.create('Ext.container.Container',{
			xtype:'container',
			layout: {
				type: 'hbox',
				pack: 'start',
				align: 'stretch'
			},
			anchor: '100%',
			margin:'5 5 5 5',
			hidden:true,
			items:[me.linkBCC,me.txtBCC,me.btnChooseBCC]
		});
		me.txtSubject=Ext.create('Ext.form.field.Text',{
			name:'subject',
			fieldLabel:getText('admin.server.sendEmail.lbl.subject'),
			labelWidth: 60,
			labelStyle:"overflow:hidden;",
			labelAlign:'right',
			anchor:'100%'
		});
		var northPanel=Ext.create('Ext.panel.Panel',{
			layout:'anchor',
			border:false,
			bodyBorder:false,
			region:'north',
			padding: '0 0 0 0',
			items:[containerTo,me.containerCC,me.containerBCC,me.txtSubject]
		});
		var bodyCfg={
			region:'center',
			margin:'0 0 0 0',
			cls:'rteField',
			border:false
			/*cls:'ckeField100Percent'*/
		};
		me.txtBody=CWHF.createRichTextEditorField('mailBody',bodyCfg,false,true);
		me.formPanel=Ext.create('Ext.form.Panel', {
			layout:'border',
			border    : false,
			margins: '0 0 0 0',
			bodyStyle: "padding: 5px;",
			items:[northPanel,me.txtBody]
		});
	},
	init:function(){
		var me=this;
		me.initView();
	},
	clear:function(){
		var me=this;
		me.txtBody.setValue('');
		me.txtSubject.setValue(null);
		me.txtTo.setValue(null);
		me.txtCC.setValue(null);
		me.txtBCC.setValue(null);
	},
	validate:function(){
		var me=this;
		return true;
	},
	sendEmail:function(){
		var me=this;
		CWHF.submitRTEditor(me.txtBody);
		if(!me.validate){
			return false;
		}
		me.formPanel.setLoading(com.trackplus.TrackplusConfig.getText("common.lbl.loading"));
		me.formPanel.getForm().submit({
			url:'sendEmail!sendEmail.action',
			success: function(form, action) {
				me.formPanel.setLoading(false);
				CWHF.showMsgInfo(getText('admin.server.sendEmail.lbl.sentSuccessful'));
			},
			failure: function(form, action) {
				me.formPanel.setLoading(false);
				var errorCode=action.result.errorCode;
				var errorMessage=action.result.errorMessage;
				switch(errorCode){
					case me.ERROR_NEED_PERSON:{
						me.txtTo.focus();
						break;
					}
					case me.ERROR_NEED_SUBJECT:{
						me.txtSubject.focus();
						break;
					}
				}
				if(errorMessage){
					CWHF.showMsgError(errorMessage);
				}
			}
		});
	},
	openLinkTo:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.to'));
		me.openPersonDialog(me.txtTo,title);
	},
	openLinkCC:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.cc'));
		me.openPersonDialog(me.txtCC,title);
	},
	openLinkBCC:function(){
		var me=this;
		var title=getText('item.action.sendItemEmail.choosePerson.title',getText('item.action.sendItemEmail.lbl.bcc'));
		me.openPersonDialog(me.txtBCC,title);
	},
	openPersonDialog:function(txtTo,title){
		var me=this;
		me.currentTxtTo=txtTo;
		var personPikerDialog=Ext.create('com.trackplus.util.PersonPickerDialog',{
			title:title,
			options:null,
			includeEmail:true,
			includeGroups:true,
			handler:me.addPersonHandler,
			scope:me
		});
		personPikerDialog.showDialog();
	},
	addPersonHandler:function(value,displayValue){
		var me=this;
		if(CWHF.isNull(displayValue)){
			return ;
		}
		var oldValue=me.currentTxtTo.getValue();
		var newValue="";
		if(oldValue&&oldValue!==''){
			newValue=oldValue+";"
		}
		newValue+=displayValue.join('; ');
		me.currentTxtTo.setValue(newValue);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.DatabaseBackup',{
	extend:'Ext.Base',
	constructor: function(config) {
	},
//	static
	ERROR_NEED_FILE_NAME:1,
	labelWidth:250,
	textFieldWidth:250+300,
	textFieldWidthShort:250+70,
	alignR:"right",
	FieldSetWidth:250+300+150,
	//dateTimeIsoFormat:'Y-m-d H:i:s',
//	end static
	btnStart:null,
	formPanel:null,
	backupDir:null,
	backupFieldSet:null,
	backupFieldSetConf:null,
	gridAvailableBackups:null,
	createToolbar:function(){
		var me=this;
		if(CWHF.isNull(me.btnStart)){
			me.btnStart=new Ext.Button({
				text:getText('admin.server.databaseBackup.button.Execute'),
				overflowText:getText('admin.server.databaseBackup.button.Execute'),
				tooltip:getText('admin.server.databaseBackup.button.Execute'),
				iconCls: 'backup',
				disabled:false,
				handler:function(){
					me.startBackup.call(me);
				}
			});
		}
		return [me.btnStart];
	},
	/**
	 * Gets a control by the path according to the "arguments" starting form the main tab panel
	 */
	getControl: function() {
		return CWHF.getControl.apply(this.formPanel, arguments);
	},
	getHelpWrapper: function() {
		return CWHF.getHelpWrapper.apply(this.formPanel, arguments);
	},
	getWrappedControl: function() {
		return CWHF.getWrappedControl.apply(this.formPanel, arguments);
	},
	/**
	 * Create the grid with available backups
	 */
	createGridAvailableBackups:function(){
		var store = Ext.create('Ext.data.Store', {
			autoLoad: false,
			fields: [{name:'name', type:'string'},
					{name:'systemVersion', type:'string'},
					{name:'dbVersion', type:'string'},
					{name:'dbType', type:'string'},
					{name:'valid', type:'bool'},
					{name:'length', type:'int'},
					{name:'lastModified', type:'date', dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat}],
					proxy: {
						type: 'ajax',
						url : 'databaseBackup!getAvailableBackups.action',
						reader: {
							type: 'json'
						}
					}
		});
		var gridAvBackups = Ext.create('Ext.grid.Panel', {
			store: store,
			bodyBorder:false,
			cls:'gridNoBorder',
			title:getText('admin.server.databaseBackup.lbl.availableBackups'),
			columns: [{text: getText('admin.server.databaseBackup.lbl.backupName'), width: 250, dataIndex: 'name', sortable: true},
				{text: getText('common.lbl.size'), width: 100, dataIndex: 'length', sortable: true,
					renderer:function(value){
						return Ext.util.Format.fileSize(value);
					}
				},
				{text: getText('common.lbl.date'), width: 125, dataIndex: 'lastModified', sortable: true,
					renderer:Ext.util.Format.dateRenderer(com.trackplus.TrackplusConfig.DateTimeFormat)
				},{text:getText('admin.server.config.systemVersion'),width: 115, dataIndex: 'systemVersion', sortable: true},
				{text:getText('admin.server.config.dbVersion'),width: 115, dataIndex: 'dbVersion', sortable: true},
				{text:getText('admin.server.databaseBackup.dbType'),width: 100, dataIndex: 'dbType', sortable: true}
			],
			margin:'0 0 0 0',
			region:'center',
			border:false,
			viewConfig: {
				stripeRows:true,
				getRowClass: function(record) {
					var cls="";
					if(record.data['valid']===false){
						cls="invalidBackupRow";
					}
					return cls;
				}
			}
		});
		return gridAvBackups;
	},
	createErrorBox:function() {
		var errorBox = Ext.create('Ext.form.Panel', {
			itemId: 'errorBox',
			bodyPadding: 10,
			margin: '0 0 15 0',
			cls: 'errBox',
			bodyCls: 'errBox',
			hidden: true
		});
		return errorBox;
	},
	/**
	 * Create the top field set for direct backup creation by user
	 */
	createBackupFieldSet:function(){
		var me=this;
		var txtName=CWHF.createTextField("admin.server.databaseBackup.lbl.backupName",
				"backupName", {itemId:'backupName', labelWidth:me.labelWidth});
		var chkSendNotifyEmail=CWHF.createCheckbox("admin.server.databaseBackup.lbl.sendNotifyEmail",
				"sendNotifyEmail", {labelWidth:me.labelWidth});
		var chkIncludeAttachments=CWHF.createCheckbox("admin.server.databaseBackup.lbl.includeAttachments",
				"includeAttachments", {labelWidth:me.labelWidth});
		var fieldSetBackup={
			xtype: 'fieldset',
			width: me.FieldSetWidth,
			title: getText('admin.server.databaseBackup.lbl.saveNow'),
			collapsible: false,
			defaultType: 'textfield',
			defaults: {anchor: '100%'},
			layout: 'anchor',
			items: [chkSendNotifyEmail,chkIncludeAttachments,txtName]
		};
		return fieldSetBackup;
	},
	/**
	 * Create the top field set for direct backup creation by user
	 */
	createBackupFieldSetConf:function(){
		var me=this;
		var autoBackup=CWHF.createCheckboxWithHelp('admin.server.config.isDatabaseBackupJobOn',
				'autoBackup',{itemId:'autoBackup'},{
						change:function(){
							me.enableAutoBackup.call(me);
					}
				}
		);
		var backupDir=CWHF.createTextField("admin.server.config.backupDir",
				"backupDir", {itemId:'backupDir', labelWidth:me.labelWidth, width:515});
		var backupOnDays=CWHF.createComboWithHelp('admin.server.databaseBackup.lbl.backupDays',
				'backupOnDays',{itemId:'backupOnDays', multiSelect :true},null);
		var noOfBackupsCmp=CWHF.createNumberFieldWithHelp('admin.server.databaseBackup.lbl.noOfBackups',
				'noOfBackups',0,1,99999,{width:me.labelWidth+30,hideTrigger:true,itemId:'noOfBackups'});
		var backupTime=CWHF.createTimeFieldWithHelp('admin.server.databaseBackup.lbl.backupTime',
				'backupTime', {itemId:"backupTime",altFormats:"H:i", allowBlank:false,increment:5});
		var chkIncludeAttachments=CWHF.createCheckbox("admin.server.databaseBackup.lbl.includeAttachments",
				"includeAttachmentsConf", {itemId:'includeAttachmentsConf', labelWidth:me.labelWidth});
			/*Ext.create('Ext.form.field.Checkbox',{
			fieldLabel:getText('admin.server.databaseBackup.lbl.includeAttachments'),
			checked:true,
			inputValue:'true',
			name: 'includeAttachmentsConf',
			itemId:'includeAttachmentsConf',
			labelStyle:{overflow:'hidden'},
			labelWidth:me.labelWidth,
			labelAlign:me.alignR
		});*/
		var saveBtn={xtype:'button',
				style:{ marginBottom: '5px', marginLeft: '5px'},
				enableToggle:false,
				id:'SaveBtn',
				width:null,
				text:getText('admin.server.databaseBackup.button.saveConfig'),
				handler:function(){
					me.saveConfiguration.call(me);
				}
		};
		var btnWrapper={
				xtype: 'panel',
				border:false,
				bodyBorder:false,
				margin: '15 0 10 0',
				layout: 'hbox',
				items: [{ xtype: 'label',
						  width:me.labelWidth,
						  text: ''
			        	},
			        saveBtn]
		};
		var fieldSetBackupConf={
			xtype: 'fieldset',
			itemId: 'fsauto',
			width: me.FieldSetWidth,
			title: getText('admin.server.databaseBackup.lbl.automatedBackupConf'),
			collapsible: true,
			defaultType: 'textfield',
			defaults: {anchor: '100%'},
			layout: 'anchor',
			collapsed: 'true',
			items: [autoBackup,
			        backupDir,
			        chkIncludeAttachments,
			        backupOnDays,
			        backupTime,
			        noOfBackupsCmp,
			        btnWrapper]
		};
		return fieldSetBackupConf;
	},
	/**
	 * Enable or disable input elements for incoming mail panel
	 */
	enableAutoBackup:function() {
		var me=this;
		// Get the main enable/disable check box
		autoBackup = this.getWrappedControl("fsauto", "autoBackup");
		var autoBackupChkd = autoBackup.getValue();
		// Get all components to disable or enable
		this.getControl("fsauto", "backupDir").setDisabled(!autoBackupChkd);
		this.getControl("fsauto", "includeAttachmentsConf").setDisabled(!autoBackupChkd);
		this.getHelpWrapper("fsauto", "backupOnDays").setDisabled(!autoBackupChkd);
		this.getHelpWrapper("fsauto", "backupTime").setDisabled(!autoBackupChkd);
		this.getHelpWrapper("fsauto", "noOfBackups").setDisabled(!autoBackupChkd);
	},
	/**
	 * Create the main component
	 *
	 */
	createMainComponent:function(){
		var me=this;
		me.gridAvailableBackups=me.createGridAvailableBackups();
		me.formPanel=Ext.create('Ext.form.Panel', {
			region:'north',
			layout:'anchor',
			url: 'databaseBackup!backup.action',
			border	: false,
			margins: '0 0 0 0',
			bodyStyle: "padding: 5px 5px 10px 5px;",
			fieldDefaults: {
				labelWidth: 270,
				labelAlign:me.alignR
			}
		});
		me.formPanel.add(me.createErrorBox());
		me.formPanel.add(me.createBackupFieldSet());
		me.formPanel.add(me.createBackupFieldSetConf());
		var panel=Ext.create('Ext.panel.Panel', {
			layout:'border',
			border	: false,
			bodyBorder:false,
			margins: '0 0 0 0',
			items:[me.formPanel,me.gridAvailableBackups]
		});
		me.mainPanel = panel;
		me.load();
		return panel;
	},
	/**
	 * load the data into the form
	 */
	load:function(){
		var me=this;
		me.formPanel.getForm().load({
			url : 'databaseBackup.action',
			success: function(form, action) {
				try{
					me.afterLoad.call(me,action.result.data);
					var ebox = me.formPanel.getComponent("errorBox");
					ebox.setVisible(false);
				}catch(ex){}
			},
			failure: function(form, action) {
				me.afterLoad.call(me,action.result.data);
				var ebox = me.formPanel.getComponent("errorBox");
				ebox.update(action.result.msg);
				ebox.setVisible(true);
				Ext.MessageBox.show({
					title: '',
					msg: getText('admin.server.databaseBackup.err.problemStarting'),
					buttons: Ext.MessageBox.OK,
					icon:  Ext.MessageBox.ERROR
				});
			}
		});
	},
	/**
	 * After the data has been delivered from the server...
	 * @param data
	 */
	afterLoad:function(data){
		var me=this;
		me.formPanel.setLoading(false);
		me.gridAvailableBackups.setTitle(getText('admin.server.databaseBackup.lbl.availableBackups')
				+ ' ' + data['backupDir']);
		me.enableAutoBackup();
		var bod = this.getWrappedControl("fsauto", "backupOnDays");
		bod.store.loadData(data['backupOnDaysList']);
		bod.setValue(data['backupOnDays']);
		me.gridAvailableBackups.store.loadData(data['availableBackups']);
	},
	/**
	 * Save the configuration
	 */
	saveConfiguration:function(data) {
		var me=this;
		if(!me.formPanel.getForm().isValid()){
			return false;
		}
		me.formPanel.setLoading(getText("common.lbl.loading"));
		me.formPanel.getForm().url='databaseBackup!saveConfig.action';
		me.formPanel.getForm().submit({
			scope: me,
			success: function(form, action) {
				me.afterLoad.call(me,action.result.data);
				var ebox = me.formPanel.getComponent("errorBox");
				ebox.setVisible(false);
				Ext.MessageBox.show({
					title: '',
					msg: getText('admin.server.databaseBackup.lbl.confSaved'),
					buttons: Ext.MessageBox.OK,
					icon:  Ext.MessageBox.INFO
				});
			},
			failure: function(form, action) {
				me.afterLoad.call(me,action.result.data);
				var ebox = me.formPanel.getComponent("errorBox");
				ebox.update(action.result.msg);
				ebox.setVisible(true);
				Ext.MessageBox.show({
					title: '',
					msg: getText('admin.server.databaseBackup.err.problemWithConf'),
					buttons: Ext.MessageBox.OK,
					icon:  Ext.MessageBox.ERROR
				});
			}
		});
	},
	/**
	 * Start the backup...
	 */
	startBackup:function(){
		var me=this;
		/*if(!me.formPanel.getForm().isValid()){
			return false;
		}*/
		me.formPanel.setLoading(getText("common.lbl.loading"));
		me.formPanel.getForm().submit({
			url:'databaseBackup!backup.action',
			clientValidation:false,
			success: function(form, action) {
				me.afterLoad.call(me,action.result.data);
				var ebox = me.formPanel.getComponent("errorBox");
				ebox.update(action.result.msg);
				ebox.setVisible(false);
				CWHF.showMsgInfo(getText('admin.server.databaseBackup.lbl.backupStarted'));
			},
			failure: function(form, action) {
				me.afterLoad.call(me,action.result.data);
				var ebox = me.formPanel.getComponent("errorBox");
				ebox.update(action.result.msg);
				ebox.setVisible(true);
				CWHF.showMsgInfo(getText('admin.server.databaseBackup.err.problemStarting'));
			}
		});
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.server.DatabaseRestore',{
	extend:'Ext.Base',
	constructor: function(config) {
	},
//static
ERROR_NEED_FILE_NAME:1,
//dateTimeIsoFormat:'Y-m-d H:i:s',
//end static
btnStart:null,
btnDelete:null,
formPanel:null,
chkIncludeAttachments:null,
txtAttachmentDir:null,
turl:null,
backupFile:null,
backupDir:null,
alignR:"right",
gridAvailableBackups:null,
createToolbar:function(){
	var me=this;
	if(CWHF.isNull(me.btnStart)){
		me.btnStart=new Ext.Button({
			text:getText('admin.server.databaseRestore.button.restoreExecute'),
			overflowText:getText('admin.server.databaseRestore.button.restoreExecute'),
			tooltip:getText('admin.server.databaseRestore.button.restoreExecute'),
			iconCls: 'restore',
			disabled:true,
			handler:function(){
				me.execute.call(me);
			}
		});
	}
	if(CWHF.isNull(me.btnDelete)){
		me.btnDelete=new Ext.Button({
			text:getText('admin.server.databaseRestore.button.delete'),
			overflowText:getText('admin.server.databaseRestore.button.delete'),
			tooltip:getText('admin.server.databaseRestore.button.delete'),
			iconCls: 'delete',
			disabled:true,
			handler:function(){
				me.exeDelete.call(me);
			}
		});
	}
	return [me.btnStart, me.btnDelete];
},
createMainComponent:function(){
	var me=this;
	var store = Ext.create('Ext.data.Store', {
		autoLoad: false,
		fields: [
			{name:'name', type:'string'},
			{name:'systemVersion', type:'string'},
			{name:'dbVersion', type:'string'},
			{name:'dbType', type:'string'},
			{name:'valid', type:'bool'},
			{name:'length', type:'int'},
			{name:'lastModified', type:'date', dateFormat: com.trackplus.TrackplusConfig.ISODateTimeFormat}
		],
		proxy: {
			type: 'ajax',
			url : 'databaseBackup!getAvailableBackups.action',
			reader: {
				type: 'json'
			}
		}
	});
	var sm = Ext.create('Ext.selection.CheckboxModel',{
		checkOnly:false,
		mode:'SINGLE',
		listeners:{
			beforeselect:function(selModel, record, index) {
				return record.get('valid')===true;
			},
			beforedeselect:function(selModel, record, index) {
				return record.get('valid')=== true;
			}
		}
	});
	me.gridAvailableBackups = Ext.create('Ext.grid.Panel', {
		store: store,
		bodyBorder:false,
		cls:'gridNoBorder',
		selModel: sm,
		title:getText('admin.server.databaseBackup.lbl.availableBackups'),
		columns: [
			{text: getText('common.lbl.name'), width: 250, dataIndex: 'name', sortable: true},
			{text: getText('common.lbl.size'), width: 100, dataIndex: 'length', sortable: true,
				renderer:function(value){
					return Ext.util.Format.fileSize(value);
				}
			},
			{text: getText('common.lbl.date'), width: 125, dataIndex: 'lastModified', sortable: true,
				renderer:Ext.util.Format.dateRenderer(com.trackplus.TrackplusConfig.DateTimeFormat)
			},{text:getText('admin.server.config.systemVersion'),width: 115, dataIndex: 'systemVersion', sortable: true},
			{text:getText('admin.server.config.dbVersion'),width: 115, dataIndex: 'dbVersion', sortable: true},
			{text:getText('admin.server.databaseBackup.dbType'),width: 100, dataIndex: 'dbType', sortable: true}
		],
		margin:'0 0 0 0',
		region:'center',
		border:false,
		viewConfig: {
			stripeRows:true,
			getRowClass: function(record) {
				var cls="";
				if(record.data['valid']===false){
					cls="invalidBackupRow";
				}
				return cls;
			}
		},
		listeners: {
			selectionChange: function() {
				me.selectedChanged.call(me);
			}
		}
	});
	var txtDriverClassName=CWHF.createTextField("admin.server.databaseRestore.lbl.driverClassName",
			"driverClassName", {width:675, allowBlank:false});
	var mainHint = Ext.create('Ext.Component', {
		cls: 'infoBox_bottomBorder',
		border:true,
		html:getText('admin.server.databaseRestore.lbl.mainHint'),
		margin:'0 0 5 0'
	});
	var txtUrl=CWHF.createTextField("admin.server.databaseRestore.lbl.url",
			"turl", {width:675, allowBlank:false});
	var txtUser=CWHF.createTextField("admin.server.databaseRestore.lbl.user",
			"user", {width:415, allowBlank:false});
	var txtPassword=CWHF.createTextField("admin.server.databaseRestore.lbl.password",
			"password", {inputType: 'password', width:415, allowBlank:false});
	var chkSendNotifyEmail=CWHF.createCheckbox("admin.server.databaseRestore.lbl.sendNotifyEmail",
			"sendNotifyEmail", {checked:true});
	me.chkIncludeAttachments=CWHF.createCheckbox("admin.server.databaseRestore.lbl.includeAttachments",
		"includeAttachments", {checked:false},
		{
			change: function(radioGroup, newValue, oldValue, options) {
				me.chkIncludeAttachmentsChange.call(me);
			}
		}
	);
	var testBtn={xtype:'button',
		style:{marginTop:'3px', marginBottom: '15px', marginLeft:'255px'},
		enableToggle:false,
		iconCls: 'check16',
		text:getText('admin.server.databaseRestore.button.testConnection'),
		handler:function(){
			me.testConnection.call(me);
		}
	};
	me.backupFile=Ext.create('Ext.form.field.Text',{
		name:'backupFile',
		hidden: true
	});
	me.backupDir=Ext.create('Ext.form.field.Text',{
		name:'backupDir',
		hidden: true
	});
	me.jaction=Ext.create('Ext.form.field.Text',{
		name:'action',
		hidden: true
	});
	me.txtAttachmentDir=CWHF.createTextField("admin.server.databaseRestore.lbl.attachmentRestoreDir",
			"attachmentDir", {width:675});
	me.formPanel=Ext.create('Ext.form.Panel', {
		layout:'anchor',
		region:'north',
		url: 'databaseRestore!restore.action',
		border	: false,
		margins: '0 0 5 0',
		//bodyStyle: "padding: 5px 5px 10px 5px;",
		fieldDefaults: {
			labelWidth: 270,
			labelAlign: me.alignR
		},
		items:[mainHint,txtDriverClassName, txtUrl,txtUser, txtPassword, testBtn, chkSendNotifyEmail,
		me.chkIncludeAttachments,me.txtAttachmentDir, me.backupFile]
	});
	var panel=Ext.create('Ext.panel.Panel', {
		layout:'border',
		border	: false,
		bodyBorder:false,
		margins: '0 0 0 0',
		items:[me.formPanel,me.gridAvailableBackups]
	});
	return panel;
},
reload:function(){
	var me=this;
	me.formPanel.getForm().load({
		url : 'databaseRestore.action',
		success: function(form, action) {
			try{
				var jsonData=Ext.decode(action.response.responseText).data;
				me.gridAvailableBackups.setTitle(getText('admin.server.databaseBackup.lbl.availableBackups')
						+ ' ' + jsonData.backupDir);
				me.afterLoad.call(me,action.result.data);
			}catch(ex){}
		},
		failure: function(form, action) {
			Ext.MessageBox.alert(this.failureTitle, action.response.responseText);
		}
	});
},
afterLoad:function(data){
	var me=this;
	me.gridAvailableBackups.store.loadData(data['availableBackups']);
},
execute:function(){
	var me=this;
	if(!me.formPanel.getForm().isValid()){
		return false;
	}
	me.formPanel.setLoading(getText("common.lbl.loading"));
	me.formPanel.getForm().submit({
		success: function(form, action) {
			me.formPanel.setLoading(false);
			CWHF.showMsgInfo(getText('admin.server.databaseRestore.lbl.started'));
		},
		failure: function(form, action) {
			me.formPanel.setLoading(false);
			var errorMessage=action.result.errorMessage;
			if(CWHF.isNull(errorMessage)||errorMessage===''){
				errorMessage="";
				if(action.result.errors){
					for(var x in action.result.errors){
						errorMessage+=action.result.errors[x]+"</br>";
					}
				}
			}
			CWHF.showMsgError(errorMessage);
		}
	});
},
exeDelete:function(){
	var me=this;
	if(!me.formPanel.getForm().isValid()){
		return false;
	}
	me.formPanel.setLoading(getText("common.lbl.loading"));
	me.formPanel.getForm().submit({
		url: 'databaseRestore!delete.action',
		success: function(form, action) {
			me.formPanel.setLoading(false);
			var availableBackups=Ext.decode(action.response.responseText).data;
			me.gridAvailableBackups.store.loadData(availableBackups);
		},
		failure: function(form, action) {
			me.formPanel.setLoading(false);
			var errorCode=action.result.errorCode;
			var errorMessage="";
			if(action.result.errors){
				for(var i=0;i<action.result.errors.length;i++){
					errorMessage+=action.result.errors[i].label+"</br>";
				}
			}
			CWHF.showMsgError(errorMessage);
		}
	});
},
chkIncludeAttachmentsChange:function(){
	var me=this;
	var check=me.chkIncludeAttachments.getRawValue();
	me.txtAttachmentDir.allowBlank = !check;
	me.txtAttachmentDir.validate();
},
selectedChanged:function() {
	var me = this;
	var record = me.gridAvailableBackups.selModel.getLastSelected();
	if (me.gridAvailableBackups.selModel.getCount() < 1) {
		me.btnStart.setDisabled(true);
		me.btnDelete.setDisabled(true);
	}
	else {
		me.backupFile.setValue(record.get('name'));
		me.btnStart.setDisabled(false);
		me.btnDelete.setDisabled(false);
	}
},
testConnection:function() {
	var me=this;
	me.formPanel.setLoading(getText("common.lbl.loading"));
	me.formPanel.getForm().submit({
		url: 'databaseRestore!testConnection.action',
		success: function(form, response){
			me.formPanel.setLoading(false);
			CWHF.showMsgInfo(getText('admin.server.databaseRestore.lbl.connectSucceeded'));
		},
		failure:function(form, response){
			me.formPanel.setLoading(false);
			CWHF.showMsgError(getText('admin.server.databaseRestore.err.connectFailed'));
		}
	});
}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.ICalendarURL',{
	extend:'Ext.Base',
	config:{
		data:{}
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	view:null,
	btnGenerate:null,
	btnDownload:null,
	tree:null,
	createView:function(){
		var me=this;
		var store = Ext.create('Ext.data.TreeStore', {
			proxy: {
				type: 'ajax',
				url: 'projectPicker.action',
				extraParams: {
					useChecked: true
				}
			}
		});
		me.tree = Ext.create('Ext.tree.Panel', {
			store: store,
			rootVisible: false,
			useArrows: true,
			margin:'10 10 10 10',
			frame: true,
			title: getText('admin.project.lbl.project'),
			width: 300,
			height: 200
		});
		var infoBox={
			xtype: 'component',
			cls: 'infoBox_bottomBorder',
			border:true,
			html: getText('admin.myprefs.iCalendar.defaultUrlMessage')
		};
		me.boxURL=Ext.create('Ext.Component',{
			border:true,
			html:'...',
			margin:'10 0 0 10',
			anchor:'100%',
			hidden:true
		});
		me.view=Ext.create('Ext.panel.Panel',{
			layout:'anchor',
			margin:'0 0 0 0',
			border:false,
			bodyBorder:false,
			items:[infoBox,me.tree,me.boxURL]
		});
		return me.view;
	},
	getToolbarButtons:function(){
		var me=this;
		if(CWHF.isNull(me.btnGenerate)){
			me.btnGenerate=Ext.create('Ext.button.Button',{
				overflowText:getText('common.btn.generateUrl'),
				tooltip:getText('common.btn.generateUrl'),
				text: getText('common.btn.generateUrl'),
				iconCls: 'save',
				disabled:false,
				handler:function(){
					me.generateURL.call(me);
				}
			});
			me.btnDownload=Ext.create('Ext.button.Button',{
				overflowText:getText('common.btn.download'),
				tooltip:getText('common.btn.download'),
				text: getText('common.btn.download'),
				iconCls: 'download',
				disabled:false,
				handler:function(){
					me.download();
				}
			});
		}
		return [me.btnGenerate];
	},
	generateURL:function(){
		var me=this;
		if(CWHF.isNull(me.tree)){
			return false;
		}
		var records = me.tree.getView().getChecked();
		if(CWHF.isNull(records)||records.length===0){
			Ext.MessageBox.show({
				title:getText('admin.myprefs.iCalendar.title'),
				msg: getText('common.err.required',getText('admin.project.lbl.projectForOp')),
				buttons: Ext.MessageBox.OK,
				icon: Ext.MessageBox.ERROR
			});
			return false;
		}
		var selectedProjects="";
		for(var i=0;i<records.length;i++){
			selectedProjects+=records[i].data.id;
			if(i<records.length-1){
				selectedProjects+='-';
			}
		}
		me.view.setLoading(true);
		Ext.Ajax.request({
			url: "iCalendar!generateURL.action",
			params:{
				selectedProjects:selectedProjects,
				allProjects:false
			},
			success: function(response){
				var jsonData=Ext.decode(response.responseText);
				me.boxURL.update(jsonData.data);
				me.boxURL.setVisible(true);
				me.view.setLoading(false);
			},
			failure:function(response){
				alert("failure");
				me.view.setLoading(false);
			}
		});
	},
	download:function(){
		alert("download");
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.NotifyConfig',{
	extend:'com.trackplus.admin.TreeBase',
	config: {
		//default project setting
		defaultSettings: false,
		//the exclusiveProject set only for automail in project settings
		exclusiveProjectID: null
	},
	baseAction: 'notify',
	entityID:'node',
	//actions
	actionSave: null,
	actionDelete: null,
	notifySettings: null,
	notifyTriggers: null,
	notifyFilters: null,
	AUTOMAIL_ASSIGNMENT: '1',
	AUTOMAIL_TRIGGER: '2',
	AUTOMAIL_FILTER: '3',
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
	},
	/**
	 * Gets the tree's fields: all fields for all possible types
	 */
	getTreeFields: function() {
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
				{ name : 'iconCls', mapping : 'iconCls', type: 'string'}];
	},
	/**
	 * Called from two places:
	 * 1. projectConfig.js: selecting the automail node (nodeId==='10')
	 * 2. from this class by selecting either an automail assignment/trigger/filter node
	 */
	loadDetailPanel: function(node, leaf, opts) {
		var nodeId = node.data['id'];
		if (nodeId==='10') {
			//called from projectConfig.js: selecting the automail node (nodeId==='10')
			return this.createCenterPanel();
		} else {
			switch (nodeId) {
			case this.AUTOMAIL_ASSIGNMENT:
				if (CWHF.isNull(this.notifySettings)) {
					this.notifySettings = Ext.create('com.trackplus.admin.NotifySettingsList',
						{defaultSettings: this.getDefaultSettings(), exclusiveProjectID:this.getExclusiveProjectID()});
				}
				this.loadGrid(this.notifySettings);
				break;
			case this.AUTOMAIL_TRIGGER:
				if (CWHF.isNull(this.notifyTriggers)) {
					this.notifyTriggers = Ext.create('com.trackplus.admin.NotifyTriggerList',
							{defaultSettings: this.getDefaultSettings()});
				}
				this.loadGrid(this.notifyTriggers);
				break;
			case this.AUTOMAIL_FILTER:
				if (CWHF.isNull(this.notifyFilters)) {
					this.notifyFilters = Ext.create('com.trackplus.admin.customize.category.CategoryConfig',
							{rootID:'notifyFilter', projectID:this.getExclusiveProjectID(), excludePrivate:this.getDefaultSettings()});
				}
				this.loadTreeWithGrid(this.notifyFilters);
				break;
			}
		}
	},
	loadGrid: function(gridConfig) {
		//not quite clear why this initGrid() must be called: gridConfig.getGrid() executes the initGrid() internally
		//if grid is not null, and grid is not null after the first call but somehow the this.centerPanel.removeAll()
		//leaves the grid in an inconsistent state that's why initGrid() should be called again although grid is not null.
		//Otherwise the further attempts to select the grid result in empty detail section even through the grid data is received
		/*gridConfig.initGrid();
		var grid=gridConfig.getGrid();
		gridConfig.reload();*/
		if (this.centerPanel) {
			this.mainPanel.remove(this.centerPanel, true);
		}
		this.centerPanel = gridConfig;
		this.mainPanel.add(this.centerPanel);
		//borderLayout.setActiveToolbarActionList(gridConfig.getToolbarActions());
	},
	loadTreeWithGrid: function(treeWithGridConfig) {
		if (this.centerPanel) {
			this.mainPanel.remove(this.centerPanel, true);
		}
		this.centerPanel = treeWithGridConfig.createCenterPanel();
		this.mainPanel.add(this.centerPanel);
		borderLayout.setActiveToolbarActionList(treeWithGridConfig.getToolbarActions());
	},
	/**
	 * Automatically expand the private repository
	 */
	onTreeNodeLoad: function(treeStore, node) {
	    if (node.isRoot()) {
	        this.tree.getSelectionModel().select(node.firstChild);
	        //node.firstChild.select();
	        //for not project specific categories expand the private repository (first child)
	        //treeStore.load({node:node.firstChild, callback:function(){node.firstChild.select()}});
	    }
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.NotifySettingsList", {
	extend:"com.trackplus.admin.GridBase",
	xtype: "notifySettingsList",
    controller: "notifySettingsList",
	config: {
		defaultSettings:false,
		//the exclusiveProject set only for automail in project settings
		exclusiveProjectID: null
	},
	columns: [{
			text: getText('common.lbl.name'),
			flex:1, dataIndex: 'projectLabel', sortable:true, renderer:"inheritedRenderer",
			filter: {
	            type: "string"
	        }
		}, {
			text: getText('admin.customize.automail.trigger.lblAlone'),
			flex:1, dataIndex: 'triggerLabel', sortable:true, renderer:"inheritedRenderer",
			filter: {
	            type: "string"
	        }
		}, {
			text: getText('admin.customize.automail.filter.lblAlone'),
			flex:1, dataIndex: 'filterLabel', sortable:true, renderer:"inheritedRenderer",
			filter: {
	            type: "string"
	        }
		}],
	initComponent : function() {
		this.fields = [{name: 'id',	type: 'int'},
						{name: 'project',	type: 'int'},
						{name: 'projectLabel',	type: 'string'},
						{name: 'triggerLabel',	type: 'string'},
						{name: 'filterLabel',	type: 'string'},
						{name: 'inherited',	type: 'boolean'}];
		this.storeUrl = "notifySettings!loadList.action";
		this.callParent();
	},
	getEntityLabel: function() {
		return getText('admin.customize.automail.assignments.lbl.assignment');
	},
	actionOverwrite:null,
	/**
	 * The iconCls for the add button, overwrites base class icon
	 */
	getAddIconCls: function() {
		return 'automailAdd';
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getEditIconCls: function() {
		return 'automailEdit';
	},
	/**
	 * The iconCls for the overwrite button
	 */
	getOverwriteIconCls: function() {
		return 'copy';
	},
	/**
	 * The key for overwrite button text
	 */
	getOverwriteButtonKey: function() {
		return 'common.btn.overwrite';
	},
	/**
	 * The title for "add" popup and "add" action tooltip
	 */
	getOverwriteTitleKey: function() {
		return 'common.lbl.overwrite';
	},
	/**
	 * Get extra parameters for grid load
	 */
	getLoadGridParams:function() {
		return {defaultSettings: this.getDefaultSettings(), exclusiveProjectID:this.getExclusiveProjectID()};
	},
	//actions
	initActions:function(){
		this.actionAdd = CWHF.createAction(this.getAddButtonKey(), this.getAddIconCls(), "onAdd", {tooltip:this.getActionTooltip(this.getAddTitleKey())});
		this.actionEdit = CWHF.createAction(this.getEditButtonKey(), this.getEditIconCls(), "onEdit", {tooltip:this.getActionTooltip(this.getEditTitleKey()), disabled:true});
		this.actions = [this.actionAdd, this.actionEdit];
		if (this.getDefaultSettings()===false) {
			this.actionOverwrite = CWHF.createAction(this.getOverwriteButtonKey(), this.getOverwriteIconCls(), "onOverwrite", {tooltip:this.getActionTooltip(this.getOverwriteTitleKey()), disabled:true});
			this.actions.push(this.actionOverwrite);
		}
		this.actionDelete = CWHF.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(), "onDelete", {tooltip:this.getActionTooltip(this.getDeleteTitleKey()), disabled:true});
		this.actions.push(this.actionDelete);
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	getGridContextMenuActions: function(selectedRecords, selectionIsSimple) {
		var actions = [];
		if (selectionIsSimple) {
			var inherited = selectedRecords.data['inherited'];
			if (inherited && this.actionOverwrite) {
				actions.push(this.actionOverwrite);
			} else {
				if (this.actionEdit) {
					actions.push(this.actionEdit);
				}
				if (this.actionDelete) {
					actions.push(this.actionDelete);
				}
			}
		}
		return actions;
	},
	onGridStoreLoad: function(store, records) {
		if (this.getExclusiveProjectID() && records && records.length>0) {
			this.actionAdd.setDisabled(true);
		} else {
			this.actionAdd.setDisabled(false);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.NotifySettingsListController', {
	extend: "Ext.app.ViewController",
	alias: "controller.notifySettingsList",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction: "notifySettings",
	entityID:'notifySettingsID',
	//editWidth:500,
	//editHeight:210,
	/**
	 * Parameters for adding a new entity
	 */
	getAddParams:function() {
		return {defaultSettings: this.getView().getDefaultSettings(), exclusiveProjectID: this.getView().getExclusiveProjectID()};
	},
	/**
	 * Parameters for editing an existing entity
	 */
	getEditParams:function(recordData) {
		var params = {defaultSettings: this.getView().getDefaultSettings(), exclusiveProjectID: this.getView().getExclusiveProjectID()};
		params[''+this.entityID]=recordData.id;
		return params;
	},
	/**
	 * Parameters for deleting an existing entity
	 */
	getDeleteParams:function(selectedRecord) {
		var params = new Object();
		params[""+this.entityID]=selectedRecord.data.id;
		params["defaultSettings"]=this.getView().getDefaultSettings();
		return params;
	},
	/**
	 * Handler for overwrite
	 */
	onOverwrite: function(){
		var recordData=this.getView().getSingleSelectedRecordData();
		if (recordData) {
			this.openEditEntity(this.getView().getActionTooltip(this.getView().getOverwriteTitleKey()), recordData, "overwrite");
		}
	},
	/**
	 * Parameters for saving an entity (extra parameters additionally to submit parameters)
	 */
	getSaveParams: function(recordData, type){
		var result=null;
		if (type==="add"){
			result = this.getAddParams();
		} else {
			if (type==="edit") {
				result = this.getEditParams(recordData);
			} else {
				if (type==="overwrite") {
					result = new Object();
					//the default (original) notifySettingsID is not needed
					//but the project should be explicitly set because it is disabled (not automatically submitted)
					result["project"]=recordData.project;
				}
			}
		}
		if (CWHF.isNull(result)) {
			//should not be null because dynamic parameters might be added right before submit
			//(in either submitHandler()  or preSubmitProcess() implementations)
			result = new Object();
		}
		return result;
	},
	/**
	 * Function to be called before submit to add dynamic parameters
	 * to existing submitUrlParams based on the panel's content
	 */
	preSubmitProcess: function(submitUrlParams, panel, submitAction) {
	 	//add parameters to submitUrlParams based on panel
		if (submitAction==="overwrite") {
			//if overwrite, the project combo is disabled and consequently not submitted
			//manually add project parameter
			var projectsList = panel.getComponent("projectsList");
			if (projectsList) {
				submitUrlParams["project"]=projectsList.getValue();
			}
		}
		return submitUrlParams;
	},
	/**
	 * Render the inherited rows as grey
	 */
	inheritedRenderer: function(value, metadata, record) {
		if (record.data.inherited) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	/**
	 * Enable change only if not inherited
	 */
	onSelectionChange: function(view, arrSelections) {
		if (CWHF.isNull(arrSelections) || arrSelections.length===0){
			this.getView().actionDelete.setDisabled(true);
			this.getView().actionEdit.setDisabled(true);
			if (this.getView().actionOverwrite) {
				this.getView().actionOverwrite.setDisabled(true);
			}
		} else {
			var selectedRecord = arrSelections[0];
			var inherited = selectedRecord.data["inherited"];
			this.getView().actionDelete.setDisabled(inherited);
			this.getView().actionEdit.setDisabled(inherited);
			if (this.getView().actionOverwrite) {
				this.getView().actionOverwrite.setDisabled(!inherited);
			}
		}
	},
	/**
	 *  Handler for double click
	 */
	onItemDblClick:function(view, record) {
		var inherited = record.data["inherited"];
		if (inherited) {
			this.onOverwrite.call(this);
		} else {
			this.onEdit.call(this);
		}
	},
	/**
	 * Populate the combos once data is loaded
	 */
	afterLoadForm: function(data, panel) {
	    //first set the filter, because by onProjectSelect the filterPicker's value will be sent
	    var filterPicker = panel.getComponent("filter");
	    filterPicker.updateMyOptions(data["filterTree"]);
	    filterPicker.setValue(data["filter"]);
	    var projectPicker = panel.getComponent("project");
	    projectPicker.updateMyOptions(data["projectTree"]);
	    projectPicker.setValue(data["project"]);
		var triggersList = panel.getComponent("trigger");
		triggersList.store.loadData(data["triggersList"]);
		triggersList.setValue(data["trigger"]);
	},
	/**
	 * Gets the form items
	 */
	getEditPanelItems: function(recordData, type) {
		var inherited = (type==="overwrite");
		var notifySettingsID = null;
		if (recordData) {
			notifySettingsID = recordData['id'];
		}
		var labelWidth = 150;
		var width = 400;
	    var filterPicker = CWHF.createSingleTreePicker("admin.customize.automail.filter.lblAlone",
	        "filter", [], null,
	        {itemId:"filter",
	    	 allowBlank:false,
	         labelWidth:labelWidth,
	         width:width,
	         margin:'0 0 5 0'
	        })
	    var projectPicker = CWHF.createSingleTreePicker("admin.project.lbl.project",
	        "project", [], null,
	        {	itemId:'project',
	    		allowBlank:false,
	            labelWidth: labelWidth,
	            width:width,
	            margin:'0 0 5 0'
	        }, {select:{fn: this.onProjectSelect, scope:this,
	            filterPicker: filterPicker}});
		return [projectPicker,
				CWHF.createCombo("admin.customize.automail.trigger.lblAlone",
						"trigger", {itemId:"trigger", width:width, labelWidth:labelWidth, allowBlank:false}),
				filterPicker];
	},
	/**
	 * Change event handler
	 * @param projectPicker
	 * @param selectedProjects
	 * @param options
	 */
	onProjectSelect: function(projectPicker, selectedProject, options) {
	    var filterPicker = options["filterPicker"];
	    Ext.Ajax.request({
	        url: this.baseAction + "!projectChange.action",
	        params:{defaultSettings: this.getView().getDefaultSettings(), project: projectPicker.getValue(), filter: filterPicker.getValue()},
	        scope:this,
	        success: function(response){
	            var responseJSON = Ext.decode(response.responseText);
	            filterPicker.updateMyOptions(responseJSON["filterTree"]);
	            filterPicker.setValue(responseJSON["filter"]);
	        },
	        failure: function(response){
	            com.trackplus.util.requestFailureHandler(response);
	        }
	    })
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.NotifyTriggerList", {
	extend: "com.trackplus.admin.GridBase",
	xtype: "notifyTriggerList",
    controller: "notifyTriggerList",
	config : {
	    defaultSettings : false
	},
	columns: [ {
	    text : getText('common.lbl.name'),
	    flex : 1,
	    dataIndex : 'label',
	    sortable : true,
		filter: {
            type: "string"
        }
	}, {
		text : getText('admin.customize.automail.trigger.lbl.type'),
	    width : 150,
	    dataIndex : 'typeLabel',
	    sortable : true
	}], 
	initComponent : function() {
		this.fields =[{
					    name : 'id',
					    type : 'int'
					}, {
					    name : 'label',
					    type : 'string'
					}, {
					    name : 'typeLabel',
					    type : 'string'
					}, {
					    name : 'own',
					    type : 'boolean'
					}];
		this.storeUrl = "notifyTrigger!loadList.action";
		this.callParent();
	},
	getEntityLabel : function() {
	    return getText('admin.customize.automail.trigger.lblOperation');
	},
	/**
	 * Get extra parameters for grid load
	 */
	getLoadGridParams : function() {
	    return {
		    defaultSettings : this.defaultSettings
	    };
	},
	/**
	 * If not own allow only copy
	 */
	getGridContextMenuActions : function(selectedRow) {
	    var canModify = selectedRow.data["own"];
	    if (canModify) {
		    return [this.actionEdit, this.actionCopy, this.actionDelete];
	    } else {
		    return [this.actionCopy];
	    }
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.NotifyTriggerListController', {
	extend: "Ext.app.ViewController",
	alias: "controller.notifyTriggerList",
	mixins: {
		baseController: "com.trackplus.admin.GridBaseController"
	},
	baseAction : "notifyTrigger",
	entityID : "notifyTriggerID",
	editWidth : 1000,
	editHeight : 600,
	peviousSelectedRows : [],
	/**
	 * Parameters for adding a new entity
	 */
	getAddParams : function() {
	    return {
		    defaultSettings : this.defaultSettings
	    };
	},
	/**
	 * Parameters for editing an existing entity
	 */
	getEditParams : function(recordData) {
	    var params = new Object();
	    params['' + this.entityID] = recordData.id;
	    params["defaultSettings"] = this.defaultSettings;
	    return params;
	},
	/**
	 * Parameters for deleting an existing entity
	 */
	getDeleteParams : function(selectedRecord) {
	    var params = new Object();
	    params['' + this.entityID] = selectedRecord.data.id;
	    params['defaultSettings'] = this.defaultSettings;
	    return params;
	},
	headerChkHandler : function(event, chkBox, options) {
	    var checked = chkBox.checked;
	    var numberOfRecords = this.formStore.getTotalCount();
	    var column = options.column;
	    for (i = 0; i < numberOfRecords; i++) {
		    var record = this.formStore.getAt(i);
		    // record.data[column] = checked;
		    record.set(column, checked);
	    }
	},
	getColumnByIndex : function(index) {
	    switch (index) {
	    case 1:
		    return "originator";
	    case 2:
		    return "manager";
	    case 3:
		    return "responsible";
	    case 4:
		    return "consulted";
	    case 5:
		    return "informed";
	    case 6:
		    return "observer";
	    }
	},
	createEditForm : function(recordData, type) {
	    var labelTextField = CWHF.createTextField('common.lbl.name', 'label', {
	        itemId : 'label',
	        allowBlank : false,
	        labelWidth : 100,
	        width : 500,
	        anchor : '100%',
	        margin : '10 10 10 10',
	        region : 'north'
	    });
	    // trigger fields
	    var triggerFields = [ {
	        name : 'id',
	        mapping : 'id',
	        type : 'string'
	    }, {
	        name : 'objectID',
	        mapping : 'objectID',
	        type : 'int'
	    }, {
	        name : 'actionTypeLabel',
	        mapping : 'actionTypeLabel',
	        type : 'string',
	        persist : false
	    }, {
	        name : 'fieldTypeLabel',
	        mapping : 'fieldTypeLabel',
	        type : 'string',
	        persist : false
	    }, {
	        name : 'fieldLabel',
	        mapping : 'fieldLabel',
	        type : 'string',
	        persist : false
	    }, {
	        name : 'originator',
	        mapping : 'originator',
	        type : 'boolean'
	    }, {
	        name : 'manager',
	        mapping : 'manager',
	        type : 'boolean'
	    }, {
	        name : 'responsible',
	        mapping : 'responsible',
	        type : 'boolean'
	    }, {
	        name : 'consulted',
	        mapping : 'consulted',
	        type : 'boolean'
	    }, {
	        name : 'informed',
	        mapping : 'informed',
	        type : 'boolean'
	    }, {
	        name : 'observer',
	        mapping : 'observer',
	        type : 'boolean'
	    } ];
	    // trigger columns
	    var triggerFieldColumns = [
	            {
	                text : getText('admin.customize.automail.trigger.lbl.actionType'),
	                menuDisabled : true,
	                dataIndex : 'actionTypeLabel',
	                flex : 1
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.fieldType'),
	                menuDisabled : true,
	                dataIndex : 'fieldTypeLabel',
	                flex : 1
	            },
	            {
	                text : getText('common.lbl.field'),
	                menuDisabled : true,
	                dataIndex : 'fieldLabel',
	                flex : 1
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.originator')
	                        + '&nbsp;<input type="checkbox" id="originator">',
	                menuDisabled : true,
	                dataIndex : 'originator',
	                flex : 1,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.manager')
	                        + '&nbsp;<input type="checkbox" id="manager">',
	                menuDisabled : true,
	                dataIndex : 'manager',
	                flex : 1,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.responsible')
	                        + '&nbsp;<input type="checkbox" id="responsible">',
	                menuDisabled : true,
	                dataIndex : 'responsible',
	                flex : 1,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.consultant')
	                        + '&nbsp;<input type="checkbox" id="consulted">',
	                menuDisabled : true,
	                dataIndex : 'consulted',
	                flex : 1,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.informant')
	                        + '&nbsp;<input type="checkbox" id="informed">',
	                menuDisabled : true,
	                dataIndex : 'informed',
	                flex : 1,
	                xtype : 'checkcolumn'
	            },
	            {
	                text : getText('admin.customize.automail.trigger.lbl.observer')
	                        + '&nbsp;<input type="checkbox" id="observer">',
	                menuDisabled : true,
	                dataIndex : 'observer',
	                flex : 1,
	                xtype : 'checkcolumn'
	            } ];
	    var isCopy = type === "copy";
	    var triggerID = recordData.id;
	    // detail store
	    this.formStore = new Ext.data.Store({
	        proxy : {
	            type : 'ajax',
	            api : {
	                read : 'notifyTrigger!edit.action',
	                update : 'notifyTrigger!save.action'
	            },
	            extraParams : {
	                // extraParams by read
	                notifyTriggerID : triggerID,
	                copy : isCopy
	            },
	            reader : {
	                type : 'json',
	                rootProperty : 'records',
	                keepRawData: true
	            },
	            writer : {
	                type : 'json',
	                allowSingle : false,
	                writeAllFields : true,
	                rootProperty : 'records',
	                encode : true
	            }
	        },
	        fields : triggerFields,
	        remoteSort : true,
	        idProperty : 'id',
	        successProperty : 'success',
	        autoSync : false,
	        listeners : {
	            load : {
	                scope : this,
	                fn : function(store, records) {
		                var rawData = store.getProxy().getReader().rawData;
		                labelTextField.setValue(rawData.label);
		                labelTextField.setDisabled(rawData.disabled);
		                // this.formEdit.updateLayout();
		                var toolbar = this.win.getDockedItems('toolbar[dock="bottom"]');
		                // the first one is the save button
		                toolbar[0].getComponent(0).setDisabled(rawData.disabled);
		                for (var i = 1; i <= 6; i++) {
			                var column = this.getColumnByIndex(i);
			                var checkBox = document.getElementById(column);// Ext.get(column);
			                checkBox.checked = rawData[column];
		                }
	                }
	            },
	            beforesync : {
	                scope : this,
	                fn : function() {
		                // Grid data is changed.
		                // Label might be changed or not, anyway send it to the
						// server
		                this.formStore.getProxy().extraParams = {
		                    // extraParams by update
		                    notifyTriggerID : triggerID,
		                    copy : isCopy,
		                    label : labelTextField.getValue(),
		                    defaultSettings : this.defaultSettings
		                };
	                }
	            },
	            datachanged : {
	                scope : this,
	                fn : function(store, opts) {
		                // Grid data is changed
		                // Label might be changed or not: to be sure load the
						// store again
		                this.reload.call(this);
	                }
	            }
	        }
	    });
	    var triggerFieldsGrid = {
	        xtype : 'grid',
	        itemId : 'detailGrid',
	        columns : triggerFieldColumns,
	        sortableColumns : false,
	        draggable : false,
	        store : this.formStore,
	        border : false,
	        bodyBorder : false,
	        loadMask : true,
	        region : 'center',
	        selModel : this.createSelModel(),
	        style : {
		        borderTop : '1px solid #D0D0D0'
	        },
	        viewConfig : {
		        forceFit : true,
		        stripeRows : true,
	        },
	        listeners : {
	            afterrender : {
	                fn : function() {
		                for (i = 1; i <= 6; i++) {
			                var column = this.getColumnByIndex(i);
			                var checkBox = Ext.get(column);
			                checkBox.addListener('click', this.headerChkHandler, this, {
				                column : column
			                });
		                }
	                },
	                scope : this
	            },
	            /*
				 * var columns = _grid.getColumnModel().config; var view =
				 * _grid.getView(); var columnIndex = 0; Ext.each(columns,
				 * function(column){ var headerHtml = '<div class="x-grid" +
				 * columnIndex + '-hd-inner x-grid' + columnIndex + '-hd-' +
				 * column.id + '" unselectable="on" style="">' + column.header; //
				 * To show mandatory column flag headerHtml += '&nbsp;<font
				 * color=red>*</font> //column id starting with "imageColumn"
				 * text. You can also use column.id === "imageColumn" or your
				 * column id if(column.id.match("^" + "imageColumn")) {
				 * headerHtml += '&nbsp;<img src="/images/headerImage.jpg"
				 * width=12 height=12>'; } //To add checkbox to specific column
				 * header //else if(column.id.match("^" + "checkboxColumn")){
				 * headerHtml += '&nbsp;<input type="checkbox"
				 * id="'+column.header+'chk"
				 * onclick="javascript:headerChkHandler()">'; //} headerHtml += '</div>';
				 * //replace the view headerCell innerHTML.
				 * view.getHeaderCell(columnIndex).innerHTML = headerHtml;
				 * columnIndex = columnIndex + 1; });
				 */
	            // This method handles row selecting, deselecting
	            selectionchange : {
	                fn : function(model, selected, eOpts) {
		                this.changeEntireRowSelection(this.peviousSelectedRows, false);
		                this.changeEntireRowSelection(selected, true);
		                this.peviousSelectedRows = selected;
	                },
	                scope : this
	            }
	        },
	        plugins : [ Ext.create('Ext.grid.plugin.CellEditing', {
		        clicksToEdit : 1
	        }) ]
	    };
	    return new Ext.panel.Panel({
	        border : false,
	        layout : 'border',
	        autoScroll : true,
	        margin : '0 0 0 0',
	        bodyStyle : {
		        padding : '0px'
	        },
	        items : [ labelTextField, triggerFieldsGrid ]
	    });
	},
	/**
	 * This method set each row each checkbox checked /true or false/ In case of
	 * setting false: if header checkbox checked then actual checkbox remains
	 * checked otherwise bill be unchecked
	 */
	changeEntireRowSelection : function(rows, checked) {
	    for (i = 0; i < rows.length; i++) {
		    var record = rows[i];
		    for (var j = 1; j < 7; j++) {
			    if (!checked) {
				    var column = this.getColumnByIndex(j);
				    var checkBox = document.getElementById(column);
				    if (!checkBox.checked) {
					    record.set(this.getColumnByIndex(j), checked);
				    }
			    } else {
				    record.set(this.getColumnByIndex(j), checked);
			    }
		    }
	    }
	},
	/**
	 * Not a form panel load
	 */
	loadHandler : function() {
	    this.formStore.load();
	},
	/**
	 * Not a form panel submit
	 */
	submitHandler : function(window, submitUrl, submitUrlParams) {
	    var labelTextField = this.formEdit.getComponent('label');
	    if (!labelTextField.validate()) {
		    return;
	    }
	    var records = this.formStore.getUpdatedRecords();
	    if (records  && records.length > 0) {
		    // at least a record was changed
		    // the label might be changed or not
		    this.formStore.sync();
	    } else {
		    if (labelTextField.isDirty()) {
			    // var params = this.getSaveParams(recordData, type);
			    // add the current label to submitUrlParams
			    submitUrlParams["label"] = labelTextField.getValue();
			    submitUrlParams["defaultSettings"] = this.defaultSettings;
			    // no record but the label was changed
			    Ext.Ajax.request({
			        url : 'notifyTrigger!save.action',
			        params : submitUrlParams,
			        scope : this,
			        success : function(response) {
				        var responseJson = Ext.decode(response.responseText);
				        this.reload.call(this, {
					        rowToSelect : responseJson.id
				        });
			        },
			        failure : function(result) {
				        Ext.MessageBox.alert(this.failureTitle, result.responseText);
			        }
			    });
		    }
	    }
	    this.win.close();
	},
	/**
	 * This method creates row selection model for grid.
	 */
	createSelModel : function() {
	    selModel = Ext.create('com.trackplus.itemNavigator.CheckboxModel', {
	        allowDeselect : true,
	        checkOnly : false,
	        mode : 'MULTI'
	    });
	    return selModel;
	},
	/**
	 * Enable change only if own trigger
	 */
	onSelectionChange : function(view, arrSelections) {
	    if (CWHF.isNull(arrSelections) || arrSelections.length === 0) {
		    this.getView().actionDelete.setDisabled(true);
		    this.getView().actionEdit.setDisabled(true);
		    this.getView().actionCopy.setDisabled(true);
	    } else {
		    var selectedRecord = arrSelections[0];
		    var own = selectedRecord.data['own'];
		    this.getView().actionDelete.setDisabled(!own);
		    this.getView().actionEdit.setDisabled(!own);
		    this.getView().actionCopy.setDisabled(!own);
	    }
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.treeConfig.TreeConfig',{
	//inherits from TreeBase (neither TreeDetail nor TreeWithGrid)
	//because it contains common functionality for
	//fieldConfig (TreeDetail) and screenConfig (a kind if TreeWithGrid)
	extend:'com.trackplus.admin.TreeBase',
	config: {
		rootID:'_',
		fromProjectConfig: false,
		projectOrProjectTypeID: null
	},
	folderAction: "treeConfig",
	leafDetailByFormLoad: true,
	entityID:'node',
	//common actions for fieldConfig and screenConfig
	actionOverwrite: null,
	actionReset: null,
	actionReload: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	/**
	 * Get the detail part after selecting a tree node
	 * The base class (TreeConfig) inherits from TreeBase (neither TreeDetail nor TreeWithGrid)
	 * which means that the getDetailPanel is not implemented in base classes
	 */
	loadDetailPanel: function(node, leaf) {
		if (leaf) {
			this.loadDetailPanelWithFormLoad(node, false);
		} else {
			this.loadSimpleDetailPanel(node, false);
		}
	},
	/**
	 * The url for getting the leaf detail: either this should be overridden or the leafDetailUrl should be specified in the config
	 */
	/*protected*/getLeafDetailUrl: function() {
		return this.getBaseAction() + '!load.action';
	},
	initActions: function() {
		this.actionOverwrite = this.createLocalizedAction(getText('common.btn.derive'),
				'copy', this.onOverwrite, this.getTitle('common.lbl.derive'), true);
		this.actionReset = this.createLocalizedAction(getText('common.btn.reset'),
				'reset', this.onReset, this.getTitle('common.lbl.reset'), true);
		this.actionReload = this.createLocalizedAction(getText('common.btn.reload'),
				'reload', this.onReload);
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields: function() {
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'inheritedConfig', mapping : 'inheritedConfig', type: 'boolean'},
				{ name : 'defaultConfig', mapping : 'defaultConfig', type: 'boolean'},
				{ name : 'childrenAreLeaf', mapping : 'childrenAreLeaf', type: 'boolean'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
				{ name : 'icon', mapping : 'icon', type: 'string'},
				{ name : 'iconCls', mapping : 'iconCls', type: 'string'},
				{ name : 'assignedID', mapping : 'assignedID', type: 'int'}];
	},
	getTreeExpandExtraParams: function() {
		return {fromProjectConfig: this.getFromProjectConfig(),
			projectOrProjectTypeID: this.getProjectOrProjectTypeID()};
	},
	/**
	 * Refresh after a successful save
	 */
	/*protected abstract*/refreshAfterSaveSuccess: function(result) {
	},
	/**
	 * The validate method called before submit
	 * Implement if the validation is not set directly at the form items (but verified later)
	 * panel: the form panel whose controls should or shouldn't be validated
	 * enableValidation: whether the validation should really occur
	 * 	true: before save
	 * 	false: submit needed to refresh only a part of the detail (like change field type specific part after field type change)
	 * 	The validation occurs automatically before every submit.
	 * 	If the form control validations are set then the validation might
	 * 	fail even if for a certain submit no validation is needed.
	 * 	Because in this case the "automatic" validation should succeed in order to make the submit possible
	 * 	we can't set validation directly on form controls, but this validate method will be called with the corresponding validateNeeded
	 */
	/*protected*/prepareValidate: function(panel, enableValidation) {
	},
	/**
	 * The node parameter sent to server
	 *
	 */
	/*protected*/getNodeParam: function(extraConfig) {
		var saveParams = new Object();
		var recordData = this.getSingleSelectedRecordData(true);
		if (recordData) {
			var nodeId = this.getRecordID(recordData, {fromTree:true});
			if (nodeId) {
				saveParams['node'] = nodeId;
			}
		}
		return saveParams;
	},
	/**
	 * Overwrite a leaf node
	 */
	onOverwrite: function() {
		Ext.Ajax.request({
			url: this.getFolderAction() + '!overwrite.action',
			params: this.getNodeParam(),
			scope: this,
			success : function(response) {
				var result = Ext.decode(response.responseText);
				var treeStore = this.tree.getStore();
				var treeView = this.tree.getView();
				var nodeToReload=treeStore.getNodeById(result.node);
				if (nodeToReload) {
					//for actualizing toolbar buttons in
					//treeNodeSelect according to  inheritedConfig
					nodeToReload.data['inheritedConfig'] = result.inheritedConfig;
					nodeToReload.set('text', result.text);
					nodeToReload.commit();
					var index = treeView.indexOf(nodeToReload);
					treeView.refreshNode(index);
					//actualize the toolbar buttons
					//although a tree refresh is not needed
					this.treeNodeSelect(/*this.tree, [nodeToReload]*/null, nodeToReload);
				}
			},
			failure: function(response) {
				com.trackplus.util.requestFailureHandler(response, options);
			}
		});
	},
	/**
	 * Reset a leaf or a branch node
	 */
	onReset: function() {
		Ext.Ajax.request({
			url: this.getFolderAction() + '!reset.action',
			params: this.getNodeParam(),
			scope: this,
			success : function(response) {
				var result = Ext.decode(response.responseText);
				var treeView = this.tree.getView();
				var nodeToReload=this.tree.getStore().getNodeById(result.node);
				if (nodeToReload) {
					var refreshTree = result.refreshTree;
					var branchReset = result.branchReset;
					if (refreshTree || branchReset) {
						//screen assignment reset or field configuration reset for a branch node
						var startFromNode;
						var refreshStartFromNode = false;
						var selectStartFromNode = false;
						if (refreshTree) {
							//refresh the entire tree (screen assignment)
							startFromNode = this.tree.getRootNode();
						} else {
							//refresh only a branch (field configuration)
							/*if (nodeToReload.isLeaf()) {
							 //refresh the leaf's parent
							 startFromNode = nodeToReload.parentNode;
							 } else {*/
							//refresh the resetted branch node itself
							startFromNode = nodeToReload;
							refreshStartFromNode = true;
							selectStartFromNode = true;
							//}
						}
						refreshStartFromNode=refreshStartFromNode||(result.node==='workflow_workflow');
						this.refreshTreeOpenBranches(startFromNode, refreshStartFromNode, selectStartFromNode, null, result.node,
								result.issueType, result.projectType, result.project);
						//this.treeNodeSelect(this.tree, [startFromNode]);
					} else {
						//actualize the node directly in the tree without branch reload
						//(by a field configuration leaf reset)
						nodeToReload.data['inheritedConfig'] = true;
						nodeToReload.set('text', result.text);
						nodeToReload.commit();
						var index = treeView.indexOf(nodeToReload);
						treeView.refreshNode(index);
						//actualize the toolbar buttons according to  inheritedConfig
						this.treeNodeSelect(/*this.tree, [nodeToReload]*/null, nodeToReload);
					}
				}
			},
			failure: function(response, options) {
				com.trackplus.util.requestFailureHandler(response, options);
			}
		});
	},
	/**
	 * Reload the selected branch: typically useful to refresh a branch caused by changes made by other users
	 */
	onReload: function() {
		var node = this.getLastSelectedTreeNode();
		var treeStore = this.tree.getStore();
		treeStore.load({node:node});
		/*var selectionModel = this.tree.getSelectionModel();
		var selectedArr = 	selectionModel.getSelection();
		if (selectedArr && selectedArr.length>0) {
			treeStore.load({node:selectedArr[0]});
		}*/
	},
	/**
	 * Reload the needed branches of the tree and select a node after reload
	 * startFromNode: the node to start the reload from
	 * refreshStartFromNode: whether to refresh also the startFromNode or start with their children
	 * selectStartFromNode: whether to select the startNode (true by reset)
	 * parentNode: the parent of the node to be selected. If this is specified
	 * the callback after load will be called to select the nodeIdToSelect.
	 * Should be specified only if another node should be specified as the actually selected
	 * (for reset not needed)
	 * nodeIdToSelect: which node to select after reload
	 */
	refreshTreeOpenBranches: function(startFromNode, refreshStartFromNode,
			selectStartFromNode, parentNode, nodeIdToSelect, issueType, projectType, project) {
		var treeStore = this.tree.getStore();
		var branchNodes;
		if (refreshStartFromNode) {
			branchNodes = [startFromNode];
		} else {
			branchNodes = startFromNode.childNodes;
		}
		Ext.each(branchNodes, function(branchNode, index) {
			var nodeID=branchNode.data['id'];
			if (branchNode.hasChildNodes()) {
				var childrenAreLeaf=branchNode.data['childrenAreLeaf'];
				if(branchNode===treeStore.getRootNode()){
					childrenAreLeaf=true;
				}
				//TODO  fix childrenAreLeaf into tree node model. There seems to be a problem with extJS,
				if(nodeID.indexOf('workflow_projectType_')===0||
					nodeID.indexOf('workflow_project_')===0){
					childrenAreLeaf=true;
				}
				if (childrenAreLeaf && branchNode.isLoaded() &&
						this.branchReloadNeeded(branchNode, issueType, projectType, project)) {
					//real reload is made only at the last branch level (higher level branches are not reloaded)
					var options = {node:branchNode};
					//call the selection callback only if the actual branchNode is the parentNode of the node to be selected
					if (selectStartFromNode || (parentNode && branchNode.data['id']===parentNode.data['id'])) {
						if (selectStartFromNode && CWHF.isNull(nodeIdToSelect)) {
							//if selectStartFromNode the nodeIdToSelect parameter
							//is not required because it should be same as startFromNode
							nodeIdToSelect = startFromNode;
						}
						options.callback = this.selectNode;
						options.scope = {tree:this.tree, nodeIDToSelect:nodeIdToSelect};
					}
					//branchNode.removeAll(false);
					//by loading a node the selection is lost which fires a selectionChange event: treeNode select is executed with empty selections
					//but it does not fire the select event!!!
					treeStore.load(options);
					//this.loadStore(treeStore, options);
				} else {
					this.refreshTreeOpenBranches.call(this, branchNode, false, false, parentNode, nodeIdToSelect, issueType, projectType, project);
				}
			}
		}, this);
	},
	/**
	 * Reduce the number of open branches to reload by filtering by domain parameters if they are specified
	 */
	branchReloadNeeded: function(branchNode, issueType, projectType, project) {
		var branchIssueType = branchNode.raw['issueType'];
		var branchProjectType = branchNode.raw['projectType'];
		var branchProject = branchNode.raw['project'];
		if (issueType && branchIssueType && issueType!==branchIssueType) {
			return false;
		} else {
			if (projectType && branchProjectType && projectType!==branchProjectType) {
				return false;
			} else {
				if (project && branchProject && project!==branchProject) {
					return false;
				}
			}
		}
		return true;
	}
	/**
	 * Select a node with id nodeId in tree.
	 * Scope is contains tree and nodeId
	 */
	/*selectNode: function() {
		if (this.nodeId && this.tree) {
			var selectionModel = this.tree.getSelectionModel();
			var nodeToSelect = this.tree.getStore().getNodeById(this.nodeId);
			if (nodeToSelect) {
				selectionModel.select(nodeToSelect);
			}
		}
	}*/
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.treeConfig.FieldConfig',{
	extend:'com.trackplus.admin.customize.treeConfig.TreeConfig',
	config: {
		rootID:'_'
	},
	baseAction: "fieldConfigItemDetail",
	confirmDeleteEntity:true,
	confirmDeleteNotEmpty: true,
	fieldSetWidth: 500,
	textFieldWidth: 350,
	labelWidth: 120,
	//extra actions for field configuration
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function(rootID) {
		return getText('admin.customize.field.config.lbl.description');
	},
	/**
	 * The localized leaf name
	 */
	getEntityLabel: function() {
		return getText('admin.customize.field.lbl.fieldConfig');
	},
	/**
	 * Add "Field" not "Field Config" (getEntityLabel() does not fit here)
	 */
	getAddLabel: function() {
		return getText(this.getAddTitleKey(), getText("admin.customize.field.lbl.field"));
	},
	/**
	 * Delete "Field" not "Field Config" (getEntityLabel() does not fit here)
	 */
	getDeleteLabel: function() {
		return getText(this.getDeleteTitleKey(), getText("admin.customize.field.lbl.field"));
	},
	initActions: function() {
		this.callParent();
		this.actionSave = this.createLocalizedAction(getText('common.btn.save'),
				'save', this.onSave, this.getTitle('common.lbl.save'), true);
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		var actions = [this.actionSave, this.actionOverwrite, this.actionReset];
		return actions;
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	getToolbarActionChangesForTreeNodeSelect: function(selectedNode) {
		if (selectedNode) {
			var leaf = selectedNode.isLeaf();
			var inheritedConfig=selectedNode.data['inheritedConfig'];
			var defaultConfig=selectedNode.data['defaultConfig'];
			this.actionSave.setDisabled(!leaf || inheritedConfig);
			this.actionOverwrite.setDisabled(!leaf || !inheritedConfig);
			this.actionReset.setDisabled(inheritedConfig || defaultConfig);
		} else {
			//add field
			this.actionSave.setDisabled(false);
			this.actionOverwrite.setDisabled(true);
			this.actionReset.setDisabled(true);
		}
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 *
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var actions = [];
		if (selectionIsSimple) {
			var inheritedConfig = selectedRecord.data['inheritedConfig'];
			var defaultConfig = selectedRecord.raw['defaultConfig'];
			var isLeaf = selectedRecord.isLeaf();
			if (inheritedConfig && !defaultConfig && isLeaf) {
				actions.push(this.actionOverwrite);
			}
			if (!inheritedConfig && !defaultConfig) {
				actions.push(this.actionReset);
			}
			if (!isLeaf) {
				actions.push(this.actionReload);
			}
		}
		return actions;
	},
	/**
	 * Gets the folder details
	 */
	getFolderDetailItems: function(node, add, responseJson) {
		return this.getInfoBoxItems(responseJson.info);
	},
	/**
	 * Gets the leaf details
	 */
	getLeafDetailItems: function(node, add) {
		return [{
				xtype:'hidden',
				name: 'add',
				value: add
			},{
				xtype: 'fieldset',
				title: getText('admin.customize.field.config.detail.lbl.fieldConfig'),
				itemId:"fieldFieldset",
				defaultType : 'textfield',
				style:{
					marginTop: '6px'
				},
				defaults : {
					labelStyle:'overflow: hidden;',
					msgTarget : 'side',
					anchor : '-20',
					width: this.textFieldWidth
				},
				width: this.fieldSetWidth,
				items: this.getFieldItems()
			}, {
				xtype: 'fieldset',
				title: getText('admin.customize.field.config.detail.lbl.generalConfig'),
				itemId:"fieldConfigFieldset",
				defaultType : 'textfield',
				// margin:'0 0 0 5',
				defaults : {
					labelStyle:'overflow: hidden;',
					msgTarget : 'side',
					anchor : '-20',
					width: this.textFieldWidth
				},
				width: this.fieldSetWidth,
				items: this.getFieldConfigItems()
			}
		];
	},
	/**
	 * Get field details
	 */
	getFieldItems: function() {
		return [CWHF.createTextField("common.lbl.name", "name",
					{itemId: "name", labelWidth:this.labelWidth,
					width:this.textFieldWidth, allowBlank : false,
					stripCharsRe : /\s|:|\<|\>|\/|\.|\(|\)|\'|\"|\,/}),
				CWHF.createCombo("admin.customize.field.lbl.fieldType", "fieldType",
					{itemId: "fieldType", labelWidth:this.labelWidth, hidden: true, idType: "string"},
					{select: {fn:this.selectFieldType, scope:this}}, "fieldType"),
				CWHF.createCheckbox("admin.customize.field.lbl.filterField", "filterField",
					{itemId: "filterField", labelWidth:this.labelWidth, hidden: true}),
				CWHF.createCheckbox("admin.customize.field.lbl.deprecated", "deprecated",
					{itemId: "deprecated", labelWidth:this.labelWidth, hidden: true}),
				CWHF.createTextAreaField("common.lbl.description", "description",
					{itemId: "description", labelWidth:this.labelWidth, width:450})];
	},
	/**
	 * Get field config details
	 */
	getFieldConfigItems: function() {
		return [CWHF.createTextField("common.lbl.label", "label",
				{itemId: "label", labelWidth:this.labelWidth,
					width:this.textFieldWidth, allowBlank : false}),
				CWHF.createTextField("common.lbl.tooltip", "tooltip",
					{itemId: "tooltip", labelWidth:this.labelWidth,
					width:this.textFieldWidth}),
				CWHF.createCheckbox("admin.customize.field.config.detail.lbl.required", "required",
					{itemId: "required", labelWidth:this.labelWidth/*, hidden: true*/}),
				CWHF.createCheckbox("admin.customize.field.config.detail.lbl.history", "history",
					{itemId: "history", labelWidth:this.labelWidth/*, hidden: true*/})];
	},
	/**
	 * Post process for leaf load
	 */
	getEditLeafPostDataProcess: function(recordData, add) {
		return this.fieldPostDataProcess;
	},
	/**
	 * Post process for folder load (only for add)
	 */
	getEditFolderPostDataProcess: function(recordData, add) {
		if (add) {
			//add from a non leaf node: same as add to leaf node or add when no node is selected
			return this.fieldPostDataProcess;
		} else {
			//no post process needed for folder selections
			return null;
		}
	},
	/**
	 * Method to process the data to be loaded arrived from the server by editing the leaf
	 */
	fieldPostDataProcess: function(data, panel) {
		var fieldFieldset = panel.getComponent("fieldFieldset");
		var fieldConfigFieldset = panel.getComponent("fieldConfigFieldset");
		var fieldAttributesDisabled = data.fieldAttributesDisabled;
		fieldFieldset.getComponent('name').setDisabled(fieldAttributesDisabled);
		var inheritedConfig = data.inheritedConfig;
		var customField = data.customField;
		var fieldTypeCombo = fieldFieldset.getComponent('fieldType');
		if (customField) {
			fieldTypeCombo.setVisible(true);
			fieldTypeCombo.store.loadData(data.fieldTypesList);
			fieldTypeCombo.setValue(data.fieldType);
			fieldTypeCombo.setDisabled(data.fieldTypeDisabled || fieldAttributesDisabled);
		}
		//if (data.renderDeprecated) {
			fieldFieldset.getComponent('deprecated').setVisible(data.renderDeprecated);
			fieldFieldset.getComponent('deprecated').setDisabled(fieldAttributesDisabled);
		//}
		//if (data.renderFilterField) {
			fieldFieldset.getComponent('filterField').setVisible(data.renderFilterField);
			fieldFieldset.getComponent('filterField').setDisabled(fieldAttributesDisabled);
		//}
		fieldFieldset.getComponent('description').setDisabled(fieldAttributesDisabled);
		fieldConfigFieldset.getComponent('label').setDisabled(inheritedConfig);
		fieldConfigFieldset.getComponent('tooltip').setDisabled(inheritedConfig);
		//if (data.renderRequired) {
			//fieldConfigFieldset.getComponent('required').setVisible(data.renderRequired);
			fieldConfigFieldset.getComponent('required').setDisabled(inheritedConfig || !data.renderRequired);
		//}
		//if (data.renderHistory) {
			//fieldConfigFieldset.getComponent('history').setVisible(data.renderHistory);
			fieldConfigFieldset.getComponent('history').setDisabled(inheritedConfig || !data.renderHistory);
		//}
		var specificItem = panel.getComponent("specificItem");
		if (specificItem) {
			//the value will not be removed from Ext.form.Basic only from the UI
			//workaround: set the fields to disabled to not to be submitted then remove the component
			//it seems to be enough to disable the panel not necessarily the components one by one
			specificItem.setDisabled(true);
			panel.remove(specificItem);
		}
		var specificFieldConfigClass = data['specificFieldConfigClass'];
		if (specificFieldConfigClass && specificFieldConfigClass!=="") {
			this.addSpecificConfig(panel, specificFieldConfigClass, this.fieldSetWidth);
			var specificItem = panel.getComponent("specificItem");
			if (specificItem) {
				//specificItem.setWidth(this.fieldSetWidth);
				data['node'] = this.selectedNodeID;
				data['labelWidth'] = this.labelWidth;
				specificItem.onDataReady(data);
			}
		}
	},
	/**
	 * Add the field type specific configuration
	 */
	addSpecificConfig: function(panel, specificFieldConfigClass, width) {
		if (specificFieldConfigClass) {
			var specificItem = Ext.create(specificFieldConfigClass,{
				// margin:'0 0 0 5',
				width: width
			});
			specificItem.setTitle(getText('admin.customize.field.config.detail.lbl.specificConfig'));
			if (specificItem) {
				panel.add(specificItem);
				panel.updateLayout();
			}
		}
	},
	/**
	 * Prepare the form for adding a new field
	 */
	onAddLeaf: function() {
		var node = this.getSingleSelectedRecord(true);
		this.loadDetailPanelWithFormLoad(node, true);
		this.actionSave.setDisabled(false);
	},
	/**
	 * Save the detail part
	 * The 'add' parameter is added as hidden field to the corresponding form detail items
	 * Alternatively this should be included as extra parameter here if 'add' were declared
	 * as class level variable set in onAdd action and reset on treeNode select
	 */
	onSave: function(extraConfig) {
		this.prepareValidate(this.centerPanel, true);
		this.centerPanel.getForm().submit({
			url: this.getBaseAction() + '!save.action',
			params: this.getNodeParam(extraConfig),
			scope: this,
			success: function(form, action) {
				var result = action.result;
				if (result.success) {
					this.refreshAfterSaveSuccess(result);
				} else {
					com.trackplus.util.showError(result);
				}
			},
			failure: function(form, action) {
				com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	},
	/**
	* By selecting a new field type the validation should be disabled
	* because a submit should be possible to the server even with incomplete data.
	* (even the incomplete data should not be lost)
	* By saving a field config the validation should be enabled
	**/
	prepareValidate: function(panel, validate) {
		var fieldFieldset = panel.getComponent("fieldFieldset");
		fieldFieldset.getComponent('name').allowBlank = !validate;
		var fieldConfigFieldset = panel.getComponent("fieldConfigFieldset");
		fieldConfigFieldset.getComponent('label').allowBlank = !validate;
	},
	/**
	 * By selecting another field type update the proxy urls
	 * for the grid store and reload the data into the store
	 */
	selectFieldType: function(comboBox, record, index ) {
		var onSuccessOrFail = function(form, action) {
			var result = action.result;
			if (result.success) {
				this.postProcessFieldConfig(this.centerPanel, action.result.data);
			} else {
				Ext.MessageBox.alert(this.failureTitle, action.response.responseText);
			}
		};
		//var panel = this.centerPanel.getComponent(0);
		//deactivate validation during the field type change
		this.prepareValidate(this.centerPanel, false);
		this.centerPanel.getForm().submit({
			fromCenterPanel:true,
			url : this.getBaseAction() + '!load.action',
			scope: this,
			params: this.getNodeParam(),
			success : function(form, action) {
				var result = action.result;
				if (result.success) {
					this.fieldPostDataProcess(action.result.data, this.centerPanel);
				} else {
					com.trackplus.util.showError(result);
				}
			},
			failure : function(form, action) {
					com.trackplus.util.submitFailureHandler(form, action);
				}
			});
	},
	/**
	 * Parameters for adding a new leaf
	 * The 'add' parameter is added as hidden fields to the corresponding form detail items
	 * (Alternatively this should be set here if 'add' is declared as class level variable,
	 * set in onAdd action and reset on treeNode select)
	 */
	getNodeParam: function(extraConfig) {
		var saveParams = this.callParent(arguments);
		var renameConfirmed = false;
		if (extraConfig) {
			renameConfirmed = extraConfig.renameConfirmed;
			if (renameConfirmed) {
				saveParams['renameConfirmed'] = renameConfirmed;
			}
		}
		return saveParams;
	},
	/**
	 * Rename a field
	 */
	renameField: function(btn) {
		if (btn === 'yes') {
			this.onSave.call(this, {renameConfirmed:true});
		}
	},
	/**
	 * Refresh after a successful save
	 */
	refreshAfterSaveSuccess: function(result) {
		errorMessage = result.errorMessage;
		if (errorMessage) {
			/*Ext.MessageBox.confirm(
				getText('admin.customize.field.config.detail.lbl.rename'),
				errorMessage, this.renameField, this)*/
			Ext.MessageBox.show({title:getText('admin.customize.field.config.detail.lbl.rename'),
					msg: errorMessage,
					buttons: Ext.Msg.YESNO,
					icon: Ext.Msg.WARNING,
					fn: this.renameField,
					scope:this});
		} else {
			var refreshTree = result.refreshTree;
			if (refreshTree) {
				//refresh the entire tree after adding a new field or changing the name of an existing field
				//if it was not added from a "Custom fields" node then it can be that the parents are not loaded
				//but after adding the new field should be selected. Consequently the parents should be loaded
				//because the refreshTreeOpenBranches() works only for already loaded branches
				this.expandAscendentPath.call(this, result.pathToExpand, result.node);
			} else {
				//save an existing field configuration: no tree refresh needed
				var nodeToReload=this.tree.getStore().getNodeById(result.node);
				if (nodeToReload) {
					this.treeNodeSelect(/*this.tree, [nodeToReload]*/null, nodeToReload);
				}
			}
		}
	},
	/**
	 * Load and expand a path (ascendent hierarchy from ancestors to leaf) in the tree
	 * Once the path is expanded the refreshTreeOpenBranches is called
	 */
	expandAscendentPath: function(pathToExpand, node, actualParent) {
		if (actualParent) {
			actualParent.expand(false);
		}
		if (pathToExpand && pathToExpand.length>0) {
			var parentNodeID = pathToExpand.shift();
			parentNode=this.tree.getStore().getNodeById(parentNodeID);
					/*if (CWHF.isNull(parentNode)) {
						//when called from on project/project type configuration the field_field can't be found
						//but still you should expand starting from the selected project/project type
						this.expandAscendentPath(pathToExpand, node, parentNode);
					} else {*/
						this.tree.getStore().load({node:parentNode, callback:function() {
								this.expandAscendentPath(pathToExpand, node, parentNode)
							},
							scope:this});
					//}
		} else {
			//refresh the entire tree
			this.refreshTreeOpenBranches(this.tree.getRootNode(), false, false, actualParent, node);
		}
	},
	/**
	 * The localized entity name to be deleted
	 * Should be implemented only if differs from entity name
	 * (for example in field configuration: entity label is "field configuration" but delete label is "field")
	 */
	getDeleteEntityLabel:function() {
		//because a field will be deleted, not a field config
		return getText('admin.customize.field.lbl.field');
	},
	/**
	 * Delete handler
	 */
	onDelete: function() {
		var selectedRecords = this.getSelectedRecords(true);
		if (selectedRecords) {
			var isLeaf = this.selectedIsLeaf(true);
			if (isLeaf) {
				var extraConfig = {fromTree:true, isLeaf:isLeaf};
				this.deleteHandler(selectedRecords, extraConfig);
			}
		}
	},
	/**
	 * Reload after delete
	 */
	reload: function(refreshParamsObject) {
		this.refreshTreeOpenBranches(refreshParamsObject.root, false, false, refreshParamsObject.parentNode, refreshParamsObject.nodeIdToSelect);
	},
	/**
	 * Gets reload parameters after delete
	 */
	getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		//select the parent node of the deleted node
		var nodeToSelect = selectedRecords.parentNode;
		var parentNode = null;
		//parent node of the node to be selected
		if (nodeToSelect) {
			parentNode = nodeToSelect.parentNode;
		}
		return {root:this.tree.getRootNode(), parentNode:nodeToSelect, nodeIdToSelect:nodeToSelect.data['id']}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Although it inherits from TreeConfig which is a treeBase,
 * some behavior is similar to treeWithGrid that's why some methods of
 * treeWithGrid are implemented again (alternatively use multiple inheritance?)
 *
 */
Ext.define('com.trackplus.admin.customize.treeConfig.AssignmentConfig',{
	extend:'com.trackplus.admin.customize.treeConfig.TreeConfig',
	config: {
		rootID:'_'
	},
	allowMultipleSelections:true,//for delete
	textFieldWidth: 350,
	labelWidth: 120,
	//actions
	actionApply: null,
	actionAdd: null,
	actionEdit: null,
	actionCopy: null,
	actionDelete: null,
	actionDesign: null,
	actionImport: null,
	actionExport: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	initCenterPanel: function(centerPanel) {
		this.initTree();
		this.showGrid();
	},
	getEntityConfigLabelSingular: function() {
		return "";
	},
	getEntityConfigLabelPlural: function() {
		return "";
	},
	/**
	 * Add "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getAddLabel: function() {
		return getText(this.getAddTitleKey(), this.getEntityConfigLabelSingular());
	},
	/**
	 * Edit "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getEditLabel: function() {
		return getText(this.getEditTitleKey(), this.getEntityConfigLabelSingular());
	},
	/**
	 * Copy "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getCopyLabel: function() {
		return getText(this.getCopyTitleKey(), this.getEntityConfigLabelSingular());
	},
	/**
	 * Delete "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getDeleteLabel: function() {
		return getText(this.getDeleteTitleKey(), this.getEntityConfigLabelSingular());
	},
	/**
	 * The a message patameterized with the deleteEntityLabel
	 */
	getDeleteEntityMessage: function(titleKey, extraConfig) {
		return getText(titleKey, this.getEntityConfigLabelSingular());
	},
	/**
	 * Design "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getDesignLabel: function() {
		return getText("common.lbl.configure", this.getEntityConfigLabelSingular());
	},
	/**
	 * Import "Forms" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getImportLabel: function() {
		return getText("common.lbl.import", this.getEntityConfigLabelPlural());
	},
	/**
	 * Export "Forms" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getExportLabel: function() {
		return getText("common.lbl.export", this.getEntityConfigLabelPlural());
	},
	isDisabledAddAction:function(){
		return false;
	},
	isDisabledImportAction:function(){
		return false;
	},
	initActions: function() {
		this.callParent();
		this.actionApply = this.createLocalizedAction(getText('common.btn.apply'),
				'apply', this.onApply, this.getTitle('common.lbl.apply'), true);
		this.actionAdd = this.createLocalizedAction(this.getAddLabel(), this.getAddIconCls(), this.onAdd, this.getAddLabel(),this.isDisabledAddAction());
		this.actionEdit = this.createLocalizedAction(getText(this.getEditButtonKey()), this.getEditIconCls(), this.onEdit, this.getEditLabel(), true);
		this.actionCopy = this.createLocalizedAction(getText(this.getCopyButtonKey()), this.getCopyIconCls(), this.onCopy, this.getCopyLabel(), true);
		this.actionDelete = this.createLocalizedAction(getText(this.getDeleteButtonKey()), this.getDeleteIconCls(), this.onDelete, this.getDeleteLabel(), true);
		this.actionDesign = this.createLocalizedAction(getText('common.btn.config'), 'btnConfig', this.onConfig, this.getDesignLabel(), true);
		this.actionImport = this.createLocalizedAction(getText('common.btn.import'), 'import', this.onImport, this.getImportLabel(),this.isDisabledImportAction());
		this.actionExport = this.createLocalizedAction(getText('common.btn.export'), 'export', this.onExport, this.getExportLabel(), true);
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		return [this.actionApply, this.actionReset, {xtype: 'tbspacer', width: 45, disabled:true}, this.actionAdd,
				this.actionEdit, this.actionCopy, this.actionDelete, this.actionDesign, this.actionImport, this.actionExport];
	},
	/**
	 * Same as it treeWithGrid
	 */
	getContextMenuActions: function(selectedRecords, selectionIsSimple, fromTree) {
		if (fromTree) {
			return this.getTreeContextMenuActions(selectedRecords, selectionIsSimple);
		} else {
			return this.getGridContextMenuActions(selectedRecords, selectionIsSimple);
		}
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	getGridContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectionIsSimple) {
			var selectedTreeNode = this.getSingleSelectedRecord(true);
			if (selectedTreeNode && selectedTreeNode.isLeaf()) {
				return [this.actionApply, this.actionEdit, this.actionCopy, this.actionDelete, this.actionDesign];
			} else {
				return [this.actionEdit, this.actionCopy, this.actionDelete, this.actionDesign];
			}
		} else {
			return [this.actionDelete];
		}
	},
	/**
	 * Paste a node in the tree after copy/cut
	 */
	saveAssignment: function(draggedObjectID, droppedNodeID) {
		Ext.Ajax.request({
			url: this.getBaseAction() + '!save.action',
			params: {
				assignedID: draggedObjectID,
				node: droppedNodeID
			},
			scope: this,
			disableCaching:true,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success === true) {
					this.refreshAfterSaveSuccess(responseJson);
				} else {
					com.trackplus.util.showError(responseJson);
				}
			},
			failure: function(result){
				Ext.MessageBox.alert(this.failureTitle, result.responseText)
			},
			method:"POST"
		});
	},
	treeNodeSelect: function(rowModel, node, index) {
		var record = this.grid.getStore().getById(node.data['assignedID']);
		if (record) {
			this.selectGridRow(record);
		}
		this.getToolbarActionChangesForTreeNodeSelect(node);
	},
	isAssignable: function(node) {
		return false;
	},
	dragAndDropOnTree:false,
	initTree:function(){
		var me=this;
		me.callParent(arguments);
		me.initMyListeners();
	},
	initMyListeners:function(){
		var me=this;
		me.tree.view.addListener('afterrender',me.onTreeViewAfterRenderer,me);
		me.tree.view.addListener('beforedrop',function(node,data, overModel, dropFunction,eOpts){
			/*var leaf =overModel.data["leaf"];
			if(!leaf){
				return false;
			}
			return true;*/
			return this.isAssignable(overModel);
		}, me);
		me.tree.getView().addListener('drop',function(node,data, overModel, dropFunction,eOpts){
			me.onDropTreeNode.call(me,node,data, overModel,dropFunction,eOpts);
			return true;
		});
	},
	onTreeViewAfterRenderer:function(){
		var me=this;
		me.dropZone = Ext.create('com.trackplus.util.TreeDropZone', {
			view: me.tree.view,
			ddGroup: this.getBaseAction(),
			isValidNode:function(node){
				/*var leaf =node.data["leaf"];
				if(!leaf){
					return false;
				}
				return true;*/
				return this.isAssignable(node);
			},
			isValidNodeScope: me
		});
	},
	onDropTreeNode: function(node, data, overModel) {
		var draggedNodeID=data.records[0].data['id'];
		var droppedNodeID=overModel.data['id'];
		if (draggedNodeID && droppedNodeID) {
			this.saveAssignment(draggedNodeID, droppedNodeID);
		}
		return true;
	},
	getGridFields: function() {
		return [
				{name: 'id',type:'int'},
				{name: 'name',type:'string'},
				{name: 'tagLabel',type:'string'},
				{name: 'description', type: 'string'},
				{name: 'owner', type: 'string'}];
	},
	getGridColumns: function() {
		return [{text: getText('common.lbl.name'), flex:1,
			dataIndex: 'name',id:'name',sortable:true,
			filter: {
	            type: "string"
	        }},
		{text: getText('common.lbl.tagLabel'), flex:1,
			dataIndex: 'tagLabel',id:'tagLabel',sortable:true,
			filter: {
	            type: "string"
	        }},
		{text: getText('common.lbl.description'),flex:1,
			dataIndex: 'description',id:'description',sortable:true,
			filter: {
	            type: "string"
	        }},
		{text: getText('admin.customize.form.config.owner'),flex:1,
			dataIndex: 'owner',id:'owner',sortable:true,
			filter: {
	            type: "string"
	        }}]
	},
	getSelectedObjectIDs: function() {
		var selectedObjectIDs = new Array();
		var selectedRecordsArr = this.getSelection();
		if (selectedRecordsArr) {
			Ext.Array.forEach(selectedRecordsArr, function(record, index, allItems)
					{selectedObjectIDs.push(record.data['id']);}, this);
		}
		return selectedObjectIDs.join(",");
	},
	/*protected abstract*/getGridListURL:function() {
		return "";
	},
	/*protected abstract*/getGridRowEditURL: function() {
		return "";
	},
	/*protected abstract*/getGridRowSaveURL: function() {
		return "";
	},
	/*protected abstract*/getConfigGridRowURL: function() {
		return "";
	},
	/*protected abstract*/getImportURL: function() {
		return "";
	},
	/*protected abstract*/getExportURL: function(selectedObjectIDs) {
		return "";
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*protected abstract getDeleteUrl: function(extraConfig){
		return "";
	},*/
	/**
	 * Shows the grid according to the selected node
	 */
	showGrid: function() {
		var store = Ext.create('Ext.data.Store', {
			proxy: {
				type: 'ajax',
				url: this.getGridListURL(),
				reader: {
					type: 'json'
				}
			},
			fields: this.getGridFields(),
			idProperty: 'id',
			autoLoad: true
		});
		var gridConfig = {
				xtype: 'grid',
				store: store,
				selModel: Ext.create('Ext.selection.CheckboxModel', {mode:"MULTI"}), //for screen export
				columns: this.getGridColumns(),
				plugins: ["gridfilters"],
				autoWidth: true,
				border: false,
				bodyBorder:false,
				cls:'gridNoBorder',
				stripeRows: true
			};
		gridConfig.viewConfig = {
			plugins: {
				ptype: 'gridviewdragdrop',
				ddGroup: this.getBaseAction(),
				enableDrag: true,
				enableDrop: false
			}/*,
			listeners: {
				drop: {scope:this, fn: function(node, data, dropRec, dropPosition) {
					this.onGridDrop(node, data, dropRec, dropPosition);
					}
				}
			}*/
		};
		var gridListeners = {selectionchange: {fn:this.onGridSelectionChange, scope:this}};
		gridListeners.itemcontextmenu = {fn:this.onGridRowCtxMenu, scope:this};
		gridListeners.itemdblclick = {fn:this.onEdit, scope:this};
		gridConfig.listeners = gridListeners;
		//create the grid
		this.grid = Ext.create('Ext.grid.Panel', gridConfig);
		this.centerPanel.add(this.grid);
	},
	/**
	 * Enable/disable actions based on the actual selection
	 */
	onGridSelectionChange: function (view, selections) {
		this.enableDisableToolbarButtons(view, selections);
		var selectedRow = null;
		if (selections && selections.length>0) {
			selectedRow = selections[0];
		}
		this.adjustToolbarButtonsTooltip(selectedRow, false);
	},
	/**
	 * Show the context menu in grid
	 */
	onGridRowCtxMenu: function(grid, record, item, index, evtObj) {
		this.onCtxMenu(false, record, evtObj);
		return false;
	},
	/**
	 * Enable/disable actions based on the actual selection
	 */
	enableDisableToolbarButtons: function (view, selections) {
		if (CWHF.isNull(selections) || selections.length===0) {
			this.actionEdit.setDisabled(true);
			this.actionApply.setDisabled(true);
			this.actionCopy.setDisabled(true);
			this.actionDelete.setDisabled(true);
			this.actionDesign.setDisabled(true);
			this.actionExport.setDisabled(true);
		} else {
			var selectedRecord = selections[0];
			var isLeaf = selectedRecord.data['leaf'];
			this.actionDelete.setDisabled(false);
			this.actionExport.setDisabled(false);
			if (selections.length===1) {
				var selectedTreeNode = this.getSingleSelectedRecord(true);
				if (selectedTreeNode && this.isAssignable(selectedTreeNode)/*selectedTreeNode.isLeaf()*/) {
					this.actionApply.setDisabled(false);
				}
				this.actionEdit.setDisabled(false);
				this.actionCopy.setDisabled(false);
				this.actionDesign.setDisabled(false);
			} else {
				this.actionApply.setDisabled(true);
				this.actionEdit.setDisabled(true);
				this.actionCopy.setDisabled(true);
				this.actionDesign.setDisabled(true);
			}
		}
	},
	/**
	 * Get the node to select after save after add operation
	 */
	getReloadParamsFromResult: function() {
		return [{parameterName:'rowToSelect', fieldNameFromResult:'id'}];
	},
	/**
	 * Save the detail part
	 * The 'add' parameter is added as hidden field to the corresponding form detail items
	 * Alternatively this should be included as extra parameter here if 'add' were declared
	 * as class level variable set in onAdd action and reset on treeNode select
	 */
	onApply: function() {
		var selectedTreeNode = this.getSingleSelectedRecord(true);
		var selectedGridRow = this.getSingleSelectedRecord(false);
		if (selectedTreeNode && selectedGridRow) {
			this.saveAssignment(selectedGridRow.data['id'], selectedTreeNode.data['id']);
		}
	},
	/**
	 * Handler for adding a new screen
	 */
	onAdd: function() {
		var title = this.getAddLabel();
		var reloadParamsFromResult = this.getReloadParamsFromResult();
		return this.onAddEdit(title, true,
				null, null, reloadParamsFromResult);
	},
	/**
	 * Handler for editing a screen
	 */
	onEdit: function() {
		var title = this.getEditLabel();
		var loadParams = this.getEditParams(false);
		var submitParams = this.getEditParams(false);
		var reloadParamsFromResult = this.getReloadParamsFromResult();
		return this.onAddEdit(title, false,
				loadParams, submitParams, reloadParamsFromResult);
	},
	/**
	 * Handler for copying a screen
	 */
	onCopy: function() {
		var title = this.getCopyLabel();
		var loadParams = this.getEditParams(true);
		var submitParams = this.getEditParams(true);
		var reloadParamsFromResult = this.getReloadParamsFromResult();
		return this.onAddEdit(title, false,
				loadParams, submitParams, reloadParamsFromResult);
	},
	getObjectIDName: function() {
		return "objectID";
	},
	/**
	 * Parameters for editing an existing entity
	 * recordData: the selected entity data
	 */
	getEditParams: function(copy) {
		var params = {copy:copy};
		var recordData = this.getSingleSelectedRecordData(false);
		if (recordData) {
			var objectID = recordData['id'];
			if (objectID) {
				params[this.getObjectIDName()] = objectID;
			}
		}
		return params;
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * isLeaf: whether to add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	onAddEdit: function(title, add, loadParams, submitParams,
			refreshParamsFromResult) {
		var loadUrl = this.getGridRowEditURL();
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = this.getGridRowSaveURL();
		var submit = {	submitUrl:submitUrl,
						submitUrlParams:submitParams,
						submitButtonText:getText('common.btn.save'),
						refreshAfterSubmitHandler:com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit,
						refreshParametersAfterSubmit:refreshParamsFromResult};
		var items = this.getPanelItems();
		var windowParameters = {title:title,
			width:this.editWidth,
			height:this.editHeight,
			load:load,
			submit:submit,
			items:items};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	reload: com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit,
	/**
	 * Helper for preparing the params
	 * get the ID based on the record and extra config
	 */
	getRecordID: function(recordData, extraConfig) {
		//id for both tree or grid/ used maily for delete
		return recordData['id'];
	},
	onDelete: function() {
		var selectedRecords = this.getSelectedRecords(false);
		if (selectedRecords) {
			this.deleteHandler(selectedRecords);
		}
	},
	/*getDeleteParams: function(selectedRecords, extraConfig) {
		return this.getEditParams(false);
	},*/
	onConfig:function(){
		var me=this;
		var recordData=me.getSingleSelectedRecordData();
		if(CWHF.isNull(recordData)){
			return false;
		}
		var id=recordData.id;
		//window.location.href='screenEdit.action?componentID='+id+'&backAction=cockpit.action';
		window.location.href=this.getConfigGridRowURL(id);
	},
	getPanelItems: function() {
		return [CWHF.createTextField('common.lbl.name','name', {anchor:'100%', allowBlank:false}),
				CWHF.createTextField('common.lbl.tagLabel','tagLabel', {anchor:'100%'}),
				CWHF.createTextAreaField('common.lbl.description','description', {anchor:'100%'})]
	},
	/*protected abstract*/getUploadFileLabel: function() {
		return null;
	},
	/**
	 * panel for importing the e-mail templates
	 */
	getImportPanel:function() {
		this.formPanel= new Ext.form.FormPanel({
			region:'center',
			border:false,
			bodyStyle: 'padding:5px',
			defaults: {
				labelStyle:'overflow: hidden;',
				margin:"5 5 0 0",
				msgTarget:	'side',
				anchor:	'-20'
			},
			method: 'POST',
			fileUpload: true,
			items: [CWHF.createCheckbox('common.lbl.overwriteExisting', 'overwriteExisting', {labelWidth:200}),
					CWHF.createFileField(this.getUploadFileLabel(), 'uploadFile',
					{itemId:"uploadFile", allowBlank:false, labelWidth:200})]
		});
		return this.formPanel;
	},
	onImport: function() {
		var submit = [{submitUrl:this.getImportURL(),
				submitButtonText:getText('common.btn.upload'),
				validateHandler: Upload.validateUpload,
				expectedFileType: /^.*\.(xml)$/,
				refreshAfterSubmitHandler:this.reload}];
		var title = getText('common.lbl.upload', this.getEntityConfigLabelPlural());
		var windowParameters = {title:title,
				width:550,
				height:150,
				submit:submit,
				formPanel: this.getImportPanel(),
				cancelButtonText: getText('common.btn.done')};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	onExport: function() {
		var selectedObjectIDs = this.getSelectedObjectIDs();
		attachmentURI=this.getExportURL(selectedObjectIDs);
		window.open(attachmentURI);
	},
	/**
	 * Refresh after a successful save
	 */
	refreshAfterSaveSuccess: function(result) {
		var refreshTree = result.refreshTree;
		var nodeIdToSelect = result.node;
		var node = this.tree.getStore().getNodeById(nodeIdToSelect);
		var parentNode = null;
		if (node) {
			parentNode = node.parentNode;
		}
		if (refreshTree) {
			this.refreshTreeOpenBranches(this.tree.getRootNode(), false, false, parentNode, nodeIdToSelect);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Although it inherits from TreeConfig which is a treeBase,
 * some behavior is similar to treeWithGrid that's why some methods of
 * treeWithGrid are implemented again (alternatively multiple inheritance?)
 *
 */
Ext.define('com.trackplus.admin.customize.treeConfig.ScreenConfig',{
	extend:'com.trackplus.admin.customize.treeConfig.AssignmentConfig',
	config: {
		rootID:'_'
	},
	baseAction: "screenConfigItemDetail",
	/**
	 * The width of the screen edit window
	 */
	editWidth:500,
	/**
	 * The height of the screen edit window
	 */
	editHeight:350,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	getToolbarActions: function() {
		var sysAdmin=com.trackplus.TrackplusConfig.user.sys;
		this.actionImport.setDisabled(!sysAdmin);
		var actions = [this.actionApply, this.actionReset, {xtype: 'tbspacer', width: 45, disabled:true},
					this.actionEdit, this.actionDesign, this.actionImport, this.actionExport];
		return actions;
	},
	enableDisableToolbarButtons: function (view, selections) {
		var sysAdmin=com.trackplus.TrackplusConfig.user.sys;
		if (CWHF.isNull(selections) || selections.length===0) {
			this.actionEdit.setDisabled(true);
			this.actionApply.setDisabled(true);
			this.actionDesign.setDisabled(true);
			this.actionExport.setDisabled(true);
		} else {
			var selectedRecord = selections[0];
			var isLeaf = selectedRecord.data['leaf'];
			this.actionExport.setDisabled(!sysAdmin);
			if (selections.length===1) {
				var selectedTreeNode = this.getSingleSelectedRecord(true);
				if (selectedTreeNode && this.isAssignable(selectedTreeNode)/*selectedTreeNode.isLeaf()*/) {
					this.actionApply.setDisabled(false);
				}
				this.actionEdit.setDisabled(!sysAdmin);
				this.actionDesign.setDisabled(!sysAdmin);
			} else {
				this.actionApply.setDisabled(true);
				this.actionEdit.setDisabled(true);
				this.actionDesign.setDisabled(true);
			}
		}
	},
	getGridContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var sysAdmin=com.trackplus.TrackplusConfig.user.sys;
		if (selectionIsSimple) {
			var selectedTreeNode = this.getSingleSelectedRecord(true);
			if (selectedTreeNode && selectedTreeNode.isLeaf()) {
				if (sysAdmin) {
					var actions = [this.actionApply, this.actionEdit, this.actionDesign];
					return actions;
				}else{
					return [this.actionApply];
				}
			} else {
				if(sysAdmin) {
					var actions =  [this.actionEdit, this.actionDesign];
					return actions;
				}
				return [];
			}
		} else {
			if (sysAdmin) {
				var actions = [];
				return actions;
			} else {
				return [];
			}
		}
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function(rootID) {
		return getText('admin.customize.form.config.lbl.description');
	},
	/**
	 * The localized leaf name
	 */
	getEntityLabel: function() {
		return getText('admin.customize.form.config.lbl.formAssignment');
	},
	getEntityConfigLabelSingular: function() {
		return getText("admin.customize.form.config.lbl.form");
	},
	getEntityConfigLabelPlural: function() {
		return getText("admin.customize.form.config.lbl.forms");
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	getToolbarActionChangesForTreeNodeSelect: function(node) {
		if (node ) {
			var inheritedConfig=node.data['inheritedConfig'];
			var defaultConfig=node.data['defaultConfig'];
			this.actionReset.setDisabled(inheritedConfig || defaultConfig);
			this.actionApply.setDisabled(!this.isAssignable(node));
		}
	},
	isAssignable: function(node) {
		return node.isLeaf();
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var actions = [];
		if (selectionIsSimple) {
			var inheritedConfig = selectedRecord.data['inheritedConfig'];
			var defaultConfig = selectedRecord.data['defaultConfig'];
			var leaf = selectedRecord.isLeaf();
			var selectedTreeNode = this.getSingleSelectedRecord(true);
			if (!inheritedConfig && !defaultConfig&&selectedTreeNode && this.isAssignable(selectedTreeNode)) {
				actions.push(this.actionReset);
			}
			if (!leaf) {
				actions.push(this.actionReload);
			}
		}
		return actions;
	},
	getGridListURL: function() {
		return "indexScreens.action";
	},
	getGridRowEditURL: function() {
		return "indexScreens!edit.action";
	},
	getGridRowSaveURL: function() {
		return "indexScreens!save.action";
	},
	getObjectIDName: function() {
		return "screenID";
	},
	getImportURL: function() {
		return this.getBaseAction() + "!importScreens.action";
	},
	getExportURL: function(selectedObjectIDs) {
		return this.getBaseAction() + "!export.action?selectedObjectIDs="+selectedObjectIDs;
	},
	/**
	 * The struts action for delete/replace
	 */
	/*protected*/getDeleteUrlBase: function(extraConfig) {
		return "indexScreens";
	},
	/**
	 * Url for deleting an entity
	 * extraConfig: for simple grid nothing, for tree with grid {fromTree:fromTree, isLeaf:isLeaf}
	 */
	/*getDeleteUrl: function(extraConfig){
		return 'indexScreens!delete.action';
	},*/
	getConfigGridRowURL: function(id) {
		return 'screenEdit.action?componentID='+id;
	},
	/*getDeleteParams: function(selectedRecords, extraConfig) {
		return this.getEditParams(false);
	},*/
	getDeleteParamName: function() {
	    return "selectedScreenIDs";
	},
	getPanelItems: function() {
		return  [CWHF.createTextField('common.lbl.name','name',
					{anchor:'100%', allowBlank:false, labelWidth:this.labelWidth, width:this.textFieldWidth}),
				CWHF.createTextField('common.lbl.tagLabel','tagLabel',
					{anchor:'100%', labelWidth:this.labelWidth, width:this.textFieldWidth,itemId:'tagLabel'}),
				CWHF.createTextAreaField('common.lbl.description','description',
					{anchor:'100%', labelWidth:this.labelWidth, width:this.textFieldWidth})];
	},
	getUploadFileLabel: function() {
		return "admin.customize.form.import.lbl.uploadFile";
	},
	onImport: function() {
		var submit = [{submitUrl:this.getBaseAction() + "!importScreens.action",
				submitButtonText:getText('common.btn.upload'),
				validateHandler: Upload.validateUpload,
				expectedFileType: /^.*\.(xml)$/,
				refreshAfterSubmitHandler:this.reload}];
		var title = getText('common.lbl.upload', this.getEntityConfigLabelPlural());
		var windowParameters = {title:title,
				width:550,
				height:150,
				submit:submit,
				formPanel: this.getImportPanel(),
				cancelButtonText: getText('common.btn.done')};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	onExport: function() {
		var attachmentURI=this.getBaseAction() + "!export.action?selectedScreenIDs="+this.getSelectedScreenIDs();
		window.open(attachmentURI);
	},
	getSelectedScreenIDs:function(){
		var selectedTemplateIDs = new Array();
		var selectedRecordsArr = this.getSelection();
		if (selectedRecordsArr) {
			Ext.Array.forEach(selectedRecordsArr, function(record, index, allItems)
			{selectedTemplateIDs.push(record.data['id']);}, this);
		}
		return selectedTemplateIDs.join(",");
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.customize.userLevel.UserLevel",{
	extend:"com.trackplus.admin.TreeWithGrid",
	config: {
		rootID : ""
	},
	confirmDeleteEntity:true,
	gridHasItemdblclick: false,
	baseAction:"userLevel",
	entityID:"node",
	editWidth:400,
	editHeight:200,
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function() {
		return getText("admin.customize.userLevel.lbl.description");
	},
	/**
	 * The localized entity name
	 */
	getEntityLabel: function(extraConfig) {
		return getText("admin.customize.userLevel.lbl.userLevel");
	},
	initActions: function() {
		this.actionAdd = this.createAction(this.getAddButtonKey(),
				this.getAddIconCls(), this.onAddLeaf, false, this.getAddTitleKey());
		this.actionEdit = this.createAction(this.getEditButtonKey(),
				this.getEditIconCls(), this.onEditTreeNode, true,
		            this.getEditTitleKey());
		this.actionDelete = this.createAction(this.getDeleteButtonKey(),
				this.getDeleteIconCls(), this.onDeleteFromTree, true, this.getDeleteTitleKey());
	    this.actions = [this.actionAdd, this.actionEdit, this.actionDelete];
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	    	return [this.actionAdd, this.actionEdit, this.actionDelete];
	    } else {
	    	return [];
	    }
	},
	onTreeNodeDblClick: function(view, record) {
		var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	        return this.callParent(arguments);
	    } else {
	        return [];
	    }
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields: function() {
		return [{name: 'id', type: 'string'},
				{name: 'text', type: 'string'},
				{name: 'iconCls', type: 'string'},
				{name: 'leaf', type: 'boolean'}];
	},
	/**
	 * Gets the grid store's fields for the selected node
	 */
	getGridFields: function(node) {
		return [{name: 'id',	type: 'string'},
				{name: 'path', type: 'string'},
				{name: 'name',	type: 'string'},
				{name: 'selected',	type: 'boolean'}];
	},
	/**
	 * Gets the grid columns for the selected node
	 */
	getGridColumns: function(node) {
		return [{text: getText('admin.customize.userLevel.lbl.path'),
					flex:1, dataIndex: 'path', sortable: true},
				{text: getText('common.lbl.name'),
						flex:1, dataIndex: 'name', sortable: true},
				{text: getText('admin.customize.userLevel.lbl.selected'),
						flex:1, dataIndex: 'selected', sortable: true,  xtype: "checkcolumn",
						listeners: {"checkchange": {fn: this.onCheckChange, scope:this},
									"beforecheckchange": {fn: this.onBeforeCheckChange, scope:this}}}];
	},
	onCheckChange: function(checkBox, rowIndex, checked, eOpts) {
		var record = this.grid.getStore().getAt(rowIndex);
		if (record) {
			var params = {actionID:record.data["id"], node:this.selectedNodeID, checked:checked};
			Ext.Ajax.request({
				url: this.getBaseAction() + "!changeAction.action",
				params: params,
				scope: this,
				success: function(response) {
					var result = Ext.decode(response.responseText);
					if (result.success) {
					} else {
						com.trackplus.util.showError(result);
					}
				},
				failure: function(response) {
					Ext.MessageBox.alert(this.failureTitle, response.responseText);
				}
			});
		}
	},
	onBeforeCheckChange: function(checkBox, rowIndex, checked, eOpts) {
		var sys = com.trackplus.TrackplusConfig.user.sys;
	    if (sys) {
	    	return true;
	    } else {
	    	return false;
	    }
	},
	getGridViewConfig: function() {
		return {
			forceFit: true,
			markDirty: false
		};
	},
	/**
	* Prepare adding/editing a report
	*/
	getEditLeafPanelItems: function() {
		return [CWHF.createTextField("common.lbl.name",
					"name", {labelWidth:100}),
				CWHF.createTextAreaField('common.lbl.description',
					"description", {labelWidth:100})];
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	getToolbarActionChangesForTreeNodeSelect: function(selectedNode) {
		this.actionEdit.setDisabled(false);
		this.actionDelete.setDisabled(false);
	},
	getAddReloadParamsAfterSave: function(addLeaf) {
		return {nodeIDToReload: this.rootID};
	},
	reload:com.trackplus.util.RefreshAfterSubmit.refreshSimpleTree,
	getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		return {reloadTree:true}
	},
	/**
	 * Get the node to select after save after add operation
	 */
	getAddSelectionAfterSaveFromResult: function() {
		//do not specify rowToSelect, do not select anything in the grid after add
		return [{parameterName:"node", fieldNameFromResult:"node"},
		        {parameterName:"reloadTree", fieldNameFromResult:"reloadTree"}];
	},
	/**
	 * Get the node to select after save after edit operation
	 */
	getEditReloadParamsAfterSaveFromResult: function(fromTree) {
		return [{parameterName:"node", fieldNameFromResult:"node"},
		        {parameterName:"reloadTree", fieldNameFromResult:"reloadTree"}];
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.list.ListConfig',
	            {
	                extend : 'com.trackplus.admin.TreeWithGrid',
	                config : {
	                    rootID : '_',
	                    fromProjectConfig : false
	                },
	                confirmDeleteEntity : true,
	                baseAction : "listOptions",
	                entityID : 'node',
	                dragAndDropOnTree : true,
	                customListWindowWidth : 500,
	                customListWindowHeight : 300,
	                labelWidth : 180,
	                listOptionWindowWidth : 450,
	                listOptionWindowHeight : 390,
	                replaceToolbarOnTreeNodeSelect : true,
	                // actions
	                actionChildIssueTypeAssignmentFromGrid : null,
	                actionChildIssueTypeAssignmentFromTree : null,
	                actionUploadFromGrid : null,
	                actionUploadFromTree : null,
	                actionDownloadFromGrid : null,
	                actionDownloadFromTree : null,
	                actionMoveUp : null,
	                actionMoveDown : null,
	                actionImport : null,
	                actionExportFromGrid : null,
	                actionExportFromTree : null,
	                localizedLabels : null,
	                uploadWindowWidth : 550,
	                uploadWindowHeight : 180,
	                constructor : function(config) {
	                    var config = config || {};
						this.initConfig(config);
	                    this.initBase();
	                },
	                isProjectSpecificRoot : function(recordData) {
	                    return this.getFromProjectConfig() && recordData['id'] === this.getRootID();
	                },
	                /**
					 * Initialization method
					 */
	                initBase: function() {
	                    this.initLocalizedLabels();
	                },
	                initLocalizedLabels : function() {
	                    Ext.Ajax.request({
	                        fromCenterPanel : true,
	                        url : 'listOptionsLocalize.action',
	                        scope : this,
	                        success : function(response) {
		                        var result = Ext.decode(response.responseText);
		                        this.localizedLabels = new Object();
		                        Ext.each(result.records, function(item) {
			                        this.localizedLabels[item.id] = item.label;
		                        }, this);
		                        this.initActions();
	                        },
	                        failure : function(response) {
		                        Ext.MessageBox.alert(this.failureTitle, response.responseText);
	                        }
	                    });
	                },
	                getEditWidth : function(recordData, isLeaf, add, fromTree, operation) {
	                    if (this.isListOperation(recordData, isLeaf, add, fromTree, operation)) {
		                    return this.customListWindowWidth;
	                    } else {
		                    return this.listOptionWindowWidth;
	                    }
	                },
	                getEditHeight : function(recordData, isLeaf, add, fromTree, operation) {
	                    if (this.isListOperation(recordData, isLeaf, add, fromTree, operation)) {
		                    return this.customListWindowHeight;
	                    } else {
		                    return this.listOptionWindowHeight;
	                    }
	                },
	                /**
					 * Whether the operation refers to a list or a list option
					 */
	                isListOperation : function(recordData, isLeaf, add, fromTree, operation) {
	                    if (this.isProjectSpecificRoot(recordData)) {
		                    return true;
	                    }
	                    // in the tree either the global lists node or a project
						// node is selected
	                    var listParentNode = this.selectedNode.data['nodeChildrenListForLabel'] === -20
	                            || this.selectedNode.data['nodeChildrenListForLabel'] === -21;
	                    if ((listParentNode && (operation === "add" || ((operation === "edit" || operation === "copy") && !fromTree)))
	                            || // add from tree or edit or copy from grid
	                            ((operation === "edit" || operation === "copy") && fromTree && (CWHF.isNull(recordData["optionID"]) || recordData["optionID"] === 0))) {// a
																																								// custom
																																								// list
																																								// selected:edit
																																								// or
																																								// copy
																																								// from
																																								// tree
		                    return true;
	                    } else {
		                    return false;
	                    }
	                },
	                /**
					 * The message to appear first time after selecting this
					 * menu entry Is should be shown by selecting the root but
					 * the root is typically not visible
					 */
	                getRootMessage : function(rootID) {
	                    return getText("admin.customize.list.lbl.description");
	                },
	                /**
					 * Get the title of the window in context
					 */
	                getEntityLabel : function(extraConfig) {
	                    var tooltipKey = extraConfig.tooltipKey; // see crudBase getTitle
	                    if (tooltipKey && ("common.lbl.upload" === tooltipKey || "common.lbl.download" === tooltipKey)) {
		                    return getText('admin.customize.list.lbl.iconOp');
	                    } else {
		                    var listForLabel = null;
		                    var fromTree = false;
		                    if (extraConfig ) {
			                    fromTree = extraConfig.fromTree;
		                    }
		                    var selectedRecord = this.getLastSelected(fromTree);
		                    if (selectedRecord ) {
			                    if (fromTree) {
				                    if (tooltipKey
				                            && (tooltipKey === this.actionAdd.initialConfig.tooltipKey || tooltipKey === this.actionImport.initialConfig.tooltipKey)) {
					                    // for add and childAssignment get the
										// label for children
					                    listForLabel = selectedRecord.data['nodeChildrenListForLabel'];
				                    } else {
					                    // for other operation get the label
										// corresponding to the node
					                    listForLabel = selectedRecord.data['nodeListForLabel'];
				                    }
			                    } else {
				                    listForLabel = selectedRecord.data['rowListForLabel'];
			                    }
		                    } else {
			                    // probably root in projectConfig
			                    listForLabel = -21;// project specific list
		                    }
		                    if (listForLabel ) {
			                    return this.localizedLabels[listForLabel];
		                    }
	                    }
	                    return "";
	                },
	                initActions : function() {
	                    this.actionAdd = this.createAction(this.getAddButtonKey(), this.getAddFolderIconCls(),
	                            this.onAdd, true, this.getAddTitleKey(), "add");
	                    this.actionEditGridRow = this.createAction(this.getEditButtonKey(), this.getEditIconCls(),
	                            this.onEditGridRow, true, this.getEditTitleKey(), "editGridRow");
	                    this.actionEditTreeNode = this.createAction(this.getEditButtonKey(), this.getEditIconCls(),
	                            this.onEditTreeNode, false, this.getEditTitleKey(), "editTreeNode");
	                    this.actionCopyGridRow = this.createAction(this.getCopyButtonKey(), this.getCopyIconCls(),
	                            this.onCopyGridRow, true, this.getCopyTitleKey(), "copyGridRow");
	                    this.actionCopyTreeNode = this.createAction(this.getCopyButtonKey(), this.getCopyIconCls(),
	                            this.onCopyTreeNode, false, this.getCopyTitleKey(), "copyTreeNode");
	                    this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(),
	                            this.getDeleteIconCls(), this.onDeleteFromGrid, true, this.getDeleteTitleKey(),
	                            "deleteGridRow");
	                    this.actionDeleteTreeNode = this.createAction(this.getDeleteButtonKey(), this
	                            .getDeleteIconCls(), this.onDeleteFromTree, false, this.getDeleteTitleKey(),
	                            "deleteTreeNode");
	                    this.actionChildIssueTypeAssignmentFromGrid = this.createAction(
	                            "admin.customize.list.button.filterByChildIssueType", "itemAction_addChild",
	                            this.onChildIssueTypeAssignmentGrid, true,
	                            "admin.customize.list.button.filterByChildIssueType.tt");
	                    this.actionChildIssueTypeAssignmentFromTree = this.createAction(
	                            "admin.customize.list.button.filterByChildIssueType", "itemAction_addChild",
	                            this.onChildIssueTypeAssignmentTree, false,
	                            "admin.customize.list.button.filterByChildIssueType.tt");
	                    this.actionUploadFromGrid = this.createAction("common.btn.upload", "upload",
	                            this.createUploadFormFromGrid, false, "common.lbl.upload", "uploadIconGridRow");
	                    this.actionUploadFromTree = this.createAction("common.btn.upload", "upload",
	                            this.createUploadFormFromTree, true, "common.lbl.upload", "uploadIconTreeNode");
	                    this.actionDownloadFromGrid = this.createAction("common.btn.download", "download",
	                            this.downloadIconFromGrid, false, "common.lbl.download", "downloadIconGridRow");
	                    this.actionDownloadFromTree = this.createAction("common.btn.download", "download",
	                            this.downloadIconFromTree, true, "common.lbl.download", "downloadIconTreeNode");
	                    this.actionMoveUp = this.createAction("common.btn.up", "moveUp", this.onMoveUpGridRow, false,
	                            "common.lbl.up", "moveUp");
	                    this.actionMoveDown = this.createAction("common.btn.down", "moveDown", this.onMoveDownGridRow,
	                            false, "common.lbl.down", "moveDown");
	                    this.actionImport = this.createAction("common.btn.import", "import", this.onImport, false,
	                            "common.lbl.import", "importList");
	                    this.actionExportGridRow = this.createAction("common.btn.export", "export",
	                            this.onExportGridRow, true, "common.lbl.export", "exportGridRow");
	                    this.actionExportTreeNode = this.createAction("common.btn.export", "export",
	                            this.onExportTreeNode, false, "common.lbl.export", "exportTreeNode");
	                },
	                /**
					 * Get the toolbar actions. By default all actions, override
					 * if not all actions should appear in toolbar
					 */
	                getToolbarActions : function() {
	                    return [];
	                },
	                /**
					 * Initialize all actions and return the toolbar actions
					 * this time called also by treeNodeSelect
					 */
	                getToolbarActionsForTreeNodeSelect : function(node) {
	                    if (CWHF.isNull(node) /* || arrSelectedNodes.length===0 */) {
		                    // first load of the listConfig
		                    // return [this.actionAdd, this.actionEditGridRow,
							// this.actionDeleteGridRow];
		                    return [];
	                    } else {
		                    var actions = [];
		                    // after selecting a tree node
		                    var isLeaf = node.isLeaf();
		                    var mightEditChild = false;
		                    var mightDeleteChild = false;
		                    var canAddChild = false;
		                    var mightCopyChild = false;
		                    if (this.isProjectSpecificRoot(node.data)) {
			                    // after initializing the project specific
								// branch for project lists
			                    // although in the list tree no node is
								// selected, the add refers to the project
								// specific root
			                    // selectedNode.isRoot(): after deleting a list
								// (directly below root)
			                    canAddChild = true;
			                    mightEditChild = true;
			                    mightDeleteChild = true;
			                    mightCopyChild = true;
		                    } else {
			                    canAddChild = node.data["canAddChild"];
			                    mightEditChild = node.data["mightEditChild"]
			                            || (isLeaf && node.parentNode.data["mightEditChild"]);
			                    mightDeleteChild = node.data["mightDeleteChild"]
			                            || (isLeaf && node.parentNode.data["mightDeleteChild"]);
			                    mightCopyChild = node.data["mightCopyChild"];
		                    }
		                    var hasChildFilter = node.data["hasChildFilter"];
		                    var childrenHaveIcon = node.data["childrenHaveIcon"];
		                    if (canAddChild) {
			                    actions.push(this.actionAdd);
			                    this.actionAdd.setDisabled(false);
		                    }
		                    if (mightCopyChild) {
			                    // first unselected, select by grid row select
			                    actions.push(this.actionCopyGridRow);
			                    this.actionCopyGridRow.setDisabled(true);
		                    }
		                    if (mightEditChild) {
			                    actions.push(this.actionEditGridRow);
			                    this.actionEditGridRow.setDisabled(true);
		                    }
		                    if (mightDeleteChild) {
			                    actions.push(this.actionDeleteGridRow);
			                    this.actionDeleteGridRow.setDisabled(true);
		                    }
		                    var childListID = null;
		                    if (canAddChild) {
			                    childListID = node.data["childListID"];
			                    if (CWHF.isNull(childListID) || childListID === 0) {
				                    // global or project node
				                    actions.push(this.actionImport);
			                    }
		                    }
		                    if (mightCopyChild) {
			                    // first unselected, select by grid row select
			                    actions.push(this.actionExportGridRow);
			                    this.actionExportGridRow.setDisabled(true);
		                    }
		                    if (hasChildFilter) {
			                    // actions.push(this.actionChildAssignment);
			                    // this.actionChildAssignment.setDisabled(false);
			                    actions.push(this.actionChildIssueTypeAssignmentFromGrid);
			                    this.actionChildIssueTypeAssignmentFromGrid.setDisabled(true);
		                    }
		                    if (childrenHaveIcon) {
			                    if (mightEditChild) {
				                    actions.push(this.actionUploadFromGrid);
			                    }
			                    actions.push(this.actionDownloadFromGrid);
			                    // both disabled until selection
			                    this.actionUploadFromGrid.setDisabled(true);
			                    this.actionDownloadFromGrid.setDisabled(true);
		                    }
		                    if (childListID  && childListID !== 0 && mightEditChild) {
			                    actions.push(this.actionMoveUp);
			                    actions.push(this.actionMoveDown);
			                    // both disabled until selection
			                    this.actionMoveUp.setDisabled(true);
			                    this.actionMoveDown.setDisabled(true);
		                    }
		                    return actions;
	                    }
	                },
	                /**
					 * Gets the tree's fields
					 */
	                getTreeFields : function() {
	                    return [ {
	                        name : "id",
	                        mapping : "id",
	                        type : "string"
	                    }, {
	                        name : "text",
	                        mapping : "text",
	                        type : "string"
	                    }, {
	                        name : "topParentList",
	                        mapping : "topParentList",
	                        type : "int"
	                    }, {
	                        name : "type",
	                        mapping : "type",
	                        type : "int"
	                    }, {
	                        name : "childListID",
	                        mapping : "childListID",
	                        type : "int"
	                    }, {
	                        name : "optionID",
	                        mapping : "optionID",
	                        type : "int"
	                    }, {
	                        name : "canEdit",
	                        mapping : "canEdit",
	                        type : "boolean"
	                    }, {
	                        name : "mightEditChild",
	                        mapping : "mightEditChild",
	                        type : "boolean"
	                    }, {
	                        name : "canDelete",
	                        mapping : "canDelete",
	                        type : "boolean"
	                    }, {
	                        name : "mightDeleteChild",
	                        mapping : "mightDeleteChild",
	                        type : "boolean"
	                    }, {
	                        name : "nodeListForLabel",
	                        mapping : "nodeListForLabel",
	                        type : "int"
	                    }, {
	                        name : "canAddChild",
	                        mapping : "canAddChild",
	                        type : "boolean"
	                    }, {
	                        name : "canCopy",
	                        mapping : "canCopy",
	                        type : "boolean"
	                    }, {
	                        name : "mightCopyChild",
	                        mapping : "mightCopyChild",
	                        type : "boolean"
	                    }, {
	                        name : "nodeChildrenListForLabel",
	                        mapping : "nodeChildrenListForLabel",
	                        type : "int"
	                    }, {
	                        name : "icon",
	                        mapping : "icon",
	                        type : "string"
	                    }, {
	                        name : "leaf",
	                        mapping : "leaf",
	                        type : "boolean"
	                    }, {
	                        name : "hasTypeflag",
	                        mapping : "hasTypeflag",
	                        type : "boolean"
	                    }, {
	                        name : "childrenHaveTypeflag",
	                        mapping : "childrenHaveTypeflag",
	                        type : "boolean"
	                    }, {
	                        name : "disableTypeflag",
	                        mapping : "disableTypeflag",
	                        type : "boolean"
	                    }, {
	                        name : "hasIcon",
	                        mapping : "hasIcon",
	                        type : "boolean"
	                    }, {
	                        name : "childrenHaveIcon",
	                        mapping : "childrenHaveIcon",
	                        type : "boolean"
	                    }, {
	                        name : "hasCssStyle",
	                        mapping : "hasCssStyle",
	                        type : "boolean"
	                    }, {
	                        name : "childrenHaveCssStyle",
	                        mapping : "childrenHaveCssStyle",
	                        type : "boolean"
	                    }, {
	                        name : "hasChildFilter",
	                        mapping : "hasChildFilter",
	                        type : "boolean"
	                    }, {
	                        name : "hasPercentComplete",
	                        mapping : "hasPercentComplete",
	                        type : "boolean"
	                    }, {
	                        name : "childrenHavePercentComplete",
	                        mapping : "childrenHavePercentComplete",
	                        type : "boolean"
	                    }, {
	                        name : "hasDefaultOption",
	                        mapping : "hasDefaultOption",
	                        type : "boolean"
	                    }, {
	                        name : "childrenHaveDefaultOption",
	                        mapping : "childrenHaveDefaultOption",
	                        type : "boolean"
	                    } ];
	                },
	                getTreeExpandExtraParams : function() {
	                    return {
		                    fromProjectConfig : this.getFromProjectConfig()
	                    };
	                },
	                onChildIssueTypeAssignmentGrid : function() {
	                    var recordData = this.getSingleSelectedRecordData(false);
	                    if (recordData ) {
		                    this.onChildIssueTypeAssignment(recordData.node, recordData);
	                    }
	                },
	                onChildIssueTypeAssignmentTree : function() {
	                    this.onChildIssueTypeAssignment(this.selectedNodeID, this.selectedNode);
	                },
	                onChildIssueTypeAssignment : function(nodeID, record) {
	                    this.childIssueTypeAssignment = Ext.create("com.trackplus.admin.SimpleAssignment", {
	                        objectID : nodeID,
	                        objectIDParamName : "parentIssueTypeNodeID",
	                        dynamicIcons : true
	                    });
	                    this.childIssueTypeAssignment.baseAction = "childIssueTypeAssignments";
	                    var assignmentWin = Ext.create("Ext.window.Window", {
	                        height : 450,
	                        width : 500,
	                        title : getText("admin.customize.list.button.filterByChildIssueType"),
	                        autoScroll : true,
	                        border : false,
	                        buttons : [ {
	                            text : getText("common.btn.done"),
	                            handler : function() {
		                            assignmentWin.close();
	                            }
	                        } ],
	                        layout : "fit",
	                        items : [ this.childIssueTypeAssignment.getDetailPanel(record) ]
	                    }).show();
	                },
	                /** ****fileupload start***** */
	                downloadIconFromGrid : function() {
	                    var recordData = this.getSingleSelectedRecordData(false);
	                    if (recordData ) {
		                    this.downloadIcon(recordData.node);
	                    }
	                },
	                downloadIconFromTree : function() {
	                    this.downloadIcon(this.selectedNodeID);
	                },
	                downloadIcon : function(selectedNodeID) {
	                    attachmentURI = "listOptionIcon!download.action?node=" + selectedNodeID;
	                    window.open(attachmentURI);
	                },
	                createUploadFormFromGrid : function() {
	                    var record = this.getSingleSelectedRecord(false);
	                    if (record ) {
		                    this.createUploadForm(false, record);
	                    }
	                },
	                createUploadFormFromTree : function() {
	                    this.createUploadForm(true, this.selectedNode);
	                },
	                createUploadForm : function(fromTree, record) {
	                    var width = this.uploadWindowWidth;
	                    var height = this.uploadWindowHeight;
	                    var loadUrl = "listOptionIcon.action";
	                    var loadParams = this.getEditParams(fromTree);
	                    var load = {
	                        loadUrl : loadUrl,
	                        loadUrlParams : loadParams
	                    };
	                    var submitParams = this.getEditParams(fromTree);
	                    var submit = [ {
	                        submitUrl : "listOptionIcon!upload.action",
	                        submitUrlParams : submitParams,
							disabled:true,
	                        submitButtonText : getText("common.btn.upload"),
	                        submitHandler : this.uploadFileHandler
	                    }, {
	                        submitUrl : "listOptionIcon!delete.action",
	                        submitUrlParams : submitParams,
	                        submitButtonText : getText("common.btn.delete"),
	                        submitHandler : this.deleteUploadedFileHandler
	                    } ];
	                    var postDataProcess = this.renderUploadPostDataProcess;
	                    var title = getText("common.lbl.upload", getText("admin.customize.list.lbl.icon"));
	                    var windowParameters = {
	                        title : title,
	                        width : width,
	                        height : height,
	                        load : load,
	                        submit : submit,
	                        formPanel : this.getFormPanel(),
	                        postDataProcess : postDataProcess,
	                        cancelButtonText : getText("common.btn.done"),
	                        refreshAfterCancel : true,
	                        extraConfig : {
		                        fromTree : fromTree
	                        }
	                    };
	                    var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
	                    windowConfig.showWindowByConfig(this);
	                },
	                /**
					 * Get the node to reload after upload operation
					 */
	                getReloadParamsAfterUpload : function(fromTree) {
	                    if (this.selectedNode ) {
		                    if (fromTree) {
			                    // edited/copied from tree
			                    var parentNode = this.selectedNode.parentNode;
			                    if (parentNode ) {
				                    // the parent of the edited node should be
									// reloaded
				                    return {
				                        nodeIDToReload : parentNode.data["id"],
				                        nodeIDToSelect : this.selectedNode.data["id"],
				                        rowToSelect : this.selectedNode.data["id"]
				                    };
			                    }
		                    } else {
			                    // edited from grid:
			                    var gridRow = this.getLastSelected(fromTree);
			                    if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
				                    // in the tree a leaf node selected -> grid
									// with a single row: the parent of the
									// selected tree node should be reloaded
				                    var parentNode = this.selectedNode.parentNode;
				                    if (parentNode ) {
					                    // the parent of the edited node should
										// be reloaded
					                    var reloadParams = {
					                        nodeIDToReload : parentNode.data["id"],
					                        nodeIDToSelect : this.selectedNode.data["id"]
					                    };
					                    if (gridRow ) {
						                    reloadParams["rowToSelect"] = gridRow.data["node"];
					                    }
					                    return reloadParams;
				                    }
			                    } else {
				                    // in the tree the parent of the edited grid
									// row is selected: the actually selected
									// tree node should be reloaded
				                    var reloadParams = {
					                    nodeIDToReload : this.selectedNode.data["id"]
				                    };
				                    if (gridRow ) {
					                    reloadParams["rowToSelect"] = gridRow.data["node"];
				                    }
				                    return reloadParams;
			                    }
		                    }
	                    }
	                    return null;
	                },
	                validateFileExtension : function(fileName) {
	                    var exp = /^.*\.(jpg|JPG|png|PNG|gif|GIF)$/;
	                    return exp.test(fileName);
	                },
	                getFormPanel : function(fromTree, selectedEntryID) {
	                    var icon = Ext.create("Ext.Img", {
	                        src : Ext.BLANK_IMAGE_URL,
	                        width : 16,
	                        height : 16,
	                        itemId : "actualIcon"
	                    });
	                    var iconWrapper = Ext.create("Ext.form.FieldContainer", {
	                        combineErrors : true,
	                        itemId : "iconPanel",
	                        fieldLabel : getText("admin.customize.list.lbl.icon"),
	                        labelWidth : this.labelWidth,
	                        labelAlign : "right",
	                        labelStyle : {
		                        overflow : "hidden"
	                        },
	                        layout : "hbox",
	                        items : [ icon ]
	                    });
	                    var picFiles = [ iconWrapper,
	                            CWHF.createLabelComponent("admin.customize.list.lbl.iconName", "actualIconName", {
		                            labelWidth : this.labelWidth, itemId:"actualIconName"
	                            }), CWHF.createFileField("admin.customize.list.lbl.newIcon", "iconFile", {
	                                allowBlank : false,
	                                labelWidth : this.labelWidth,
	                                itemId     : "iconFile"
	                            },{change:{fn: this.newIconFileChanged, scope:this}}) ];
	                    return Ext.create("Ext.form.Panel", {
	                        bodyStyle : "padding:5px",
	                        url : "listOptionIcon!upload.action",
	                        defaults : {
	                            labelStyle : "overflow: hidden;",
	                            margin : "5 5 0 0",
	                            msgTarget : "side",
	                            anchor : "-20"
	                        },
	                        method : "POST",
	                        fileUpload : true,
	                        items : picFiles
	                    });
	                },
					newIconFileChanged:function(){
						var toolbars = this.win.getDockedItems("toolbar[dock='bottom']");
						if (toolbars ) {
							// disable delete button if no icon is specified
							toolbars[0].getComponent(0).setDisabled(false);
						}
					},
	                renderUploadPostDataProcess : function(data, formPanel, fromTree) {
	                    var actualIcon = formPanel.getComponent("iconPanel").getComponent("actualIcon");
	                    if (actualIcon ) {
		                    actualIcon.setSrc(data.icon);
		                    // actualIcon.doComponentLayout();
	                    }
	                    actualIconName = formPanel.getComponent("actualIconName");
	                    if (actualIconName ) {
		                    actualIconName.setValue(data["iconName"]);
	                    }
	                    // Ext.getDom("pic").src = data.icon;
	                    /*
						 * if (data["iconName"]) {
						 * formPanel.getComponent("actualIconName").setValue(data["iconName"]);
						 * formPanel.getComponent("actualIconName").setVisible(true); }
						 */
	                    formPanel.getComponent("iconFile").setValue("");
	                    var toolbars = this.win.getDockedItems("toolbar[dock='bottom']");
	                    if (toolbars ) {
							toolbars[0].getComponent(0).setDisabled(true);
		                    // disable delete button if no icon is specified
		                    toolbars[0].getComponent(1).setDisabled(CWHF.isNull(data.iconName) || data.iconName === "");
	                    }
	                },
	                uploadFileHandler : function(window, submitUrl, submitUrlParams, extraConfig) {
	                    var theForm = this.formEdit.getForm();
	                    if (!theForm.isValid()) {
		                    Ext.MessageBox.alert(getText("admin.customize.list.title.upload", this.getEntityLabel({
			                    fromTree : false
		                    })), getText("admin.customize.list.lbl.iconFileNotSpecified"));
		                    return;
	                    }
	                    var iconFile = this.formEdit.getComponent("iconFile");
	                    if (!this.validateFileExtension(iconFile.getRawValue())) {
		                    Ext.MessageBox.alert(getText("admin.customize.list.title.upload", this.getEntityLabel({
			                    fromTree : false
		                    })), getText("admin.customize.list.lbl.iconFileWrongType"));
		                    return;
	                    }
	                    var fromTree = false;
	                    if (extraConfig ) {
		                    fromTree = extraConfig.fromTree;
	                    }
	                    theForm.submit({
	                        scope : this,
	                        params : submitUrlParams,
	                        success : function(form, action) {
		                        this.renderUploadPostDataProcess(action.result.data, this.formEdit, fromTree);
		                        this.reload.call(this, this.getReloadParamsAfterUpload(fromTree));
	                        },
	                        failure : function(form, action) {
		                        com.trackplus.util.submitFailureHandler(form, action);
	                        }
	                    });
	                },
	                deleteUploadedFileHandler : function(window, submitUrl, submitUrlParams, extraConfig) {
	                    var pictUploadForm = this.formEdit;
	                    var fromTree = false;
	                    if (extraConfig ) {
		                    fromTree = extraConfig.fromTree;
	                    }
	                    Ext.Ajax.request({
	                        url : submitUrl,
	                        scope : this,
	                        params : submitUrlParams,
	                        success : function(response) {
		                        var result = Ext.decode(response.responseText);
		                        /*
								 * Ext.getDom('pic').src = "";
								 * pictUploadForm.getComponent('actualIconName').setValue("");
								 * pictUploadForm.getComponent('iconFile').setRawValue('');
								 */
		                        this.renderUploadPostDataProcess(result.data, pictUploadForm, fromTree);
		                        this.reload.call(this, this.getReloadParamsAfterUpload(fromTree));
	                        }
	                    });
	                },
	                /** ****fileupload end***** */
	                getGridViewConfig: function(node) {
	            		if (this.hasDragAndDropOnGrid(node)) {
	            			return {
	            				plugins: {
	            					ptype: "gridviewdragdrop",
	            					dragGroup: this.getBaseAction() + "gridDDGroup",
	            					dropGroup: this.getBaseAction() + "gridDDGroup",
	            					enableDrag: true,
	            					enableDrop: true
	            				},
	            				listeners: {
	            					drop: {scope:this, fn: function(node, data, dropRec, dropPosition) {
	            						this.onGridDrop(node, data, dropRec, dropPosition);
	            						}
	            					}
	            				},
	            				markDirty: false //for changing the default values for custom lists
	            			};
	            		}
	            		return null;
	            	},
	                getListFields : function() {
	                    return [ {
	                        name : "id",
	                        type : "int"
	                    }, {
	                        name : "label",
	                        type : "string"
	                    }, {
	                        name : "canEdit",
	                        type : "boolean"
	                    }, {
	                        name : "canCopy",
	                        type : "boolean"
	                    }, {
	                        name : "canDelete",
	                        type : "boolean"
	                    }, {
	                        name : "rowListForLabel",
	                        type : "int"
	                    }, {
	                        name : "iconCls",
	                        type : "string"
	                    }, {
	                        name : "leaf",
	                        type : "boolean"
	                    }, {
	                        name : "node",
	                        type : "string"
	                    } ];
	                },
	                getListOptionFields : function() {
	                    return [ {
	                        name : "id",
	                        type : "int"
	                    }, {
	                        name : "label",
	                        type : "string"
	                    }, {
	                        name : "canEdit",
	                        type : "boolean"
	                    }, {
	                        name : "canDelete",
	                        type : "boolean"
	                    }, {
	                        name : "rowListForLabel",
	                        type : "int"
	                    }, {
	                        name : "hasTypeflag",
	                        type : "boolean"
	                    }, {
	                        name : "disableTypeflag",
	                        type : "boolean"
	                    }, {
	                        name : "typeflagLabel",
	                        type : "string"
	                    }, {
	                        name : "hasIcon",
	                        type : "boolean"
	                    }, {
	                        name : "iconName",
	                        type : "string"
	                    }, {
	                        name : "icon",
	                        type : "string"
	                    }, {
	                        name : "hasCssStyle",
	                        type : "boolean"
	                    }, {
	                        name : "cssStyle",
	                        type : "string"
	                    }, {
	                        name : "hasChildFilter",
	                        type : "boolean"
	                    }, {
	                        name : "hasPercentComplete",
	                        type : "boolean"
	                    }, {
	                        name : "percentComplete",
	                        type : "int",
		                    allowNull : true
	                    }, {
	                        name : "hasDefaultOption",
	                        type : "boolean"
	                    }, {
	                        name : "defaultOption",
	                        type : "boolean"
	                    }, {
	                        name : "leaf",
	                        type : "boolean"
	                    }, {
	                        name : "node",
	                        type : "string"
	                    } ];
	                },
	                getListColumns : function() {
	                    return [{
	                    	text : getText("admin.customize.list.lbl.icon"),
	                        width : 60,
	                        dataIndex : "iconCls",
	                        sortable : false,
	                        hidden : false,
	                        renderer : function(value, metadata, record) {
		                        // metadata.tdCls = value;
		                        return '<div style="width:16px;height:16px" class="' + value + '">&nbsp;</div>';
	                        }
	                    }, {
	                    	text : getText("common.lbl.name"),
	                        flex : 1,
	                        dataIndex : "label",
	                        sortable : false,
	                        hidden : false
	                    } ];
	                },
	                getListOptionColumns : function(node) {
	                    var columnModelArr = [ {
	                    	text : getText("common.lbl.name"),
	                        flex : 1,
	                        dataIndex : "label",
	                        sortable : false,
	                        hidden : false
	                    } ];
	                    var hasIcon;
	                    var hasTypeflag;
	                    var hasCssStyle;
	                    var hasPercentComplete;
	                    var hasDefaultOption;
	                    if (node.isLeaf()) {
		                    hasIcon = node.data["hasIcon"];
		                    hasTypeflag = node.data["hasTypeflag"];
		                    hasCssStyle = node.data["hasCssStyle"];
		                    hasPercentComplete = node.data["hasPercentComplete"];
		                    hasDefaultOption = node.data["hasDefaultOption"];
	                    } else {
		                    hasIcon = node.data["childrenHaveIcon"];
		                    hasTypeflag = node.data["childrenHaveTypeflag"];
		                    hasCssStyle = node.data["childrenHaveCssStyle"];
		                    hasPercentComplete = node.data["childrenHavePercentComplete"];
		                    hasDefaultOption = node.data["childrenHaveDefaultOption"];
	                    }
	                    if (hasIcon) {
		                    columnModelArr.push({
		                    	text : getText("admin.customize.list.lbl.icon"),
		                        width : 60,
		                        dataIndex : "icon",
		                        sortable : false,
		                        hidden : false,
		                        renderer : function(val) {
			                        if (val  && val !== "") {
				                        return '<img src="' + val + '"/>';
			                        }
			                        return '';
		                        }
		                    });
		                    columnModelArr.push({
		                    	text : getText("admin.customize.list.lbl.iconName"),
		                        width : 100,
		                        dataIndex : "iconName",
		                        sortable : false,
		                        hidden : false
		                    });
	                    }
	                    if (hasCssStyle) {
		                    var colorRendererColumn = Ext.create("Ext.grid.column.Column", {
		                    	text : getText("admin.customize.list.lbl.style"),
		                        width : 100,
		                        dataIndex : "cssStyle",
		                        sortable : false,
		                        hidden : false
		                    });
		                    colorRendererColumn.renderer = function(value, metadata) {
			                    metadata.style = value;// 'background-color:#'+
														// value;
			                    return "Test text";
		                    };
		                    columnModelArr.push(colorRendererColumn);
	                    }
	                    if (hasPercentComplete) {
		                    columnModelArr.push({
		                    	text : getText("admin.customize.list.lbl.percentComplete"),
		                        width : 100,
		                        dataIndex : "percentComplete",
		                        sortable : false,
		                        hidden : false
		                    });
	                    }
	                    if (hasTypeflag) {
		                    columnModelArr.push({
		                    	text : getText("admin.customize.list.lbl.typeflag"),
		                        width : 150,
		                        dataIndex : "typeflagLabel",
		                        sortable : false,
		                        hidden : false
		                    });
	                    }
	                    if (hasDefaultOption) {
		                    columnModelArr.push({
		                        xtype : "checkcolumn",
		                        text : getText("admin.customize.list.lbl.defaultOption"),
		                        width : 100,
		                        dataIndex : "defaultOption",
		                        sortable : false,
		                        hidden : false,
		                        //disabled : true,
		                        listeners: {"checkchange": {fn: this.changeDefault, scope:this}}
		                    });
	                    }
	                    return columnModelArr;
	                },
	                changeDefault: function(checkBox, rowIndex, checked, eOpts) {
	            		var record = this.grid.getStore().getAt(rowIndex);
	            		if (record) {
	            			var params = {node:record.data["node"], defaultOption:checked};
	            			Ext.Ajax.request({
	            				url: this.getBaseAction() + "!changeDefault.action",
	            				params: params,
	            				scope: this,
	            				success: function(response) {
	            				},
	            				failure: function(response) {
	            					Ext.MessageBox.alert(this.failureTitle, response.responseText);
	            				}
	            			});
	            		}
	            	},
	                /**
					 * Whether drag and drop on grid is possible
					 */
	                hasDragAndDropOnGrid : function(node) {
	                    var childListID = node.data["childListID"];
	                    if (childListID  && childListID !== 0) {
		                    // custom or system options
		                    return true;
	                    }
	                },
	                getGridFields : function(node) {
	                    var childListID = node.data["childListID"];
	                    if (CWHF.isNull(childListID) || childListID === 0) {
		                    return this.getListFields();
	                    } else {
		                    // custom or system options
		                    return this.getListOptionFields();
	                    }
	                },
	                getGridColumns : function(node) {
	                    var childListID = node.data["childListID"];
	                    if (CWHF.isNull(childListID) || childListID === 0) {
		                    return this.getListColumns();
	                    } else {
		                    // custom or system options
		                    return this.getListOptionColumns(node);
	                    }
	                },
	                /**
					 * Return false if dragging this node is not allowed
					 */
	                canDragDropNode : function(nodeToDrag, copy, overModel) {
	                    // drag a global or project specific custom list or
						// option within a custom cascading list
	                    var canDragDropOption = false;
	                    var draggedNodeTopList = nodeToDrag.data["topParentList"];
	                    var droppedToTopList = overModel.data["topParentList"];
	                    if (draggedNodeTopList  && droppedToTopList
	                            && draggedNodeTopList === droppedToTopList) {
		                    canDragDropOption = true;
	                    }
	                    var canDragList = nodeToDrag.data["nodeListForLabel"] === -20
	                            || nodeToDrag.data["nodeListForLabel"] === -21;
	                    if (!(canDragList || canDragDropOption)) {
		                    return false;
	                    }
	                    // move a list to another place
	                    var canDropList = overModel.data["canAddChild"]
	                            && (overModel.data["nodeChildrenListForLabel"] === -20 || overModel.data["nodeChildrenListForLabel"] === -21);
	                    if (!(canDropList || canDragDropOption)) {
		                    return false;
	                    }
	                    /*
						 * Ext.Ajax.request({ url: strutsBaseAction +
						 * '!dropWouldDuplicate.action', params: { nodeFrom:
						 * nodeFrom.data["id"], nodeTo: nodeTo.data["id"], },
						 * scope: this, disableCaching:true, success:
						 * function(response){ var responseJson =
						 * Ext.decode(response.responseText); if
						 * (responseJson.success === false) { if
						 * (responseJson.errorMessage) { //no right to
						 * delete Ext.MessageBox.alert(this.failureTitle,
						 * responseJson.errorMessage) } } }, failure:
						 * function(result){
						 * Ext.MessageBox.alert(this.failureTitle,
						 * result.responseText) }, method:"POST", });
						 */
	                    return true;
	                },
	                enableDisableToolbarButtons : function(view, arrSelections) {
	                    var selectedRecord = arrSelections[0];
	                    if (CWHF.isNull(selectedRecord)) {
		                    this.actionDeleteGridRow.setDisabled(true);
		                    this.actionEditGridRow.setDisabled(true);
		                    this.actionCopyGridRow.setDisabled(true);
		                    this.actionChildIssueTypeAssignmentFromGrid.setDisabled(true);
		                    this.actionExportGridRow.setDisabled(true);
		                    this.actionUploadFromGrid.setDisabled(true);
		                    this.actionDownloadFromGrid.setDisabled(true);
		                    this.actionMoveUp.setDisabled(true);
		                    this.actionMoveDown.setDisabled(true);
	                    } else {
		                    var canDelete = selectedRecord.data["canDelete"];
		                    this.actionDeleteGridRow.setDisabled(!canDelete);
		                    var canEdit = selectedRecord.data["canEdit"];
		                    this.actionEditGridRow.setDisabled(!canEdit);
		                    this.actionChildIssueTypeAssignmentFromGrid.setDisabled(!canEdit);
		                    this.actionUploadFromGrid.setDisabled(!canEdit);
		                    this.actionMoveDown.setDisabled(!canEdit);
		                    this.actionMoveUp.setDisabled(!canEdit);
		                    if (canEdit) {
			                    var store = this.grid.getStore();
			                    if (store ) {
				                    this.actionMoveDown.setDisabled(selectedRecord === store.last());
				                    this.actionMoveUp.setDisabled(selectedRecord === store.first());
			                    }
		                    }
		                    var canCopy = selectedRecord.data["canCopy"];
		                    this.actionCopyGridRow.setDisabled(!canCopy);
		                    this.actionExportGridRow.setDisabled(!canCopy);
		                    var hasIcon = selectedRecord.data["iconName"]
		                            && selectedRecord.data["iconName"] !== "";
		                    this.actionDownloadFromGrid.setDisabled(!hasIcon);
	                    }
	                },
	                /**
	                 * Prepare adding/editing a custom list
	                 */
	                getCustomListWindowItems : function(node, add, canEdit) {
	                    var windowItems = [ CWHF.createTextField("common.lbl.name", "label", {
	                        disabled : !canEdit,
	                        allowBlank : false,
	                        labelWidth : this.labelWidth
	                    }) ];
	                    //list types
	                    /*com.trackplus.util.createCombo("customListTypesList",
	                    		getText('admin.customize.list.lbl.listtype'),
	                    		"customListType", add, null, null, null, null,
	                    		{select: function(listTypeCombo) {
	                    			var cascadingCombo = listTypeCombo.ownerCt.getComponent('cascadingTypesList');
	                    			if (listTypeCombo.getValue()===3) {
	                    				if (CWHF.isNull(cascadingCombo.getValue()) || cascadingCombo.getValue()==="") {
	                    					cascadingCombo.setValue(cascadingCombo.store.data.items[0].data.id);
	                    				}
	                    				cascadingCombo.show();
	                    			} else {
	                    				cascadingCombo.hide();
	                    			}
	                    		}})];*/
	                    //cascading parent
	                    /*windowItems.push(com.trackplus.util.createCombo("cascadingTypesList",
	                    		getText('admin.customize.list.lbl.cascadingType'),
	                    		"cascadingType", add, null, null, null, null, null, {hidden:true}));*/
	                    //repository types
	                    /*windowItems.push(com.trackplus.util.createCombo("repositoryTypesList",
	                    		getText('common.lbl.queries.repository'),
	                    		"repositoryType", add || canEdit, null, null, null, null,
	                    		{select: function(repositoryCombo) {
	                    			var projectCombo = repositoryCombo.ownerCt.getComponent('projectsList');
	                    			if (repositoryCombo.getValue()===3) {
	                    				if (CWHF.isNull(projectCombo.getValue()) || projectCombo.getValue()==="") {
	                    					projectCombo.setValue(projectCombo.store.data.items[0].data.id);
	                    				}
	                    				projectCombo.show();
	                    			} else {
	                    				projectCombo.hide();}
	                    		}}));
	                    //project
	                    windowItems.push(com.trackplus.util.createCombo("projectsList",
	                    		this.localizedLabels[1], "project", add || canEdit, null, null, null, null, null, {hidden:true}));*/
	                    windowItems.push(CWHF.createTextAreaField("common.lbl.description", "description", {
	                        disabled : !(add || canEdit),
	                        labelWidth : this.labelWidth
	                    }));
	                    return windowItems;
	                },
	                /**
	                 * Prepare adding/editing a system or custom list entry
	                 */
	                getListOptionWindowItems : function(node, hasTypeflag, disableTypeflag, hasCssStyle,
	                        hasPercentComplete, hasDefaultOption, canEdit) {
	                    //dialog for adding/editing a list option
	                    var windowItems = [ CWHF.createTextField("common.lbl.name", "label", {
	                        disabled : !canEdit,
	                        allowBlank : false,
	                        labelWidth : this.labelWidth
	                    }) ];
	                    if (hasTypeflag) {
		                    //type flag combo
		                    windowItems.push(CWHF.createCombo("admin.customize.list.lbl.typeflag", "typeflag", {
		                    	itemId: "typeflag",
		                        disabled : disableTypeflag || !canEdit,
		                        labelWidth : this.labelWidth
		                    }));
	                    }
	                    if (hasPercentComplete) {
		                    windowItems.push(CWHF.createNumberField("admin.customize.list.lbl.percentComplete",
		                            "percentComplete", 0, 0, 100, {
		                                disabled : !canEdit,
		                                labelWidth : this.labelWidth
		                            }));
	                    }
	                    if (hasDefaultOption) {
		                    windowItems.push(CWHF.createCheckbox("admin.customize.list.lbl.defaultOption",
		                            "defaultOption", {
		                                disabled : !canEdit,
		                                labelWidth : this.labelWidth
		                            }));
	                    }
	                    if (hasCssStyle) {
		                    windowItems.push({
		                        xtype : "fieldset",
		                        itemId : "fsStyle",
		                        //width: this.FieldSetWidth,
		                        title : getText("admin.customize.list.lbl.style"),
		                        collapsible : false,
		                        defaults : {
			                        anchor : "100%"
		                        },
		                        layout : "anchor",
		                        items : [
		                                CWHF.createColorPicker("admin.customize.list.lbl.style.bgrColor",
		                                        "cssStyleBean.bgrColor", {
		                                			itemId : "cssStyleBeanBgrColor",
		                                            disabled : !canEdit,
		                                            labelWidth : this.labelWidth
		                                        }),
		                                CWHF.createColorPicker("admin.customize.list.lbl.style.color",
		                                        "cssStyleBean.color", {
		                                			itemId : "cssStyleBeanColor",
		                                            disabled : !canEdit,
		                                            labelWidth : this.labelWidth
		                                        }),
		                                CWHF.createCombo("admin.customize.list.lbl.style.fontWeight",
		                                        "cssStyleBean.fontWeight", {
		                                			itemId: "fontWeight",
		                                            disabled : !canEdit,
		                                            idType : "string",
		                                            labelWidth : this.labelWidth
		                                        }),
		                                CWHF.createCombo("admin.customize.list.lbl.style.fontStyle",
		                                        "cssStyleBean.fontStyle", {
		                                			itemId: "fontStyle",
		                                            disabled : !canEdit,
		                                            idType : "string",
		                                            labelWidth : this.labelWidth
		                                        }),
		                                CWHF.createCombo("admin.customize.list.lbl.style.text-decoration",
		                                        "cssStyleBean.textDecoration", {
		                                			itemId: "textDecoration",
		                                            disabled : !canEdit,
		                                            idType : "string",
		                                            labelWidth : this.labelWidth
		                                        }) ]
		                    });
		                    /*windowItems.push(CWHF.createColorPicker("admin.customize.list.lbl.style.bgrColor",
		                    		"cssStyleBean.bgrColor", {disabled:!canEdit}));
		                    windowItems.push(CWHF.createColorPicker("admin.customize.list.lbl.style.color",
		                    		"cssStyleBean.color", {disabled:!canEdit}));
		                    windowItems.push(CWHF.createCombo(
		                    		"admin.customize.list.lbl.style.fontWeight",
		                    		"cssStyleBean.fontWeight", {disabled:!canEdit, idType:"String"}));
		                    windowItems.push(CWHF.createCombo(
		                    		"admin.customize.list.lbl.style.fontStyle",
		                    		"cssStyleBean.fontStyle", {disabled:!canEdit, idType:"String"}));
		                    windowItems.push(CWHF.createCombo(
		                    		"admin.customize.list.lbl.style.text-decoration",
		                    		"cssStyleBean.textDecoration", {disabled:!canEdit, idType:"String"}));*/
	                    }
	                    return windowItems;
	                },
	                /**
	                 * Load the combos after the result has arrived containing also the combo data sources
	                 */
	                postDataLoadCombos : function(data, panel) {
	                    /*if (panel.items.items) {
	                    	panel.items.items.forEach(function(item) {
	                    		//for each combo-type control set the value also:
	                    		//for a combos itemId <xxx>sList the json result should contain
	                    		//both <xxx>sList for the combo datasource and <xxx> for the combo's actual value
	                    		//the json field for value is
	                    		if (item.xtype === "combo") {
	                    			var comboSource = data[item.itemId];
	                    			item.store.loadData(comboSource);
	                    			//-'Lists'
	                    			item.setValue(data[item.itemId.substring(0,item.itemId.length-5)]);
	                    		}
	                    	});
	                    }*/
	                    var typeFlagsList = panel.getComponent("typeflag");
	                    if (typeFlagsList ) {
		                    typeFlagsList.store.loadData(data["typeflagsList"]);
		                    typeFlagsList.setValue(data["typeflag"]);
	                    }
	                    var fsStyle = panel.getComponent("fsStyle");
	                    if (fsStyle ) {
		                    var fontWeight = fsStyle.getComponent("fontWeight");
		                    if (fontWeight ) {
			                    fontWeight.store.loadData(data["fontWeightsList"]);
		                    }
		                    var fontStyle = fsStyle.getComponent("fontStyle");
		                    if (fontStyle ) {
			                    fontStyle.store.loadData(data["fontStylesList"]);
		                    }
		                    var textDecoration = panel.getComponent("fsStyle").getComponent("textDecoration");
		                    if (textDecoration ) {
			                    textDecoration.store.loadData(data["textDecorationsList"]);
		                    }
		                    var bgrColor = fsStyle.getComponent("cssStyleBeanBgrColor");
		                    if (bgrColor  && data["cssStyleBean.bgrColor"] ) {
			                    bgrColor.setFieldStyle('background-color:#' + data["cssStyleBean.bgrColor"]
			                            + '; background-image: none;');
		                    }
		                    var color = fsStyle.getComponent("cssStyleBeanColor");
		                    if (color  && data["cssStyleBean.color"] ) {
			                    color.setFieldStyle('background-color:#' + data["cssStyleBean.color"]
			                            + '; background-image: none;');
		                    }
	                    }
	                },
	                optionPostDataProcess : function(data, panel) {
	                    this.postDataLoadCombos(data, panel);
	                },
	                /**
	                 * The method to process the data to be loaded arrived from the server
	                 */
	                getEditPostDataProcess : function(record, isLeaf, add, fromTree, operation) {
	                    var recordData = null;
	                    if (record ) {
		                    recordData = record.data;
	                    }
	                    if (this.isListOperation(recordData, isLeaf, add, fromTree, operation)) {
		                    return null;//this.listPostDataProcess;
	                    } else {
		                    return this.optionPostDataProcess;
	                    }
	                },
	                /**
	                 * Get the panel items
	                 * recordData: the record data (for the record to be edited or added to)
	                 * isLeaf: whether add a leaf or a folder
	                 * add: whether it is add or edit
	                 * fromTree: operations started from tree or from grid
	                 * operation:  the name of the operation
	                 */
	                getPanelItems : function(recordData, isLeaf, add, fromTree, operation) {
	                    var nodeID = this.getRecordID(recordData, {
		                    fromTree : fromTree
	                    });
	                    var canEdit = false;
	                    if (operation === "add" || operation === "copy") {
		                    canEdit = true;
	                    } else {
		                    if (operation === "edit") {
			                    canEdit = recordData["canEdit"];
		                    }
	                    }
	                    if (this.isListOperation(recordData, isLeaf, add, fromTree, operation)) {
		                    return this.getCustomListWindowItems(nodeID, add, canEdit);
	                    } else {
		                    var hasTypeflag;
		                    var disableTypeflag;
		                    var hasCssStyle;
		                    var hasPercentComplete;
		                    var hasDefaultOption;
		                    if (add) {
			                    hasTypeflag = recordData["childrenHaveTypeflag"];
			                    disableTypeflag = recordData["disableTypeflag"];
			                    hasCssStyle = recordData["childrenHaveCssStyle"];
			                    hasPercentComplete = recordData["childrenHavePercentComplete"];
			                    hasDefaultOption = recordData["childrenHaveDefaultOption"];
		                    } else {
			                    hasTypeflag = recordData["hasTypeflag"];
			                    disableTypeflag = recordData["disableTypeflag"];
			                    hasCssStyle = recordData["hasCssStyle"];
			                    hasPercentComplete = recordData["hasPercentComplete"];
			                    hasDefaultOption = recordData["hasDefaultOption"];
		                    }
		                    return this.getListOptionWindowItems(nodeID, hasTypeflag, disableTypeflag, hasCssStyle,
		                            hasPercentComplete, hasDefaultOption, canEdit);
	                    }
	                },
	                /**
	                 * Handler for adding a node (folder or leaf)
	                 */
	                onAdd : function() {
	                    var operation = "add";
	                    var title = this.getTitle(this.getAddTitleKey(), {
		                    fromTree : true
	                    });
	                    var loadParams = this.getAddLeafParams();
	                    var submitParams = this.getAddLeafParams();
	                    var reloadParams = this.getAddReloadParamsAfterSave(true);
	                    var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
	                    var selectedRecord = this.getSingleSelectedRecord(true);
	                    if (CWHF.isNull(selectedRecord)) {
		                    selectedRecord = this.tree.getRootNode();
	                    }
	                    return this.onAddEdit(title, selectedRecord, operation, true, true, true, loadParams,
	                            submitParams, reloadParams, reloadParamsFromResult);
	                },
	                /**
	                 * Parameters for adding a new entry to a leaf:
	                 * add a child to a leaf node: exclusively by extending custom selects:
	                 * simple -> parent child or parent child -> parent child grandchild
	                 * without explicitly asking for the exact type of the composite select
	                 */
	                getAddLeafParams : function() {
	                    //false as it would be added to a folder to send the leaf's id, not the parent folder's id
	                    return this.getAddParams(false);
	                },
	                /**
	                 * Copy a grid row: right now only custom lists can be copied (options, or option branches not)
	                 */
	                onCopyGridRow : function() {
	                    return this.onCopy(false);
	                },
	                /**
	                 * Copy a tree node: right now only custom lists can be copied (options, or option branches not)
	                 */
	                onCopyTreeNode : function() {
	                    return this.onCopy(true);
	                },
	                /**
	                 * Handler for copy
	                 */
	                onCopy : function(fromTree) {
	                    var operation = "copy";
	                    var isLeaf = this.selectedIsLeaf(fromTree);
	                    var title = this.getTitle(this.getCopyTitleKey(), {
		                    fromTree : fromTree
	                    });
	                    var loadParams = this.getEditParams(fromTree);
	                    loadParams["copy"] = true;
	                    var submitParams = this.getEditParams(fromTree);
	                    submitParams["copy"] = true;
	                    var reloadParams = this.getCopyReloadParamsAfterSave(fromTree);
	                    var reloadParamsFromResult = this.getEditReloadParamsAfterSaveFromResult(fromTree);
	                    var selectedRecord = this.getSingleSelectedRecord(fromTree);
	                    return this.onAddEdit(title, selectedRecord, operation, isLeaf, false, fromTree, loadParams,
	                            submitParams, reloadParams, reloadParamsFromResult);
	                },
	                /**
	                 * Get the node to reload after save after copy operation
	                 */
	                getCopyReloadParamsAfterSave : function(fromTree) {
	                    if (fromTree) {
		                    if (this.selectedNode ) {
			                    var parentNode = this.selectedNode.parentNode;
			                    if (parentNode ) {
				                    return {
					                    nodeIDToReload : parentNode.data["id"]
				                    };
			                    }
		                    }
	                    }
	                    //else nodeIDToReload is not set which means by default this.selectedNode (see refreshGridAndTreeAfterSubmit())
	                    return null;
	                },
	                /**
	                 * Parameters for reloading after a delete operation
	                 */
	                getReloadParamsAfterDelete : function(selectedRecords, extraConfig, responseJson) {
	                    if (selectedRecords ) {
		                    //we suppose that only one selection is allowed in tree
		                    var selNode = selectedRecords;
		                    if (selNode ) {
			                    var parentNode = null;
			                    var grandParentNode = null;
			                    var parentNodeID = null;
			                    if (extraConfig ) {
				                    fromTree = extraConfig.fromTree;
				                    if (fromTree) {
					                    //delete from tree: select the parent of the deleted node for reload and select
					                    parentNode = selNode.parentNode;
					                    if (parentNode ) {
						                    parentNodeID = parentNode.data.id;
					                    }
					                    if (responseJson["lastCascadingChildDeleted"] && parentNode ) {
						                    grandParentNode = parentNode.parentNode;
						                    //in this case not the same as parentNode.data.id becuause the
						                    //childListID and leaf components of the nodeID changes
						                    parentNodeID = responseJson["node"];
					                    }
					                    var grandParentNodeID = null;
					                    if (grandParentNode ) {
						                    grandParentNodeID = grandParentNode.data.id;
					                    } else {
						                    grandParentNodeID = parentNodeID;
					                    }
					                    return {
					                        nodeIDToReload : grandParentNodeID,
					                        nodeIDToSelect : parentNodeID
					                    };
				                    } else {
					                    //delete from grid: the parent or the leaf to be deleted is selected already in tree
					                    if (responseJson["lastCascadingChildDeleted"] && this.selectedNode ) {
						                    //in this case not the same as this.selectedNode.data.id becuause the
						                    //childListID and leaf components of the nodeID changes
						                    parentNodeID = responseJson["node"];
						                    //in both cases the grid contains the single element to be deleted
						                    if (this.selectedNode.isLeaf()) {
							                    //the leaf to be deleted was selected in the tree
							                    grandParentNode = this.selectedNode.parentNode.parentNode;
						                    } else {
							                    //the parent of the leaf to be deleted was selected in the tree
							                    grandParentNode = this.selectedNode.parentNode;
						                    }
						                    if (grandParentNode ) {
							                    var grandParentNodeID = grandParentNode.data.id;
							                    return {
							                        nodeIDToReload : grandParentNodeID,
							                        nodeIDToSelect : parentNodeID
							                    };
						                    }
					                    } else {
						                    if (this.getShowGridForLeaf() && this.selectedNode.isLeaf()) {
							                    return {
								                    nodeIDToReload : this.selectedNode.parentNode.data.id
							                    };
						                    }
						                    return {
							                    nodeIDToSelect : this.selectedNode.data.id
						                    };
					                    }
				                    }
			                    }
		                    }
	                    }
	                    return null;
	                },
	                /**
	                 * panel for importing the e-mail templates
	                 */
	                getImportPanel : function() {
	                    this.formPanel = new Ext.form.FormPanel({
	                        border : false,
	                        bodyStyle : "padding-left:10px",
	                        defaults : {
	                            labelStyle : "overflow: hidden;",
	                            margin : "5 5 0 0",
	                            msgTarget : "side",
	                            anchor : "-20"
	                        },
	                        method : "POST",
	                        fileUpload : true,
	                        items : [
	                                CWHF.createFileField("admin.customize.list.import.lbl.uploadFile", "uploadFile", {
		                                allowBlank : false,
		                                itemId     : "uploadFile"
	                                }),
	                                CWHF.createCheckbox("common.lbl.overwriteExisting", "overwriteExisting"),
	                                CWHF.createCheckbox("common.lbl.clearChildren", "clearChildren") ]
	                    });
	                    return this.formPanel;
	                },
	                onImport : function() {
	                    var submit = [ {
	                        submitUrl : this.getBaseAction() + "!importList.action",
	                        submitButtonText : getText("common.btn.upload"),
	                        submitUrlParams : {
		                        node : this.selectedNodeID
	                        },
	                        validateHandler : Upload.validateUpload,
	                        expectedFileType : /^.*\.(xml)$/,
	                        refreshAfterSubmitHandler : this.reload
	                    } ];
	                    var title = getText("common.lbl.upload", getText("admin.customize.list.import.lbl.uploadFile"));
	                    var windowParameters = {
	                        title : title,
	                        width : 600,
	                        height : 180,
	                        submit : submit,
	                        formPanel : this.getImportPanel(),
	                        cancelButtonText : getText("common.btn.done")
	                    };
	                    var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
	                    windowConfig.showWindowByConfig(this);
	                },
	                onExportGridRow : function() {
	                    this.onExport(false);
	                },
	                onExportTreeNode : function() {
	                    this.onExport(true);
	                },
	                onExport : function(fromTree) {
	                    attachmentURI = this.getBaseAction() + "!exportList.action?node=" + this.getSelectedID(fromTree);
	                    window.open(attachmentURI);
	                },
	                getSelectedID : function(fromTree) {
	                    var recordData = this.getSingleSelectedRecordData(fromTree);
	                    if (recordData ) {
		                    return this.getRecordID(recordData, {
			                    fromTree : fromTree
		                    });
	                    }
	                    return null;
	                },
	                /**
	                 * Get the itemId of those actions whose context menu text or
	                 * toolbar button tooltip should be changed according to the current selection
	                 */
	                getActionItemIdsWithContextDependentLabel : function() {
	                    return [ "add", "editGridRow", "editTreeNode", "copyGridRow", "copyTreeNode", "deleteGridRow",
	                            "deleteTreeNode", "uploadIconGridRow", "uploadIconTreeNode", "downloadIconGridRow",
	                            "downloadIconTreeNode", "moveUp", "moveDown", "exportGridRow", "exportTreeNode",
	                            "importList" ];
	                },
	                /**
	                 * Get the actions available in context menu depending on the currently selected row
	                 *
	                 */
	                getTreeContextMenuActions : function(selectedRecord, selectionIsSimple) {
	                    var canEdit = selectedRecord.data["canEdit"];
	                    var canDelete = selectedRecord.data["canDelete"];
	                    var canAddChild = selectedRecord.data["canAddChild"];
	                    var canCopy = selectedRecord.data["canCopy"];
	                    var hasIcon = selectedRecord.data["hasIcon"];
	                    var hasChildFilter = selectedRecord.data["hasChildFilter"];
	                    var actions = [];
	                    if (canAddChild) {
		                    actions.push(this.actionAdd);
		                    var childListID = selectedRecord.data["childListID"];
		                    if (CWHF.isNull(childListID) || childListID === 0) {
			                    actions.push(this.actionImport);
		                    }
	                    }
	                    if (canEdit) {
		                    actions.push(this.actionEditTreeNode);
	                    }
	                    if (hasChildFilter && selectedRecord.isLeaf()) {
		                    actions.push(this.actionChildIssueTypeAssignmentFromTree);
	                    }
	                    if (canDelete) {
		                    actions.push(this.actionDeleteTreeNode);
	                    }
	                    if (canCopy) {
		                    actions.push(this.actionCopyTreeNode);
		                    actions.push(this.actionExportTreeNode);
	                    }
	                    if (hasIcon) {
		                    if (canEdit) {
			                    actions.push(this.actionUploadFromTree);
		                    }
		                    actions.push(this.actionDownloadFromTree);
	                    }
	                    return actions;
	                },
	                /**
	                 * Get the actions available in context menu depending on the currently selected row
	                 *
	                 */
	                getGridContextMenuActions : function(selectedRecord, selectionIsSimple) {
	                    var canEdit = selectedRecord.data["canEdit"];
	                    var canDelete = selectedRecord.data["canDelete"];
	                    var canCopy = selectedRecord.data["canCopy"];
	                    var hasIcon = selectedRecord.data["hasIcon"];
	                    var listOption = selectedRecord.data["id"];
	                    var hasChildFilter = selectedRecord.data["hasChildFilter"];
	                    var actions = [];
	                    if (canEdit) {
		                    actions.push(this.actionEditGridRow);
	                    }
	                    if (hasChildFilter) {
		                    actions.push(this.actionChildIssueTypeAssignmentFromGrid);
	                    }
	                    if (canDelete) {
		                    actions.push(this.actionDeleteGridRow);
	                    }
	                    if (canCopy) {
		                    actions.push(this.actionCopyGridRow);
		                    actions.push(this.actionExportGridRow);
	                    }
	                    if (hasIcon ) {
		                    if (canEdit) {
			                    actions.push(this.actionUploadFromGrid);
		                    }
		                    if (selectedRecord.data["iconName"]  && selectedRecord.data["iconName"] !== "") {
			                    actions.push(this.actionDownloadFromGrid);
		                    }
	                    }
	                    if (listOption  && listOption !== 0 && canEdit) {
		                    //it is an option
		                    var store = this.grid.getStore();
		                    if (store ) {
			                    if (selectedRecord !== store.first()) {
				                    actions.push(this.actionMoveUp);
			                    }
			                    if (selectedRecord !== store.last()) {
				                    actions.push(this.actionMoveDown);
			                    }
		                    }
	                    }
	                    return actions;
	                },
	                onTreeNodeDblClick : function(view, record) {
	                    var canEdit = record.data["canEdit"];
	                    if (canEdit) {
		                    this.onEditTreeNode();
	                    }
	                },
	                onGridRowDblClick : function(view, record) {
	                    var canEdit = record.data["canEdit"];
	                    if (canEdit) {
		                    this.onEditGridRow();
	                    }
	                }
	            });

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.customize.objectStatus.ObjectStatus',{
	extend:'com.trackplus.admin.TreeWithGrid',
	config: {
		rootID:'_'
	},
	confirmDeleteEntity:true,
	baseAction: "objectStatus",
	//showGridForLeaf:true,
	entityID:'node',
	listOptionWindowWidth: 500,
	listOptionWindowHeight: 150,
	//actions
	actionAdd: null,
	actionMoveUp: null,
	actionMoveDown: null,
	localizedLabels: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	/**
	 * Initialization method
	 */
	initBase: function() {
		this.initActions();
		this.initLocalizedLabels();
	},
	initLocalizedLabels: function() {
		Ext.Ajax.request({
			url: this.getBaseAction() + '!localizedLabels.action',
			scope: this,
			success: function(response) {
				var result = Ext.decode(response.responseText);
				this.localizedLabels = new Object();
				Ext.each(result.records, function(item) {
					this.localizedLabels[item.id] = item.label;
					}, this);
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
			})
	},
	getEditWidth: function(recordData, isLeaf, add, fromTree, operation) {
		return this.listOptionWindowWidth;
	},
	getEditHeight: function(recordData, isLeaf, add, fromTree, operation) {
		return this.listOptionWindowHeight;
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function(rootID) {
		return getText("menu.admin.custom.objectStatus.tt");
	},
	/**
	 * Get the title of the window in context
	 */
	getEntityLabel: function(extraConfig) {
		var tooltipKey = extraConfig.tooltipKey; //see crudBase getTitle
		var listForLabel = null;
		var fromTree = false;
		if (extraConfig) {
			fromTree = extraConfig.fromTree;
		}
		var selectedRecord = this.getLastSelected(fromTree);
		if (selectedRecord) {
			if (fromTree) {
				if (tooltipKey && tooltipKey===this.actionAdd.initialConfig.tooltipKey) {
					//for add and childAssignment get the label for children
					listForLabel = selectedRecord.data['listForLabel'];
				}
			} else {
				listForLabel = selectedRecord.data['listForLabel'];
			}
		}
		if (listForLabel) {
			return this.localizedLabels[listForLabel];
		}
		return "";
	},
	initActions: function() {
		this.actionAdd = this.createAction(this.getAddButtonKey(),
				this.getAddFolderIconCls(), this.onAdd, true, this.getAddTitleKey(), "add");
		this.actionEditGridRow = this.createAction(this.getEditButtonKey(),
				this.getEditIconCls(), this.onEditGridRow, true, this.getEditTitleKey(), "editGridRow");
		this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(),
				this.getDeleteIconCls(), this.onDeleteFromGrid, true, this.getDeleteTitleKey(), "deleteGridRow");
		this.actionMoveUp = this.createAction("common.btn.up",
				"moveUp", this.onMoveUpGridRow, true, "common.lbl.up", "moveUp");
		this.actionMoveDown = this.createAction("common.btn.down",
				"moveDown", this.onMoveDownGridRow, true, "common.lbl.down", "moveDown");
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		return [this.actionAdd, this.actionEditGridRow, this.actionDeleteGridRow, this.actionMoveUp, this.actionMoveDown];
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 * this time called also by treeNodeSelect
	 */
	getToolbarActionChangesForTreeNodeSelect: function(selectedNode) {
		this.actionAdd.setDisabled(false);
		this.actionEditGridRow.setDisabled(true);
		this.actionDeleteGridRow.setDisabled(true);
		this.actionMoveUp.setDisabled(true);
		this.actionMoveDown.setDisabled(true);
	},
	onTreeNodeDblClick: function(view, record) {
		//nothing: do not try to edit a tree node
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields: function() {
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'modifiable', mapping : 'modifiable', type: 'boolean'},
				{ name : 'listForLabel', mapping : 'listForLabel', type: 'int'},
				{ name : 'iconCls', mapping : 'iconCls', type: 'string'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'}];
	},
	/**
	 * Whether drag and drop on tree is possible
	 */
	hasDragAndDropOnGrid: function(node) {
		return true;
	},
	getGridFields: function(node) {
		return [{name: 'id', 	type: 'int'},
			{name: 'label', type: 'string'},
			{name: 'modifiable', type: 'boolean'},
			{name: 'listForLabel',	type: 'int'},
			{name: 'typeflagLabel',	type: 'string'},
			{name: 'leaf',	type: 'boolean'},
			{name: 'node',	type: 'string'}];
	},
	getGridColumns: function(node) {
		return [{text: getText('common.lbl.name'),
			flex:1, dataIndex: 'label', sortable: false, hidden:false},
			{text: getText('admin.customize.list.lbl.typeflag'),
			width: 100, dataIndex: 'typeflagLabel', sortable: false, hidden:false
		}];
	},
	onGridDrop: function(node, data, dropRec, dropPosition) {
		var before = false;
		if (dropPosition==="before") {
			before = true;
		}
		var request={node:data.records[0].get('node'), droppedToNode:dropRec.get('node'), before:before};
		this.onOrderChange(this.getBaseAction() + "!droppedNear.action", request);
	},
	enableDisableToolbarButtons: function(view, arrSelections) {
		var selectedRecord = arrSelections[0];
		if (CWHF.isNull(selectedRecord)) {
			this.actionDeleteGridRow.setDisabled(true);
			this.actionEditGridRow.setDisabled(true);
			this.actionMoveUp.setDisabled(true);
			this.actionMoveDown.setDisabled(true);
		} else {
			var modifiable = selectedRecord.data['modifiable'];
			this.actionDeleteGridRow.setDisabled(!modifiable);
			this.actionEditGridRow.setDisabled(!modifiable);
			this.actionMoveDown.setDisabled(!modifiable);
			this.actionMoveUp.setDisabled(!modifiable);
			if (modifiable) {
				var store = this.grid.getStore();
				if (store) {
					this.actionMoveDown.setDisabled(selectedRecord===store.last());
					this.actionMoveUp.setDisabled(selectedRecord===store.first());
				}
			}
		}
	},
	/**
	* Prepare adding/editing a system or custom list entry
	*/
	getListOptionWindowItems: function(node, canEdit) {
		//dialog for adding/editing a list option
		var windowItems = [CWHF.createTextField(
				'common.lbl.name', "label", {disabled:!canEdit, allowBlank:false, labelWidth:150})];
		//type flag combo
		windowItems.push(CWHF.createCombo('admin.customize.list.lbl.typeflag',
				"typeflag", {itemId:"typeflagsList", disabled:!canEdit, labelWidth:150}));
		return windowItems;
	},
	/**
	 * Load the combos after the result has arrived containing also the combo data sources
	 */
	postDataLoadCombos: function(data, panel) {
		if (panel.items.items) {
			Ext.Array.forEach(panel.items.items,function(item) {
				//for each combo-type control set the value also:
				//for a combos itemId <xxx>sList the json result should contain
				//both <xxx>sList for the combo datasource and <xxx> for the combo's actual value
				//the json field for value is
				if (item.xtype === "combo") {
					var comboSource = data[item.itemId];
					item.store.loadData(comboSource);
					//-'Lists'
					item.setValue(data[item.itemId.substring(0,item.itemId.length-5)]);
				}
			});
		}
	},
	/**
	 * The method to process the data to be loaded arrived from the server
	 */
	getEditPostDataProcess: function(record, isLeaf, add, fromTree, operation) {
		return this.postDataLoadCombos;
	},
	/**
	 * Get the panel items
	 * recordData: the record data (for the record to be edited or added to)
	 * isLeaf: whether add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * operation:  the name of the operation
	 */
	getPanelItems: function(recordData, isLeaf, add, fromTree, operation) {
		var nodeID = this.getRecordID(recordData, {fromTree:fromTree});
		var canEdit = false;
		if (operation==='add' || operation==='copy') {
			canEdit = true;
		} else {
			if (operation==='edit') {
				canEdit=recordData['modifiable'];
			}
		}
		return this.getListOptionWindowItems(nodeID, canEdit);
	},
	/**
	 * Handler for adding a node (folder or leaf)
	 */
	onAdd: function() {
		var operation = "add";
		var title = this.getTitle(this.getAddTitleKey(), {fromTree:true});
		var loadParams = this.getAddLeafParams();
		var submitParams = this.getAddLeafParams();
		var reloadParams = this.getAddReloadParamsAfterSave(true);
		var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
		var selectedRecord = this.getSingleSelectedRecord(true);
		return this.onAddEdit(title, selectedRecord, operation, true, true, true,
				loadParams, submitParams, reloadParams, reloadParamsFromResult);
	},
	/**
	 * Parameters for adding a new entry to a leaf:
	 * add a child to a leaf node: exclusively by extending custom selects:
	 * simple -> parent child or parent child -> parent child grandchild
	 * without explicitly asking for the exact type of the composite select
	 */
	/*protected*/getAddLeafParams: function() {
		//false as it would be added to a folder to send the leaf's id, not the parent folder's id
		return this.getAddParams(false);
	},
	/**
	 * Move the selected grid row up
	 */
	onMoveUpGridRow: function() {
		var gridRow = this.getLastSelectedGridRow();
		if (gridRow) {
			nodeID = gridRow.data.node;
			this.onOrderChange(this.getBaseAction() + "!moveUp.action", {node:nodeID});
		}
	},
	/**
	 * Move the selected grid row down
	 */
	onMoveDownGridRow: function() {
		var gridRow = this.getLastSelectedGridRow();
		if (gridRow) {
			var nodeID = gridRow.data.node;
			this.onOrderChange(this.getBaseAction() + "!moveDown.action", {node:nodeID});
		}
	},
	/**
	 * Private function foe changing the order by drag and drop or move up/down
	 */
	onOrderChange: function(url, params) {
		Ext.Ajax.request({
			url: url,
			disableCaching: true,
			scope: this,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				if (responseJson.success !== true) {
					Ext.MessageBox.alert(this.failureTitle, responseJson.errorMessage);
				}
				com.trackplus.util.RefreshAfterSubmit.refreshGridAndTreeAfterSubmit.call(this, {rowToSelect:responseJson.node});
			},
			failure: function(reponse){
				Ext.MessageBox.alert(this.failureTitle, reponse.responseText);
			},
			isUpload: false,
			method:'POST',
			params: params
		});
	},
	/**
	 * Reload after a change operation
	 */
	reload:com.trackplus.util.RefreshAfterSubmit.refreshGridAfterSubmit,
	/**
	 * Parameters for reloading after a delete operation
	 * By delete the reload and select parameters are known before
	 */
	/*protected abstract*/getReloadParamsAfterDelete: function(selectedRecords, extraConfig, responseJson) {
		return null;
	},
	/**
	 * Get the itemId of those actions whose context menu text or
	 * toolbar button tooltip should be changed according to the current selection
	 */
	getActionItemIdsWithContextDependentLabel: function() {
		return ["add", "editGridRow", "deleteGridRow", "moveUp", "moveDown"];
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 *
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var modifiable=selectedRecord.data['modifiable'];
		var actions = [];
		if (modifiable) {
			actions.push(this.actionAdd);
		}
		return actions;
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 *
	 */
	getGridContextMenuActions: function(selectedRecord, selectionIsSimple) {
		var modifiable=selectedRecord.data['modifiable'];
		var actions = [];
		if (modifiable) {
			actions.push(this.actionEditGridRow);
			actions.push(this.actionDeleteGridRow);
			var store = this.grid.getStore();
			if (store) {
				if (selectedRecord!==store.first()) {
					actions.push(this.actionMoveUp);
				}
				if (selectedRecord!==store.last()) {
					actions.push(this.actionMoveDown);
				}
			}
		}
		return actions;
	},
	onGridRowDblClick: function(view, record) {
		var modifiable = record.data['modifiable'];
		if (modifiable) {
			this.onEditGridRow();
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.project.ProjectConfig', {
	extend : 'com.trackplus.admin.TreeDetail',
	config : {
	    // the project tree from the admin navigation menu
	    projectTree : null,
	    rootID : null,
	    sys : true,
	    lastSelections : {},
	    isTemplate : false
	},
	hasPrivateProject : true,
	templateIsActive : false,
	baseAction : 'project',
	tabPanel: null,
	/**
	 * Ask for extra confirmation if the entity to be deleted
	 * has dependencies
	 */
	confirmDeleteNotEmpty : true,
	// subproject
	addAsSubproject : false,
	// by adding a project whether to add a private project
	addAsPrivateProject : false,
	// actions
	actionAddProject : null,
	actionAddSubproject : null,
	actionAddPrivateProject : null,
	actionCopyProject : null,
	actionCreateWorkspaceFromTemplate : null,
	actionCreateTemplateFromWorkspace : null,
	actionLockUnlock : null,
	actionSave : null,
	actionCancel : null,
	actionDelete : null,
	// force getToolbarActionsForTreeNodeSelect() because:
	// getToolbarActions() is called when selecting a project
	// and getToolbarActionsForTreeNodeSelect() is called after
	// selecting the fist project node (general)
	replaceToolbarOnTreeNodeSelect : true,
	roleAssignment : null,
	accountAssignment : null,
	phases : null,
	lists : null,
	filters : null,
	reportTemplates : null,
	screenConfig : null,
	fieldConfig : null,
	workflowConfig : null,
	automail : null,
	cockpit : null,
	versionControl : null,
	importFromMsProject : null,
	exportToMsProject : null,
	labelWidth : 200,
	textFieldWidth : 200 + 300,
	textFieldWidthShort : 200 + 150,
	textFieldWidthCheck : 200 + 80,
	FieldSetWidth : 250 + 300 + 150,
	alignR : "right",
	prefillByWidth : 200 + 350,
	protocolWidth : 200 + 350,
	securityConnectionWidth : 200 + 350,
	COPY_ACTION_WP_FROM_TPL : 0,
	COPY_ACTION_TPL_FROM_WP : 1,
	COPY_ACTION_COPY_TPL : 2,
	COPY_ACTION_COPY_WP : 3,
	constructor : function(config) {
	    var config = config || {};
	    this.initConfig(config);
	    // the actions are initialized asynchronously after
		// getting the localized labels:
	    // initialize the lists and phases directly to be sure
		// that the localized labels are available
	    // when actions are initialized on treeNodeSelect
	    this.lists = Ext.create('com.trackplus.admin.customize.list.ListConfig', {
	        fromProjectConfig : true
	    });
	    this.phases = Ext.create('com.trackplus.admin.project.Release', {
	        projectID : this.getRootID()
	    });
	    this.initBase(config);
	},
	GENERAL : 1,
	ASSIGN_ROLES : 2,
	PHASES : 3,
	LISTS : 4,
	FILTERS : 5,
	REPORT_TEMPLTATES : 6,
	SCREEN_ASSIGNMENT : 7,
	FIELD_CONFIGURATION : 8,
	ASSIGN_ACCOUNTS : 9,
	AUTOMAIL : 10,
	COCKPIT : 11,
	VERSION_CONTROL : 12,
	WORKFLOW : 13,
	EXPORT_TO_MSPROJECT : 14,
	IMPORT_FROM_MSPROJECT : 15,
	EMAIL_PROTOCOL : {
	    POP3 : 'pop3',
	    IMAP : 'imap'
	},
	SECURITY_CONNECTIONS_MODES : {
	    NEVER : 0,
	    TLS_IF_AVAILABLE : 1,
	    TLS : 2,
	    SSL : 3
	},
	DEFAULT_EMAIL_PORTS : {
	    POP3 : 110,
	    POP3_SSL : 995,
	    IMAP : 143,
	    IMAP_SSL : 993
	},
	PREFILL : {
	    LASTWORKITEM : 1,
	    PROJECTDEFAULT : 2
	},
	addOrEditProject:function(loadParams, submitParams, title, refreshScope, refreshMethod){
		var width = 800;
		var height = 650;
		var loadUrl = this.getDetailUrl();
		var load = {loadUrl:loadUrl, loadUrlParams:loadParams};
		var submitUrl = this.getBaseAction() + "!save.action";
		var submit = {
			submitUrl:submitUrl,
			submitUrlParams:submitParams,
			refreshParametersBeforeSubmit : {
	            refreshScope : refreshScope,
	            refreshMethod : refreshMethod
	        },
	        refreshAfterSubmitHandler : function(refreshParameters, result) {
	            refreshMethod.call(refreshScope);
	        }
		};
		var windowParameters = {title:title,
			width: width,
			height: height,
			load: load,
			submit: submit,
			items: this.getDetailItems(null, loadParams.add),
			postDataProcess: this.postDataLoadCombos
		};
		var windowConfig = Ext.create("com.trackplus.util.WindowConfig", windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	/**
	 * ******************Methods for project and all
	 * associated entities****************
	 */
	/**
	 * Handler for selecting a node in the tree
	 */
	treeNodeSelect : function(rowModel, node, index, opts) {
		var leaf = false;
	    var privateProject = false;
	    if (node ) {
	        // called for the select event of the tree
	        leaf = node.data['leaf'];
	        this.selectedNodeID = node.data['id'];
	        this.storeLastSelectedSection(this.selectedNodeID);
	        this.selectedNode = node;
	        privateProject = node.data['privateProject'];
	    }
	    var selectedNodeClass = this.getSelectedNodeClass(node);
	    if (this.getSelectedNodeIsTreeBased(node)) {
	        node = this.loadTreeWithGrid(selectedNodeClass, node);
	        // call the actualizeToolbarOnTreeSelect as the
			// rootNode of the new tree would be selected
	        this.actualizeToolbarOnTreeSelect.call(selectedNodeClass, node);
	    } else {
	        if (this.getSelectedNodeIsWizardBased(node) || this.getSelectedNodeIsDetailBased(node)) {
	            if (this.centerPanel ) {
	                this.mainPanel.remove(this.centerPanel, true);
	            }
	            if (this.getSelectedNodeIsWizardBased(node)) {
	                this.centerPanel = selectedNodeClass.getWizardPanel();
	            } else {
	                this.centerPanel = selectedNodeClass.getDetailPanel(node, leaf, opts);
	            }
	            this.mainPanel.add(this.centerPanel);
	            borderLayout.setActiveToolbarActionList(selectedNodeClass.getToolbarActions());
	        } else {
	            // project general
	            selectedNodeClass.loadDetailPanel(node, leaf, opts);
	            // false because at least one project exists
	            borderLayout.setActiveToolbarActionList(selectedNodeClass.getToolbarActions(true,
	                    privateProject));
	        }
	    }
	    // toolbar content
	    // call the actualizeToolbarOnTreeSelect of the main
		// base class: "this."
	    // (important by heterogeneous trees where
		// actualizeToolbarOnTreeSelect is overridden to
	    // completly replace the toolbar at any tree node
		// select)
	    // but the toolbar methods in the overridden method are
		// called according to the actual scope
	},
	loadTreeWithGrid : function(treeWithGridConfig, node) {
	    var branchRoot = null;
	    if (node ) {
	        branchRoot = node.data['branchRoot'];
	    }
	    if (this.centerPanel ) {
	        this.mainPanel.remove(this.centerPanel, true);
	    }
	    this.centerPanel = treeWithGridConfig.createCenterPanel();
	    this.mainPanel.add(this.centerPanel);
	    var rootNode = treeWithGridConfig.tree.getRootNode();
	    treeWithGridConfig.selectedNode = rootNode;
	    treeWithGridConfig.selectedNodeID = branchRoot;
	    borderLayout.setActiveToolbarActionList(treeWithGridConfig.getToolbarActions());
	    return rootNode;
	},
	/**
	 * Whether the node specific class is a treeWithGrid
	 * implementation
	 */
	getSelectedNodeIsTreeBased : function(node) {
	    var projectConfigType = node.data['id'];
	    switch (projectConfigType) {
	    case this.PHASES:
	    case this.ASSIGN_ROLES:
	    case this.LISTS:
	    case this.FILTERS:
	    case this.REPORT_TEMPLTATES:
	    case this.FIELD_CONFIGURATION:
	    case this.SCREEN_ASSIGNMENT:
	    case this.WORKFLOW:
	    case this.AUTOMAIL:
	        return true;
	    }
	    return false;
	},
	/**
	 * Whether the node specific class is a wizard
	 * implementation
	 */
	getSelectedNodeIsWizardBased : function(node) {
	    var projectConfigType = node.data['id'];
	    return projectConfigType === this.IMPORT_FROM_MSPROJECT;
	},
	/**
	 * Whether the node specific class is a wizard
	 * implementation
	 */
	getSelectedNodeIsDetailBased : function(node) {
	    var projectConfigType = node.data['id'];
	    if (projectConfigType === this.EXPORT_TO_MSPROJECT || projectConfigType === this.VERSION_CONTROL
	            || projectConfigType === this.COCKPIT || projectConfigType === this.ASSIGN_ACCOUNTS) {
	        return true;
	    }
	    return false;
	},
	/**
	 * Implement this method only if the tree contains
	 * heterogeneous data (like project/project type
	 * assignments) The specific methods on tree node selection
	 * should be called in the scope of the specific
	 * implementation Return the scope of the node specific
	 * implementation Additionally the locale tree and
	 * centerPanel objects are borrowed by the specific
	 * implementations (we do not initialize own tree for each
	 * specific implementation. An initialized (not null) tree
	 * is needed for the selection methods in tree in the
	 * context of a specific implementation and the centerPanel
	 * for rendering the data corresponding to the selected node
	 */
	getSelectedNodeClass : function(node) {
	    var projectConfigType = node.data['id'];
	    var branchRoot = node.data['branchRoot'];
	    var projectID = node.data['projectID'];
	    switch (projectConfigType) {
	    case this.GENERAL:
	        return this;
	    case this.PHASES:
	        this.phases.rootID = branchRoot;
	        return this.phases;
	    case this.ASSIGN_ROLES:
	        if (CWHF.isNull(this.roleAssignment)) {
	            this.roleAssignment = Ext.create("com.trackplus.admin.project.RoleAssignment", {
	                rootID : branchRoot,
	                treeWidth : 200
	            });
	        }
	        return this.roleAssignment;
	    case this.ASSIGN_ACCOUNTS:
	        if (CWHF.isNull(this.accountAssignment)) {
	            this.accountAssignment = Ext.create("com.trackplus.admin.SimpleAssignment", {
	                objectID : this.getRootID(),
	                objectIDParamName : "projectID"
	            });
	            this.accountAssignment.baseAction = "accountAssignments";
	        }
	        return this.accountAssignment;
	    case this.LISTS:
	        this.lists.setRootID(branchRoot);
	        return this.lists;
	    case this.FILTERS:
	        if (CWHF.isNull(this.filters)) {
	            this.filters = Ext.create('com.trackplus.admin.customize.category.CategoryConfig', {
	                rootID : branchRoot,
	                projectID : this.getRootID()
	            });
	        }
	        return this.filters;
	    case this.REPORT_TEMPLTATES:
	        if (CWHF.isNull(this.reportTemplates)) {
	            var branchRoot = node.data['branchRoot'];
	            this.reportTemplates = Ext.create(
	                    'com.trackplus.admin.customize.category.CategoryConfig', {
	                        rootID : branchRoot,
	                        projectID : this.getRootID()
	                    });
	        }
	        return this.reportTemplates;
	    case this.FIELD_CONFIGURATION:
	        if (CWHF.isNull(this.fieldConfig)) {
	            var branchRoot = node.data['branchRoot'];
	            this.fieldConfig = Ext.create('com.trackplus.admin.customize.treeConfig.FieldConfig', {
	                rootID : branchRoot,
	                fromProjectConfig : true
	            });
	        }
	        return this.fieldConfig;
	    case this.SCREEN_ASSIGNMENT:
	        if (CWHF.isNull(this.screenConfig)) {
	            var branchRoot = node.data['branchRoot'];
	            this.screenConfig = Ext.create('com.trackplus.admin.customize.treeConfig.ScreenConfig',
	                    {
	                        rootID : branchRoot,
	                        fromProjectConfig : true
	                    });
	        }
	        return this.screenConfig;
	    case this.AUTOMAIL:
	        if (CWHF.isNull(this.automail)) {
	            this.automail = Ext.create('com.trackplus.admin.NotifyConfig', {
	                defaultSettings : true,
	                exclusiveProjectID : this.getRootID()
	            });
	        }
	        return this.automail;
	    case this.COCKPIT:
	        if (CWHF.isNull(this.cockpit)) {
	            this.cockpit = Ext.create('com.trackplus.admin.project.ProjectCockpit', {
	                projectID : this.getRootID()
	            });
	        }
	        return this.cockpit;
	    case this.VERSION_CONTROL:
	        if (CWHF.isNull(this.versionControl)) {
	            this.versionControl = Ext.create('com.trackplus.vc.VersionControlFacade', {
	            	versionControlFacadeModel: {
	                    projectID : this.getRootID()
	                }
	            });
	        }
	        return this.versionControl;
	    case this.WORKFLOW:
	        if (CWHF.isNull(this.workflowConfig)) {
	            var branchRoot = node.data['branchRoot'];
	            this.workflowConfig = Ext.create(
	                    'com.trackplus.admin.customize.treeConfig.WorkflowConfig', {
	                        rootID : branchRoot,
	                        fromProjectConfig : true,
	                        projectOrProjectTypeID : projectID
	                    });
	        }
	        return this.workflowConfig;
	    case this.EXPORT_TO_MSPROJECT:
	        if (CWHF.isNull(this.exportToMsProject)) {
	            this.exportToMsProject = Ext.create('com.trackplus.admin.action.ExportMsProject', {
	                projectID : this.getRootID()
	            });
	        }
	        return this.exportToMsProject;
	    case this.IMPORT_FROM_MSPROJECT:
	        if (CWHF.isNull(this.importFromMsProject)) {
	            this.importFromMsProject = Ext.create('com.trackplus.admin.action.ImportMsProject', {
	                projectID : this.getRootID()
	            });
	        }
	        return this.importFromMsProject;
	    }
	},
	/**
	 * Gets the tree's fields: all fields for all possible
	 * config types
	 */
	getTreeFields : function() {
	    return [ {
	        name : 'id',
	        mapping : 'id',
	        type : 'int'
	    }, {
	        name : 'text',
	        mapping : 'text',
	        type : 'string'
	    }, {
	        name : 'leaf',
	        mapping : 'leaf',
	        type : 'boolean'
	    }, {
	        name : 'iconCls',
	        mapping : 'iconCls',
	        type : 'string'
	    }, {
	        name : 'projectID',
	        mapping : 'projectID',
	        type : 'int'
	    }, {
	        name : 'privateProject',
	        mapping : 'privateProject',
	        type : 'boolean'
	    }, {
	        name : 'branchRoot',
	        mapping : 'branchRoot',
	        type : 'string'
	    } ];
	},
	/**
	 * ****************Methods strictly for project
	 * CRUD********************
	 */
	/**
	 * The localized entity name
	 */
	getEntityLabel : function(extraConfig) {
	    if (this.getIsTemplate()) {
	        return getText('admin.project.lbl.templateForOp');
	    } else {
	        return getText('admin.project.lbl.projectForOp');
	    }
	},
	/**
	 * The iconCls for the add button, overwrites base class
	 * icon
	 */
	getAddIconCls : function() {
	    return 'projecttAdd';
	},
	/**
	 * The iconCls for the edit button, overwrites base class
	 * icon
	 */
	getSaveIconCls : function() {
	    return 'projecttSave';
	},
	getAddSubprojectLabel : function() {
	    return getText(this.getAddTitleKey(), getText("admin.project.lbl.subproject"));
	},
	getAddPrivateProjectLabel : function() {
	    return getText(this.getAddTitleKey(), getText("admin.project.lbl.privateProject"));
	},
	getCopyToButtonKey : function() {
	    return "common.btn.copyTo";
	},
	/**
	 * Initialization method
	 */
	initBase: function(config) {
	    Ext.Ajax.request({
	        url : this.getBaseAction() + '!getWorkspaceAndTemplateToolbarConfig.action',
	        params : {
	            projectID : this.getRootID()
	        },
	        fromCenterPanel : true,
	        scope : this,
	        success : function(response) {
	            var result = Ext.decode(response.responseText);
	            this.hasPrivateProject = result.hasPrivateWorkspace;
	            this.templateIsActive = result.templateIsActive;
	            this.initActions();
	        },
	        failure : function(response) {
	            Ext.MessageBox.alert(this.failureTitle, response.responseText);
	        }
	    });
	},
	initActions : function() {
	    this.actionAddProject = this.createLocalizedAction(this.getTitle(this.getAddTitleKey()), this
	            .getAddIconCls(), this.onAddProject, this.getTitle(this.getAddTitleKey()));
	    this.actionAddSubproject = this.createLocalizedAction(this.getAddSubprojectLabel(), this
	            .getAddIconCls(), this.onAddSubproject, this.getAddSubprojectLabel());
	    this.actionAddPrivateProject = this.createLocalizedAction(this.getAddPrivateProjectLabel(),
	            this.getAddIconCls(), this.onAddPrivateProject,
	            getText("admin.project.lbl.privateProject.tt"));
	    this.actionCopyProject = this.createLocalizedAction(getText(this.getCopyButtonKey()), this
	            .getCopyIconCls(), this.onCopy, this.getTitle(this.getCopyTitleKey()));
	    this.actionCreateWorkspaceFromTemplate = this.createLocalizedAction(
	            getText('admin.project.lbl.spaceFromTemplate'), this.getCopyIconCls(),
	            this.onCreateFromCopy, getText('admin.project.lbl.spaceFromTemplate'));
	    this.actionCreateTemplateFromWorkspace = this.createLocalizedAction(
	            getText('admin.project.lbl.templateFromSpace'), this.getCopyIconCls(),
	            this.onCreateFromCopy, getText('admin.project.lbl.templateFromSpace'));
	    this.actionLockUnlock = this.createLocalizedAction(this.getTemplateLockUnlockLabel(), this
	            .getTemplateLockUnlockIcon(), this.onLockUnlock, this.getTemplateLockUnlockToolTip());
	    this.actionSave = this.createLocalizedAction(getText('common.btn.save'), this.getSaveIconCls(),
	            this.onSave, this.getTitle('common.lbl.save'));
	    this.actionCancel = this.createLocalizedAction(getText('common.btn.cancel'), 'cancel',
	            this.onCancel, getText('common.btn.cancel'));
	    this.actionDelete = this.createLocalizedAction(getText('common.btn.delete'), this
	            .getDeleteIconCls(), this.onDelete, this.getTitle('common.lbl.delete'));
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 * noProject no project exists for this user privateProject
	 * the selected project is private project
	 */
	getToolbarActions : function(projectIsSelected, privateProjectIsSelected) {
	    var actions = [];
	    if (this.getSys()) {
	        actions.push(this.actionAddProject);
	    }
	    if (com.trackplus.TrackplusConfig.appType!==APPTYPE_BUGS && projectIsSelected && privateProjectIsSelected && !privateProjectIsSelected) {
	        actions.push(this.actionAddSubproject);
	    }
	    if (!this.hasPrivateProject && com.trackplus.TrackplusConfig.user.privateWorkspace
	            && !this.getIsTemplate()) {
	        actions.push(this.actionAddPrivateProject);
	    }
	    if (projectIsSelected && privateProjectIsSelected  && !privateProjectIsSelected) {
	        actions.push(this.actionCopyProject);
	    }
	    if (projectIsSelected) {
	        if (this.getIsTemplate()) {
	            actions.push(this.actionCreateWorkspaceFromTemplate);
	            actions.push(this.actionLockUnlock);
	        } else {
	            actions.push(this.actionCreateTemplateFromWorkspace);
	        }
	    }
	    if (projectIsSelected) {
	        actions.push(this.actionSave);
	        actions.push(this.actionDelete);
	    }
	    return actions;
	},
	/**
	 * Handler after loading the node: select the general node
	 * after loading the root's children
	 */
	onTreeNodeLoad : function(treeStore, node) {
	    var me = this;
	    // select the first child (general settings)
	    if (node.isRoot()) {
	        var selectedNode = null;
	        if (me.getLastSelections().lastSelectedSection ) {
	            selectedNode = treeStore.getNodeById(me.getLastSelections().lastSelectedSection);
	        }
	        if (CWHF.isNull(selectedNode)) {
	            selectedNode = node.firstChild;
	        }
	        var treeSelectionModel = this.tree.getSelectionModel();
	        treeSelectionModel.select(selectedNode);
	    }
	},
	/**
	 * Prepare the form for adding a new project
	 */
	onAddProject : function() {
	    this.onAdd(false, false);
	},
	/**
	 * Prepare the form for adding a new project
	 */
	onAddSubproject : function() {
	    this.onAdd(true, false);
	},
	onAddPrivateProject : function() {
	    this.onAdd(false, true);
	},
	onAdd : function(addAsSubproject, addAsPrivateProject) {
	    this.addAsSubproject = addAsSubproject;
	    this.addAsPrivateProject = addAsPrivateProject;
	    this.mainPanel = Ext.create('Ext.panel.Panel', {
	        layout : 'border',
	        //region : 'center',
	        border : false,
	        items : []
	    });
	    borderLayout.borderLayoutController.setCenterContent(this.mainPanel);
	    this.loadDetailPanelWithFormLoad(null, true, {
	        addAsSubproject : addAsSubproject,
	        addAsPrivateProject : addAsPrivateProject
	    });
	    borderLayout.setActiveToolbarActionList(this.getToolbarActionsForTreeNodeSelect());
	},
	onCopy : function() {
	    var projectCopyModel = {
	        projectID : this.getRootID()
	    };
	    var actionTarget = this.COPY_ACTION_COPY_WP;
	    if (this.getIsTemplate()) {
	        actionTarget = this.COPY_ACTION_COPY_TPL;
	    }
	    var projectCopyController = Ext.create('com.trackplus.admin.project.ProjectCopyController', {
	    	dataModel: projectCopyModel,
	        projectConfig: this,
	        isTemplate: this.getIsTemplate(),// copy template or
											// workspace
	        applyTemplate : false,
	        actionTarget : actionTarget
	    });
	    projectCopyController.showDialog();
	},
	onCreateFromCopy : function() {
	    var projectCopyModel = {
	        projectID : this.getRootID()
	    };
	    var actionTarget = this.COPY_ACTION_TPL_FROM_WP;
	    if (this.getIsTemplate()) {
	        actionTarget = this.COPY_ACTION_WP_FROM_TPL;
	    }
	    var projectCopyController = Ext.create('com.trackplus.admin.project.ProjectCopyController', {
	    	dataModel: projectCopyModel,
	        projectConfig: this,
	        isTemplate: false, // applying this template
	        applyTemplate: true,
	        actionTarget: actionTarget
	    });
	    projectCopyController.showDialog();
	},
	onLockUnlock : function() {
	    Ext.Ajax.request({
	        url : this.getBaseAction() + '!changeTemplateState.action',
	        params : {
	            projectID : this.getRootID()
	        },
	        scope : this,
	        success : function(response) {
	            var result = Ext.decode(response.responseText);
	            var data = result.data;
	            var success = result.success;
	            if (success) {
	                this.templateIsActive = data.templateIsActive;
	                this.actionLockUnlock.setText(this.getTemplateLockUnlockLabel());
	                this.actionLockUnlock.setIconCls(this.getTemplateLockUnlockIcon());
	            } else {
	                Ext.MessageBox.alert(this.failureTitle,
	                        getText('admin.project.lbl.changeTemplateStateError'));
	            }
	        },
	        failure : function(response) {
	            Ext.MessageBox.alert(this.failureTitle, response.responseText);
	        }
	    });
	},
	onCancel : function() {
	    var selectionModel = this.getProjectTree().getSelectionModel();
	    var lastSelected = selectionModel.getLastSelected();
	    if (lastSelected ) {
	        selectionModel.select(lastSelected);
	        com.trackplus.admin.myClick(this.getProjectTree(), lastSelected);
	    } else {
	        // cancel when no project is selected: no project
			// exists for the user
	        borderLayout.controller.setCenterContent(null);
	        borderLayout.setActiveToolbarActionList(this.getToolbarActions(false));
	    }
	},
	onSave : function(button, event) {
	    this.saveProject(false);
	},
	/**
	 * Save the detail part
	 */
	saveProject : function(confirmSave) {
	    var me = this;
	    borderLayout.setLoading(true);
	    this.clearErrorTabs();
	    var params = {
	        projectID : this.getRootID(),
	        addAsSubproject : this.addAsSubproject,
	        addAsPrivateProject : this.addAsPrivateProject,
	        isTemplate : this.getIsTemplate()
	    };
	    if (confirmSave ) {
	        params['confirmSave'] = confirmSave;
	    }
	    this.centerPanel.getForm().submit({
	        url : this.getBaseAction() + '!save.action',
	        params : params,
	        scope : this,
	        success : function(form, action) {
	            borderLayout.setLoading(false);
	            var result = action.result;
	            if (result.success) {
	                this.reload(result);
	                var projectNodeToSelect = result['projectNodeToSelect'];
	                this.setRootID(projectNodeToSelect);
	                CWHF.showMsgInfo(getText('admin.project.successSave'));
	            } else {
	                errorHandlerSave(result);
	            }
	        },
	        failure : function(form, action) {
	            borderLayout.setLoading(false);
	            result = action.result;
	            if (result ) {
	                if (action.result  && action.result.errors ) {
	                    me.handleErrors(action.result.errors);
	                } else {
	                    var errorCode = result.errorCode;
	                    var title = result.title;
	                    if (errorCode  && errorCode === 4) {
	                        // 4===NEED_CONFIRMATION
	                        var errorMessage = result.errorMessage;
	                        Ext.MessageBox.confirm(title, errorMessage, function(btn) {
		                        if (btn === "no") {
			                        return false;
		                        } else {
			                        this.saveProject(true);
		                        }
	                        }, this);
	                    } else {
	                        com.trackplus.util.submitFailureHandler(form, action);
	                    }
	                }
	            } else {
	                CWHF.showMsgError(getText('admin.project.err.errorSave'));
	            }
	        }
	    });
	},
	onDelete : function() {
	    var selectedRecord = this.getProjectTree().getSelectionModel().getLastSelected();
	    if (selectedRecord ) {
	        var extraConfig = {
	            fromTree : true,
	            isLeaf : false
	        };
	        this.deleteHandler(selectedRecord, extraConfig);
	    }
	},
	/**
	 * This method returns the proper flag for reloading: or the
	 * project tree (===true) or the template project tree
	 * (===false)
	 */
	reloadProjectTree : function(actionTarget) {
	    switch (actionTarget) {
	    case this.COPY_ACTION_COPY_WP:
	    case this.COPY_ACTION_WP_FROM_TPL:
	        return true;
	        break;
	    case this.COPY_ACTION_TPL_FROM_WP:
	    case this.COPY_ACTION_COPY_TPL:
	        return false;
	        break;
	    default:
	        return true;
	    }
	},
	/**
	 * This method handles reloading the proper tree item
	 * (project or template) based on actionTarget parameter:
	 * For ex: when creating a template from workspace: the
	 * workspace node must collapse, the template node must
	 * expand with selecting the newly created node.
	 */
	reloadAfterApplyingTemplate : function(refreshParamsObject, actionTarget) {
	    var templateTree = Ext.getCmp('tree-projectTemplateTreePanel');
	    var projectTree = Ext.getCmp('tree-projectTreePanel');
	    if (actionTarget === this.COPY_ACTION_WP_FROM_TPL) {
	        Ext.getCmp('projectTreePanel').expand();
	        templateTree.getSelectionModel().deselectAll();
	    }
	    if (actionTarget === this.COPY_ACTION_TPL_FROM_WP) {
	        Ext.getCmp('projectTemplateTreePanel').expand();
	        projectTree.getSelectionModel().deselectAll();
	    }
	    var reloadProjectTree = refreshParamsObject['reloadProjectTree'];
	    var projectNodeToSelect = refreshParamsObject['projectNodeToSelect'];
	    var projectNodeToReload = refreshParamsObject['projectNodeToReload'];
	    var deletedProjectID = refreshParamsObject['deletedProjectID'];
	    // tree reload is needed: after delete, add and edit
		// with label change
	    var options = new Object();
	    if (projectNodeToReload ) {
	        var nodeToReload = null;
	        if (this.reloadProjectTree(actionTarget)) {
	            nodeToReload = projectTree.getStore().getNodeById(projectNodeToReload);
	        } else {
	            nodeToReload = templateTree.getStore().getNodeById(projectNodeToReload);
	        }
	        // if null reload the branch i.e. the main projects
	        options.node = nodeToReload;
	    }
	    if (CWHF.isNull(projectNodeToSelect)) {
	        // after deleting a main project
	        var rootNode = null;
	        if (this.reloadProjectTree(actionTarget)) {
	            rootNode = projectTree.getRootNode();
	        } else {
	            rootNode = templateTree.getRootNode();
	        }
	        if (rootNode  && rootNode.childNodes  && rootNode.childNodes.length > 0) {
	            var firstChild = rootNode.getChildAt(0);
	            if (deletedProjectID  && firstChild.data['id'] === deletedProjectID) {
	                if (rootNode.childNodes.length > 1) {
	                    var secondChild = rootNode.getChildAt(1);
	                    projectNodeToSelect = secondChild.data['id'];
	                }
	            } else {
	                projectNodeToSelect = firstChild.data['id'];
	            }
	        }
	    }
	    options.callback = this.selectNode;
	    if (this.reloadProjectTree(actionTarget)) {
	        options.scope = {
	            tree : projectTree,
	            nodeIdToReload : projectNodeToReload,
	            nodeIdToSelect : projectNodeToSelect,
	            scope : this,
	            expandWorkspaceNode : true
	        };
	        projectTree.getStore().load(options);
	    } else {
	        options.scope = {
	            tree : templateTree,
	            nodeIdToReload : projectNodeToReload,
	            nodeIdToSelect : projectNodeToSelect,
	            scope : this,
	            expandWorkspaceNode : true
	        };
	        templateTree.getStore().load(options);
	    }
	},
	/**
	 * Reload after save or delete
	 */
	reload : function(refreshParamsObject) {
	    var reloadProjectTree = refreshParamsObject['reloadProjectTree'];
	    var projectNodeToSelect = refreshParamsObject['projectNodeToSelect'];
	    var projectNodeToReload = refreshParamsObject['projectNodeToReload'];
	    var reloadProjectConfigTree = refreshParamsObject['reloadProjectConfigTree'];
	    var projectConfigTypeNodeToSelect = refreshParamsObject['projectConfigTypeNodeToSelect'];
	    var deletedProjectID = refreshParamsObject['deletedProjectID'];
	    if (!reloadProjectTree && reloadProjectConfigTree && this.tree ) {
	        // this.tree is null by add
	        // only after save
	        var options = new Object();
	        if (projectConfigTypeNodeToSelect ) {
	            // callback after load
	            options.callback = this.selectNode;
	            // options.node = projectNodeToSelect;
	            // scope for callback
	            options.scope = {
	                tree : this.tree,
	                nodeIdToSelect : projectConfigTypeNodeToSelect
	            };
	        }
	        this.tree.getStore().load(options);
	    }
	    if (reloadProjectTree) {
	        // tree reload is needed: after delete, add and edit
			// with label change
	        var options = new Object();
	        if (projectNodeToReload ) {
	            var nodeToReload = this.getProjectTree().getStore().getNodeById(projectNodeToReload);
	            // if null reload the branch i.e. the main
				// projects
	            options.node = nodeToReload;
	        }
	        if (CWHF.isNull(projectNodeToSelect)) {
	            // after deleting a main project
	            var rootNode = this.getProjectTree().getRootNode();
	            if (rootNode  && rootNode.childNodes  && rootNode.childNodes.length > 0) {
	                var firstChild = rootNode.getChildAt(0);
	                if (deletedProjectID  && firstChild.data['id'] === deletedProjectID) {
	                    if (rootNode.childNodes.length > 1) {
		                    var secondChild = rootNode.getChildAt(1);
		                    projectNodeToSelect = secondChild.data['id'];
	                    } /*
							 * else { //the last project was
							 * selected this.rootID = null;
							 * this.onCancel(); }
							 */
	                } else {
	                    projectNodeToSelect = firstChild.data['id'];
	                }
	            }
	        }
	        // if (projectNodeToSelect) {
	        // callback after load
	        options.callback = this.selectNode;
	        // scope for callback
	        options.scope = {
	            tree : this.getProjectTree(),
	            nodeIdToReload : projectNodeToReload,
	            nodeIdToSelect : projectNodeToSelect,
	            scope : this,
	            expandWorkspaceNode : false
	        };
	        // }
	        this.getProjectTree().getStore().load(options);
	    }
	},
	selectNode : function() {
	    if (this.nodeIdToReload ) {
	        nodeReloaded = this.tree.getStore().getNodeById(this.nodeIdToReload);
	        if (nodeReloaded  && !nodeReloaded.isExpanded()) {
	            nodeReloaded.expand();
	        }
	    }
	    if (this.nodeIdToSelect ) {
	        var nodeToSelect = this.tree.getStore().getNodeById(this.nodeIdToSelect);
	        if (nodeToSelect ) {
	            var selectionModel = this.tree.getSelectionModel();
	            selectionModel.select(nodeToSelect);
	            com.trackplus.admin.myClick(this.tree.getView(), nodeToSelect);
	        }
	    } else {
	        // no node to select -> no project
	        borderLayout.controller.setCenterContent(null);
	        borderLayout.setActiveToolbarActionList(this.scope.getToolbarActions(false));
	    }
	},
	/**
	 * Parameters for deleting entity recordData: the selected
	 * entity data Even if there is more than one entity
	 * selected for delete this method is called for each
	 * selected entity separately extraConfig: for simple grid
	 * nothing, for tree with grid {fromTree:fromTree,
	 * isLeaf:isLeaf}
	 */
	getDeleteParams : function(selectedRecords, extraConfig) {
	    var deleteParams = this.callParent(arguments);
	    deleteParams['projectID'] = this.getRootID();
	    return deleteParams;
	},
	/**
	 * By selecting the General node
	 */
	getToolbarActionsForTreeNodeSelect : function(selectedNode) {
	    return [ this.actionSave, this.actionCancel ];
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	getDetailUrl : function(node, add) {
	    return this.getBaseAction() + '!load.action';
	},
	/**
	 * Gets the URL for loading the node detail
	 */
	getDetailParams : function(node, add, extraDetailParameters) {
	    var detailParams = null;
	    if (CWHF.isNull(extraDetailParameters)) {
	        detailParams = new Object();
	    } else {
	        detailParams = extraDetailParameters;
	    }
	    detailParams['projectID'] = this.getRootID();
	    detailParams['add'] = add;
	    // return {projectID:this.rootID, add:add};
	    return detailParams;
	},
	/**
	 * The method to process the data to be loaded arrived from
	 * the server
	 */
	getEditPostDataProcess : function(record, isLeaf, add) {
	    return this.postDataLoadCombos;
	},
	/**
	 * Gets a control by the path according to the "arguments"
	 * starting form the main tab panel
	 */
	getControl : function() {
	    return CWHF.getControl.apply(this.tabPanel, arguments);
	},
	getHelpWrapper : function() {
	    return CWHF.getHelpWrapper.apply(this.tabPanel, arguments);
	},
	getWrappedControl : function() {
	    return CWHF.getWrappedControl.apply(this.tabPanel, arguments);
	},
	/**
	 * Load the combos after the result has arrived containing
	 * also the combo data sources
	 */
	postDataLoadCombos : function(data, panel) {
	    // project main
		var me = this;
	    var mainTab = this.getControl("mainTab");
	    var projectType = this.getWrappedControl("mainTab", "fsbasic", "projectType");
	    projectType.store.loadData(data['projectTypeList']);
	    projectType.setValue(data['projectBaseTO.projectTypeID']);
	    // add the change listener only here: if it would be
		// added by form creation by setting
	    // the listenerConfig parameter the setValue() above
		// would trigger
	    // onProjectTypeOrIssueTypeChange which is not desirable
	    projectType.on('change', this.onProjectTypeOrIssueTypeChange, this);
	    if (!this.getIsTemplate()) {
	        var projectStatus = this.getWrappedControl("mainTab", "fsbasic", "projectStatus");
	        projectStatus.store.loadData(data['projectStatusList']);
	        projectStatus.setValue(data['projectBaseTO.projectStatusID']);
	    }
	    var hasPrefix = data['hasPrefix'];
	    if (hasPrefix) {
	    	var workspacePrefixTxtBoxChangeObj = {};
	    	workspacePrefixTxtBoxChangeObj.change = function(txtBox, newValue, oldValue, eOpts) {
        		me.checkNewWorkspacePrefix(txtBox, newValue, me.getRootID());
	    	};
	    	mainTab.add({
	            xtype : 'fieldset',
	            itemId : 'fsprefix',
	            width : this.FieldSetWidth,
	            title : getText('admin.project.lbl.prefix'),
	            collapsible : false,
	            defaults : {
	                anchor : '100%'
	            },
	            layout : 'anchor',
	            items : [ CWHF.createTextFieldWithHelp('admin.project.lbl.prefix',
	                    'projectBaseTO.prefix', {
	                        width : this.textFieldWidthShort,
	                        value : data['projectBaseTO.prefix'],
	                        allowBlank : false,
	                        readOnly: data['projectBaseTO.projectTypeID'] < 0
	                    }, workspacePrefixTxtBoxChangeObj)]
	        });
	    }
	    var hasAccounting = data['hasAccounting'];
	    if (hasAccounting) {
	        this.addAccountingFieldSet(data, mainTab);
	    }
	    var hasRelease = data['hasRelease'];
	    if (hasRelease) {
	        this.addReleaseFieldSet(data, mainTab);
	    }
	    // default tab
	    var defaultManager = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultManagerID");
	    defaultManager.store.loadData(data['managerList']);
	    defaultManager.setValue(data['projectDefaultsTO.defaultManagerID']);
	    var defaultResponsible = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultResponsibleID");
	    defaultResponsible.store.loadData(data['responsibleList']);
	    defaultResponsible.setValue(data['projectDefaultsTO.defaultResponsibleID']);
	    var defaultIssueType = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultIssueTypeID");
	    defaultIssueType.store.loadData(data['issueTypeList']);
	    defaultIssueType.setValue(data['projectDefaultsTO.defaultIssueTypeID']);
	    // add the change listener only here: if it would be
		// added by form creation by setting
	    // the listenerConfig parameter the setValue() above
		// would trigger
	    // onProjectTypeOrIssueTypeChange which is not desirable
	    defaultIssueType.on('change', this.onProjectTypeOrIssueTypeChange, this);
	    var defaultPriority = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultPriorityID");
	    defaultPriority.store.loadData(data['priorityList']);
	    defaultPriority.setValue(data['projectDefaultsTO.defaultPriorityID']);
	    var defaultSeverity = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultSeverityID");
	    defaultSeverity.store.loadData(data['severityList']);
	    defaultSeverity.setValue(data['projectDefaultsTO.defaultSeverityID']);
	    // add the initial statuses for issueTypes only when the
		// data has arrived
	    var fsInitSt = this.getControl("defaultTab", "fsInitSt");
	    var initialStatus = this.getWrappedControl("defaultTab", "fsInitSt",
	            "projectDefaultsTOInitialStatusID");
	    initialStatus.store.loadData(data['statusList']);
	    initialStatus.setValue(data['projectDefaultsTO.initialStatusID']);
	    initStItems = [];
	    var initStatusData = data['initStatuses'];
	    if (initStatusData ) {
	        Ext.Array.forEach(initStatusData, function(item) {
	            var issueType = item['issueType'];
	            var status = item['status'];
	            var active = item['active'];
	            var statusList = item['statusList'];
	            var comboName = 'projectDefaultsTO.issueTypeToInitStatusMap[' + issueType + ']';
	            if (issueType < 0) {
	                comboName = 'projectDefaultsTO.issueTypeNegativeToInitStatusMap[' + (-issueType)
	                        + ']';
	            }
	            var comboControl = CWHF.createCombo(item['label'], comboName, {
	                value : status,
	                labelWidth : this.labelWidth - 40,
	                width : this.textFieldWidth - 60,
	                data : statusList,
	                disabled : !active,
	                labelIsLocalized : true
	            });
	            var issueTypePanel = new Ext.Panel({
	                border : false,
	                defaults : {
	                    margin : "4 4 0 0"
	                },
	                margin : "0 10 3 80",
	                layout : {
	                    type : 'hbox'
	                },
	                itemId : 'issueTypePanel' + issueType,
	                items : [ CWHF.createCheckbox('', '', {
	                    value : active,
	                    width : 20
	                }, {
	                    change : {
	                        fn : this.onStatusForIssueTypeChange,
	                        scope : this,
	                        comboControl : comboControl
	                    }
	                }), comboControl ]
	            });
	            initStItems.push(issueTypePanel);
	        }, this);
	        fsInitSt.add(initStItems);
	    }
	    var errors = data.errors;
	    this.markInvalidByErrors(errors, panel);
	    /*
		 * if (errors) { var accountErrorMessage =
		 * errors['projectBaseTO.defaultAccount']; if
		 * (accountErrorMessage) { var defaultAccount =
		 * this.getWrappedControl("mainTab", "fsacc",
		 * "projectBaseTO.defaultAccount")
		 * defaultAccount.markInvalid(accountErrorMessage); }
		 * else { var managerErrorMessage =
		 * errors['projectDefaultsTO.defaultManagerID']; if
		 * (managerErrorMessage) {
		 * defaultManager.markInvalid(managerErrorMessage); }
		 * var responsibleErrorMessage =
		 * errors['projectDefaultsTO.defaultResponsiblID']; if
		 * (responsibleErrorMessage) {
		 * defaultResponsible.markInvalid(responsibleErrorMessage); }
		 * var statusErrorMessage =
		 * errors['projectDefaultsTO.initialStatusID']; if
		 * (statusErrorMessage) {
		 * initialStatus.markInvalid(statusErrorMessage); } var
		 * issueTypeErrorMessage =
		 * errors['projectDefaultsTO.defaultIssueTypeID']; if
		 * (issueTypeErrorMessage) {
		 * defaultIssueType.markInvalid(issueTypeErrorMessage); }
		 * var priorityErrorMessage =
		 * errors['projectDefaultsTO.defaultPriorityID']; if
		 * (priorityErrorMessage) {
		 * defaultPriority.markInvalid(priorityErrorMessage); }
		 * var severityErrorMessage =
		 * errors['projectDefaultsTO.defaultSeverityID']; if
		 * (severityErrorMessage) {
		 * defaultSeverity.markInvalid(severityErrorMessage); }
		 * var tabPanel = panel.getComponent('tabPanel');
		 * tabPanel.setActiveTab(defaultTab); } }
		 */
	    // email tab
	    if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
	        var eoutValue = this.getWrappedControl("emailTab", "fsout",
	                "projectEmailTOSendFromProjectEmail").getValue();
	        this.enableEmailOutFields(eoutValue);
	        var emailEnabled = this.getWrappedControl("emailTab", "fseserv", "projectEmailTOEnabled");
	        this.onChangeEmailEnabled(emailEnabled, emailEnabled.getValue());
	    }
	},
	checkNewWorkspacePrefix: function(txtBox, newValue, projectID) {
		Ext.Ajax.request({
	        url : "	project!validateProjectPrefix.action",
	        disableCaching : true,
	        success : function(result) {
	        	var jsonData = Ext.decode(result.responseText);
	        	if(jsonData.projectPrefixExists) {
	        		txtBox.markInvalid(getText('common.err.duplicatePrefix'));
	        	}
	        },
	        failure : function() {
	        },
	        method : 'POST',
	        params : {'projectBaseTO.prefix': newValue, 'projectID': projectID}
	    });
	},
	markInvalidByErrors : function(errors, panel) {
	    var accountErrorFound = false;
	    var systemListErrorFound = false;
	    if (errors ) {
	        var accountErrorMessage = errors['projectBaseTO.defaultAccount'];
	        if (accountErrorMessage ) {
	            var defaultAccount = this.getWrappedControl("mainTab", "fsacc",
	                    "projectBaseTO.defaultAccount");
	            defaultAccount.markInvalid(accountErrorMessage);
	            accountErrorFound = true;
	        }
	        var defaultSystemListIDs = [ "projectDefaultsTODefaultManagerID",
	                "projectDefaultsTODefaultResponsiblID", "projectDefaultsTOInitialStatusID",
	                "projectDefaultsTODefaultIssueTypeID", "projectDefaultsTODefaultPriorityID",
	                "projectDefaultsTODefaultSeverityID" ];
	        Ext.Array.forEach(defaultSystemListIDs, function(item) {
	            var errorMessage = errors[item];
	            if (errorMessage ) {
	                var control = this.getWrappedControl("defaultTab", "fsdef", item);
	                if (control ) {
	                    if (!systemListErrorFound) {
		                    systemListErrorFound = true;
	                    }
	                    control.markInvalid(errorMessage);
	                }
	            }
	        }, this);
	        if (!accountErrorFound && systemListErrorFound) {
	            var tabPanel = panel.getComponent('tabPanel');
	            tabPanel.setActiveTab('defaultTab');
	        }
	        /*
			 * var tabBar=tabPanel.getTabBar(); var
			 * headerCm=tabBar.getComponent(1);
			 * headerCm.addCls("errorTab");
			 */
	    }
	},
	addAccountingFieldSet : function(data, mainTab) {
	    var subproject = data["subproject"];
	    var accountingInherited = data["projectAccountingTO.accountingInherited"];
	    var workTracking = data["projectAccountingTO.workTracking"];
	    var costTracking = data["projectAccountingTO.costTracking"];
	    var items = [];
	    if (this.addAsSubproject || subproject) {
	        items.push(CWHF.createCheckboxWithHelp("admin.project.lbl.accountingInherited",
	                "projectAccountingTO.accountingInherited", {
	                    width : this.textFieldWidthCheck,
	                    value : accountingInherited
	                }, {
	                    change : {
	                        fn : this.onAccountingInheritedChange,
	                        scope : this
	                    }
	                }));
	    }
	    items.push(CWHF.createCheckboxWithHelp("admin.project.lbl.work",
	            "projectAccountingTO.workTracking", {
	                width : this.textFieldWidthCheck,
	                value : workTracking,
	                itemId: 'projectAccountingTOWorkTracking'
	            }, {
	                change : {
	                    fn : this.onWorkTrackingChange,
	                    scope : this
	                }
	            }));
	    items.push(CWHF.createNumberFieldWithHelp("common.lbl.hoursPerWorkday",
	            "projectAccountingTO.hoursPerWorkday", 2, 0, 24, {
	                width : this.textFieldWidthShort,
	                value : data['projectAccountingTO.hoursPerWorkday'],
	                itemId: 'projectAccountingTOHoursPerWorkday'
	            }));
	    items.push(CWHF.createComboWithHelp("admin.project.lbl.defaultWorkUnit",
	            "projectAccountingTO.defaultWorkUnit", {
	                itemId: "projectAccountingTODefaultWorkUnit",
	    			data : data['workUnitList'],
	                value : data["projectAccountingTO.defaultWorkUnit"]
	            }));
	    items.push(CWHF.createCheckboxWithHelp("admin.project.lbl.cost",
	            "projectAccountingTO.costTracking", {
	                width : this.textFieldWidthCheck,
	                value : costTracking,
	                itemId: 'projectAccountingTOCostTracking'
	            }, {
	                change : {
	                    fn : this.onCostTrackingChange,
	                    scope : this
	                }
	            }));
	    items.push(CWHF.createTextFieldWithHelp("admin.project.lbl.currencyName",
	            "projectAccountingTO.currencyName", {
	                width : this.textFieldWidthShort,
	                value : data['projectAccountingTO.currencyName'],
	                itemId: 'projectAccountingTOCurrencyName'
	            }));
	    items.push(CWHF.createTextFieldWithHelp("admin.project.lbl.currencySymbol",
	            "projectAccountingTO.currencySymbol", {
	                width : this.textFieldWidthShort,
	                value : data['projectAccountingTO.currencySymbol'],
	                itemId : 'projectAccountingTOCurrencySymbol'
	            }));
	    items.push(CWHF.createComboWithHelp('admin.project.lbl.defaultAccount',
	            "projectAccountingTO.defaultAccount", {
	    			itemId: "projectAccountingTODefaultAccount",
	                data : data["accountList"],
	                value : data['projectAccountingTO.defaultAccount']
	            }));
	    var accountingFieldSet = {
	        xtype : 'fieldset',
	        itemId : 'fsacc',
	        width : this.FieldSetWidth,
	        title : getText('admin.project.lbl.fsaccount'),
	        collapsible : false,
	        defaultType : 'textfield',
	        defaults : {
	            anchor : '100%'
	        },
	        layout : 'anchor',
	        items : items
	    };
	    mainTab.add(accountingFieldSet);
	    var disabled = (this.addAsSubproject || subproject) && accountingInherited;
	    this.enableAccountingFields(disabled, workTracking, costTracking);
	},
	addReleaseFieldSet : function(data, mainTab) {
	    mainTab.add({
	        xtype : 'fieldset',
	        itemId : 'fsrel',
	        width : this.FieldSetWidth,
	        title : getText('admin.project.lbl.release'),
	        collapsible : false,
	        defaults : {
	            anchor : '100%'
	        },
	        layout : 'anchor',
	        items : [ CWHF.createCheckboxWithHelp('admin.project.lbl.useRelease',
	                'projectBaseTO.useRelease', {
	                    width : this.textFieldWidthCheck,
	                    value : data['projectBaseTO.useRelease'],
	                    itemId: 'projectBaseTOUseRelease'
	                }) ]
	    });
	},
	onStatusForIssueTypeChange : function(field, newValue, oldValue, options) {
	    options.comboControl.setDisabled(!newValue);
	},
	/**
	 * Enable or disable the fields related to accounting (work and cost tracking)
	 */
	enableAccountingFields : function(accountingInherited, workTracking, costTracking) {
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOWorkTracking").setDisabled(
	            accountingInherited);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOHoursPerWorkday").setDisabled(
	            accountingInherited || !workTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTODefaultWorkUnit").setDisabled(
	            accountingInherited || !workTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOCostTracking").setDisabled(
	            accountingInherited);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOCurrencyName").setDisabled(
	            accountingInherited || !costTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOCurrencySymbol").setDisabled(
	            accountingInherited || !costTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTODefaultAccount").setDisabled(
	            accountingInherited || !workTracking && !costTracking);
	},
	/**
	 * Handler for changing an invalid value handling
	 */
	onAccountingInheritedChange : function(field, newValue, oldValue, options) {
	    var accountingInherited = field.getValue();
	    var workTracking = this.getWrappedControl("mainTab", "fsacc",
	            "projectAccountingTOWorkTracking").getValue();
	    var costTracking = this.getWrappedControl("mainTab", "fsacc",
	            "projectAccountingTOCostTracking").getValue();
	    this.enableAccountingFields(accountingInherited, workTracking, costTracking);
	},
	onWorkTrackingChange : function(field, newValue, oldValue, options) {
	    var workTracking = field.getValue();
	    this.enableWorkTrackingFields(workTracking);
	},
	/**
	 * Enable or disable the fields related to work tracking
	 */
	enableWorkTrackingFields : function(workTracking) {
	    var costTracking = this.getWrappedControl("mainTab", "fsacc",
	            "projectAccountingTOCostTracking").getValue();
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOHoursPerWorkday").setDisabled(
	            !workTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTODefaultWorkUnit").setDisabled(
	            !workTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTODefaultAccount").setDisabled(
	            !workTracking && !costTracking);
	},
	onCostTrackingChange : function(field, newValue, oldValue, options) {
	    var costTracking = field.getValue();
	    this.enableCostTrackingFields(costTracking);
	},
	/**
	 * Enable or disable the fields related to cost tracking
	 */
	enableCostTrackingFields : function(costTracking) {
	    var workTracking = this.getWrappedControl("mainTab", "fsacc",
	            "projectAccountingTOWorkTracking").getValue();
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOCurrencyName").setDisabled(
	            !costTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTOCurrencySymbol").setDisabled(
	            !costTracking);
	    this.getHelpWrapper("mainTab", "fsacc", "projectAccountingTODefaultAccount").setDisabled(
	            !costTracking && !workTracking);
	},
	/**
	 * Extra options for the detail panel
	 */
	getDetailPanelConfigOptions : function() {
	    //avoid double scrolls by adding a single panel (tab panel) tp the form panel
	    return {
	        autoScroll : false,
	        layout : "fit"
	    };
	},
	/**
	 * Gets the project type items
	 */
	getDetailItems : function(node, add) {
	    var me = this;
	    var activeTab = null;
	    if (me.getLastSelections()) {
	    	activeTab = me.getLastSelections().lastSelectedTab;
		}
	    if (CWHF.isNull(activeTab)) {
	        activeTab = 0;
	    }
	    var tabs =  [ this.createTabMain(add), this.createTabDefault()];
	    if (com.trackplus.TrackplusConfig.appType !== APPTYPE_BUGS) {
	    	tabs.push(this.createTabEmail());
	    }
	    this.tabPanel = Ext.create('Ext.tab.Panel', {
	        itemId : 'tabPanel',
	        plain : true,
	        border : false,
	        bodyBorder : false,
	        cls : 'projectConfig',
	        defaults : {
	            border : false,
	            autoScroll : true,
	            bodyStyle : {
	                border : 'none',
	                padding : '0px'
	            }
	        },
	        items : tabs,
	        activeTab : activeTab
	    });
	    return this.tabPanel;
	},
	tabActivate: function(tab) {
	    var me = this;
	    var tabIndex = me.tabPanel.items.indexOf(tab);
	    me.getLastSelections().lastSelectedTab = tabIndex;
	    var storeTabUrl = "project!storeLastSelectedTab.action";
	    Ext.Ajax.request({
	        fromCenterPanel : true,
	        url : storeTabUrl,
	        disableCaching : true,
	        method : 'POST',
	        params : {
	            "tabIndex" : tabIndex
	        }
	    });
	},
	storeLastSelectedSection : function(sectionID) {
	    var storeTabUrl = "project!storeLastSelectedSection.action";
	    Ext.Ajax.request({
	        fromCenterPanel : true,
	        url : storeTabUrl,
	        disableCaching : true,
	        method : 'POST',
	        params : {
	            "sectionID" : sectionID
	        }
	    });
	},
	/**
	 * Creates the main project tab
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabMain : function(add) {
	    var me = this;
	    var items = [];
	    items.push(CWHF.createTextField('common.lbl.name', 'projectBaseTO.label', {
	        allowBlank : false,
	        maxLength : 255
	    }));
	    items.push(CWHF.createTextAreaField('common.lbl.description', 'projectBaseTO.description', {
	        height : 150,
	        maxLength : 255
	    }));
	    items.push(CWHF.createComboWithHelp('common.lbl.projectType', 'projectBaseTO.projectTypeID',
	            {itemId:'projectType'}, null));
	    if (!this.getIsTemplate()) {
	        items.push(CWHF.createComboWithHelp('admin.customize.localeEditor.type.projectStatus',
	                'projectBaseTO.projectStatusID', {itemId:'projectStatus'}, null));
	    }
	    var panel = Ext.create('Ext.panel.Panel', {
	        title : getText('admin.project.lbl.mainTab'),
	        itemId : 'mainTab',
	        items : [
	                {
	                    xtype : 'fieldset',
	                    itemId : 'fsbasic',
	                    width : this.FieldSetWidth,
	                    title : getText('admin.project.lbl.fsbasic'),
	                    collapsible : false,
	                    defaultType : 'textfield',
	                    defaults : {
	                        anchor : '100%'
	                    },
	                    layout : 'anchor',
	                    items : items
	                },
	                {
	                    xtype : 'fieldset',
	                    itemId : 'fslnk',
	                    width : this.FieldSetWidth,
	                    title : getText('admin.project.lbl.linking'),
	                    collapsible : false,
	                    defaults : {
	                        anchor : '100%'
	                    },
	                    layout : 'anchor',
	                    items : [ CWHF.createCheckboxWithHelp('admin.project.lbl.linking',
	                            'projectBaseTO.linking', {
	                                width : this.textFieldWidthCheck,
	                                itemId : 'projectBaseTOLinking'
	                            }) ]
	                }, {
	                    xtype : 'hidden',
	                    name : 'add',
	                    value : add
	                } ]
	    });
	    panel.addListener('activate', me.tabActivate, me);
	    return panel;
	},
	/**
	 * Handler for project type or issue type change
	 */
	onProjectTypeOrIssueTypeChange : function(combo, newValue, oldValue, eOpts) {
	    this.tabPanel.ownerCt.getForm().submit({
	        //allow submit even without the required name this time
	        clientValidation : false,
	        url : this.getBaseAction() + '!projectTypeChange.action',
	        params : {
	            projectID : this.getRootID(),
	            addAsSubproject : this.addAsSubproject
	        },
	        scope : this,
	        success : function(form, action) {
	            var result = action.result;
	            if (result.success) {
	                this.refreshSystemFieldCombos(result.data, this.tabPanel.ownerCt);
	            } else {
	                errorHandlerSave(result);
	            }
	        },
	        failure : function(form, action) {
	            com.trackplus.util.submitFailureHandler(form, action);
	        }
	    });
	},
	/**
	 * Load the combos after the result has arrived containing also the combo data sources
	 */
	refreshSystemFieldCombos : function(data, panel) {
	    var mainTab = this.getControl("mainTab");
	    var accountingFieldSet = this.getControl("mainTab", "fsacc");
	    var oldProjectTypeHasAccounting = accountingFieldSet !== null;
	    var newProjectTypeHasAccounting = data["hasAccounting"];
	    if (oldProjectTypeHasAccounting !== newProjectTypeHasAccounting) {
	        if (oldProjectTypeHasAccounting && !newProjectTypeHasAccounting) {
	            mainTab.remove(accountingFieldSet);
	        } else {
	            this.addAccountingFieldSet(data, mainTab);
	        }
	    } else {
	        if (newProjectTypeHasAccounting) {
	            this.actualizeAccountingByProjectType(data);
	        }
	    }
	    var releaseFieldSet = this.getControl("mainTab", "fsrel");
	    var oldProjectTypeHasRelease = releaseFieldSet !== null;
	    var newProjectTypeHasRelease = data["hasRelease"];
	    if (oldProjectTypeHasRelease !== newProjectTypeHasRelease) {
	        if (oldProjectTypeHasRelease && !newProjectTypeHasRelease) {
	            mainTab.remove(releaseFieldSet);
	        } else {
	            this.addReleaseFieldSet(data, mainTab);
	        }
	    }
	    var initialStatus = this.getWrappedControl("defaultTab", "fsInitSt",
	            "projectDefaultsTO_initialStatusID");
	    initialStatus.store.loadData(data['statusList']);
	    initialStatus.setValue(data['projectDefaultsTO.initialStatusID']);
	    var defaultIssueType = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTO_defaultIssueTypeID");
	    defaultIssueType.store.loadData(data['issueTypeList']);
	    defaultIssueType.setValue(data['projectDefaultsTO.defaultIssueTypeID']);
	    var defaultPriority = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTO_defaultPriorityID");
	    defaultPriority.store.loadData(data['priorityList']);
	    defaultPriority.setValue(data['projectDefaultsTO.defaultPriorityID']);
	    var defaultSeverity = this.getWrappedControl("defaultTab", "fsdef",
	            "projectDefaultsTODefaultSeverityID");
	    defaultSeverity.store.loadData(data['severityList']);
	    defaultSeverity.setValue(data['projectDefaultsTO.defaultSeverityID']);
	    //after project type or issue type change the system list are refreshed from the server with valid values
	    //call validate for each system field to remove the eventual invalid marked fields at postDataLoadCombos()
	    initialStatus.validate();
	    defaultIssueType.validate();
	    defaultPriority.validate();
	    defaultSeverity.validate();
	    //var tabBar=tabPanel.getTabBar();
	    //var headerCm=tabBar.getComponent(1);
	    //headerCm.removeCls("errorTab");
	},
	actualizeAccountingByProjectType : function(data) {
	    var accountingControls = [ "projectAccountingTODefaultWorkUnit",
	            "projectAccountingTOHoursPerWorkday", "projectAccountingTOCurrencyName",
	            "projectAccountingTOCurrencySymbol" ];
	    Ext.Array.forEach(accountingControls, function(itemId) {
	        var control = this.getWrappedControl("mainTab", "fsacc", itemId.split(".").join("_"));
	        if (control ) {
	            control.setValue(data[itemId]);
	        }
	    }, this);
	},
	/**
	 * Creates the project defaults tab
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabDefault : function() {
	    var me = this;
	    var panel = Ext
	            .create(
	                    'Ext.panel.Panel',
	                    {
	                        title : getText('admin.project.lbl.defaultTab'),
	                        itemId : 'defaultTab',
	                        items : [
	                                {
	                                    xtype : 'fieldset',
	                                    itemId : 'fsdef',
	                                    width : this.FieldSetWidth,
	                                    title : getText('admin.project.lbl.defaultFields'),
	                                    collapsible : false,
	                                    defaultType : 'textfield',
	                                    defaults : {
	                                        anchor : '100%'
	                                    },
	                                    layout : 'anchor',
	                                    items : [
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultManager',
	                                                    'projectDefaultsTO.defaultManagerID',{itemId:'projectDefaultsTODefaultManagerID'}),
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultResponsible',
	                                                    'projectDefaultsTO.defaultResponsibleID',{itemId:'projectDefaultsTODefaultResponsibleID'}),
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultIssueType',
	                                                    'projectDefaultsTO.defaultIssueTypeID',{itemId:'projectDefaultsTODefaultIssueTypeID'}),
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultPriority',
	                                                    'projectDefaultsTO.defaultPriorityID',{itemId:'projectDefaultsTODefaultPriorityID'}),
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultSeverity',
	                                                    'projectDefaultsTO.defaultSeverityID',{itemId:'projectDefaultsTODefaultSeverityID'}),
	                                            CWHF.getRadioGroupWithHelp(
	                                                            'admin.project.lbl.prefill',
	                                                            this.prefillByWidth,
	                                                            [
	                                                                    {
	                                                                        boxLabel : getText('admin.project.lbl.prefill.lastItem'),
	                                                                        name : 'projectDefaultsTO.prefillBy',
	                                                                        inputValue : this.PREFILL.LASTWORKITEM,
	                                                                        checked : true
	                                                                    },
	                                                                    {
	                                                                        boxLabel : getText('admin.project.lbl.prefill.projectDefault'),
	                                                                        name : 'projectDefaultsTO.prefillBy',
	                                                                        inputValue : this.PREFILL.PROJECTDEFAULT
	                                                                    } ], {
	                                                            	itemId : 'prefillBy',
	                                                                layout : 'checkboxgroup',
	                                                                columns : 2
	                                                            }) ]
	                                },
	                                {
	                                    xtype : 'fieldset',
	                                    itemId : 'fsInitSt',
	                                    width : this.FieldSetWidth,
	                                    //padding: '8 0 6 0',
	                                    title : getText('admin.project.lbl.initialState'),
	                                    collapsible : false,
	                                    defaults : {
	                                        anchor : '100%'
	                                    },
	                                    layout : 'anchor',
	                                    items : [
	                                            CWHF.createComboWithHelp(
	                                                    'admin.project.lbl.defaultInitialState',
	                                                    'projectDefaultsTO.initialStatusID',{itemId:'projectDefaultsTOInitialStatusID'}),
	                                            Ext
	                                                    .create(
	                                                            'Ext.Component',
	                                                            {
	                                                                html : getText('admin.project.lbl.defaultIssueTypeInitialState'),
	                                                                margin : '0 5 5 5',
	                                                                border : true,
	                                                                cls : 'infoBox3'
	                                                            }) ]
	                                } ]
	                    });
	    panel.addListener('activate', me.tabActivate, me);
	    return panel;
	},
	/**
	 * Handler for changing an invalid value handling
	 */
	onEmailOutChange : function(field, newValue, oldValue, options) {
	    var eoutValue = field.getValue();
	    this.enableEmailOutFields(eoutValue);
	},
	enableEmailOutFields : function(eout) {
	    this.getHelpWrapper("emailTab", "fsout", "projectEmailTOProjectFromEmail").setDisabled(!eout);
	    this.getHelpWrapper("emailTab", "fsout", "projectEmailTOProjectFromEmailName").setDisabled(!eout);
	    this.getHelpWrapper("emailTab", "fsout", "projectEmailTOSendFromProjectAsReplayTo").setDisabled(!eout);
	},
	onChangeEmailEnabled : function(checkBox, newValue, oldValue, eOpts) {
	    disabled = !newValue;
	    this.getHelpWrapper("emailTab", "fseserv", "projectEmailTOProtocol").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fseserv", "projectEmailTOServerName").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fseserv", "projectEmailTOPort").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fsauth", "projectEmailTOUser").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fsauth", "projectEmailTOPassword").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fsauth", "securityConnection").setDisabled(disabled);
	    this.getHelpWrapper("emailTab", "fsother", "keep").setDisabled(disabled);
	    this.testBtn.setDisabled(disabled);
	},
	/**
	 * Creates the project defaults tab
	 * @return {Ext.form.Panel} A panel for this tab
	 */
	createTabEmail : function() {
	    var me = this;
	    me.testBtn = Ext.create('Ext.button.Button', {
	        xtype : 'button',
	        style : {
	            marginTop : '10px',
	            marginBottom : '5px',
	            marginLeft : (me.labelWidth + 20) + 'px'
	        },
	        itemId : 'emailTab_testConnection',
	        enableToggle : false,
	        iconCls : 'check16',
	        text : getText('admin.server.config.testConnection'),
	        handler : function() {
	            me.testEmailIncoming.call(me);
	        }
	    });
	    var panel = Ext.create(
	    		'Ext.panel.Panel', {
	    			title : getText('admin.project.lbl.emailTab'),
	    			itemId : 'emailTab',
	    			layout : {
	    				type : 'anchor'
	    			},
	    			items : [{
	    				xtype : 'fieldset',
	    				itemId : 'fseserv',
	    				width : this.FieldSetWidth,
                        title : getText('admin.server.config.incomingServer'),
                        collapsible : false,
                        defaultType : 'textfield',
	                    defaults : {
	                    	anchor : '100%'
	                    },
	                    layout : 'anchor',
	                    items : [
	                    CWHF.createCheckboxWithHelp(
	                    		'admin.server.config.emailSubmission',
	                            'projectEmailTO.enabled', {itemId:"projectEmailTOEnabled"}, {
	                            change : {
	                            	fn: this.onChangeEmailEnabled,
	                                	scope: this
	                            }}),
	                             CWHF.getRadioGroupWithHelp('admin.server.config.mailReceivingProtocol',
	                            	this.protocolWidth, [{
	                            			 boxLabel : 'POP3',
	                            			 name : 'projectEmailTO.protocol',
	                            			 inputValue : 'pop3',
	                            			 checked : true
	                            		 }, {
	                            			 boxLabel : 'IMAP',
	                            			 name : 'projectEmailTO.protocol',
	                            			 inputValue : 'imap'
	                            		 }], {itemId:'projectEmailTOProtocol'}, {
	                            			 change : {
	                            				 fn : this.changePort,
	                            				 scope : this
	                            			 }
	                            		 }),
	                            		 CWHF.createTextFieldWithHelp(
	                            				 'admin.server.config.mailReceivingServerName',
	                            				 'projectEmailTO.serverName',{itemId:'projectEmailTOServerName'}),
	                            		CWHF.createTextFieldWithHelp(
	                            				'admin.server.config.mailReceivingPort',
	                            				'projectEmailTO.port', {
	                            				width : this.textFieldWidthShort,
	                            				itemId : 'projectEmailTOPort'
	                            				})
	                            ]
	                    },{
	    				xtype : 'fieldset',
	    				itemId : 'fsauth',
	                                    width : this.FieldSetWidth,
	                                    title : getText('admin.server.config.incomingAuth'),
	                                    collapsible : false,
	                                    defaultType : 'textfield',
	                                    defaults : {
	                                        anchor : '100%'
	                                    },
	                                    layout : 'anchor',
	                                    items : [
	                                            CWHF.createTextFieldWithHelp(
	                                                    'admin.server.config.mailReceivingUser',
	                                                    'projectEmailTO.user', {itemId:'projectEmailTOUser'}),
	                                            CWHF.createTextFieldWithHelp(
	                                                    'admin.server.config.mailReceivingPassWord',
	                                                    'projectEmailTO.password', {
	                                                        inputType : 'password',
	                                                        itemId : 'projectEmailTOPassword'
	                                                    }),
	                                            CWHF.getRadioGroupWithHelp('admin.server.config.mailReceivingSecurityConnection',
	                                            		this.securityConnectionWidth,[
	                                                                    {
	                                                                        boxLabel : getText('admin.server.config.securityConnections.never'),
	                                                                        name : 'projectEmailTO.securityConnection',
	                                                                        inputValue : this.SECURITY_CONNECTIONS_MODES.NEVER
	                                                                    },
	                                                                    {
	                                                                        boxLabel : getText('admin.server.config.securityConnections.tlsIsAvailable'),
	                                                                        name : 'projectEmailTO.securityConnection',
	                                                                        inputValue : this.SECURITY_CONNECTIONS_MODES.TLS_IF_AVAILABLE
	                                                                    },
	                                                                    {
	                                                                        boxLabel : getText('admin.server.config.securityConnections.tls'),
	                                                                        name : 'projectEmailTO.securityConnection',
	                                                                        inputValue : this.SECURITY_CONNECTIONS_MODES.TLS
	                                                                    },
	                                                                    {
	                                                                        boxLabel : getText('admin.server.config.securityConnections.ssl'),
	                                                                        name : 'projectEmailTO.securityConnection',
	                                                                        inputValue : this.SECURITY_CONNECTIONS_MODES.SSL
	                                                                    } ], {itemId:'securityConnection'}, {
	                                                                change : {
	                                                                    fn : this.changePort,
	                                                                    scope : this
	                                                                }
	                                                            }) ]
	                                },
	                                {
	                                    xtype : 'fieldset',
	                                    itemId : 'fsout',
	                                    width : this.FieldSetWidth,
	                                    title : getText('admin.project.lbl.fsoutgoing'),
	                                    collapsible : false,
	                                    defaultType : 'textfield',
	                                    defaults : {
	                                        anchor : '100%'
	                                    },
	                                    layout : 'anchor',
	                                    items : [
	                                            CWHF.createCheckboxWithHelp(
	                                                    'admin.project.lbl.useProjectFromAddress',
	                                                    'projectEmailTO.sendFromProjectEmail', {
	                                                        width : this.textFieldWidthCheck,
	                                                        itemId: 'projectEmailTOSendFromProjectEmail'
	                                                    }, {
	                                                        change : {
	                                                            fn : this.onEmailOutChange,
	                                                            scope : this
	                                                        }
	                                                    }),
	                                            CWHF.createTextFieldWithHelp(
	                                                    'admin.project.lbl.projectEmail',
	                                                    'projectEmailTO.projectFromEmail',
	                                                    {itemId: 'projectEmailTOProjectFromEmail'}),
	                                            CWHF.createTextFieldWithHelp(
	                                                    'admin.project.lbl.projectEmailPersonalName',
	                                                    'projectEmailTO.projectFromEmailName', {itemId:'projectEmailTOProjectFromEmailName'}),
	                                            CWHF.createCheckboxWithHelp(
	                                                    'admin.project.lbl.useProjectFromAsReplyTo',
	                                                    'projectEmailTO.sendFromProjectAsReplayTo', {
	                                                        width : this.textFieldWidthCheck,
	                                                        itemId : 'projectEmailTOSendFromProjectAsReplayTo'
	                                                    }) ]
	                                },
	                                {
	                                    xtype : 'fieldset',
	                                    itemId : 'fsother',
	                                    width : this.FieldSetWidth,
	                                    title : getText('admin.server.config.incomingOther'),
	                                    collapsible : false,
	                                    defaultType : 'textfield',
	                                    defaults : {
	                                        anchor : '100%'
	                                    },
	                                    layout : 'anchor',
	                                    items : [ CWHF.createCheckboxWithHelp(
	                                            'admin.server.config.keepMessagesOnServer',
	                                            'projectEmailTO.keepMessagesOnServer', {
	                                                itemId : 'keep',
	                                                width : this.textFieldWidthCheck
	                                            }) ]
	                                }, me.testBtn ]
	                    });
	    panel.addListener('activate', me.tabActivate, me);
	    return panel;
	},
	handleErrors : function(errors, errorMsg) {
	    var me = this;
	    var errStr = '';
	    var tabErrors = new Array();
	    if (CWHF.isNull(errorMsg)) {
	        errorMsg = getText('admin.project.err.errorSave');
	    }
	    if (errors  && errors.length > 0) {
	        for (var i = 0; i < errors.length; i++) {
	            var error = errors[i];
	            var controlPath = error.controlPath;
	            var inputComp = null;
	            if (controlPath  && controlPath.length > 0) {
	                var tabId = controlPath[0];
	                if (!Ext.Array.contains(tabErrors, tabId)) {
	                    tabErrors.push(tabId);
	                }
	                inputComp = this.getControl.apply(this, controlPath);
	                if (CWHF.isNull(inputComp)) {
	                    inputComp = this.getWrappedControl.apply(this, controlPath);
	                }
	            }
	            if (inputComp ) {
	                inputComp.markInvalid(error.errorMessage);
	            } else {
	                errStr += error.errorMessage + "</br>";
	            }
	        }
	        me.markErrorTabs(tabErrors);
	    }
	    if (errStr !== '') {
	        errorMsg = errStr;
	    }
	    CWHF.showMsgError(errorMsg);
	},
	markErrorTabs : function(tabErrors) {
	    var me = this;
	    var tabErrorsCmp = new Array();
	    if (tabErrors.length > 0) {
	        for (var i = 0; i < tabErrors.length; i++) {
	            var tabComp = this.getControl(tabErrors[i]);
	            if (tabComp ) {
	                tabErrorsCmp.push(tabComp);
	            }
	        }
	        if (tabErrorsCmp.length > 0) {
	            var selectedTab = me.tabPanel.getActiveTab();
	            if (!Ext.Array.contains(tabErrorsCmp, selectedTab)) {
	                me.tabPanel.setActiveTab(tabErrorsCmp[0]);
	            }
	            var tabBar = me.tabPanel.getTabBar();
	            for (var i = 0; i < tabErrorsCmp.length; i++) {
	                var index = me.tabPanel.items.findIndex('itemId', tabErrorsCmp[i].getItemId());
	                var headerCm = tabBar.getComponent(index);
	                headerCm.addCls("errorTab");
	            }
	        }
	    }
	},
	clearErrorTabs : function() {
	    var me = this;
	    var tabBar = me.tabPanel.getTabBar();
	    for (var i = 0; i < tabBar.items.length; i++) {
	        var headerCm = tabBar.getComponent(i);
	        headerCm.removeCls("errorTab");
	    }
	    if (me.ldapController ) {
	        me.ldapController.clearErrorTabs.call(me.ldapController);
	    }
	},
	testEmailIncoming : function() {
	    var me = this;
	    borderLayout.setLoading(true);
	    var urlStr = 'project!testIncomingEmail.action';
	    me.clearErrorTabs();
	    var form = me.tabPanel.ownerCt.getForm();
	    if (!form.isValid()) {
	        CWHF.showMsgError(getText('admin.project.err.invalidEmail'));
	        return false;
	    }
	    borderLayout.setLoading(true);
	    form.submit({
	        url : urlStr,
	        params : {
	            projectID : this.getRootID()
	        },
	        success : function(form, action) {
	            borderLayout.setLoading(false);
	            CWHF.showMsgInfo(getText('admin.project.msg.validEmail'));
	        },
	        failure : function(form, action) {
	            borderLayout.setLoading(false);
	            if (action.result  && action.result.errors ) {
	                me.handleErrors(action.result.errors, getText('admin.project.err.invalidEmail'));
	            } else {
	                CWHF.showMsgError(getText('admin.project.err.invalidEmail'));
	            }
	        }
	    });
	},
	changePort : function(protocol, securityConnection, port) {
	    var protocol = this.getWrappedControl("emailTab", "fseserv", "projectEmailTOProtocol");
	    var securityConnection = this.getWrappedControl("emailTab", "fsauth", "securityConnection");
	    var port = this.getWrappedControl("emailTab", "fseserv", "projectEmailTOPort");
	    var protocolValue = CWHF.getSelectedRadioButtonValue(protocol);
	    var securityConnectionValue = CWHF.getSelectedRadioButtonValue(securityConnection);
	    var portValue;
	    if (protocolValue === this.EMAIL_PROTOCOL.POP3) {
	        if (securityConnectionValue === this.SECURITY_CONNECTIONS_MODES.SSL) {
	            portValue = this.DEFAULT_EMAIL_PORTS.POP3_SSL;
	        } else {
	            portValue = this.DEFAULT_EMAIL_PORTS.POP3;
	        }
	    } else {
	        if (securityConnectionValue === this.SECURITY_CONNECTIONS_MODES.SSL) {
	            portValue = this.DEFAULT_EMAIL_PORTS.IMAP_SSL;
	        } else {
	            portValue = this.DEFAULT_EMAIL_PORTS.IMAP;
	        }
	    }
	    port.setValue(portValue);
	},
	getTemplateLockUnlockLabel : function() {
	    var label = getText('admin.project.lbl.templateStateEdit');
	    if (this.templateIsActive) {
	        label = getText('admin.project.lbl.templateStateLock');
	    }
	    return label;
	},
	getTemplateLockUnlockToolTip : function() {
	    var label = getText('admin.project.lbl.templateStateEdit.tt');
	    if (this.templateIsActive) {
	        label = getText('admin.project.lbl.templateStateLock.tt');
	    }
	    return label;
	},
	getTemplateLockUnlockIcon : function() {
	    var icon = "edit16";
	    if (this.templateIsActive) {
	        icon = "lock";
	    }
	    return icon;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.project.ProjectCockpit',{
	extend:'Ext.Base',
	config: {
		projectID: null
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	configButton:null,
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		var me=this;
		if (CWHF.isNull(this.configButton)) {
			this.configButton = new Ext.Button({
				overflowText:getText('admin.project.cockpit.lbl.configProject'),
				tooltip:getText('admin.project.cockpit.lbl.configProject'),
				text: getText('admin.project.cockpit.lbl.configProject'),
				iconCls: 'projectEdit',
				disabled:false,
				handler:function(){
					//project
					var urlEditScreen="dashboardEdit.action?backAction=admin.action&projectID="+me.getProjectID()+"&entityType=1";
					window.location.href=urlEditScreen;
				}
			});
			this.configReleaseButton = new Ext.Button({
				overflowText:getText('admin.project.cockpit.lbl.configRelease'),
				tooltip:getText('admin.project.cockpit.lbl.configRelease'),
				text: getText('admin.project.cockpit.lbl.configRelease'),
				iconCls: 'releaseEdit',
				disabled:false,
				handler:function(){
					//release
					var urlEditScreen="dashboardEdit.action?backAction=admin.action&projectID="+me.getProjectID()+"&entityType=9";
					window.location.href=urlEditScreen;
				}
			});
			this.actionAssignProjectCockpit =new Ext.Button({
				overflowText:getText('admin.project.lbl.resetProjectCockpit'),
				tooltip:getText('admin.project.lbl.resetProjectCockpit'),
				text: getText('admin.project.lbl.resetProjectCockpit'),
				iconCls: 'cockpitReset',
				disabled:false,
				handler:me.onAssignProjectCockpit,
				scope:me
			});
			this.actionAssignReleaseCockpit =new Ext.Button({
				overflowText:getText('admin.project.lbl.resetReleaseCockpit'),
				tooltip:getText('admin.project.lbl.resetReleaseCockpit'),
				text: getText('admin.project.lbl.resetReleaseCockpit'),
				iconCls: 'cockpitReset',
				disabled:false,
				handler:me.onAssignReleaseCockpit,
				scope:me
			});
		}
		return [this.configButton,this.actionAssignProjectCockpit,this.configReleaseButton,this.actionAssignReleaseCockpit];
	},
	onAssignProjectCockpit:function(){
		var me=this;
		com.trackplus.dashboard.resetDashboard('project!cokpitAssignment.action',
			{projectID:me.getProjectID(),entityType:1},me.projectCokpitAssignmentSuccess,me);
	},
	projectCokpitAssignmentSuccess: function() {
		CWHF.showMsgInfo(getText('admin.project.msg.resetProjectCockpit'));
	},
	onAssignReleaseCockpit:function(){
		var me=this;
		com.trackplus.dashboard.resetDashboard('project!cokpitAssignment.action',
			{projectID:me.getProjectID(),entityType:9}, me.releaseCokpitAssignmentSuccess,me);
	},
	releaseCokpitAssignmentSuccess: function() {
		CWHF.showMsgInfo(getText('admin.project.msg.resetReleaseCockpit'));
	},
	getDetailPanel: function() {
		this.panel= Ext.create('Ext.panel.Panel',{
			region: 'center',
			border: false,
			autoScroll: false,
			bodyStyle: 'padding:0px',
			layout:'anchor',
			items:[Ext.create('Ext.Component',{
				html: getText('admin.project.cockpit.help'),
				border:true,
				anchor:'100%',
				minWidth:650,
				cls:'infoBox_bottomBorder'
			})]
		});
		return this.panel;
	},
	loadDetailPanel:function(){
	},
	panelLoad: function(projectOrReleaseID) {
	},
	postLoadProcess: function(panel, data) {
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.project.ProjectCopyController',{
	extend:'Ext.Base',
	config: {
		dataModel: null,
		projectConfig: null,
		actionTarget:null
	},
	view:null,
	copy:false,
	projectID:null,
	COPY_ACTION_WP_FROM_TPL: 0,
	COPY_ACTION_TPL_FROM_WP: 1,
	COPY_ACTION_COPY_TPL: 2,
	COPY_ACTION_COPY_WP: 3,
	constructor : function(config) {
		var config = config || {};
		this.initConfig(config);
		this.projectID=this.getDataModel().projectID;
	},
	getTitle: function() {
		switch(this.getActionTarget()) {
		    case this.COPY_ACTION_COPY_WP:
		    	return getText('admin.project.copy.title');
		        break;
		    case this.COPY_ACTION_TPL_FROM_WP:
		        return getText('admin.project.copy.titleCreateTplFromWp');
		        break;
		    case this.COPY_ACTION_COPY_TPL:
		        return getText('admin.project.copy.titleCopyTpl');
		        break;
		    case this.COPY_ACTION_WP_FROM_TPL:
		    	return getText('common.btn.copyTo');
		        break;
		    default:
		    	return getText('admin.project.copy.title');
		}
	},
	getSaveLabel: function() {
		switch(this.getActionTarget()) {
		    case this.COPY_ACTION_COPY_WP:
		    case this.COPY_ACTION_COPY_TPL:
		    	return getText('common.btn.copy');
		        break;
		    case this.COPY_ACTION_WP_FROM_TPL:
				return getText('admin.project.lbl.createSpace');
		        break;
		    case this.COPY_ACTION_TPL_FROM_WP:
		    	return getText('admin.project.lbl.createTemplate');
		        break;
		    default:
		    	return getText('common.btn.copy');
		}
	},
	/**
	 * Handler for add/edit a node/row
	 * title: 'add'/'edit'/'copy'
	 * recordData: the selected record (tree node data or grid row data)
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * loadParams
	 * submitParams
	 * refreshParams
	 * refreshParamsFromResult
	 */
	showDialog: function() {
		var width = 500;
		var height = 600;
		var loadParams = {projectID:this.projectID, actionTarget:this.getActionTarget()};
		var load = {loadUrl:"projectCopy.action", loadUrlParams:loadParams};
		var submitParams = {projectID:this.projectID, actionTarget:this.getActionTarget()};
		var submit = {submitUrl:"projectCopy!copy.action",
					submitUrlParams:submitParams,
					submitButtonText:this.getSaveLabel(),
					refreshAfterSubmitHandler:this.reload};
		var postDataProcess = this.postDataProcess;
		var helpText = this.getWindowTopHelpText();
		//admin.project.copy.lbl.projectName
		var windowParameters = {title:this.getTitle(),
			width:width,
			height:height,
			load:load, submit:submit,
			panelConfig:{
				bodyStyle:{
					padding:'5 5 5 0'
				}
			},
			items:[{
					xtype: 'component',
					cls:"infoBox_bottomBorder",
					border:true,
					html: helpText
				},
				CWHF.createTextField("admin.project.copy.lbl.projectName", "projectName",{itemId:'projectName', allowBlank:false, maxLength:255, padding: '5 5 5 5'})],
			postDataProcess:postDataProcess};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	postDataProcess: function(data, panel) {
		this.populateProjectCopyControls(this, panel, data);
	},
	reload: function(reloadParameters, result) {
		this.getProjectConfig().reloadAfterApplyingTemplate(result, this.getActionTarget());
	},
	populateProjectCopyControls: function(scope, projectCopyMainPanel, data) {
		var customLists = data["customLists"];
		var projectCopyControls = [];
		if (projectCopyMainPanel) {
			var showAsSibling = data['showAsSibling'];
			if (showAsSibling) {
				projectCopyControls.push(CWHF.createCheckbox("admin.project.copy.lbl.copyAsSiblingProject",
						"copyAsSibling"));
			}
			var showCopySubprojects = data['showCopySubprojects'];
			if (showCopySubprojects) {
				projectCopyControls.push(CWHF.createCheckbox("admin.project.copy.lbl.copySubprojects",
						"copySubprojects"));
			}
			var showCopyItems = data["showCopyItems"];
			if (showCopyItems) {
				projectCopyControls.push({xtype:"fieldset",
					itemId:"fsItems",
					title: getText("admin.project.copy.lbl.copyItems"),
					//collapsible: false,
					//defaults: {anchor: '100%'},
					//layout: 'anchor',
					items:[CWHF.createCheckbox("admin.project.copy.lbl.copyOpenItems", "copyOpenItems", null,
							{change: {fn: this.changeCopyItems, scope:this,
								panel:projectCopyMainPanel, customLists:customLists}}),
							CWHF.createCheckbox("admin.project.copy.lbl.copyAttachments", "copyAttachments", {itemId:"copyAttachments",disabled:true})
					       ]});
				}
		}
		var showCopyReleases = data["showCopyReleases"];
		if (showCopyReleases || (customLists && customLists.length>0)) {
			var items = [];
			if (showCopyReleases) {
				items.push(CWHF.createCheckbox("admin.project.copy.lbl.releases", "copyReleases"),{itemId:"copyReleases"});
			}
			if (customLists && customLists.length>0) {
				Ext.Array.forEach(customLists, function(expression) {
					var expressionPanel = CWHF.createCheckbox(expression["entityLabel"],
							expression["entityName"], {labelIsLocalized:true});
					items.push(expressionPanel);
				}, scope);
			}
			projectCopyControls.push({xtype:"fieldset",
				itemId:"fsLists",
				title: getText("admin.project.copy.lbl.customLists"),
				items:items});
		}
		var associatedEntities = data["associatedEntities"];
		if (associatedEntities) {
			var items = [];
			Ext.Array.forEach(associatedEntities, function(expression) {
				var expressionPanel = CWHF.createCheckbox(expression["entityLabel"],
						expression["entityName"], {labelIsLocalized:true});
				items.push(expressionPanel);
			}, scope);
			projectCopyControls.push({xtype:"fieldset",
				itemId:"fsAssociated",
				title: getText("admin.project.copy.lbl.copyAssignments"),
				//collapsible: false,
				//bodyPadding: '10 10 10 10',
				//defaults: {anchor: '100%'},
				//layout: 'anchor',
				items:items});
		}
		//add all panels at once
		projectCopyMainPanel.add(projectCopyControls);
	},
	changeCopyItems: function(checkboxField, newValue, oldValue, options) {
		var mainPanel = options.panel;
		var copyAttachmentsCheckBox =  CWHF.getControl.apply(mainPanel, ["fsItems", "copyAttachments"]);
		if (copyAttachmentsCheckBox) {
			copyAttachmentsCheckBox.setDisabled(!newValue);
			if (!newValue) {
				copyAttachmentsCheckBox.setValue(false);
			}
		}
		var copyReleasesCheckbox = CWHF.getControl.apply(mainPanel, ["fsLists", "copyReleases"]);
		if (copyReleasesCheckbox) {
			copyReleasesCheckbox.setDisabled(newValue);
			if (newValue) {
				copyReleasesCheckbox.setValue(true);
			}
		}
		var customLists = options.customLists;
		if (customLists && customLists.length>0) {
			Ext.Array.forEach(customLists, function(expression) {
				var customListCheckBox = CWHF.getControl.apply(mainPanel, ["fsLists", expression["entityName"]]);
				if (customListCheckBox) {
					customListCheckBox.setDisabled(newValue);
					if (newValue) {
						customListCheckBox.setValue(newValue);
					}
				}
			}, this);
		}
		var projectFieldConfigsCheckbox = CWHF.getControl.apply(mainPanel, ["fsAssociated", "associatedEntitiyMap[5]"]);
		if (projectFieldConfigsCheckbox) {
			projectFieldConfigsCheckbox.setDisabled(newValue);
			if (newValue) {
				projectFieldConfigsCheckbox.setValue(true);
			}
		}
	},
	getWindowTopHelpText: function() {
		switch(this.getActionTarget()) {
		    case this.COPY_ACTION_COPY_WP:
		    	return getText('admin.project.copy.lbl.message');
		        break;
		    case this.COPY_ACTION_TPL_FROM_WP:
		        return getText('admin.projectTemplate.copy.lbl.messageCreateTplFromWp');
		        break;
		    case this.COPY_ACTION_COPY_TPL:
		        return getText('admin.projectTemplate.copy.lbl.messageCopyTemplate');
		        break;
		    case this.COPY_ACTION_WP_FROM_TPL:
		    	return getText('admin.projectTemplate.copy.lbl.messageCreateWpFromTpl');
		        break;
		    default:
		    	return getText('admin.project.copy.lbl.message');
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
com.trackplus.admin.project.Release=Ext.define('com.trackplus.admin.project.Release',{
	extend:'com.trackplus.admin.TreeWithGrid',
	config: {
		/**
		 * The ID of the selected project, used only by localization
		 */
		projectID: null
	},
	statics:{
		createEditPanelItems:function(lw){
			return [CWHF.createTextField('common.lbl.name',
				'releaseDetailTO.label', {allowBlank:false, labelWidth:lw, maxLength:255}),
				CWHF.createCombo('admin.customize.localeEditor.type.releaseStatus',
					'releaseDetailTO.releaseStatusID', {itemId:"releaseStatusID", labelWidth:lw}),
				CWHF.createDateField('admin.project.release.lbl.dueDate', 'releaseDetailTO.dueDate', {labelWidth:lw}),
				CWHF.createCheckboxWithHelp('admin.project.release.lbl.defaultReleaseNoticed', 'releaseDetailTO.defaultNoticed', {labelWidth:lw, width:lw+50}),
				CWHF.createCheckboxWithHelp('admin.project.release.lbl.defaultReleaseScheduled', 'releaseDetailTO.defaultScheduled',{labelWidth:lw, width:lw+50}),
				CWHF.createTextAreaField('common.lbl.description', 'releaseDetailTO.description', {maxLength:255, labelWidth:lw})];
		},
		/**
		 * Load the combos after the result has arrived containing also the combo data sources
		 */
		postDataLoadCombo: function(data, panel) {
			var statusCombo = panel.getComponent('releaseStatusID');
			if (statusCombo) {
				//no statusCombo for phase
				statusCombo.store.loadData(data['statusList']);
				statusCombo.setValue(data['releaseDetailTO.statusID']);
			}
		}
	},
	baseAction: 'release',
	dragAndDropOnGrid: true,
	dragAndDropOnTree: true,
	/**
	 * The tree, set in projectConfig.js
	 */
	tree: null,
	folderEditWidth:500,
	folderEditHeight:400,
	labelWidth: 120,
	localizedMain: null,
	localizedChild: null,
	showClosedReleases: true,
	//by adding a release whether to add a main release or a child release
	addAsChild: false,
	//actions
	actionAddMainRelease: null,
	actionAddChildRelease: null,
	actionEditGridRow: null,
	actionEditTreeNode: null,
	actionDeleteGridRow: null,
	actionDeleteTreeNode: null,
	actionDetachFromParentRelease: null,
	actionMoveUp: null,
	actionMoveDown: null,
	actionShowClosed: null,
	actionReload: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase(config);
	},
	/**
	 * Initialization method
	 */
	initBase: function(config) {
		this.initLocalizedLabels(config.projectID);
	},
	initLocalizedLabels: function(projectID) {
		Ext.Ajax.request({
			fromCenterPanel:true,
			url: this.getBaseAction() + '!localizedLabels.action',
			scope: this,
			params: {node:projectID},
			success: function(response) {
				var result = Ext.decode(response.responseText);
				this.localizedMain = result.localizedMain;
				this.localizedChild = result.localizedChild;
				this.showClosedReleases = result.showClosedReleases;
				this.initActions();
			},
			failure: function(response) {
				Ext.MessageBox.alert(this.failureTitle, response.responseText);
			}
		});
	},
	/**
	 * to show the release grid with all main releases
	 * even if no release is selected to allow changing the order of the main releases
	 */
	postInitCenterPanel: function(rootNode) {
		this.getGridPanel(rootNode);
	},
	/**
	 * The localized entity name
	 */
	getEntityLabel: function(extraConfig) {
		var entityLabel = null;
		if (extraConfig) {
			var selectedRecord = extraConfig.selectedRecord;
			var fromTree = extraConfig.fromTree;
			if (selectedRecord) {
				var isChild = selectedRecord.data['isChild'];
				if (isChild) {
					//a release node in grid or in tree
					return this.localizedChild;
				}
			}
		}
		return this.localizedMain;
	},
	/**
	 * The iconCls for the add button, overwrites base class icon
	 */
	getAddIconCls: function() {
		return 'releaseAdd';
	},
	/**
	 * The iconCls for the edit button, overwrites base class icon
	 */
	getEditIconCls: function() {
		return 'releaseEdit';
	},
	getAddMainLabel: function() {
		return getText(this.getAddTitleKey(), this.localizedMain);
	},
	/**
	 * Add "Form" not "Form assignment" (getEntityLabel() does not fit here)
	 */
	getAddChildLabel: function() {
		return getText(this.getAddTitleKey(), this.localizedChild);
	},
	initActions: function() {
		this.actionAddMainRelease = this.createLocalizedAction(this.getAddMainLabel(),
				this.getAddIconCls(), this.onAddMainRelease, this.getAddMainLabel());
		this.actionAddChildRelease = this.createLocalizedAction(this.getAddChildLabel(),
				this.getAddIconCls(), this.onAddChildRelease, this.getAddChildLabel(), true);
		this.actionEditGridRow = this.createAction(this.getEditButtonKey(), this.getEditIconCls(),
				this.onEditGridRow, true, this.getEditTitleKey(), "editGridRow");
		this.actionEditTreeNode = this.createAction(this.getEditTitleKey(), this.getEditIconCls(),
				this.onEditTreeNode, false, this.getEditTitleKey(), "editTreeNode");
		this.actionDeleteGridRow = this.createAction(this.getDeleteButtonKey(), this.getDeleteIconCls(),
				this.onDeleteFromGrid, true, this.getDeleteTitleKey(), "deleteGridRow");
		this.actionDeleteTreeNode = this.createAction(this.getDeleteTitleKey(), this.getDeleteIconCls(),
				this.onDeleteFromTree, false, this.getDeleteTitleKey(), "deleteTreeNode");
		this.actionDetachFromParentRelease = this.createLocalizedAction(getText("common.lbl.detachFromParent"),
				"clear", this.onDetachFromParentRelease, getText("common.lbl.detachFromParent"));
		this.actionMoveUp = this.createAction("common.btn.up",
				"moveUp", this.onMoveUpGridRow, true, "common.lbl.up", "moveUp");
		this.actionMoveDown = this.createAction('common.btn.down',
				"moveDown", this.onMoveDownGridRow, true, "common.lbl.down", "moveDown");
		var showHideLabelKey = this.getShowHideLabelKey();
		this.actionShowClosed = this.createAction(showHideLabelKey,
				"showHide", this.onShowHide, false, showHideLabelKey, "showHide",
				{enableToggle:true, pressed:!this.showClosedReleases});
		this.actionReload = this.createLocalizedAction(getText("common.btn.reload"),
				"reload", this.onReload);
	},
	getShowHideLabelKey: function() {
		if (this.showClosedReleases) {
			return 'common.btn.hide';
		} else {
			return 'common.btn.show';
		}
	},
	onShowHide: function() {
		var toolbar = borderLayout.getActiveToolbarList();
		var toolbarButton = toolbar.getComponent('showHide');
		//this.showClosedReleases = !this.showClosedReleases;
		this.showClosedReleases = !toolbarButton.pressed;
		var showHideLabel = getText(this.getShowHideLabelKey());
		toolbarButton.setText(showHideLabel);
		toolbarButton.setTooltip(showHideLabel);
		this.treeNodeSelect(null, null, null, {showClosedReleases:this.showClosedReleases});
	},
	/**
	 * Reload the selected branch after showHide
	 */
	onReload: function() {
		var node = this.getLastSelectedTreeNode();
		var treeStore = this.tree.getStore();
		treeStore.load({node:node});
	},
	/**
	 * Get the extra parameters for the gridStore
	 */
	getGridExtraParams: function(node, opts) {
		if (CWHF.isNull(node)) {
			//called manually
			node = this.selectedNode;
		}
		var params = {
			node: node.data['id']
		};
		if (opts && opts['showClosedReleases']) {
			//called manually from onShowHide handler
			params['showClosedReleases'] = opts['showClosedReleases'];
		}
		return params;
	},
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		return [this.actionAddMainRelease, this.actionAddChildRelease,
				this.actionEditGridRow, this.actionDeleteGridRow,
				this.actionMoveUp, this.actionMoveDown, this.actionShowClosed];
	},
	/**
	 * Handler for adding a folder node
	 */
	onAddMainRelease: function() {
		this.onAdd(false);
	},
	/**
	 * Handler for adding a leaf node
	 */
	onAddChildRelease: function() {
		this.onAdd(true);
	},
	/**
	 * Handler for adding a folder node
	 */
	onAdd: function(addAsChild) {
		var title = this.getTitle(this.getAddTitleKey());
		var loadParams = this.getAddParams(addAsChild);
		var submitParams = this.getAddParams(addAsChild);
		//var reloadParams = this.getAddReloadParamsAfterSave(false);
		var reloadParamsFromResult = this.getAddSelectionAfterSaveFromResult();
		var selectedRecord = this.getSingleSelectedRecord(true);
		return this.onAddEdit(title, selectedRecord, null, false, true, true,
				loadParams, submitParams, null, reloadParamsFromResult);
	},
	/**
	 * Parameters for adding a new leaf
	 */
	/*private*/getAddParams: function(addAsChild) {
		var addParams = {add:true, addAsChild:addAsChild};
		var addToNode = null;
		if (this.selectedNode) {
			addParams['node'] = this.selectedNode.data['id'];
		}
		return addParams;
	},
	/**
	 * Get the node to select after save after add operation
	 */
	/*private*/getAddSelectionAfterSaveFromResult: function() {
		//specify nodeIDToSelect to select the added node based on the 'node' field from resulting JSON,
		//do not specify rowToSelect, do not select anything in the grid after add
		//return {parameterName:'nodeIDToSelect', fieldNameFromResult:'node'};
		return [{parameterName:'nodeIDToSelect', fieldNameFromResult:'node'},
				{parameterName:'rowToSelect', fieldNameFromResult:'node'},
				{parameterName:'nodeIDToReload', fieldNameFromResult:'nodeIDToReload'},
				{parameterName:'reloadTree', fieldNameFromResult:'reloadTree'}];
	},
	/**
	 * Get the actions available in context menu depending on the currently selected row
	 *
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectedRecord) {
			var actions = [this.actionAddChildRelease, this.actionEditTreeNode, this.actionDeleteTreeNode, this.actionReload];
			if (selectedRecord.parentNode && !selectedRecord.parentNode.isRoot()) {
				actions.push(this.actionDetachFromParentRelease);
			}
			return actions;
		}
		return [];
	},
	/**
	 * Gets the grid store's fields for the selected node
	 */
	getTreeFields: function(node) {
			return [{name : 'id', mapping : 'id', type: 'string'},
					{ name : 'text', mapping : 'text', type: 'string'},
					{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
					{ name: 'isChild',	type: 'boolean'},
					{ name : 'iconCls', mapping : 'iconCls', type: 'string'}];
	},
	/**
	 * Gets the grid store's fields for the selected node
	 */
	getGridFields: function(node) {
			return [{name: 'node',	type: 'string'},
				{name : 'label', type: 'string'},
				{name: 'statusFlag', type: 'int'},
				{name: 'statusLabel', type: 'string'},
				{name: 'dueDate',	type: 'date', dateFormat: com.trackplus.TrackplusConfig.ISODateFormat},
				{name: 'defaultNoticed',	type: 'boolean'},
				{name: 'defaultScheduled',	type: 'boolean'},
				{name: 'isChild',	type: 'boolean'}];
	},
	/**
	 * Gets the grid columns for the selected node
	 */
	getGridColumns: function(node) {
			return [{text: getText('common.lbl.name'),
				flex:1, dataIndex: 'label', sortable: false, renderer:this.renderer},
			{text: getText('admin.project.release.lbl.status'),
				flex:1, dataIndex: 'statusLabel', sortable: false, renderer:this.renderer},
			{text: getText('admin.project.release.lbl.dueDate'),
				flex:1, dataIndex: 'dueDate', sortable: false,
				renderer:this.dateRenderer},
			{xtype: 'checkcolumn', text: getText('admin.project.release.lbl.defaultReleaseNoticed'),
				flex:1, dataIndex: 'defaultNoticed', sortable: false},
			{xtype: 'checkcolumn', text: getText('admin.project.release.lbl.defaultReleaseScheduled'),
				flex:1, dataIndex: 'defaultScheduled', sortable: false}];
	},
	dateRenderer: function(value, metadata, record) {
		if (record.data.statusFlag===2) {
			metadata.style = 'color:#909090';
		}
		return Ext.util.Format.date(value, com.trackplus.TrackplusConfig.DateFormat);
	},
	/**
	 * Renderer for grid columns
	 */
	renderer: function(value, metadata, record){
		if (record.data.statusFlag===2) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	/**
	 * Return false if dragging this node is not allowed
	 */
	canDragDropNode: function(nodeToDrag, copy, overModel) {
		return nodeToDrag && !nodeToDrag.isAncestor(overModel);
	},
	onDetachFromParentRelease: function() {
		var selectedRecord = this.getLastSelected(true);
		if (selectedRecord) {
			var nodeID = selectedRecord.data["id"];
			Ext.Ajax.request({
				url: this.getBaseAction() + "!clearParent.action",
				params: {
					node:nodeID
				},
				disableCaching:true,
				scope:this,
				success: function(response){
					com.trackplus.util.RefreshAfterSubmit.refreshTreeAfterSubmit.call(this, {nodeIDToSelect:nodeID, reloadTree:true});
				}
			});
		}
	},
	/**
	 * Get the panel items
	 * recordData: the record data (for the record to be edited or added to)
	 * isLeaf: whether add a leaf or a folder
	 * add: whether it is add or edit
	 * fromTree: operations started from tree or from grid
	 * operation: the name of the operation
	 */
	getPanelItems: function(recordData, isLeaf, add, fromTree, operation) {
		return com.trackplus.admin.project.Release.createEditPanelItems(this.labelWidth);
	},
	/**
	 * The method to process the data to be loaded arrived from the server
	 */
	getEditPostDataProcess: function(record, isLeaf, add) {
		return com.trackplus.admin.project.Release.postDataLoadCombo;
	},
	recommendedReplace:function(scope, submit, result) {
		var releaseTree = CWHF.createSingleTreePicker("admin.project.release.moveReleaseItems.replacementRelease",
	            "replacementID", result.replacementTree, null,
	            {itemId:"replacementID",
				allowBlank:true,
	            labelWidth:250,
	            margin:'5 0 0 0'
	            });
		var windowItems = [{xtype : 'label',
			html: result.errorMessage}, releaseTree];
		var title = getText("admin.project.release.moveReleaseItems.title");
		var replaceLoad = {loadHandler: function() {}};//nothing to load
		var replaceSubmit = {	//submitUrl:me.getReplaceAndDeleteUrl(extraConfig),
						//submitUrlParams:me.getReplaceAndDeleteParams(selectedRecords, extraConfig),
						submitButtonText:getText("common.btn.move"),
						submitHandler: function(window, submitUrl, submitUrlParams, extraConfig) {
							//var theForm = scope.formEdit.getForm();
							//var replaceReleaseForItems = scope.formPanel.getComponent("replacementID");
							submit.submitUrlParams["replacementID"]=releaseTree.getValue();
							window.close();
							scope.submitHandler(submit, this, 0);
						}
						//deleting more users can be a lengthy operation
	                    //timeout:300,
						//refreshAfterSubmitHandler:me.reload,
						//refreshParametersBeforeSubmit:me.getReloadParamsAfterDelete(selectedRecords, extraConfig, responseJson)
					};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig'/*,
				{postDataProcess:me.replaceOptionPostDataProcess, extraConfig:extraConfig}*/);
		windowConfig.showWindow(this, title, this.replacementWidth, this.replacementHeight, replaceLoad, replaceSubmit, windowItems);
	},
	/**
	 * The replacement items for the deleted entity
	 */
	getReplacementItems: function(responseJson, selectedRecords, extraConfig) {
		return [{xtype : 'label',
				itemId: 'replacementWarning'},
	            CWHF.createSingleTreePicker("Replacement",
	            "replacementID", [], null,
	            {itemId:"replacementID",
	            allowBlank:false,
	             blankText: getText('common.err.replacementRequired',
	                    this.getEntityLabel(extraConfig)),
	             labelWidth:150,
	             margin:'5 0 0 0'
	            })
				];
	},
	/**
	 * Load the data source and value for the replacement options tree
	 * Override this for different tree based pickers
	 */
	loadReplacementOptionData: function(replacementControl, data) {
	    replacementControl.updateMyOptions(data["replacementTree"]);
	},
	getActionItemIdsWithContextDependentLabel: function() {
		return ["editGridRow", "editTreeNode",
				"deleteGridRow", "deleteTreeNode", "moveUp", "moveDown", "showHide"];
	},
	/**
	 * Which actions to enable/disable depending on tree selection
	 */
	getToolbarActionChangesForTreeNodeSelect: function(selectedNode) {
		this.actionAddChildRelease.setDisabled(CWHF.isNull(selectedNode) || this.rootID===selectedNode.data['id']);
		this.actionEditGridRow.setDisabled(true);
		this.actionDeleteGridRow.setDisabled(true);
		this.actionMoveUp.setDisabled(true);
		this.actionMoveDown.setDisabled(true);
	},
	/**
	 * Enable/disable actions based on the actual selection
	 */
	enableDisableToolbarButtons: function (view, selections) {
		if (CWHF.isNull(selections) || selections.length===0) {
			this.actionAddChildRelease.setDisabled(true);
			this.actionDeleteGridRow.setDisabled(true);
			this.actionEditGridRow.setDisabled(true);
			this.actionMoveUp.setDisabled(true);
			this.actionMoveDown.setDisabled(true);
		} else {
			this.actionDeleteGridRow.setDisabled(false);
			if (selections.length===1) {
				this.actionAddChildRelease.setDisabled(false);
				this.actionEditGridRow.setDisabled(false);
				this.actionMoveUp.setDisabled(false);
				this.actionMoveDown.setDisabled(false);
			} else {
				this.actionAddChildRelease.setDisabled(true);
				this.actionEditGridRow.setDisabled(true);
				this.actionMoveUp.setDisabled(true);
				this.actionMoveDown.setDisabled(true);
			}
		}
	},
	getRootID: function() {
		return this.getProjectID();
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
com.trackplus.vc={};
Ext.define("com.trackplus.vc.VersionControlFacade",{
	extend:'Ext.Base',
	config: {
		versionControlFacadeModel:null
	},
	view:null,
	vcController:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
		me.vcController=Ext.create('com.trackplus.vc.VersionControlController',{
			versionControlControllerModel:me.versionControlFacadeModel
		});
	},
	getDetailPanel:function(){
		var me=this;
		return me.vcController.createView.call(me.vcController);
	},
	initActions:function(){
		this.vcController.initToolbar.call(this.vcController);
	},
	getToolbarActions:function(){
		var me=this;
		return me.vcController.getToolbar.call(me.vcController);
	}
});
Ext.define("com.trackplus.vc.VersionControlController",{
	extend:'Ext.Base',
	config: {
		versionControlControllerModel:null
	},
	vcView:null,
	lastFormData:null,
	vcPlugin:null,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		me.initialConfig = config;
		Ext.apply(me, config);
		this.initConfig(config);
	},
	createView:function(){
		var me=this;
		me.vcView=Ext.create('com.trackplus.vc.VersionControlView',{
			versionControlViewModel:me.versionControlControllerModel,
			vcController:me
		});
		me.addMyListeners();
		me.loadData.call(me);
		return me.vcView;
	},
	getVcView:function(){
		var me=this;
		if(CWHF.isNull(me.vcView)){
			me.createView();
		}
		return me.vcView;
	},
	addMyListeners:function(){
		var me=this;
		me.vcView.addListener('changeUseVC',me.changeUseVC,me);
		me.vcView.addListener('changeVC',me.changeVC,me);
	},
	getToolbar:function(){
		var me=this;
		if(CWHF.isNull(me.actionSave)){
			me.initToolbar();
		}
		return [me.actionSave];
	},
	initToolbar:function(){
		var me=this;
		me.actionSave=Ext.create('Ext.Action',{
			overflowText:getText('common.btn.save'),
			tooltip:getText('common.btn.save'),
			text: getText('common.btn.save'),
			iconCls: 'save',
			disabled:false,
			handler:function(){
				me.save.call(me);
			}
		});
	},
	loadData:function(){
		var me=this;
		var urlStr="versionControlConfig.action";
		Ext.Ajax.request({
			url: urlStr,
			params:{projectID:+me.versionControlControllerModel.projectID},
			disableCaching:true,
			scope: me,
			success: function(response){
				var responseJson = Ext.decode(response.responseText);
				var data=responseJson.data;
				me.versionControlControllerModel=data;
				me.lastFormData=me.versionControlControllerModel;
				me.vcView.cmbVCPlugins.store.loadData(me.versionControlControllerModel['vcPluginList']);
				me.vcView.cmbVCPlugins.setValue(me.versionControlControllerModel['vc.versionControlType']);
				me.vcView.checkUseVC.setValue(''+me.versionControlControllerModel['vc.useVersionControl']);
			}
		});
	},
	save:function(){
		var me=this;
		var urlStr="versionControlConfig!save.action?projectID="+me.versionControlControllerModel.projectID;
		borderLayout.setLoading(true);
		me.vcView.formPanel.getForm().submit({
			url:urlStr,
			params:{
				'vc.useVersionControl':me.vcView.checkUseVC.getRawValue(),
				'vc.versionControlType':me.vcView.cmbVCPlugins.getValue()
			},
			success: function(form, action) {
				borderLayout.setLoading(false);
				var success=action.result.success;
				if(success===false){
					me.handleErrors(action.result.errors);
				}else{
					CWHF.showMsgInfo(getText('admin.project.versionControl.successSave'));
				}
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				me.handleErrors(action.result.errors);
			}
		});
	},
	testVC:function(){
		var me=this;
		if(!me.vcView.formPanel.getForm().isValid()){
			CWHF.showMsgError(getText('admin.project.versionControl.errorSave'));
			return false;
		}
		borderLayout.setLoading(true);
		var urlStr='versionControlConfig!test.action?projectID='+me.versionControlControllerModel.projectID;
		me.vcView.formPanel.getForm().submit({
			url:urlStr,
			params:{
				'vc.useVersionControl':me.vcView.checkUseVC.getRawValue(),
				'vc.versionControlType':me.vcView.cmbVCPlugins.getValue()
			},
			success: function(form, action) {
				borderLayout.setLoading(false);
				CWHF.showMsgInfo('The settings are valid');
			},
			failure: function(form, action) {
				borderLayout.setLoading(false);
				if(action.result&&action.result.errors){
					me.handleErrors(action.result.errors);
				}else{
					CWHF.showMsgError('Invalid settings!');
				}
			}
		});
	},
	handleErrors:function(errors){
		var me=this;
		var errMsg=getText('admin.project.versionControl.errorSave');
		for(var i=0;i<errors.length;i++){
			var inputComp=me.vcPlugin.getControl.call(me.vcPlugin,errors[i].id);
			if(inputComp){
				inputComp.markInvalid(errors[i].label);
			}else{
				errMsg=errMsg+errors[i].label+' ';
			}
		}
		CWHF.showMsgError(errMsg);
	},
	changeVC:function(pluginID){
		var me=this;
		me.lastFormData=me.vcView.formPanel.getForm().getValues();
		me.doChangeVC(pluginID);
	},
	doChangeVC:function(pluginID){
		var me=this;
		me.vcView.clearFormPanel();
		me.vcPlugin=null;
		var pluginCls=null;
		var pluginDescriptor=null;
		var vcPluginList=me.versionControlControllerModel['vcPluginList'];
		for(var i=0;vcPluginList&&i<vcPluginList.length;i++){
			if(vcPluginList[i].id===pluginID){
				pluginDescriptor=vcPluginList[i];
				pluginCls=pluginDescriptor['jsConfigClass'];
				break;
			}
		}
		if(pluginCls){
			try{
				me.vcPlugin=Ext.create(pluginCls,{
					versionControlPluginModel:me.versionControlControllerModel,
					pluginDescriptor:pluginDescriptor
				});
			}catch(e){
				alert("ex:"+e);
			}
		}
		if(me.vcPlugin&&me.vcView.checkUseVC.getRawValue()){
			me.vcView.replaceFormPanel(me.vcPlugin);
			me.vcView.setLoading(true);
			var urlStr="versionControlConfig!loadVCPlugin.action";
			me.vcView.formPanel.getForm().load({
				url:urlStr,
				params:{
					projectID:me.versionControlControllerModel.projectID,
					pluginID:pluginID
				},
				success:function(form,action){
					var data=action.result.data;
					try{
						me.vcPlugin.postProcessDataLoad.call(me.vcPlugin,data);
					}catch(e){}
					me.vcView.setLoading(false);
				}
			});
		}
	},
	changeUseVC:function(useVC){
		var me=this;
		me.vcView.cmbVCPlugins.setDisabled(!useVC);
		me.vcView.testBtn.setDisabled(!useVC);
		if(CWHF.isNull(useVC&&me.vcView.cmbVCPlugins.getValue())){
			if(me.versionControlControllerModel['vcPluginList']&&me.versionControlControllerModel['vcPluginList'].length>0){
				me.vcView.cmbVCPlugins.setValue(me.versionControlControllerModel['vcPluginList'][0].id);
			}
		}
		me.doChangeVC(me.vcView.cmbVCPlugins.getValue());
	}
});
Ext.define("com.trackplus.vc.VersionControlView",{
	extend:'Ext.panel.Panel',
	config: {
		versionControlViewModel:null,
		vcController:null
	},
	region:'center',
	layout:'border',
	border:false,
	bodyBorder:false,
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		//TODO remove comment and check the right way to call adding events
//		this.addEvents('changeVC','changeUseVC');
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=new Array();
		me.checkUseVC=Ext.create('Ext.form.field.Checkbox',{
			fieldLabel:getText('admin.project.versionControl.useVersionControl'),
			name      : 'vc.useVersionControl',
			labelAlign :'right',
			labelWidth:250,
			style:{marginLeft:'15px'},
			inputValue: 'true',
			listeners:{
				change: {fn:me.changeUseVC, scope:me}
			}
		});
		me.cmbVCPlugins= Ext.create('Ext.form.field.ComboBox', {
			hideLabel:true,
			style:{marginLeft:'5px'},
			displayField: 'label',
			valueField	 : 'id',
			store: new Ext.data.Store({
				data : [],
				fields	 : [{name:'id', type:'string'}, {name:'label', type:'string'}],
				autoLoad: false
			}),
			queryMode: 'local',
			typeAhead: true,
			triggerAction: 'all',
			name:"vc.versionControlType",
			listeners:{
				select: {fn:me.changeVC, scope:me}
			}
		});
		var infoBox=Ext.create('Ext.Component',{
			html: getText('admin.project.versionControl.help'),
			border:true,
			region:'north',
			cls:'infoBox_bottomBorder'
		});
		items.push(infoBox);
		me.northPanel=Ext.create('Ext.panel.Panel',{
			layout:{
				type: 'hbox',
				padding: 5
			},
			border:false,
			bodyBorder:false,
			items:[me.checkUseVC,me.cmbVCPlugins]
		});
		me.formPanel=Ext.create('Ext.form.Panel',{
			autoScroll:true,
			border:false,
			bodyBorder:false
		});
		me.testBtn=Ext.create('Ext.button.Button',{
			style:{marginTop:'10px', marginBottom: '5px', marginLeft:'275px'},
			disabled :true,
			iconCls: 'check16',
			text: getText('admin.project.versionControl.lbl.test'),
			handler:function(){
				me.vcController.testVC.call(me.vcController);
			},
			scope:me
		});
		me.centerPanel=Ext.create('Ext.panel.Panel',{
			region:'center',
			layout:'anchor',
			autoScroll:true,
			border:false,
			items:[me.northPanel,me.formPanel,me.testBtn]
		});
		items.push(me.centerPanel);
		return items;
	},
	changeUseVC:function(){
		var me=this;
		me.fireEvent.call(me,'changeUseVC',me.checkUseVC.getRawValue());
	},
	changeVC:function(){
		var me=this;
		me.fireEvent.call(me,'changeVC',me.cmbVCPlugins.getValue());
	},
	replaceFormPanel:function(pan){
		var me=this;
		me.formPanel.removeAll(true);
		me.formPanel.add(pan);
		me.formPanel.updateLayout();
	},
	clearFormPanel:function(){
		var me=this;
		me.centerPanel.remove(me.formPanel,true);
		me.formPanel=Ext.create('Ext.form.Panel',{
			autoScroll:true,
			border:false,
			bodyBorder:false
		});
		me.centerPanel.insert(1,me.formPanel);
		me.updateLayout();
		me.formPanel.removeAll(true);
		me.formPanel.updateLayout();
	}
});
Ext.define("com.trackplus.vc.VersionControlPlugin",{
	extend:'Ext.panel.Panel',
	config: {
		versionControlPluginModel:null,
		pluginDescriptor:null
	},
	layout:'anchor',
	labelWidth:250,
	textFieldWidth:250+300,
	alignR:'right',
	border:false,
	bodyBorder:false,
	bodyPadding:0,
	getControl:function(id){
		return null;
	},
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.callParent();
	},
	createChildren:function(){
		var me=this;
		var items=new Array();
		items.push(me.createBrowserFieldSet());
		return items;
	},
	postProcessDataLoad:function(data){
		var me=this;
		me.cmbBrowser.store.loadData(data.browsers);
		me.browserList=data.browsers;
		var browserID=data['vc.browserID'];
		me.cmbBrowser.setValue(browserID);
		var linksDisabled=(CWHF.isNull(browserID)||browserID==="-1");
		me.setDisabledLinks(linksDisabled);
		if(browserID === 'integratedwebsvn') {
			me.setRepoBrowserTxtFieldDisabled(true);
		}
	},
	createBrowserFieldSet:function(){
		var me=this;
		var options=[];
		me.cmbBrowser=CWHF.createCombo('admin.project.lbl.vcBrowser', 'vc.browserID',{data:options,idType:'string'},
			{select: {fn: me.changeBrowser, scope:me}});
		me.cmbBrowser.setValue(me.browser);
		me.cmbBrowserWrapper=Ext.create('com.trackplus.util.HelpWrapperComponent',{
			inputComp:me.cmbBrowser,
			helpStr:getText('admin.project.lbl.vcBrowser.help')
		});
		me.txtChangedLink=CWHF.createTextField('admin.project.lbl.vc.changesetLink','vc.changesetLink',{anchor:'100%'});
		me.txtAddedLink=CWHF.createTextField('admin.project.lbl.vc.addedLink','vc.addedLink',{anchor:'100%'});
		me.txtModifiedLink=CWHF.createTextField('admin.project.lbl.vc.modifiedLink','vc.modifiedLink',{anchor:'100%'});
		me.txtReplacedLink=CWHF.createTextField('admin.project.lbl.vc.replacedLink','vc.replacedLink',{anchor:'100%'});
		me.txtDeletedLink=CWHF.createTextField('admin.project.lbl.vc.deletedLink','vc.deletedLink',{anchor:'100%'});
		var fieldSetBrowser={
			xtype: 'fieldset',
			title: getText('admin.project.lbl.vcBrowser'),
			collapsible: false,
			defaultType: 'textfield',
			defaults: {anchor: '100%'},
			layout: 'anchor',
			items:[me.cmbBrowserWrapper,me.txtChangedLink,me.txtAddedLink,me.txtModifiedLink,
			me.txtReplacedLink,me.txtDeletedLink]
		};
		return fieldSetBrowser;
	},
	createRadioGroup:function(fieldLabelKey,name,value,options,handler, handlerScope,disabled){
		var me=this;
		var width=me.textFieldWidth;
		var columns=1;
		var items=new Array();
		for(var i=0;i<options.length;i++){
			items.push({
				name:name,
				inputValue: options[i].id,
				//id:name+"_"+options[i].id,
				boxLabel:options[i].label,
				checked:options[i].id===value
			});
		}
		var inputComp=Ext.create('Ext.form.RadioGroup',{
			fieldLabel:CWHF.isNull(fieldLabelKey)?"":getText(fieldLabelKey),
			hideLabel:(CWHF.isNull(fieldLabelKey)),
			labelStyle:{overflow:'hidden'},
			labelWidth:me.labelWidth,
			labelAlign:me.alignR,
			width:width,
			anchor:'100%',
			layout: 'hbox',
			columns: columns,
			vertical: true,
			defaults:{margin:'0 5 0 0'},
			listeners: {
				change: function(radioGroup, newValue, oldValue, options) {
					if(handler){
						handler.call(handlerScope,radioGroup, newValue, oldValue, options);
					}
				}
			},
			items:items
		});
		return inputComp;
	},
	setDisabledLinks:function(linksDisabled){
		var me=this;
		me.txtChangedLink.setDisabled(linksDisabled);
		me.txtAddedLink.setDisabled(linksDisabled);
		me.txtModifiedLink.setDisabled(linksDisabled);
		me.txtReplacedLink.setDisabled(linksDisabled);
		me.txtDeletedLink.setDisabled(linksDisabled);
	},
	setRepoBrowserTxtFieldDisabled: function(isDisabled) {
		var me = this;
		me.txtChangedLink.setReadOnly(isDisabled);
		me.txtAddedLink.setReadOnly(isDisabled);
		me.txtModifiedLink.setReadOnly(isDisabled);
		me.txtReplacedLink.setReadOnly(isDisabled);
		me.txtDeletedLink.setReadOnly(isDisabled);
	},
	changeBrowser:function(){
		var me=this;
		var browserValue=me.cmbBrowser.getValue();
		var linksDisabled=(CWHF.isNull(browserValue)||browserValue==="-1");
		me.setDisabledLinks(linksDisabled);
		var changesetLink="";
		var addedLink="";
		var modifiedLink="";
		var replacedLink="";
		var deletedLink="";
		if(me.browserList&&browserValue&&browserValue!=="-1"){
			for(var i=0;i<me.browserList.length;i++){
				var selected=false;
				if (me.browserList[i].id===browserValue) {
					changesetLink=me.browserList[i].baseURL+me.browserList[i].changesetLink;
					addedLink=me.browserList[i].baseURL+me.browserList[i].addedLink;
					modifiedLink=me.browserList[i].baseURL+me.browserList[i].modifiedLink;
					replacedLink=me.browserList[i].baseURL+me.browserList[i].replacedLink;
					deletedLink=me.browserList[i].baseURL+me.browserList[i].deletedLink;
					break;
				}
			}
		}
		me.txtChangedLink.setValue(changesetLink);
		me.txtAddedLink.setValue(addedLink);
		me.txtModifiedLink.setValue(modifiedLink);
		me.txtReplacedLink.setValue(replacedLink);
		me.txtDeletedLink.setValue(deletedLink);
		if(browserValue === 'integratedwebsvn') {
			me.setRepoBrowserTxtFieldDisabled(true);
		} else {
			me.setRepoBrowserTxtFieldDisabled(false);
		}
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
/**
 * Class for role and account assignments for project
 */
Ext.define('com.trackplus.admin.project.RoleAssignment',{
	extend:'com.trackplus.admin.TreeDetailAssignment',
	config: {
		rootID: '_'
	},
	baseAction:'roleAssignments',
	/**
	 * actions
	 */
	actionRemovePerson: null,
	constructor: function(config) {
		var config = config || {};
		this.initConfig(config);
		this.initBase();
	},
	getEntityLabel: function(extraConfig) {
		var isGroup = false;
		if (extraConfig && extraConfig.selectedRecord) {
			isGroup = extraConfig.selectedRecord.data["isGroup"];
		}
		if (isGroup) {
			return getText("admin.user.group.lbl.group");
		} else {
			return getText("admin.user.lbl.user");
		}
	},
	/**
	 * Initialize all possible actions
	 */
	initActions: function() {
		this.actionRemovePerson = this.createLocalizedAction(getText("common.lbl.remove", getText("admin.user.lbl.user")),
				this.getDeleteIconCls(), this.onRemovePerson, getText("common.lbl.remove", getText("admin.user.lbl.user")));
		this.actionRemovePerson = this.createAction("common.lbl.remove", this.getDeleteIconCls(), this.onRemovePerson, false,
				"common.lbl.remove", "removePerson");
	},
	/**
	 * Context menu for tree
	 */
	getTreeContextMenuActions: function(selectedRecord, selectionIsSimple) {
		if (selectedRecord.isLeaf()) {
			return [this.actionRemovePerson];
		} else {
			return [];
		}
	},
	getActionItemIdsWithContextDependentLabel: function() {
		return ["removePerson"];
	},
	/**
	 * The message to appear first time after selecting this menu entry
	 * Is should be shown by selecting the root but the root is typically not visible
	 */
	getRootMessage: function() {
		return getText("admin.project.roleAssignment.lbl.infoGeneral");
	},
	onRemovePerson: function() {
		this.reloadAssigned(this.getBaseAction()+"!unassign.action", {});
	},
	/**
	 * Gets the tree's fields
	 */
	getTreeFields: function() {
		return [{name : 'id', mapping : 'id', type: 'string'},
				{ name : 'text', mapping : 'text', type: 'string'},
				{ name : 'leaf', mapping : 'leaf', type: 'boolean'},
				{ name : 'group', mapping : 'group', type: 'boolean'},
				{ name : 'iconCls', mapping : 'iconCls', type: 'string'}];
	},
	getGridFields: function(record) {
		return [{name:'id', type:'int'},
				{name:'name', type:'string'},
				{name:'userName', type:'string'},
				{name:'active', type:'boolean'},
				{name:'activeLabel', type:'string'},
				{name:'group', type:'boolean'},
				{name:'groupLabel', type:'string'},
				{name:'employeeId', type:'string'},
				{name:'department', type:'string'}];
	},
	getColumnModel: function() {
		return [{
			text:getText('common.lbl.name'),
			flex:2, dataIndex:'name', sortable:true,groupable:false,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.userName'),
			flex:1, dataIndex:'userName', sortable:true,groupable:false,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.user.profile.lbl.department'),
			flex:2, dataIndex:'department', sortable:true,groupable:true,
			renderer:this.renderer,
			filter: {
	            type: "string"
	        }
		}, {
			text:getText('admin.project.roleAssignment.lbl.group'),
			flex:1, dataIndex:'groupLabel', sortable:true, groupable:true,
			renderer:this.renderer,
			filter: {
				type: "list",
				options: [getText("common.boolean.Y"),
							getText("common.boolean.N")]
			}
		}, {
			text:getText('admin.user.profile.lbl.employeeId'),
			flex:1, dataIndex:'employeeId', sortable:true,groupable:false,
			renderer:this.renderer, hidden:true,
			filter: {
	            type: "string"
	        }
		},{
			text: getText('admin.user.manage.lbl.activ'),
			flex:1, dataIndex: 'activeLabel', sortable:true,groupable:true,
			renderer:this.renderer, hidden:true,
			filter: {
				type: "list",
				options: [getText("common.boolean.Y"),
							getText("common.boolean.N")]
			}
		}];
	},
	/**
	 * Render the inherited rows as grey
	 */
	renderer: function(value, metadata, record) {
		if (!record.data["active"]) {
			metadata.style = 'color:#909090';
		}
		return value;
	},
	hideGridHeaders: function() {
		return false;
	},
	enableColumnHide: function() {
		return true;
	},
	getGridFeatures: function() {
		var groupingFeature = Ext.create('Ext.grid.feature.Grouping',{
			groupHeaderTpl: '{name} ({rows.length} Item{[values.rows.length > 1 ? "s" : ""]})'
		});
		return features = [groupingFeature];
	},
	getGroupingFeature:function(features){
	  return features[0];
	},
	getDetailWidth: function() {
		return 600;
	},
	getDetailHeight: function() {
		return 600;
	},
	getMinWidth: function() {
		return 425;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ImportWizard',{
	extend:'Ext.Base',
	config: {
	},
	wizardPanel: null,
	fileName: null,
	uploadDone: false,
	constructor : function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	getToolbarActions: function() {
		//return this.actions;
		return [];
	},
	/**
	 * Initialize the wizard panel. The initialization will be actualized
	 * once the card's data is loaded or further edited by the user
	 */
	getWizardPanel: function() {
		var toolbarItems = [];
		var numberOfCards = this.getNumberOfCards();
		if (numberOfCards>1) {
			toolbarItems.push({xtype: 'button',
				itemId: 'previous',
				text:'&laquo; '+ getText('common.lbl.wizard.previous'),
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, btn.up("panel"));
				},
				//at the beginning disabled
				disabled: true
			});
			toolbarItems.push('-');
			toolbarItems.push({xtype: 'button',
				itemId: 'next',
				text: getText('common.lbl.wizard.next')+' &raquo;',
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, btn.up("panel"));
				}
			});
			toolbarItems.push('-');
			toolbarItems.push({xtype: 'button',
				itemId: 'finish',
				iconCls: 'import16',
				text: getText('common.btn.import'),
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, btn.up("panel"));
				},
				disabled: true
				});
			toolbarItems.push('->');
			toolbarItems.push({xtype  : 'box',
				itemId : 'indicator',
				style  : 'margin-right: 5px',
				width: 100,
				autoEl : {
					tag	: 'div',
					html: ''
				}
			 });
		} else {
			//for direct import no navigation is needed
			toolbarItems.push({	itemId: 'finish',
				text: getText('common.btn.import'),
				scope: this,
				handler: function(btn) {
					this.loadDataForCard(1, true);
				},
				disabled: false
			});
		}
		this.wizardPanel = Ext.create('Ext.panel.Panel', {
			title: '',
			layout: 'card',
			region: 'center',
			cls: 'importWizard',
			//bodyStyle: 'padding:15px; border-left:none',
			//bodyStyle: 'border-left:none',
			defaults: {
				// applied to each contained panel
				border: false
			},
			// the panels (or "cards") within the layout
			items: [this.createEmptyCard("card1", true)],
			dockedItems: [{
				xtype: 'toolbar',
				cls: 'importWizard',
				dock: 'top',
				items: toolbarItems
			}]
		});
		this.initCards(2);
		this.loadDataForCard(1);
		return this.wizardPanel;
	},
	/**
	 * Depending on the actual card and data initialize the expected cards depending on the data received
	 */
	/*private*/initCards: function(cardNo) {
		//first clean the eventual next cards
		var layoutItems = this.wizardPanel.getLayout().getLayoutItems();
		if (layoutItems.length>1) {
			for ( var i = cardNo-1; i < layoutItems.length; i++) {
				this.wizardPanel.remove(layoutItems[i], true);
			}
		}
		for (var i = cardNo; i <= this.getNumberOfCards(); i++) {
			this.wizardPanel.add(this.createEmptyCard("card"+ i, false));
		}
		//actualize the toolbar according to the number of wizard panels
		this.actualizeToolbar(this.wizardPanel);
	},
	removeCard: function(cardNo) {
		var layoutItems = this.wizardPanel.getLayout().getLayoutItems();
		if (layoutItems.length>=cardNo) {
			this.wizardPanel.remove(cardNo-1, true);
		}
		//actualize the toolbar according to the number of wizard panels
		this.actualizeToolbar(this.wizardPanel);
	},
	getNumberOfCards: function() {
		return 1;
	},
	/**
	 * Creates a new empty form panel for a card
	 */
	createEmptyCard: function(itemId, fileUpload) {
		var panelConfig = {
				itemId: itemId,
				componentCls: 'importWizard',
				fileUpload:	fileUpload,
				//bodyStyle:	'padding: 5px; border-left:none',
				border: false,
				autoScroll:true,
				defaults: {
					labelStyle:'overflow: hidden;',
					//margin:"5 5 0 0",
					msgTarget:	'side'/*,
					anchor:	'-20'*/
				},
				method: "POST",
				//autoScroll:	true,
				items: []
			};
		return Ext.create('Ext.form.Panel', panelConfig);
	},
	onNavigate: function(btn, panel) {
		var layout = panel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = panel.items.indexOf(activeItem);
		var numItems = panel.items.getCount() - 1;
		if (btn) {
	        var params = null;
			if (btn.itemId === 'next' || btn.itemId === 'finish' && index <= numItems) {
				//+ 2 because index is 0 based and the data for the next card is loaded
				var reload = false;
				if (index===numItems) {
					//reload the error handling card
					index = index-1;
					reload = true;
	                //two forms should be submitted by conflict handling: the second one is "serialized" in params
	                params = this.getDataBeforeCardDelete(index+2, reload);
				}
				//TODO: redundantly initializes the next cards.
				//After a form is submitted and we go back to the previous card
				//the field values of the already submitted data is somehow stored/cached in the Ext.form.Basic
				//(even if the Ext.form.Panel form with all his fields is removed). Consequently when the form will be sumbitted
				//next time all form field values are duplicated in submit resulting in server side errors.
				//To avoid this initialize all next cards after each next.
				this.initCards(index+2);
				var dataIsValid = this.loadDataForCard(index+2, reload, params);
				if (dataIsValid!==false) {
					//if data is valid then change to the next card
					panel.layout.setActiveItem(index + 1);
				}
			} else {
				if (btn.itemId === 'previous' && index > 0) {
					var activeItem = layout.getActiveItem();
					//remove all data from the current card before moving back to the previous card: next always starts from an empty card
					activeItem.removeAll();
					panel.layout.setActiveItem(index - 1);
				}
			}
		}
		this.actualizeToolbar(panel);
	},
	/**
	 * Go back to the previous card if after submitting a card an error is received from the server
	 * (if data validation fails on the client side before submit then the card is not incremented anyway)
	 */
	goPrevious: function() {
		var layout = this.wizardPanel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = this.wizardPanel.items.indexOf(activeItem);
		//var numItems = this.wizardPanel.items.getCount() - 1;
		if (index > 0) {
			this.wizardPanel.layout.setActiveItem(index - 1);
		}
		this.actualizeToolbar(this.wizardPanel);
	},
	goNext: function() {
		var layout = this.wizardPanel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = this.wizardPanel.items.indexOf(activeItem);
		//var numItems = this.wizardPanel.items.getCount() - 1;
		if (index > 0) {
			this.wizardPanel.layout.setActiveItem(index + 1);
		}
		this.actualizeToolbar(this.wizardPanel);
	},
	/**
	 * Actualize the toolbar settings according to the current index
	 */
	actualizeToolbar: function(panel) {
		var layout = panel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = panel.items.indexOf(activeItem);
		var numItems = panel.items.getCount();
		var toolbar = panel.getDockedItems('toolbar[dock="top"]');
		var previous = toolbar[0].getComponent('previous');
		if (previous) {
			previous.setDisabled(!layout.getPrev());
		}
		var next = toolbar[0].getComponent('next');
		if (next) {
			next.setDisabled((index+1)>=(numItems-1));
		}
		var finish = toolbar[0].getComponent('finish');
		if (finish) {
			finish.setDisabled((index+1)!==(numItems-1));
		}
		var indicator = toolbar[0].getComponent('indicator');
		if (indicator) {
			var indicatorText = getText("common.lbl.wizard.step", (index + 1), numItems);
			panel.setTitle(this.getTitle(index + 1));
			indicator.update(indicatorText);
		}
	},
	/**
	 * Gets the card title depending on card number
	 * should be overridden in the derived classes
	 */
	/*protected abstract*/getTitle: function(cardNo) {
		return '';
	},
	validateFileExtension: function(fileName) {
		var exp = this.getFilePattern();
		return exp.test(fileName);
	},
	/*protected abstract*/getFilePattern: function() {
		return /^.*$/
	},
	/*protected abstract*/getFileTypeLabel: function() {
		return "";
	},
	/*protected abstract*/getFileEmptyText: function() {
	    return "";
	},
	/**
	 * Load/submit the data for on the cardNo
	 * cardNo: the card number to go next, or the actual card number if reload
	 * reload: whether to reload the current card or submit the current values and go to the next card
	 * return false and optionally show an alert box if there is a validation problem which prevents navigating to the next card
	 */
	/*protected abstract*/loadDataForCard: function(cardNo, reload, params) {
	},
	/*protected abstract*/getDataBeforeCardDelete: function(cardNo, reload) {
	},
	submitFromCardToCard: function(cardFrom, cardTo, params, reload, timeout) {
		var me = this;
		var panelFrom = this.wizardPanel.getComponent("card" + cardFrom);
		var panelTo = this.wizardPanel.getComponent("card" + cardTo);
		if (!panelFrom.getForm().isValid()) {
			return false;
		}
		var showLoadingOnComp = me.getWindowComponent();
		if (CWHF.isNull(showLoadingOnComp)) {
			showLoadingOnComp = panelTo;
		}
		showLoadingOnComp.setLoading(getText("common.lbl.loading"));
	   if (timeout) {
	        //for huge files the import can take longer as the standard 30 sec timeout
	        //if timeout expires before the file is completely processed the failure callback executed
	        panelFrom.getForm().timeout = timeout;
	    }
		panelFrom.getForm().submit({
			url: this.getImportWizardUrl(cardTo, reload),
			params: params,
			scope: this,
			method: "POST",
			success: function(form, action) {
				showLoadingOnComp.setLoading(false);
				panelTo.removeAll(true);
				panelTo.add(this.getImportWizardItemsForCard(cardTo));
				this.postDataProcess(panelTo, action.result, cardTo, cardFrom);
			},
			failure: function(form, action) {
				showLoadingOnComp.setLoading(false);
				panelTo.removeAll();
				panelTo.add(this.getImportWizardItemsForCard(cardTo));
	            var data = action.result;
	            if (CWHF.isNull(data)) {
	                //not controlled failure: for ex. connection time out
	                data =  action.response;
	            }
				this.postDataProcess(panelTo, data, cardTo, cardFrom);
			}
		});
	},
	submitFromCardToCardMessageOnFailure: function(cardFrom, cardTo, params, reload, back) {
		var me = this;
		var panelFrom = this.wizardPanel.getComponent("card" + cardFrom);
		var panelTo = this.wizardPanel.getComponent("card" + cardTo);
		var showLoadingOnComp = me.getWindowComponent();
		if (CWHF.isNull(showLoadingOnComp)) {
			showLoadingOnComp = panelTo;
		}
		showLoadingOnComp.setLoading(getText("common.lbl.loading"));
		panelFrom.getForm().submit({
			url: this.getImportWizardUrl(cardTo, reload),
			params: params,
			scope: this,
			method: "POST",
			success: function(form, action) {
				showLoadingOnComp.setLoading(false);
				//do not recreate the form (items for card) if there is no card change
				//because the previous fields in the formBase are not cleaned
				//consequently it would duplicate the fields to submit
				//instead upgrade the existing fields with refreshed data
				if (cardFrom!==cardTo) {
					panelTo.removeAll(true);
					var panel = this.getImportWizardItemsForCard(cardTo);
					panelTo.add(panel);
				}
				this.postDataProcess(panelTo, action.result, cardTo, cardFrom);
			},
			failure: function(form, action) {
				showLoadingOnComp.setLoading(false);
				if (back) {
					this.goPrevious();
				}
				com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	},
	/*protected abstract*/getImportWizardUrl: function(card, reload) {
		return "";
	},
	/**
	 * Get the initial items for a card
	 * Additional items can be added once the data is back from the server
	 */
	/*protected abstract*/getImportWizardItemsForCard: function(card) {
		return this.getImportWizardCard1Items();
	},
	/*protected abstract*/postDataProcess: function(panel, data, cardTo, cardFrom) {
		this.postProcessCard1(panel, data);
	},
	/**************************Import source**************************************/
	/*protected*/getImportWizardCard1Items: function() {
		var card1Items = [CWHF.createFileField(
							getText("common.lbl.file", this.getFileTypeLabel()), 'uploadFile',
							{itemId:"uploadFile", allowBlank:false, labelWidth:250, width:700, labelIsLocalized: true, emptyText:this.getFileEmptyText()},
							{change:{fn:function(){
								this.uploadDone=false;},
								scope:this}})];
		card1Items.push({xtype: 'label',
			itemId: 'importSourceError'});
		return card1Items;
	},
	/**
	 * Post process first card data
	 * Called after first loading the first card data and after each import source change
	 */
	postProcessCard1: function(formPanel, data) {
		var uploadFile = formPanel.getComponent('uploadFile');
		uploadFile.setRawValue('');
	},
	getWindowComponent: function() {
		return null;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ImportExcel',{
	extend:'com.trackplus.admin.action.ImportWizard',
	config: {
	},
	itemNavigatorController: null,
	selectedSheet: null,
	workItemIDFieldIDs:null,
	window: null,
	dialogHeight:470,
	dialogWidth:850,
	getNumberOfCards: function() {
		return 4;
	},
	getTitle: function(cardNo) {
		var titleKey=null;
		switch (cardNo) {
		case 1:
			titleKey = "admin.actions.importExcel.title.upload";
			break;
		case 2:
			titleKey = "admin.actions.importExcel.title.excelFieldMatch";
			break;
		case 3:
			titleKey = "admin.actions.importExcel.invalidValueHadling.title";
			break;
		case 4:
			titleKey = "admin.actions.importExcel.title.errorAndConflict";
			break;
		}
		if (titleKey) {
			return getText(titleKey);
		} else {
			return '';
		}
	},
	getFilePattern: function(fileName) {
		return /^.*\.(xls|XLS|xlsx|XLSX)$/;
	},
	getFileTypeLabel: function() {
		return getText('admin.actions.importExcel.lbl.uploadFile');
	},
	getFileEmptyText: function() {
	    //return getText("admin.actions.importExcel.lbl.fileEmptyText");
	    //TODO replace back as soon as the drag and drop works in browser
	    return "";
	},
	getImportWizardUrl: function(card, reload) {
		if (card===1) {
			return 'excelUploadRender.action';
		} else {
			if (card===2) {
				return 'excelUpload.action';
			} else {
				if (card===3) {
					if (reload) {
						return "excelInvalidValueHandling.action";
					} else {
						return "excelFieldMatch!save.action";
					}
				} else {
					if (card===4) {
						return "excelImport.action";
					}
				}
			}
		}
	},
	getDataBeforeCardDelete: function(cardNo, reload) {
	    var params = null;
	    if (cardNo===4) {
	        params = {fileName:this.fileName, selectedSheet: this.selectedSheet};
	        if (reload && this.workItemIDFieldIDs) {
	            var overwriteMap = new Object();
	            var card4 = this.wizardPanel.getComponent("card4");
	            var errorAndConflictPanel = card4.getComponent('errorAndConflict');
	            var conflictPanel = errorAndConflictPanel.getComponent('conflictPanel');
	            Ext.Array.forEach(this.workItemIDFieldIDs, function(workItemIDFieldID) {
	                var radioButtons = conflictPanel.getComponent('conflictResoultion'+workItemIDFieldID);
	                var paramName = "overwriteMap['" + workItemIDFieldID + "']";
	                var paramValue = CWHF.getSelectedRadioButtonValue(radioButtons);
	                params[paramName]= paramValue;
	            }, this);
	        }
	    }
	    return params;
	},
	/**
	 * Load/submit the data for on the cardNo
	 * cardNo: the card number to go next, or the actual card number if reload
	 * reload: whether to reload the current card or submit to the current values and go to the next card
	 * return false and optionally show an alert box if there is a validation problem which prevents navigating to the next card
	 */
	loadDataForCard: function(cardNo, reload, params) {
		if (cardNo===1) {
			//for the very first card nothing to submit only render (load)
			var panel1 = this.wizardPanel.getComponent('card1');
			panel1.add(this.getImportWizardItemsForCard(cardNo));
			panel1.getForm().load({
				url: this.getImportWizardUrl(cardNo, reload),
				scope: this,
				success : function(form, action) {
					try{
						this.postDataProcess(panel1, action.result.data, 1);
						//if data is valid we can go to the next card
					}catch(ex){}
				},
				failure: function(form, action) {
					Ext.MessageBox.alert(this.failureTitle, action.response.responseText)
				}
			});
		} else {
			//from card to each card starts with a submit
			if (cardNo===2) {
				var panel1 = this.wizardPanel.getComponent('card1');
				if (!panel1.getForm().isValid()) {
					// Ext.MessageBox.alert('',
					Ext.MessageBox.show({
							title: '',
							msg: getText('admin.actions.importTp.lbl.uploadFileNotSpecified'),
							buttons: Ext.Msg.OK,
							icon: Ext.MessageBox.ERROR
					});
					return false;
				}
				var importFile = panel1.getComponent('uploadFile');
				if (!this.validateFileExtension(importFile.getRawValue())) {
					Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileWrongType'),
						getText('common.err.fileExpectedType', this.getFileTypeLabel()));
					return false;
				}
				if (this.uploadDone) {
					Ext.MessageBox.alert(getText('admin.actions.importTp.err.uploadAgain'),
							getText('admin.actions.importTp.err.uploadAgain', this.getFileTypeLabel()));
						return false;
				}
				this.uploadDone = true;
				this.submitFromCardToCardMessageOnFailure(1, 2, null, reload, true);
			} else {
				if (cardNo===3) {
					var cardToSubmit = 2;
					if (reload) {
						cardToSubmit = 3;
					}
					var params = {fileName:this.fileName, selectedSheet: this.selectedSheet, reload: reload};
					this.submitFromCardToCardMessageOnFailure(cardToSubmit, 3, params, reload, true);
				} else {
					if (cardNo===4) {
	                    if (CWHF.isNull(params)) {
	                        params = {fileName:this.fileName, selectedSheet: this.selectedSheet};
	                    }
						this.submitFromCardToCard(3, 4, params, false, 300000);//5 minutes timeout
					}
				}
			}
		}
	},
	/**
	 * Get the initial items for a card
	 * Additional items can be added once the data is back from the server
	 */
	getImportWizardItemsForCard: function(card) {
		if (card===1) {
			var items = this.getImportWizardCard1Items();
			if(items && items.length > 0) {
				items[0].setMargin('2 0 0 0');
			}
			return items;
		} else {
			if (card===2) {
				return this.getExcelMappingItems();
			} else {
				if (card===3) {
						return this.getExcelInvalidHandlingItems();
				} else {
					if (card===4) {
						return  this.getExcelErrorAndConflictHandlingItems();
					}
				}
			}
		}
	},
	postDataProcess: function(panel, jsonResult, cardTo, cardFrom) {
		if (cardTo===1) {
			this.postProcessCard1(panel, jsonResult);
		} else {
			if (cardTo===2) {
				this.postProcessExcelMapping(panel, jsonResult);
				this.actualizeToolbar(this.wizardPanel);
			} else {
				if (cardTo===3) {
					this.postProcessInvalidHandling(panel, jsonResult, cardTo, cardFrom);
				} else {
					if (cardTo===4) {
						this.postProcessExcelErrorAndConflictHandling(panel, jsonResult);
					}
				}
			}
		}
	},
	/**************************Excel column - Genji field mappings**************************************/
	/**
	 * Gets the items for excel field mapping, before the data has arrived
	 */
	getExcelMappingItems: function() {
		var panelConfig = {
				itemId: 'mappings',
				layout: {
					type: 'table',
					columns: 4,
					tdAttrs: { style: {
							padding: '5px 15px 0 0'
						}
					}
				},
				bodyStyle:	'margin: 0 0 0 35px;',
				border: false,
				method: "POST",
				autoScroll:	true,
				items: []
			};
		return [{xtype: 'component',
	            cls:"infoBox_bottomBorder",
	            border:true,
	            anchor:'100%',
	            margin:"0 0 0 0",
	            html: getText("admin.actions.importExcel.fieldMatch.message")},
	        CWHF.createCombo('admin.actions.importExcel.fieldMatch.lbl.sheet', 'selectedSheet',
				{labelWidth:250, width:470, margin: '5 0 0 70', labelAlign:"right", itemId:"selectedSheet"},
				{select: {fn: this.reloadExcelFieldMapping, scope:this}}),
				Ext.create('Ext.form.Panel', panelConfig)];
	},
	/**
	 * Add field mappings data for rendering after the result has arrived
	 */
	postProcessExcelMapping: function(panel, jsonResult) {
		var data = jsonResult.data;
		this.fileName = data['fileName'];
		var excelFieldMapperExpressions = data['mappingExpressions'];
		var sheetNames = data['sheetNames'];
		var sheetsCombo = panel.getComponent('selectedSheet');
		sheetsCombo.store.loadData(data['sheetNames']);
		this.selectedSheet = data['selectedSheet'];
		sheetsCombo.setValue(data['selectedSheet']);
		var fieldList = data['fieldList'];
		items = [];
		items.push({xtype: 'label',
			html: '<b>'+getText('admin.actions.importExcel.fieldMatch.lbl.columnNumber')+'</b>'
			});
		items.push({xtype: 'label',
			html: '<b>'+getText('admin.actions.importExcel.fieldMatch.lbl.columnLabel')+'</b>'
			});
		items.push({xtype: 'label',
			html: '<b>'+getText('admin.actions.importExcel.fieldMatch.lbl.field')+'</b>'
			});
		items.push({xtype: 'label',
			html: '<b>'+getText('admin.actions.importExcel.fieldMatch.lbl.isIdentifier')+'</b>'
			});
		if (panel) {
			if (excelFieldMapperExpressions) {
				//var mappingExpressionPanels = [];
				Ext.Array.forEach(excelFieldMapperExpressions, function(mappingExpression) {
					var columnIndex = mappingExpression.columnIndex;
					items.push({xtype: 'label',
						html: mappingExpression.columnLetter,
						width: 200
						});
					items.push({xtype: 'label',
						html: mappingExpression.columnName,
						width: 200
					});
					items.push(CWHF.createCombo(null,
							'columnIndexToFieldIDMap[' + columnIndex + ']',
							{itemId:'columnMapping' + columnIndex,
							width:200,
							data:fieldList,
							value:mappingExpression.fieldID},
							{select: {fn: this.setIsIdentifier, scope:this,
								panel: panel,
								columnIndex: columnIndex,
								possibleIdentifiers: data['possibleIdentifiers'],
								mandatoryIdentifiers: data['mandatoryIdentifiers']}},
								'columnMapping'+columnIndex));
					items.push(CWHF.createCheckbox('','columnIndexIsIdentifierMap[' + columnIndex + ']',
							{itemId:'columnIsIdentifier'+columnIndex, width: 100, padding: '0 0 0 20',
						disabled:mappingExpression.identifierDisabled, value:mappingExpression.isIdentifier}));
				}, this);
			}
		}
		var mappingsPanel = panel.getComponent('mappings');
		mappingsPanel.removeAll(true);
		//add all panels at once
		mappingsPanel.add(items);
	},
	/**
	 * Reload the field mapping after changing the excel sheet
	 */
	reloadExcelFieldMapping: function(combo, records, eOpts) {
		var panel = this.wizardPanel.getComponent('card2');
		panel.setLoading(getText("common.lbl.loading"));
		this.selectedSheet = combo.getValue();
		Ext.Ajax.request({
			url: 'excelFieldMatch.action',
			params: {fileName:this.fileName, selectedSheet: this.selectedSheet},
			disableCaching:true,
			scope: this,
			success: function(response) {
				var responseJson = Ext.decode(response.responseText);
				this.postProcessExcelMapping(panel, responseJson);
				panel.setLoading(false);
			},
			failure: function(response){
				com.trackplus.util.requestFailureHandler(response);
				panel.setLoading(false);
			}
		})
	},
	/**
	 * Set/reset disable automatically the identifier checkbox by selecting a field
	 */
	setIsIdentifier: function(combo, records, options) {
		var panel = options.panel;
		var columnIndex = options.columnIndex;
		var possibleIdentifiers = options.possibleIdentifiers;
		var mandatoryIdentifiers = options.mandatoryIdentifiers;
		var mappingPanel = panel.getComponent('mappings');
		if (mappingPanel) {
			var fieldMapper = mappingPanel.getComponent("columnMapping" + columnIndex);
			var columnIsIdentifier = mappingPanel.getComponent("columnIsIdentifier" + columnIndex);
			//var selectedIndex = fieldMapper.selectedIndex;
			//var selectedValue = fieldMapper.options[selectedIndex].value;
			var selectedValue = fieldMapper.getValue();
			if (CWHF.isNull(selectedValue)|| ""===selectedValue) {
				//the empty entry -> field is not mapped
				columnIsIdentifier.setValue(false);
				columnIsIdentifier.setDisabled(true);
			} else {
				var isPossibleIdentifier = Ext.Array.contains(possibleIdentifiers, selectedValue);
				var isMandatoryIdentifier = Ext.Array.contains(mandatoryIdentifiers, selectedValue);
				if (isMandatoryIdentifier) {
					columnIsIdentifier.setValue(true);
					columnIsIdentifier.setDisabled(true);
				} else {
					if (isPossibleIdentifier) {
						columnIsIdentifier.setDisabled(false);
					} else {
						columnIsIdentifier.setValue(false);
						columnIsIdentifier.setDisabled(true);
					}
				}
			}
		}
	},
	/**************************Excel invalid value handling**************************************/
	/**
	 * Gets the items for excel invalid value handling, before the data has arrived
	 */
	getExcelInvalidHandlingItems: function() {
		var panelConfig = {
				itemId: 'invalidValueHandlingPanel',
				layout: {
					type: 'table',
					columns: 3,
					tdAttrs: { style: {
						padding: '5px 15px 0 0'
					}
				}
				},
				bodyStyle:	'padding: 5px',
				border: false,
				method: "POST",
				autoScroll:	true,
				items: []
			};
		return [{xtype: 'component',
	            cls:"infoBox_bottomBorder",
	            border:true,
	            anchor:'100%',
	            margin:"0 0 0 0",
	            html: getText("admin.actions.importExcel.invalidValueHadling.message")},
	        Ext.create('Ext.form.Panel', panelConfig)];
	},
	postProcessInvalidHandling: function(panel, jsonResult, cardTo, cardFrom) {
		if (cardFrom===2) {
			this.postProcessInvalidHandlingFirstTime(panel, jsonResult)
		} else {
			this.postProcessInvalidHandlingUpdate(panel, jsonResult);
		}
	},
	/**
	 * Add invalid value handling data for rendering after the result has arrived
	 */
	postProcessInvalidHandlingFirstTime: function(panel, jsonResult, cardTo, cardFrom) {
		var data = jsonResult.data;
		var fieldList = data['fieldList'];
		var possibleValues = data['possibleValues'];
		var invalidValueHandlingList = data['invalidValueHandlingList'];
		if (panel) {
			var invalidValueHandlingPanel = panel.getComponent("invalidValueHandlingPanel");
			items = [];
			items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.invalidValueHadling.lbl.fieldName')+'</b>',
					width: 150
				});
			items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.invalidValueHadling.lbl.defaultfieldValue')+'</b>',
					colspan: 2
				});
			if (fieldList) {
				Ext.Array.forEach(fieldList, function(fieldBean) {
					var fieldId = fieldBean.id;
					var possibleFieldValues = possibleValues['fieldID'+fieldId];
					var invalidValueHandlingValue = possibleFieldValues['invalidValueHandlingValue'];
					var possibleValueList = possibleFieldValues['possibleFieldValues'];
					var defaultFieldValue = possibleFieldValues['defaultFieldValue'];
					items.push({xtype: 'label',
						html: fieldBean.label,
						width: 150,
						padding: '10 0 0 0'
						});
					var invalidValueHandlingRadioButtons = CWHF.getRadioButtonItems(invalidValueHandlingList,
							'invalidValueHandlingMap[' + fieldId + ']', 'id', 'label', invalidValueHandlingValue, false, true);
					var invalidValueHandlingRadioGroup =
						CWHF.getRadioGroup('', 250, invalidValueHandlingRadioButtons, {itemId:'invalidValueHandling'+fieldId},
							{change: {fn: this.onInvalidHandlingChange, scope:this,
								panel: invalidValueHandlingPanel,
								fieldId: fieldId}});
					items.push(invalidValueHandlingRadioGroup);
					var control;
					if (fieldId===1) {
	                    control = CWHF.createSingleTreePicker(null,
	                        "defaultValuesMap[" + fieldId + "]", possibleValueList, defaultFieldValue,
	                        {allowBlank:false,
	                         disabled:invalidValueHandlingValue===2,
	                         itemId:'defaultValues'+fieldId
	                        }, {select:{fn: this.onProjectSelect, scope:this,
	                            fieldId: fieldId}});
					} else {
						control = CWHF.createCombo(null,
								'defaultValuesMap[' + fieldId + ']',
								{disabled:invalidValueHandlingValue===2,
									itemId: 'defaultValues' + fieldId,
									width:200,
									maxWidth: 250,
									data:possibleValueList,
									value:defaultFieldValue},
								{select: {fn: this.onSelectDefaultValue, scope:this,
									fieldId: fieldId}},
								'defaultValues'+fieldId);
					}
					items.push(control);
				}, this);
			}
			invalidValueHandlingPanel.removeAll(true);
			invalidValueHandlingPanel.add(items);
		}
	},
	/**
	 * Change event, not
	 * @param projectPicker
	 * @param selectedProject
	 * @param options
	 */
	onProjectSelect: function(projectPicker, selectedProject, options) {
	    this.onRefreshInvalidHandling(options['fieldId']);
	},
	/**
	 * Handler for changing a default value
	 */
	onSelectDefaultValue: function(combo, records, options) {
	    this.onRefreshInvalidHandling(options['fieldId']);
	},
	/**
	 * Add invalid value handling data for rendering after the result has arrived
	 */
	postProcessInvalidHandlingUpdate: function(panel, jsonResult) {
		var data = jsonResult.data;
		var fieldList = data['fieldList'];
		var possibleValues = data['possibleValues'];
		if (panel) {
			var invalidValueHandlingPanel = panel.getComponent("invalidValueHandlingPanel");
			if (fieldList) {
				Ext.Array.forEach(fieldList, function(fieldId) {
					var possibleFieldValues = possibleValues['fieldID'+fieldId];
					//var invalidValueHandlingValue = possibleFieldValues['invalidValueHandlingValue'];
					var possibleValueList = possibleFieldValues['possibleFieldValues'];
					var defaultFieldValue = possibleFieldValues['defaultFieldValue'];
					if (fieldId!==1) {
						control = invalidValueHandlingPanel.getComponent('defaultValues' + fieldId);
						if (control) {
							control.getStore().loadData(possibleValueList);
							control.setValue(defaultFieldValue);
						}
					}
				}, this);
			}
		}
	},
	/**
	 * Handler for changing an invalid value handling
	 */
	onInvalidHandlingChange: function(field, newValue, oldValue, options) {
		var fieldId = options['fieldId'];
		var panel = options['panel'];
		var invalidValueHandlingRadioGroup = panel.getComponent('invalidValueHandling' + fieldId);
		var fieldSelect = panel.getComponent('defaultValues' + fieldId);
		var checkedArr = invalidValueHandlingRadioGroup.getChecked();
		var checkedRadioValue = null;
		if (checkedArr.length>0) {
			checkedRadio = checkedArr[0];
			if (checkedRadio) {
				checkedRadioValue = checkedRadio.getSubmitValue();
			}
		}
		fieldSelect.setDisabled(checkedRadioValue===2);
		this.onRefreshInvalidHandling(fieldId);
	},
	onRefreshInvalidHandling: function(fieldId) {
		if (fieldId===1 || fieldId===2) {
			//reload is needed only for project or issueType change
			//most of the other lists depend on project and issueType
			this.loadDataForCard(3, true);
		}
	},
	/******************************************Excel conflicts*****************************************************/
	/**
	 * Gets the items for excel import, before the data has arrived
	 */
	getExcelErrorAndConflictHandlingItems: function() {
		var panelConfig = {
				itemId: 'errorAndConflict',
				bodyStyle:	'padding: 5px',
				border: false,
				method: "POST",
				//autoScroll:	true,
				items: [
					Ext.create('Ext.panel.Panel', {
						itemId: 'errorPanel',
						border:false,
						defaults:	{
							labelStyle:'overflow: hidden;',
							margin:"0 5 0 0"
						},
						layout: {
							type:'table',
							columns:1
						}
					}),
					Ext.create('Ext.form.Panel', {
						itemId: 'conflictPanel',
						defaults:	{
							labelStyle:'overflow: hidden;',
							margin:"0 5 0 0"
						},
						layout: {
							type:'table',
							columns:7,
							tdAttrs: { style: {
								padding: '5px 15px 0 0',
								'vertical-align':'top'
							}
						}
						//autoScroll:true
						},
						border:false})
					]};
		return [Ext.create('Ext.form.Panel', panelConfig)];
	},
	/**
	 * Add error or conflict handling data for rendering after the result has arrived
	 */
	postProcessExcelErrorAndConflictHandling: function(panel, data) {
		var me = this;
		var disableFinal = data['disableFinal'];
		var toolbar =  me.win.getDockedItems('toolbar[dock="bottom"]');
		var finish = toolbar[0].getComponent('finish');
		var previous = toolbar[0].getComponent('previous');
		finish.setDisabled(disableFinal);
		//previous.setDisabled(disableFinal);
		var errorAndConflictPanel = panel.getComponent('errorAndConflict');
		var errorCode = data['errorCode'];
		if (CWHF.isNull(errorCode)) {
			var message = data['message'];
			if (message) {
				var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
				errorPanel.add({xtype: 'label',
					html: '<b>' + message + '</b>'
					});
			}
			return;
		}
		switch(errorCode) {
		case 1:
			//simple message
			var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
			errorPanel.add({xtype: 'label',
				html: '<b>' + data['errorMessage'] + '</b>'
				});
			break;
		case 2:
			//more messages
			var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
			var errorMessages = data['errorMessage'];
			for ( var i = 0; i < errorMessages.length; i++) {
				errorPanel.add({xtype: 'label',
					html: errorMessages[i]
					});
			}
			break;
		case 3:
			//me.confirmDialogForImportNotFoundItemsAsNew();
			//grid and row errors
			var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
			var gridErrors = data['gridErrors'];
			if (gridErrors) {
				for ( var i = 0; i < gridErrors.length; i++) {
					var gridError = gridErrors[i];
					var errorMessage = gridError['errorMessage'];
					var locationList = gridError['locationList'];
					if (locationList) {
						errorPanel.add({xtype: 'label',
							html: '<b>' + errorMessage + '</b>'
							});
						for (var j = 0; j < locationList.length; j++) {
							errorPanel.add({xtype: 'label',
								html: locationList[j]
								});
						}
					}
					var solutionMessage = gridError['solutionMessage'];
					if (solutionMessage) {
						errorPanel.add({xtype: 'label',
							html: '<br><b>' + solutionMessage + '</b>'
							});
					}
				}
			}
			var rowErrors = data['rowErrors'];
			if (rowErrors) {
				for (var i = 0; i < rowErrors.length; i++) {
					var rowError = rowErrors[i];
					var errorMessage = rowError['errorMessage'];
					var locationList = rowError['locationList'];
					errorPanel.add({xtype: 'label',
						html: '<b>' + errorMessage + '</b>'
						});
					errorPanel.add({xtype: 'label',
						html: locationList
						});
				}
			}
			break;
		case 4:
			//field conflicts
			var errorMessage = data['errorMessage'];
			var conflicts = data['conflicts'];
			if (conflicts) {
				var conflictPanel = errorAndConflictPanel.getComponent('conflictPanel');
				var conflictResolutionList = data['conflictResolutionList'];
				items = [];
					if (errorMessage) {
					items.push({xtype: 'label',
						html: errorMessage,
						colspan: 7
					});
				}
				items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.conflict.lbl.row')+'</b>'
					});
				items.push({xtype: 'label',
					html: '<b>'+data['issueNoLabel']+'</b>'
					});
				items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.conflict.lbl.column')+'</b>'
					});
				items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.conflict.lbl.field')+'</b>'
					});
				items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.conflict.lbl.excelValue')+'</b>'
					});
				items.push({xtype: 'label',
					html: '<b>'+getText('admin.actions.importExcel.conflict.lbl.trackplusValue')+'</b>'
					});
				var conflictResolutionListBold = [];
				Ext.Array.forEach(conflictResolutionList, function(conflictResolution) {
					conflictResolutionListBold.push({id:conflictResolution["id"], label:"<b>"+conflictResolution["label"]+"</b>"});
				}, this);
				var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictResolutionListBold,
						'conflictResoultionEntry', 'id', 'label', false, false, true);
				var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300, conflictResolutionRadioButtons, {itemId:'conflictResoultionRadioGroup'},
						{change: {fn: this.onExcelConflictHandlingForAll, scope:this,
							panel: conflictPanel, /*conflictResolutionList:conflictResolutionList,*/ conflicts:conflicts}});
				items.push(conflictResolutionRadioGroup);
				this.workItemIDFieldIDs = [];
				Ext.Array.forEach(conflicts, function(conflict) {
					var row = conflict['row'];
					var fields = conflict['fields'];
					Ext.Array.forEach(fields, function(field, index) {
						if (index===0) {
							items.push({xtype: 'label',
								html: row,
								rowspan: fields.length
								});
							items.push({xtype: 'label',
								html: field['workItemID'],
								rowspan: fields.length
								});
						}
						items.push({xtype: 'label',
							html: field['columnLetter']
							});
						items.push({xtype: 'label',
							html: field['fieldName']
							});
						items.push({xtype: 'label',
							html: field['excelValue']
							});
						items.push({xtype: 'label',
							html: field['trackplusValue']
							});
						var workItemIDFieldID = field['workItemIDFieldID'];
						this.workItemIDFieldIDs.push(workItemIDFieldID);
						var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictResolutionList,
								'overwriteMap['+workItemIDFieldID + "]", 'id', 'label', false, false, true);
						var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300, conflictResolutionRadioButtons,{itemId:'conflictResoultion'+workItemIDFieldID});
						items.push(conflictResolutionRadioGroup);
					}, this);
				}, this);
				conflictPanel.add(items);
			}
			break;
		}
	},
	/*confirmDialogForImportNotFoundItemsAsNew: function() {
		var me = this;
		Ext.MessageBox.show({
	        title : getText('common.warning'),
	        msg : getText('admin.actions.importExcel.err.importNotFoundWorkItems'),
	        buttons : Ext.MessageBox.YESNO,
	        fn : function(btn) {
	            if (btn === "yes") {
					Ext.Ajax.request({
				        url : "excelImport!removeIssueNoFromMapping.action",
				        disableCaching : true,
				        success : function() {
				        	me.onNavigate(me.importButton, me.wizardPanel);
				        },
				        failure : function() {
				        },
				        method : 'POST',
				        params : {fileName:me.fileName}
				    });
	            }
	            if (btn === "no") {
					 me.win.close();
				 }
	        },
	        icon : Ext.MessageBox.QUESTION
	    });
	},*/
	onExcelConflictHandlingForAll: function(field, newValue, oldValue, options) {
		var panel = options["panel"];
		var conflictResoultionRadioGroup = panel.getComponent("conflictResoultionRadioGroup");
		var conflicts = options["conflicts"];
		var conflictResolutionValue = CWHF.getSelectedRadioButtonValue(conflictResoultionRadioGroup);
		Ext.Array.forEach(conflicts, function(conflict) {
			var row = conflict['row'];
			var fields = conflict['fields'];
			Ext.Array.forEach(fields, function(field, index) {
				var workItemIDFieldID = field['workItemIDFieldID'];
				var radioGroup = panel.getComponent('conflictResoultion'+workItemIDFieldID);
				//TODO setValue() does not work (ext js bug?).
				//radioGroup.setValue(conflictResolutionValue);
				//Once setValue fixed remove this cycle
				Ext.Array.forEach(radioGroup.items.items, function(item, index) {
					//radioGroup.items.items.each(function(item){
						//item.setValue(item.inputValue === conflictResolutionValue);
					item.setRawValue(item.inputValue === conflictResolutionValue);
				});
			}, this)
		}, this)
	},
	/**
	 * Actualize the toolbar settings according to the current index
	 */
	actualizeToolbar: function(panel) {
		var me = this;
		if(me.win) {
		var layout = panel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = panel.items.indexOf(activeItem);
		var numItems = panel.items.getCount();
		var toolbar = me.win.getDockedItems('toolbar[dock="bottom"]');
		var previous = toolbar[0].getComponent('previous');
		if (previous) {
			previous.setDisabled(!layout.getPrev());
		}
		var next = toolbar[0].getComponent('next');
		if (next) {
			next.setDisabled((index+1)>=(numItems-1));
		}
		var finish = toolbar[0].getComponent('finish');
		if (finish) {
			finish.setDisabled((index+1)!==(numItems-1));
		}
//		var indicator = toolbar[0].getComponent('indicator');
//		if (indicator) {
//			var indicatorText = getText("common.lbl.wizard.step", (index + 1), numItems);
//			panel.setTitle(this.getTitle(index + 1));
//			indicator.update(indicatorText);
//		}
		if(me.win) {
			me.win.setTitle(this.getTitle(index + 1));
		}
		}
	},
	getWizardPanel: function() {
		var me = this;
		var toolbarItems = [];
		this.wizardPanel = Ext.create('Ext.panel.Panel', {
			title: '',
			layout: 'card',
			region: 'left',
			//margin: '2 0 0 -10',
			cls: 'importWizard',
//			bodyStyle: 'padding:15px; border-left:none',
			//bodyStyle: 'border-left:none',
			defaults: {
				// applied to each contained panel
				border: false
			},
			// the panels (or "cards") within the layout
			items: [this.createEmptyCard("card1", true)]
		});
		this.initCards(2);
		this.loadDataForCard(1);
		return this.wizardPanel;
	},
	getDialogButtons: function() {
		var me = this;
		var toolbarItems = [];
		var numberOfCards = this.getNumberOfCards();
		if (numberOfCards>1) {
			toolbarItems.push({
				itemId: 'previous',
				text:'&laquo; '+ getText('common.lbl.wizard.previous'),
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, me.wizardPanel);
				},
				//at the beginning disabled
				disabled: true
			});
			toolbarItems.push('-');
			toolbarItems.push({
				itemId: 'next',
				text: getText('common.lbl.wizard.next')+' &raquo;',
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, me.wizardPanel);
				}
			});
			toolbarItems.push('-');
			me.importButton = {
					itemId: 'finish',
					iconCls: 'import16',
					text: getText('common.btn.import'),
					scope: this,
					handler: function(btn) {
						this.onNavigate(btn, me.wizardPanel);
					},
					disabled: true};
			toolbarItems.push(me.importButton);
			toolbarItems.push({
				text: getText('common.btn.done'),
				scope: this,
				handler: function(){
					me.doneHandler(me);
				}
			});
		} else {
			//for direct import no navigation is needed
			toolbarItems.push({	itemId: 'finish',
				text: getText('common.btn.import'),
				scope: this,
				handler: function(btn) {
					this.loadDataForCard(1, true);
				},
				disabled: false
			});
		}
		return toolbarItems;
	},
	/**
	 * Handler for closing the window
	 */
	doneHandler:function(scope) {
		if (this.itemNavigatorController) {
			this.itemNavigatorController.refresh.call(this.itemNavigatorController);
		}
		this.win.close();
	},
	/**
	 * This function initialize necessary components for showing pop
	 * up dialog
	 */
	createPopUpDialog: function(files, itemNavigatorController) {
		var me = this;
		this.itemNavigatorController = itemNavigatorController;
		if(CWHF.isNull(files)) {
			var windowParameters = {
				title: "",
				width: me.dialogWidth,
				height: me.dialogHeight,
				overrideButtons: me.getDialogButtons(),
				items: me.getWizardPanel()
			};
			var window = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
			window.showWindowByConfig(me);
		}else {
			var file = null;
			if(files  && files.length > 0){
				file = files[0];
			}
			var continueToUpload = true;
			if (!me.validateFileExtension(file.name)) {
				Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileWrongType'),
					getText('common.err.fileExpectedType', me.importExcelWizard.getFileTypeLabel()));
				continueToUpload = false;
			}
			if (me.uploadDone) {
				Ext.MessageBox.alert(getText('admin.actions.importTp.err.uploadAgain'),
						getText('admin.actions.importTp.err.uploadAgain', this.getFileTypeLabel()));
				continueToUpload = false;
			}
			if(continueToUpload) {
				me.uploadDone = true;
				var formData = new FormData();
				formData.append('uploadFile', file);
				formData.append('uploadFileFileName', file.name);
				borderLayout.setLoading(true);
				me.uploadExcelFile(formData);
			}
		}
	},
	/**
	 * The following method uploads dropped excel file, and
	 * opens excel import wizard pop up dialog
	 */
	uploadExcelFile: function(formData) {
		var me = this;
		var xhr = new XMLHttpRequest();
		var urlStr='excelUpload.action';
		xhr.open('POST', urlStr);
		xhr.onload = function () {
			if (xhr.status === 200) {
				borderLayout.setLoading(false);
				var windowParameters = {
					title: "",
					width: me.dialogWidth,
					height: me.dialogHeight,
					overrideButtons: me.getDialogButtons(),
					items: me.getWizardPanel()
				};
				var window = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
				var panelFrom = me.wizardPanel.getComponent("card" + 1);
				var panelTo = me.wizardPanel.getComponent("card" + 2);
				panelTo.removeAll(true);
				var panel = me.getImportWizardItemsForCard(2);
				panelTo.add(panel);
				var decodedString = Ext.decode(xhr.response);
				var jsonResult = {};
				jsonResult.data = decodedString.data;
				me.postDataProcess(panelTo, jsonResult, 2, 1);
				me.uploadDone = true;
				me.wizardPanel.layout.setActiveItem(1);
				window.showWindowByConfig(me);
				me.actualizeToolbar(me.wizardPanel);
			} else {
				alert('Something went terribly wrong...');
			}
		};
		xhr.onerror=function(e){
			borderLayout.setLoading(false);
			alert("Error uploading!" + e);
		};
		xhr.upload.onprogress = function (event) {
		};
		xhr.onerror=function(e){
			borderLayout.setLoading(false);
			alert("Error: " + e);
		}
		xhr.send(formData);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ImportDocx', {
	extend : 'com.trackplus.admin.action.ImportWizard',
	config : {},
	// selectedSheet: null,
	// workItemIDFieldIDs:null,
	fileName : null,
	addTo : null,
	workItemID : null,
	parentID : null,
	projectOrReleaseID : null,
	getNumberOfCards : function() {
	    return 4;
	},
	getTitle : function(cardNo) {
	    var titleKey = null;
	    switch (cardNo) {
	    case 1:
		    titleKey = "admin.actions.importDocx.title.upload";
		    break;
	    case 2:
		    titleKey = "admin.actions.importDocx.title.addTo";
		    break;
	    case 3:
		    titleKey = "admin.actions.importDocx.title.preview";
		    break;
	    case 4:
		    titleKey = "admin.actions.importDocx.title.result";
		    break;
		default:
			titleKey = '';
	    }
	    if (titleKey ) {
		    return getText(titleKey);
	    } else {
		    return '';
	    }
	},
	getFilePattern : function(fileName) {
	    return /^.*\.(docx|DOCX)$/;
	},
	getFileTypeLabel : function() {
	    return getText('admin.actions.importDocx.lbl.uploadFile');
	},
	getFileEmptyText : function() {
	    return getText("admin.actions.importDocx.lbl.fileEmptyText");
	},
	getImportWizardUrl : function(card, reload) {
	    if (card === 1) {
		    return 'docxlUploadRender.action';
	    } else {
		    if (card === 2) {
			    return "docxUpload.action";
		    } else {
			    if (card === 3) {
				    // return 'docxAddTo.action';
				    return "docxPreview.action";
			    } else {
				    if (card === 4) {
					    return "docxImport.action";
				    }
			    }
		    }
	    }
	},
	/**
	 * Load/submit the data for on the cardNo cardNo: the card number to go
	 * next, or the actual card number if reload reload: whether to reload the
	 * current card or submit to the current values and go to the next card
	 * return false and optionally show an alert box if there is a validation
	 * problem which prevents navigating to the next card
	 */
	loadDataForCard : function(cardNo, reload, params) {
	    if (cardNo === 1) {
		    // for the very first card nothing to submit only render (load)
		    var panel1 = this.wizardPanel.getComponent('card1');
		    panel1.add(this.getImportWizardItemsForCard(cardNo));
		    panel1.getForm().load({
		        url : this.getImportWizardUrl(cardNo, reload),
		        scope : this,
		        success : function(form, action) {
			        try {
				        this.postDataProcess(panel1, action.result.data, 1);
				        // if data is valid we can go to the next card
			        } catch (ex) {
			        }
		        },
		        failure : function(form, action) {
			        Ext.MessageBox.alert(this.failureTitle, action.response.responseText)
		        }
		    });
	    } else {
		    // from card to each card starts with a submit
		    if (cardNo === 2) {
			    var panel1 = this.wizardPanel.getComponent('card1');
			    if (!panel1.getForm().isValid()) {
				    Ext.MessageBox.show({
				        title : '',
				        msg : getText('admin.actions.importTp.lbl.uploadFileNotSpecified'),
				        buttons : Ext.Msg.OK,
				        icon : Ext.MessageBox.ERROR
				    });
				    return false;
			    }
			    var importFile = panel1.getComponent('uploadFile');
			    if (!this.validateFileExtension(importFile.getRawValue())) {
				    Ext.MessageBox.alert(getText('admin.actions.importDocx.err.uploadFileWrongType'), getText(
				            'common.err.fileExpectedType', this.getFileTypeLabel()));
				    return false;
			    }
			    if (this.uploadDone) {
				    Ext.MessageBox.alert(getText('admin.actions.importTp.err.uploadAgain'), getText(
				            'admin.actions.importTp.err.uploadAgain', this.getFileTypeLabel()));
				    return false;
			    }
			    this.uploadDone = true;
			    var params = {
				    fileName : this.fileName
			    };
			    this.submitFromCardToCard(1, 2, params);
			    // this.submitFromCardToCardMessageOnFailure(1, 2, null, reload,
				// true);
		    } else {
			    if (cardNo === 3) {
				    var params = {
				        fileName : this.fileName,
				        workItemID : this.workItemID,
				        parentID : this.parentID,
				        projectOrReleaseID : this.projectOrReleaseID
				    };
				    this.submitFromCardToCard(2, 3, params, false, 300);
			    } else {
				    if (cardNo === 4) {
					    if (CWHF.isNull(params)) {
						    params = {
							    fileName : this.fileName
						    };
					    }
					    this.submitFromCardToCard(3, 4, params, false, 300);
				    }
			    }
		    }
	    }
	},
	/**
	 * Get the initial items for a card Additional items can be added once the
	 * data is back from the server
	 */
	getImportWizardItemsForCard : function(card) {
	    if (card === 1) {
		    return this.getImportWizardUploadItems();
	    } else {
		    if (card === 2) {
			    return this.getImportWizardAddToItems();
		    } else {
			    if (card === 3) {
				    return this.createPreviewPanel();
				    // return this.getExcelInvalidHandlingItems();
			    } else {
				    if (card === 4) {
					    return this.getExcelErrorAndConflictHandlingItems();
				    }
			    }
		    }
	    }
	},
	postDataProcess : function(panel, jsonResult, cardTo, cardFrom) {
	    if (cardTo === 1) {
		    this.postProcessUpload(panel, jsonResult);
	    } else {
		    if (cardTo === 2) {
			    this.postProcessAddTo(panel, jsonResult);
		    } else {
			    if (cardTo === 3) {
				    this.postProcessPreview(panel, jsonResult);
			    } else {
				    if (cardTo === 4) {
					    this.postProcessInvalidHandling(panel, jsonResult, cardTo, cardFrom);
					    // this.postProcessExcelErrorAndConflictHandling(panel,
						// jsonResult);
				    }
			    }
		    }
	    }
	},
	/**
	 * ************************Import
	 * source*************************************
	 */
	getImportWizardUploadItems : function() {
	    var card1Items = [ CWHF.createFileField(getText("common.lbl.file", this.getFileTypeLabel()), "uploadFile", {
	        allowBlank : false,
	        labelWidth : 150,
	        width : 500,
	        labelIsLocalized : true,
	        itemId: "uploadFile"
	    }, {
		    change : {
		        fn : function() {
			        this.uploadDone = false;
		        },
		        scope : this
		    }
	    }) ];
	    card1Items.push({
	        xtype : 'label',
	        itemId : 'importSourceError'
	    });
	    return card1Items;
	},
	postProcessUpload : function(formPanel, data) {
	    var uploadFile = formPanel.getComponent("uploadFile");
	    uploadFile.setRawValue('');
	    this.initCards(2);
	},
	getImportWizardAddToItems : function() {
	    if (CWHF.isNull(this.workItemID)) {
		    var options = [ {
		        id : 1,
		        label : "admin.actions.importDocx.lbl.projectRelease"
		    }, {
		        id : 2,
		        label : "admin.actions.importDocx.lbl.parent"
		    } ];
		    var optionList = CWHF.getRadioButtonItems(options, "addTo", 'id', 'label', 1, false, false);
		    var addToRadioGroup = CWHF.getRadioGroup("admin.actions.importDocx.lbl.addTo", 350,
		            optionList, {itemId:"addToType"},
		            {
			            change : {
			                fn : this.addToTypeChanged,
			                scope : this
			            }
		            });
		    // project/release picker
		    var releasePickerConfig = {
		        activeFlag : true,
		        inactiveFlag : true,
		        notPlannedFlag : true,
		        closedFlag : false,
		        projectIsSelectable : true,
		        labelWidth : 150,
		        width : 400,
		        itemId: 'projectOrReleaseID'
		    };
		    var releasePicker = CWHF.createSingleTreePicker("admin.actions.importDocx.lbl.projectRelease",
		            "projectOrReleaseID", null, null, releasePickerConfig);
		    var parentHidden = CWHF.createHiddenField("parentID");
		    var parentIssueNo = CWHF.createTextField(null, "txtIssueNo", {
		        disabled : true,
		        readOnly : true,
		        width : 50,
		        itemId :'txtIssueNo'
		    });
		    var parentIssueTitle = CWHF.createTextField(null, "txtIssueTitle", {
		        disabled : true,
		        readOnly : true,
		        margin : '0 5 0 5',
		        width : 300,
		        itemId : 'txtIssueTitle'
		    });
		    var selectParent = {
		        xtype : 'button',
		        text : getText('common.btn.search'),
		        itemId : "searchParent",
		        disabled : true,
		        scope : this,
		        handler : function() {
			        this.chooseParent.call(this);
		        }
		    };
		    var parentPanel = Ext.create('Ext.form.FieldContainer', {
		        combineErrors : true,
		        itemId : 'parentPanel',
		        fieldLabel : getText('admin.actions.importDocx.lbl.parent'),
		        labelWidth : 150,
		        labelAlign : "right",
		        labelStyle : {
			        overflow : 'hidden'
		        },
		        layout : 'hbox',
		        items : [ parentHidden, parentIssueNo, parentIssueTitle, selectParent ]
		    });
		    return [ addToRadioGroup, releasePicker, parentPanel ];
	    } else {
		    var issueNo = CWHF.createTextField(null, "txtIssueNo", {// disabled:this.jsonData.disabled,
		        readOnly : true,
		        width : 50,
		        itemdId : 'createHiddenField'
		    });
		    var issueTitle = CWHF.createTextField(null, "txtIssueTitle", {// disabled:
																			// this.jsonData.disabled,
		        readOnly : true,
		        margin : '0 5 0 5',
		        width : 300,
		        itemId: 'txtIssueTitle'
		    });
		    return [ issueNo, issueTitle ];
	    }
	},
	chooseParent : function() {
	    var issuePicker = Ext.create('com.trackplus.util.IssuePicker', {
	        title : getText("common.btn.chooseParent"),
	        handler : this.setParent,
	        scope : this
	    });
	    issuePicker.showDialog();
	},
	setParent : function(item) {
	    var formPanel = this.wizardPanel.getComponent("card2");
	    var parentPanel = formPanel.getComponent("parentPanel");
	    this.parentID = item["objectID"];
	    var txtIssueNo = parentPanel.getComponent("txtIssueNo");
	    if (txtIssueNo ) {
		    txtIssueNo.setValue(item["id"]);
	    }
	    var txtIssueTitle = parentPanel.getComponent("txtIssueTitle");
	    if (txtIssueTitle ) {
		    txtIssueTitle.setValue(item["title"])
	    }
	},
	addToTypeChanged : function(radioGroup, newValue, oldValue, options) {
	    var formPanel = radioGroup.ownerCt;
	    var checkedArr = radioGroup.getChecked();
	    if (checkedArr.length === 1) {
		    var checkedRadio = checkedArr[0];
		    var value = checkedRadio.getSubmitValue();
		    // project=1, parent=2
		    var projectReleasesPicker = formPanel.getComponent("projectOrReleaseID");
		    projectReleasesPicker.setDisabled(value !== 1);
		    var parentPanel = formPanel.getComponent("parentPanel");
		    var searchParent = parentPanel.getComponent("searchParent");
		    searchParent.setDisabled(value === 1);
	    }
	},
	/**
	 * Post process add to
	 */
	postProcessAddTo : function(formPanel, data) {
	    this.workItemID = data["workItemID"];
	    this.fileName = data["fileName"];
	    if (CWHF.isNull(this.workItemID)) {
		    var projectReleasesPicker = formPanel.getComponent("projectOrReleaseID");
		    projectReleasesPicker.updateMyOptions(data["projectReleaseTree"]);
	    } else {
		    var issueNo = formPanel.getComponent("txtIssueNo");
		    issueNo.setValue(data["itemID"]);
		    var issueTitle = formPanel.getComponent("txtIssueTitle");
		    issueTitle.setValue(data["itemTitle"]);
	    }
	    this.initCards(3);
	},
	/**
	 * ************************Excel column - Genji field
	 * mappings*************************************
	 */
	createPreviewPanel : function() {
	    var store = Ext.create('Ext.data.TreeStore', {
	        /*
			 * proxy:{ type: 'ajax', url: 'browseProjects!expandNode.action' },
			 */
	        fields : [ 'id', 'text', 'type', 'canEdit', 'icon', 'leaf' ],
	        root : {
	            expanded : true,
	            children : []
	        }
	    });
	    return Ext.create('Ext.tree.Panel', {
	        region : 'center',
	        itemId : 'itemTree',
	        useArrows : true,
	        autoScroll : true,
	        store : store,
	        rootVisible : false,
	        border : false,
	        margins : '0 0 0 0',
	        baseCls : 'x-plain',
	        bodyStyle : {
		        border : 'none'
	        },
	        cls : 'westTreeNavigator'
	    });
	},
	/**
	 * Add field mappings data for rendering after the result has arrived
	 */
	postProcessPreview : function(panel, jsonResult) {
	    var itemTree = panel.getComponent("itemTree");
	    var rootNode = itemTree.store.getRootNode();
	    rootNode.removeAll(true);
	    var data = jsonResult.data;
	    if (data ) {
		    rootNode.appendChild(data.itemTree);
	    }
	},
	/**
	 * ************************Excel invalid value
	 * handling*************************************
	 */
	/**
	 * Gets the items for excel invalid value handling, before the data has
	 * arrived
	 */
	getExcelInvalidHandlingItems : function() {
	    var panelConfig = {
	        itemId : 'invalidValueHandlingPanel',
	        layout : {
	            type : 'table',
	            columns : 3,
	            tdAttrs : {
		            style : {
			            padding : '5px 15px 0 0'
		            }
	            }
	        },
	        bodyStyle : 'padding: 5px',
	        border : false,
	        method : "POST",
	        autoScroll : true,
	        items : []
	    };
	    return [ {
	        xtype : 'component',
	        cls : "infoBox_bottomBorder",
	        border : true,
	        anchor : '100%',
	        margin : "0 0 0 0",
	        html : getText("admin.actions.importExcel.invalidValueHadling.message")
	    }, Ext.create('Ext.form.Panel', panelConfig) ];
	},
	postProcessInvalidHandling : function(panel, jsonResult, cardTo, cardFrom) {
	    if (cardFrom === 2) {
		    this.postProcessInvalidHandlingFirstTime(panel, jsonResult)
	    } else {
		    this.postProcessInvalidHandlingUpdate(panel, jsonResult);
	    }
	},
	/**
	 * Add invalid value handling data for rendering after the result has
	 * arrived
	 */
	postProcessInvalidHandlingFirstTime : function(panel, jsonResult, cardTo, cardFrom) {
	    var data = jsonResult.data;
	    var fieldList = data['fieldList'];
	    var possibleValues = data['possibleValues'];
	    var invalidValueHandlingList = data['invalidValueHandlingList'];
	    if (panel ) {
		    var invalidValueHandlingPanel = panel.getComponent("invalidValueHandlingPanel");
		    items = [];
		    items.push({
		        xtype : 'label',
		        html : '<b>' + getText('admin.actions.importExcel.invalidValueHadling.lbl.fieldName') + '</b>',
		        width : 150
		    });
		    items.push({
		        xtype : 'label',
		        html : '<b>' + getText('admin.actions.importExcel.invalidValueHadling.lbl.defaultfieldValue') + '</b>',
		        colspan : 2
		    });
		    if (fieldList ) {
			    Ext.Array.forEach(fieldList, function(fieldBean) {
				    var fieldId = fieldBean.id;
				    var possibleFieldValues = possibleValues['fieldID' + fieldId];
				    var invalidValueHandlingValue = possibleFieldValues['invalidValueHandlingValue'];
				    var possibleValueList = possibleFieldValues['possibleFieldValues'];
				    var defaultFieldValue = possibleFieldValues['defaultFieldValue'];
				    items.push({
				        xtype : 'label',
				        html : fieldBean.label,
				        width : 150,
				        padding : '10 0 0 0'
				    });
				    var invalidValueHandlingRadioButtons = CWHF.getRadioButtonItems(invalidValueHandlingList,
				            'invalidValueHandlingMap[' + fieldId + ']', 'id', 'label', invalidValueHandlingValue,
				            false, true);
				    var invalidValueHandlingRadioGroup = CWHF.getRadioGroup('', 250,
				            invalidValueHandlingRadioButtons, {itemId:'invalidValueHandling' + fieldId}, {
					            change : {
					                fn : this.onInvalidHandlingChange,
					                scope : this,
					                panel : invalidValueHandlingPanel,
					                fieldId : fieldId
					            }
				            });
				    items.push(invalidValueHandlingRadioGroup);
				    var control;
				    if (fieldId === 1) {
					    control = CWHF.createSingleTreePicker(null, "defaultValuesMap[" + fieldId + "]",
					            possibleValueList, defaultFieldValue, {
					                allowBlank : false,
					                disabled : invalidValueHandlingValue === 2,
					                itemId : 'defaultValues' + fieldId
					            }, {
						            select : {
						                fn : this.onProjectSelect,
						                scope : this,
						                fieldId : fieldId
						            }
					            });
				    } else {
					    control = CWHF.createCombo(null, 'defaultValuesMap[' + fieldId + ']', {
					        disabled : invalidValueHandlingValue === 2,
					        width : 200,
					        maxWidth : 250,
					        data : possibleValueList,
					        value : defaultFieldValue
					    }, {
						    select : {
						        fn : this.onSelectDefaultValue,
						        scope : this,
						        fieldId : fieldId
						    }
					    }, 'defaultValues' + fieldId);
				    }
				    items.push(control);
			    }, this);
		    }
		    invalidValueHandlingPanel.removeAll(true);
		    invalidValueHandlingPanel.add(items);
	    }
	},
	/**
	 * Change event, not
	 *
	 * @param projectPicker
	 * @param selectedProject
	 * @param options
	 */
	onProjectSelect : function(projectPicker, selectedProject, options) {
	    this.onRefreshInvalidHandling(options['fieldId']);
	},
	/**
	 * Handler for changing a default value
	 */
	onSelectDefaultValue : function(combo, records, options) {
	    this.onRefreshInvalidHandling(options['fieldId']);
	},
	/**
	 * Add invalid value handling data for rendering after the result has
	 * arrived
	 */
	postProcessInvalidHandlingUpdate : function(panel, jsonResult) {
	    var data = jsonResult.data;
	    var fieldList = data['fieldList'];
	    var possibleValues = data['possibleValues'];
	    if (panel ) {
		    var invalidValueHandlingPanel = panel.getComponent("invalidValueHandlingPanel");
		    if (fieldList ) {
			    Ext.Array.forEach(fieldList, function(fieldId) {
				    var possibleFieldValues = possibleValues['fieldID' + fieldId];
				    // var invalidValueHandlingValue =
					// possibleFieldValues['invalidValueHandlingValue'];
				    var possibleValueList = possibleFieldValues['possibleFieldValues'];
				    var defaultFieldValue = possibleFieldValues['defaultFieldValue'];
				    if (fieldId !== 1) {
					    control = invalidValueHandlingPanel.getComponent('defaultValues' + fieldId);
					    if (control ) {
						    control.getStore().loadData(possibleValueList);
						    control.setValue(defaultFieldValue);
					    }
				    }
			    }, this);
		    }
	    }
	},
	/**
	 * Handler for changing an invalid value handling
	 */
	onInvalidHandlingChange : function(field, newValue, oldValue, options) {
	    var fieldId = options['fieldId'];
	    var panel = options['panel'];
	    var invalidValueHandlingRadioGroup = panel.getComponent('invalidValueHandling' + fieldId);
	    var fieldSelect = panel.getComponent('defaultValues' + fieldId);
	    var checkedArr = invalidValueHandlingRadioGroup.getChecked();
	    var checkedRadioValue = null;
	    if (checkedArr.length > 0) {
		    checkedRadio = checkedArr[0];
		    if (checkedRadio ) {
			    checkedRadioValue = checkedRadio.getSubmitValue();
		    }
	    }
	    fieldSelect.setDisabled(checkedRadioValue === 2);
	    this.onRefreshInvalidHandling(fieldId);
	},
	onRefreshInvalidHandling : function(fieldId) {
	    if (fieldId === 1 || fieldId === 2) {
		    // reload is needed only for project or issueType change
		    // most of the other lists depend on project and issueType
		    this.loadDataForCard(3, true);
	    }
	},
	/**
	 * ****************************************Excel
	 * conflicts****************************************************
	 */
	/**
	 * Gets the items for excel import, before the data has arrived
	 */
	getExcelErrorAndConflictHandlingItems : function() {
	    var panelConfig = {
	        itemId : 'errorAndConflict',
	        bodyStyle : 'padding: 5px',
	        border : false,
	        method : "POST",
	        // autoScroll: true,
	        items : [ Ext.create('Ext.panel.Panel', {
	            itemId : 'errorPanel',
	            border : false,
	            defaults : {
	                labelStyle : 'overflow: hidden;',
	                margin : "0 5 0 0"
	            },
	            layout : {
	                type : 'table',
	                columns : 1
	            }
	        }), Ext.create('Ext.form.Panel', {
	            itemId : 'conflictPanel',
	            defaults : {
	                labelStyle : 'overflow: hidden;',
	                margin : "0 5 0 0"
	            },
	            layout : {
	                type : 'table',
	                columns : 7,
	                tdAttrs : {
		                style : {
		                    padding : '5px 15px 0 0',
		                    'vertical-align' : 'top'
		                }
	                }
	            // autoScroll:true
	            },
	            border : false
	        }) ]
	    };
	    return [ Ext.create('Ext.form.Panel', panelConfig) ];
	},
	/**
	 * Add error or conflict handling data for rendering after the result has
	 * arrived
	 */
	postProcessExcelErrorAndConflictHandling : function(panel, data) {
	    var disableFinal = data['disableFinal'];
	    var toolbar = this.wizardPanel.getDockedItems('toolbar[dock="top"]');
	    var finish = toolbar[0].getComponent('finish');
	    var previous = toolbar[0].getComponent('previous');
	    finish.setDisabled(disableFinal);
	    // previous.setDisabled(disableFinal);
	    var errorAndConflictPanel = panel.getComponent('errorAndConflict');
	    var errorCode = data['errorCode'];
	    if (CWHF.isNull(errorCode)) {
		    var message = data['message'];
		    if (message ) {
			    var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
			    errorPanel.add({
			        xtype : 'label',
			        html : '<b>' + message + '</b>'
			    });
		    }
		    return;
	    }
	    switch (errorCode) {
	    case 1:
		    // simple message
		    var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
		    errorPanel.add({
		        xtype : 'label',
		        html : '<b>' + data['errorMessage'] + '</b>'
		    });
		    break;
	    case 2:
		    // more messages
		    var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
		    var errorMessages = data['errorMessage'];
		    for (var i = 0; i < errorMessages.length; i++) {
			    errorPanel.add({
			        xtype : 'label',
			        html : errorMessages[i]
			    });
		    }
		    break;
	    case 3:
		    // grid and row errors
		    var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
		    var gridErrors = data['gridErrors'];
		    if (gridErrors ) {
			    for (var i = 0; i < gridErrors.length; i++) {
				    var gridError = gridErrors[i];
				    var errorMessage = gridError['errorMessage'];
				    var locationList = gridError['locationList'];
				    if (locationList ) {
					    errorPanel.add({
					        xtype : 'label',
					        html : '<b>' + errorMessage + '</b>'
					    });
					    for (var j = 0; j < locationList.length; j++) {
						    errorPanel.add({
						        xtype : 'label',
						        html : locationList[j]
						    });
					    }
				    }
			    }
		    }
		    var rowErrors = data['rowErrors'];
		    if (rowErrors ) {
			    for (var i = 0; i < rowErrors.length; i++) {
				    var rowError = rowErrors[i];
				    var errorMessage = rowError['errorMessage'];
				    var locationList = rowError['locationList'];
				    errorPanel.add({
				        xtype : 'label',
				        html : '<b>' + errorMessage + '</b>'
				    });
				    errorPanel.add({
				        xtype : 'label',
				        html : locationList
				    });
			    }
		    }
		    break;
	    case 4:
		    // field conflicts
		    var errorMessage = data['errorMessage'];
		    var conflicts = data['conflicts'];
		    if (conflicts ) {
			    var conflictPanel = errorAndConflictPanel.getComponent('conflictPanel');
			    var conflictResolutionList = data['conflictResolutionList'];
			    items = [];
			    if (errorMessage ) {
				    items.push({
				        xtype : 'label',
				        html : errorMessage,
				        colspan : 7
				    });
			    }
			    items.push({
			        xtype : 'label',
			        html : '<b>' + getText('admin.actions.importExcel.conflict.lbl.row') + '</b>'
			    });
			    items.push({
			        xtype : 'label',
			        html : '<b>' + data['issueNoLabel'] + '</b>'
			    });
			    items.push({
			        xtype : 'label',
			        html : '<b>' + getText('admin.actions.importExcel.conflict.lbl.column') + '</b>'
			    });
			    items.push({
			        xtype : 'label',
			        html : '<b>' + getText('admin.actions.importExcel.conflict.lbl.field') + '</b>'
			    });
			    items.push({
			        xtype : 'label',
			        html : '<b>' + getText('admin.actions.importExcel.conflict.lbl.excelValue') + '</b>'
			    });
			    items.push({
			        xtype : 'label',
			        html : '<b>' + getText('admin.actions.importExcel.conflict.lbl.trackplusValue') + '</b>'
			    });
			    var conflictResolutionListBold = [];
			    Ext.Array.forEach(conflictResolutionList, function(conflictResolution) {
				    conflictResolutionListBold.push({
				        id : conflictResolution["id"],
				        label : "<b>" + conflictResolution["label"] + "</b>"
				    });
			    }, this);
			    var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictResolutionListBold,
			            'conflictResoultionEntry', 'id', 'label', false, false, true);
			    var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300,
			            conflictResolutionRadioButtons, {itemId:'conflictResoultionRadioGroup'}, {
				            change : {
				                fn : this.onExcelConflictHandlingForAll,
				                scope : this,
				                panel : conflictPanel, /* conflictResolutionList:conflictResolutionList, */
				                conflicts : conflicts
				            }
			            });
			    items.push(conflictResolutionRadioGroup);
			    this.workItemIDFieldIDs = [];
			    Ext.Array.forEach(conflicts, function(conflict) {
				    var row = conflict['row'];
				    var fields = conflict['fields'];
				    Ext.Array.forEach(fields, function(field, index) {
					    if (index === 0) {
						    items.push({
						        xtype : 'label',
						        html : row,
						        rowspan : fields.length
						    });
						    items.push({
						        xtype : 'label',
						        html : field['workItemID'],
						        rowspan : fields.length
						    });
					    }
					    items.push({
					        xtype : 'label',
					        html : field['columnLetter']
					    });
					    items.push({
					        xtype : 'label',
					        html : field['fieldName']
					    });
					    items.push({
					        xtype : 'label',
					        html : field['excelValue']
					    });
					    items.push({
					        xtype : 'label',
					        html : field['trackplusValue']
					    });
					    var workItemIDFieldID = field['workItemIDFieldID'];
					    this.workItemIDFieldIDs.push(workItemIDFieldID);
					    var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictResolutionList,
					            'overwriteMap[' + workItemIDFieldID + "]", 'id', 'label', false, false, true);
					    var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300, conflictResolutionRadioButtons,{itemId:'conflictResoultion' + workItemIDFieldID});
					    items.push(conflictResolutionRadioGroup);
				    }, this);
			    }, this);
			    conflictPanel.add(items);
		    }
		    break;
	    }
	},
	onExcelConflictHandlingForAll : function(field, newValue, oldValue, options) {
	    var panel = options["panel"];
	    var conflictResoultionRadioGroup = panel.getComponent("conflictResoultionRadioGroup");
	    var conflicts = options["conflicts"];
	    var conflictResolutionValue = CWHF.getSelectedRadioButtonValue(conflictResoultionRadioGroup);
	    Ext.Array.forEach(conflicts, function(conflict) {
		    var row = conflict['row'];
		    var fields = conflict['fields'];
		    Ext.Array.forEach(fields, function(field, index) {
			    var workItemIDFieldID = field['workItemIDFieldID'];
			    var radioGroup = panel.getComponent('conflictResoultion' + workItemIDFieldID);
			    // TODO setValue() does not work (ext js bug?).
			    // radioGroup.setValue(conflictResolutionValue);
			    // Once setValue fixed remove this cycle
			    radioGroup.items.each(function(item) {
				    item.setValue(item.inputValue === conflictResolutionValue);
			    });
		    }, this)
	    }, this)
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define("com.trackplus.admin.action.ExportDocx",{
	extend:"Ext.container.Container",
	config: {
		//selected document to export from wiki
		workItemID: null,
		//selected items to export from item navigator
		workItemIDs: null
	},
	initComponent: function() {
		this.callParent();
	},
	createExportForm: function(fromTree, record) {
		var recordData = null;
		if (record) {
			recordData = record.data;
		}
		var width = 500;
		var height = 150;
		var loadUrl = "docxTemplate.action";
		//var loadParams = this.getEditParams(fromTree);
		var load = {loadUrl:loadUrl/*, loadUrlParams:loadParams*/};
		var submitParams = {workItemID:this.workItemID, workItemIDs: this.workItemIDs};
		var submit = [{
						submitUrl:"docxExport.action",
						submitUrlParams:submitParams,
						submitButtonText:getText("common.btn.export"),
						submitHandler:this.exportHandler
					},
		            {
						submitUrl:"docxTemplate!upload.action",
						submitButtonText:getText("common.btn.upload"),
						submitHandler:this.uploadFileHandler
					},
					{
						submitUrl:"docxTemplate!download.action",
						submitButtonText:getText("common.btn.download"),
						submitHandler:this.downloadFileHandler
					},
					{
						submitUrl:"docxTemplate!delete.action",
						submitButtonText:getText("common.btn.delete"),
						submitHandler:this.deleteUploadedFileHandler
					}];
		var postDataProcess = this.renderUploadPostDataProcess;
		var title = getText("admin.actions.exportDocx.chooseTemplate");
		var windowParameters = {title:title,
			width:width,
			height:height,
			load:load, submit:submit,
			formPanel: this.getFormPanel(),
			postDataProcess:postDataProcess,
			cancelButtonText: getText('common.btn.cancel')
			};
		var windowConfig = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
		windowConfig.showWindowByConfig(this);
	},
	getFormPanel: function(fromTree, selectedEntryID) {
	  	var items = [CWHF.createCombo("admin.actions.exportDocx.templates", "docxTemplateList",
	  					{idType:"string", labelWidth:150, blankText:getText("admin.actions.exportDocx.docxTemplateNotSelected"), itemId:"docxTemplateList"}),
					CWHF.createFileField("admin.actions.exportDocx.newTemplate", "docxTemplate",
						{itemId:"docxTemplate", labelWidth:150, blankText:getText("admin.actions.exportDocx.docxTemplateNotBrowsed")})];
		return Ext.create('Ext.form.Panel', {
			bodyStyle: 'padding:5px',
			//url: 'listOptionIcon!upload.action',
			defaults: {
				labelStyle:'overflow: hidden;',
				margin:"5 5 0 0",
				msgTarget:	'side',
				anchor:	'-20'
			},
			method: 'POST',
			fileUpload: true,
			items: items
			}
		);
	},
	exportHandler:function(win, submitUrl, submitUrlParams) {
		var submitUrl = this.getUrlWithTemplate(submitUrl);
		if (submitUrlParams) {
			for (submitUrlParam in submitUrlParams) {
				submitUrl = submitUrl + "&" + submitUrlParam + "=" + submitUrlParams[submitUrlParam];
			}
		}
		window.open(submitUrl);
		win.close();
	},
	downloadFileHandler: function(win, submitUrl) {
		var submitUrl = this.getUrlWithTemplate(submitUrl);
		window.open(submitUrl);
	},
	getUrlWithTemplate: function(submitUrl) {
		var theForm = this.formEdit.getForm();
		var templatesCombo = this.formEdit.getComponent("docxTemplateList");
		var selectedTemplate = templatesCombo.getValue();
		if (CWHF.isNull(selectedTemplate)) {
			templatesCombo.allowBlank = false;
			var docxTemplate = this.formEdit.getComponent("docxTemplate");
			if (docxTemplate) {
				docxTemplate.allowBlank = true;
			}
			theForm.isValid();
			Ext.MessageBox.alert(getText("admin.actions.exportDocx.chooseTemplate"),
					getText("admin.actions.exportDocx.docxTemplateNotSelected"));
			templatesCombo.allowBlank = true;
			return;
		}
		submitUrl = submitUrl + "?docxTemplateFileName="+selectedTemplate;
		return submitUrl;
	},
	renderUploadPostDataProcess: function(data, formPanel) {
	    var templatesCombo = formPanel.getComponent("docxTemplateList");
	    templatesCombo.store.loadData(data["existingTemplates"]);
	    var uploadedTemplate = data["docxTemplateList"];
	    //if (uploadedTemplate) {
	    	templatesCombo.setValue(uploadedTemplate);
	    //}
		formPanel.getComponent("docxTemplate").setValue('');
		var toolbars = this.win.getDockedItems('toolbar[dock="bottom"]');
		if (toolbars) {
			//disable delete button if no icon is specified
			toolbars[0].getComponent(0).setDisabled(CWHF.isNull(uploadedTemplate));
			toolbars[0].getComponent(2).setDisabled(CWHF.isNull(uploadedTemplate));
			toolbars[0].getComponent(3).setDisabled(CWHF.isNull(uploadedTemplate));
		}
	},
	uploadFileHandler: function(window, submitUrl, submitUrlParams) {
		var theForm = this.formEdit.getForm();
		var docxTemplate = this.formEdit.getComponent("docxTemplate");
		var docxTemplateValue = docxTemplate.getValue();
		if (CWHF.isNull(docxTemplateValue) || docxTemplateValue==="") {
			docxTemplate.allowBlank = false;
			var templatesCombo = this.formEdit.getComponent("docxTemplateList");
			if (templatesCombo) {
				templatesCombo.allowBlank = true;
			}
			theForm.isValid();
			Ext.MessageBox.alert(getText("admin.actions.exportDocx.chooseTemplate"),
					getText("admin.actions.exportDocx.docxTemplateNotBrowsed"));
			docxTemplate.allowBlank = true;
			return;
		}
		var expr = /^.*\.(docx|DOCX|tex|TEX|tlx|zip)$/;
		if (!expr.test(docxTemplateValue)) {
			Ext.MessageBox.alert(getText("admin.actions.exportDocx.chooseTemplate"),
					getText("admin.actions.exportDocx.docxTemplateWrongType"));
				return;
		}
		theForm.submit({
			scope: this,
			url: submitUrl,
			params: submitUrlParams,
			success: function(form, action) {
				this.renderUploadPostDataProcess(action.result.data, this.formEdit);
			},
			failure: function(form, action) {
				com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	},
	deleteUploadedFileHandler : function(window, submitUrl, submitUrlParams) {
		var theForm = this.formEdit.getForm();
		var templatesCombo = this.formEdit.getComponent("docxTemplateList");
		var selectedTemplate = templatesCombo.getValue();
		if (CWHF.isNull(selectedTemplate)) {
			templatesCombo.allowBlank = false;
			var docxTemplate = this.formEdit.getComponent("docxTemplate");
			if (docxTemplate) {
				docxTemplate.allowBlank = true;
			}
			theForm.isValid();
			//templatesCombo.validate();
			Ext.MessageBox.alert(getText("admin.actions.exportDocx.chooseTemplate"),
					getText("admin.actions.exportDocx.docxTemplateNotSelected"));
			templatesCombo.allowBlank = true;
			return;
		}
		theForm.submit({
			scope: this,
			url: submitUrl,
			//params: submitUrlParams,
			success: function(form, action) {
				this.renderUploadPostDataProcess(action.result.data, this.formEdit);
			},
			failure: function(form, action) {
				com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ImportMsProject',{
	extend:'com.trackplus.admin.action.ImportWizard',
	config: {
		projectID: null
	},
	conflictParameterNames:null,
	dialogHeight:470,
	dialogWidth:820,
	isFromDragAndDrop:false,
	getNumberOfCards: function() {
		return 3;
	},
	getTitle: function(cardNo) {
		var titleKey=null;
		switch (cardNo) {
		case 1:
			titleKey = "admin.actions.importMSProject.title.upload";
			break;
		case 2:
			titleKey = "admin.actions.importMSProject.title.resourceMappings";
			break;
		case 3:
			titleKey = "admin.actions.importMSProject.title.importResult";
			break;
		}
		if (titleKey) {
			return getText(titleKey);
		} else {
			return '';
		}
	},
	getFilePattern: function(importSource, fileName) {
		return /^.*\.(xml|XML|MPP|mpp|MPT|mpt)$/;
	},
	getFileTypeLabel: function() {
		return getText("admin.actions.importMSProject.lbl.uploadFile");
	},
	getImportWizardUrl: function(card, reload) {
		if (card===1) {
			return 'msProjectUploadRender.action';
		} else {
			if (card===2) {
				return 'msProjectUpload.action';
			} else {
				if (card===3) {
					return "msProjectImport!submitResourceMapping.action";
				} /*else {
	                if (card===4) {
	                    return "msProjectImport!doImport.action";
	                }
	            } */
			}
		}
	},
	/**
	 * Load/submit the data for on the cardNo
	 * cardNo: the card number to go next, or the actual card number if reload
	 * reload: whether to reload the current card or submit to the current values and go to the next card
	 * return false and optionally show an alert box if there is a validation problem which prevents navigating to the next card
	 */
	loadDataForCard: function(cardNo, reload, parameters) {
		var me = this;
		if (cardNo===1) {
			//for the very first card nothing to submit only render (load)
			var panel1 = this.wizardPanel.getComponent('card1');
			panel1.add(this.getImportWizardItemsForCard(cardNo));
			var params = null;
			if (this.projectID) {
				params = {projectOrReleaseID:-this.projectID};
			}
			panel1.getForm().load({
				url: this.getImportWizardUrl(cardNo, reload),
				scope: this,
				params: params,
				success : function(form, action) {
					try{
						this.postDataProcess(panel1, action.result.data, 1);
						//if data is valid we can go to the next card
					}catch(ex){}
				},
				failure: function(form, action) {
					Ext.MessageBox.alert(this.failureTitle, action.response.responseText);
				}
			});
			return true;
		} else {
			//from card to each card starts with a submit
			if (cardNo===2) {
				var panel1 = this.wizardPanel.getComponent('card1');
				if (!panel1.getForm().isValid()) {
					Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileNotSpecified'),
							getText('admin.actions.importTp.lbl.uploadFileNotSpecified'));
					return false;
				}
				var importFile = panel1.getComponent('uploadFile');
				if (!this.validateFileExtension(importFile.getRawValue())) {
					Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileWrongType'),
						getText('common.err.fileExpectedType', this.getFileTypeLabel()));
					return false;
				}
				if (this.uploadDone) {
					Ext.MessageBox.alert(getText('admin.actions.importTp.err.uploadAgain'),
							getText('admin.actions.importTp.err.uploadAgain', this.getFileTypeLabel()));
						return false;
				}
				this.uploadDone = true;
				var params = {fileName:this.fileName};
				//this.submitFromCardToCardMessageOnFailure(1, 2, params, reload, true);
	            this.submitFromCardToCard(1, 2, params, reload, true);
			} else {
				if (cardNo===3) {
					//var params = {fileName:this.fileName};
	                if (CWHF.isNull(parameters)) {
	                    parameters = new Object();
	                }
	                parameters["fileName"] = this.fileName;
					return this.submitFromCardToCard(2, 3, parameters, reload, 240);
				}
			}
		}
	},
	/**
	 * Get the initial items for a card
	 * Additional items can be added once the data is back from the server
	 */
	getImportWizardItemsForCard: function(card) {
		if (card===1) {
			return this.getImportWizardCard1Items();
		} else {
			if (card===2) {
				return this.getMsProjectResourceMappingItems();
			} else {
				if (card===3) {
					return this.getMsProjectConflictHandlingItems();
				}
			}
		}
	},
	postDataProcess: function(panel, data, card) {
		if (card===1) {
			this.postProcessCard1(panel, data);
		} else {
			if (card===2) {
				if (data.data) {
					this.postProcessMsProjectResourceMapping(panel, data);
					this.actualizeToolbar(this.wizardPanel);
				} else {
					this.goNext();
					var panel3 = this.wizardPanel.getComponent("card" + 3);
					panel3.removeAll();
					panel3.add(this.getImportWizardItemsForCard(3));
					this.postProcessMsProjectConflictHandling(panel3, data);
					//this.actualizeToolbar(this.wizardPanel);
					//this.removeCard(2);
				}
			} else {
				if (card===3) {
					this.postProcessMsProjectConflictHandling(panel, data);
				}
			}
		}
	},
	/**************************Import source**************************************/
	getImportWizardCard1Items: function() {
		var me = this;
		var card1Items = [];
		if(!me.isFromDragAndDrop) {
			var card1Items = [CWHF.createFileField(
					getText("common.lbl.file", this.getFileTypeLabel()), "uploadFile",
					{margin: '5 0 0 0', allowBlank:false, labelWidth:250, width:700, labelIsLocalized: true, itemId:"uploadFile"},
					{change:{fn:function(){
						this.uploadDone=false;},
						scope:this}})];
		}
		card1Items.push({xtype: 'label',
			itemId: 'importSourceError'});
		card1Items.push(CWHF.createSingleTreePicker("admin.actions.importTp.lbl.projectRelease",
	        "projectOrReleaseID", [], null,
	        {allowBlank:false,
	            labelWidth:250,
	            width:500,
	            margin: '10 0 10 0',
	            itemId: 'projectOrReleaseID'
	        }));
		return card1Items;
	},
	/**
	 * Post process first card data
	 * Called after first loading the first card data and after each import source change
	 */
	postProcessCard1: function(formPanel, data) {
	    var projectReleasesPicker = formPanel.getComponent("projectOrReleaseID");
	    projectReleasesPicker.updateMyOptions(data["projectReleaseTree"]);
	    projectReleasesPicker.setValue(data["selectedProjectReleaseID"]);
		var uploadFile = formPanel.getComponent("uploadFile");
		uploadFile.setRawValue('');
		this.initCards(2);
	},
	/**************************MsProject resource - Genji user mappings**************************************/
	/**
	 * Gets the items for excel field mapping, before the data has arrived
	 */
	getMsProjectResourceMappingItems: function() {
		var resourcePanelConfig = {
				itemId: 'resourceMappings',
				layout: {
					type: 'table',
					columns: 4,
					style: {
						width: '100%'
					}
				},
				bodyStyle: 'padding: 5px',
				border: false,
				method: "POST",
				autoScroll:	false,
				items: []
			};
		var newUserErrorsPanelConfig = {
				itemId: 'newUserErrors',
				layout: {
					type: 'table',
					columns: 1,
					style: {
						width: '100%'
					}
				},
				bodyStyle:	'padding: 5px',
				border: false,
				method: "POST",
				autoScroll:	false,
				items: []
			};
		return [Ext.create('Ext.form.Panel', resourcePanelConfig),
				Ext.create('Ext.form.Panel', newUserErrorsPanelConfig)];
	},
	/**
	 * Add field mappings data for rendering after the result has arrived
	 */
	postProcessMsProjectResourceMapping: function(panel, jsonData) {
		var data = jsonData.data;
		this.fileName = data['fileName'];
		var resourceMappings = data['resourceMappings'];
		var trackplusPersons = data['trackplusPersons'];
		items = [];
		items.push({xtype: 'label',
			html: getText('admin.actions.importMSProject.lbl.resourceName')
			});
		items.push({xtype: 'label',
			html: getText('admin.actions.importMSProject.lbl.personName'),
			colspan: 3
			});
		if (panel) {
			if (resourceMappings) {
				Ext.Array.forEach(resourceMappings, function(resourceMapping) {
					var resourceName = resourceMapping['resourceName'];
					var resourceUID = resourceMapping['resourceUID'];
					var personID = resourceMapping['personID'];
					items.push({xtype: 'label',
						 html: resourceName,
						 width: 200
						});
					items.push(CWHF.createCombo(null,
							'resourceUIDToPersonIDMap[' + resourceUID + ']',
							{width:150,
							data:trackplusPersons,
							value:personID,
							itemId: 'resourceUIDToPersonID' + resourceUID},
							{select: {fn: this.showHide, scope:this,
								panel: panel,
								resourceUID: resourceUID}},
								'resourceUIDToPersonID'+resourceUID));
					var textFieldUsername = CWHF.createTextField('admin.actions.importMSProject.lbl.userName',
							'resourceUIDToUsernameMap['+resourceUID +']',
							{itemId:'resourceUIDToUsername'+resourceUID,
							allowBlank:false,
							width:250,
							labelWidth: 100});
					textFieldUsername.setDisabled(personID!==0);
					items.push(textFieldUsername);
					var textFieldEmail = CWHF.createTextField('admin.actions.importMSProject.lbl.email',
							'resourceUIDToEmailMap['+resourceUID +']',
							{itemId:'resourceUIDToEmail'+resourceUID,
							allowBlank:false,
							width: 250,
							labelWidth: 75});
					textFieldEmail.setDisabled(personID!==0);
					items.push(textFieldEmail);
				}, this);
			}
		}
		var mappingsPanel = panel.getComponent('resourceMappings');
		mappingsPanel.removeAll(true);
		//add all panels at once
		mappingsPanel.add(items);
		var newUserErrorsPanel = panel.getComponent('newUserErrors');
		newUserErrorsPanel.removeAll(true);
		//add all panels at once
		var errors = data['errorMessage'];
		if (errors) {
			newUserErrorsPanel.add(errors);
		}
	},
	/**
	 * Set/reset disable automatically the identifier checkbox by selecting a field
	 */
	showHide: function(combo, records, options) {
		var panel = options.panel;
		var resourceUID = options.resourceUID;
		var mappingPanel = panel.getComponent('resourceMappings');
		if (mappingPanel) {
			var resourceUIDToPersonID = mappingPanel.getComponent("resourceUIDToPersonID" + resourceUID);
			var resourceUIDToUsername = mappingPanel.getComponent("resourceUIDToUsername" + resourceUID);
			var resourceUIDToEmail = mappingPanel.getComponent("resourceUIDToEmail" + resourceUID);
			var selectedValue = resourceUIDToPersonID.getValue();
			var showUsernameAndEmail = selectedValue!==0;
			resourceUIDToUsername.setDisabled(showUsernameAndEmail);
			resourceUIDToEmail.setDisabled(showUsernameAndEmail);
		}
	},
	/******************************************Ms project conflicts*****************************************************/
	/**
	 * Gets the items for ms project import, before the data has arrived
	 */
	getMsProjectConflictHandlingItems: function() {
		var panelConfig = {
				itemId: 'errorAndConflict',
				bodyStyle:	'padding: 5px',
				border: false,
				method: "POST",
				autoScroll:	false,
				items: [
					Ext.create('Ext.panel.Panel', {
						itemId: 'errorPanel',
						border:false,
						defaults:	{
							labelStyle:'overflow: hidden;',
							margin:"0 5 0 0"
						},
						layout: {
							type:'table',
							columns:1
						}
					}),
					Ext.create('Ext.form.Panel', {
						itemId: 'conflictPanel',
						defaults:	{
							labelStyle:'overflow: hidden;',
							margin:"0 5 0 0"
						},
						layout: {
							type:'table',
							columns:6
						},
						border:false})
					]};
		return [Ext.create('Ext.form.Panel', panelConfig)];
	},
	/**
	 * Add error or conflict handling data for rendering after the result has arrived
	 */
	postProcessMsProjectConflictHandling: function(panel, data) {
		var me = this;
		var errorCode = data['errorCode'];
		var disableFinal = data['disableFinal'];
		var toolbar =  me.win.getDockedItems('toolbar[dock="bottom"]');
		var finish = toolbar[0].getComponent('finish');
		finish.setDisabled(disableFinal);
		var errorAndConflictPanel = panel.getComponent('errorAndConflict');
		var errorCode = data['errorCode'];
		if (CWHF.isNull(errorCode)) {
			var message = data['message'];
			if (message) {
				var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
				errorPanel.add({xtype: 'label',
					 html: message
					});
				finish.setText(getText('common.lbl.wizard.finish'));
				finish.setDisabled(false);
				finish.setIconCls('');
				finish.handler = function() {me.win.close();};
				var toolbar = me.win.getDockedItems('toolbar[dock="bottom"]');
				var previous = toolbar[0].getComponent('previous');
				if (previous) {
					previous.setDisabled(true);
				}
			} else {
	            var statusText = data["statusText"];
	            if (statusText) {
	                //from submitFromCardToCard -> failure branch: for ex. connection timeout: import took too long
	                var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
	                errorPanel.add({xtype: 'label',
	                    html: statusText
	                });
	            }
	        }
			return;
		}
		var conflictPanel = panel.getComponent('conflictPanel');
		switch(errorCode) {
		case 2:
			//error messages
			var errorPanel = errorAndConflictPanel.getComponent('errorPanel');
			var errorMessages = data['errorMessage'];
			for ( var i = 0; i < errorMessages.length; i++) {
				errorPanel.add({xtype: 'label',
					html: errorMessages[i]
					});
			}
			break;
		case 4:
	        this.conflictParameterNames = [];
			var errorMessage = data['errorMessage'];
			//conflicts
			var conflictPanel = errorAndConflictPanel.getComponent('conflictPanel');
			var leaveOverwriteList = data['leaveOverwriteList'];
	        var leaveDeleteList = data['leaveDeleteList'];
	        var leaveUndeleteList = data['leaveUndeleteList'];
	        conflictPanel.add({xtype: 'label',
	            html: errorMessage,
	            colspan: 6
	        });
			var conflicts = data['conflicts'];
			if (conflicts) {
				Ext.Array.forEach(conflicts, function(conflict) {
					var conflictMessage =  conflict['conflictMessage'];
	                var conflictType =  conflict['conflictType'];
	                var conflictHandlingList = null;
	                var titleColspan = 1;
	                var withValues = true;
	                switch(conflictType) {
	                    case 1:  //BUDGET;
	                    case 2: //STARTDATE
	                    case 3: //ENDDATE
	                        conflictHandlingList = data['leaveOverwriteList'];
	                        break;
	                    case 4: //DELETED
	                        conflictHandlingList = data['leaveDeleteList'];
	                        titleColspan = 3;
	                        withValues = false;
	                        break;
	                    case 5: //UNDELETED
	                        conflictHandlingList = data['leaveUndeleteList'];
	                        withValues = false;
	                        titleColspan = 3;
	                        break;
	                }
					var conflictMapName =  conflict['conflictMapName'];
	                conflictPanel.add({xtype: 'label',
	                    html: conflictMessage,
	                    colspan: 6
	                });
	                var items = [];
	                items.push({xtype: 'label',
	                    html: '<b>'+"UID"+'</b>'
	                });
	                items.push({xtype: 'label',
	                    html: '<b>'+data['issueNoLabel']+'</b>'
	                });
	                items.push({xtype: 'label',
	                    html: '<b>'+getText('common.lbl.name')+'</b>',
	                    colspan: titleColspan
	                });
	                if (withValues) {
	                    items.push({xtype: 'label',
	                        html: '<b>'+getText('admin.actions.importMSProject.conflict.lbl.msProjectValue')+'</b>'
	                    });
	                    items.push({xtype: 'label',
	                        html: '<b>'+getText('admin.actions.importMSProject.conflict.lbl.trackplusValue')+'</b>'
	                    });
	                }
	                var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictHandlingList,
	                    conflictMapName, 'id', 'label', false, false, true);
	                var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300, conflictResolutionRadioButtons,  {itemId:conflictMapName+'RadioGroup'},
	                    {change: {fn: this.onMsProjectConflictHandlingForAll, scope:this,
	                        panel: conflictPanel, conflictValues: conflict['conflictValues'], conflictMapName:conflictMapName}});
	                items.push(conflictResolutionRadioGroup);
	                conflictPanel.add(items);
					var conflictValues = conflict['conflictValues'];
					Ext.Array.forEach(conflictValues, function(conflictValue, index) {
						var workItemID = conflictValue['workItemID'];
	                    var items = [];
						items.push({xtype: 'label',
							html: conflictValue['uid']
							});
						items.push({xtype: 'label',
							html: conflictValue['itemID']
							});
						items.push({xtype: 'label',
							html: conflictValue['title'],
	                        colspan: titleColspan
							});
	                    if (withValues) {
	                        items.push({xtype: 'label',
	                            html: conflictValue['msProjectValue']
	                            });
	                        items.push({xtype: 'label',
	                            html: conflictValue['trackplusValue']
	                            });
	                    }
	                    //the name of the conflict parameter to be submitted
	                    //the radio group will have the same itemId, to store only one array (this.conflictParameterNames) for submitting the conflict paramaters. See getDataBeforeCardDelete()
	                    var conflictParamName =  conflictMapName + "[" + workItemID + "]";
	                    var conflictParamItemId =  conflictMapName + workItemID;
						var conflictResolutionRadioButtons = CWHF.getRadioButtonItems(conflictHandlingList,
	                        conflictParamName, 'id', 'label', false, false, true);
						var conflictResolutionRadioGroup = CWHF.getRadioGroup('', 300, conflictResolutionRadioButtons,{itemId:conflictParamItemId});
	                    this.conflictParameterNames.push(conflictParamName);
						items.push(conflictResolutionRadioGroup);
	                    conflictPanel.add(items);
					}, this);
				}, this);
			}
			break;
		}
	},
	onMsProjectConflictHandlingForAll: function(field, newValue, oldValue, options) {
	    var panel = options["panel"];
	    var conflictMapName =  options["conflictMapName"];
	    var conflictValues = options["conflictValues"];
	    var conflictResolutionValue = newValue[conflictMapName];
	    var conflictParameterItemId =  conflictMapName.split('[').join('');
	    conflictParameterItemId =  conflictParameterItemId.split(']').join('');
	    Ext.Array.forEach(conflictValues, function(conflictValue) {
	        var workItemID = conflictValue['workItemID'];
	        var radioGroup = panel.getComponent(conflictParameterItemId + workItemID);
	        //TODO setValue() does not work (ext js bug?).
	        //radioGroup.setValue(conflictResolutionValue);
	        //Once setValue fixed remove this cycle
	        radioGroup.items.each(function(item){
	            item.setValue(item.inputValue === conflictResolutionValue);
	        });
	    }, this)
	},
	getDataBeforeCardDelete: function(cardNo, reload) {
	    var params = null;
	    if (cardNo===3) {
	        params = new Object();
	        if (reload && this.conflictParameterNames) {
	            var overwriteMap = new Object();
	            var card3 = this.wizardPanel.getComponent("card3");
	            var errorAndConflictPanel = card3.getComponent('errorAndConflict');
	            var conflictPanel = errorAndConflictPanel.getComponent('conflictPanel');
	            Ext.Array.forEach(this.conflictParameterNames, function(conflictParameterName) {
	            	var conflictParameterItemId =  conflictParameterName.split('[').join('');
	            	conflictParameterItemId =  conflictParameterItemId.split(']').join('');
	                var radioButtons = conflictPanel.getComponent(conflictParameterItemId);
	                var paramValue = CWHF.getSelectedRadioButtonValue(radioButtons);
	                params[conflictParameterName]= paramValue;
	            }, this);
	        }
	    }
	    return params;
	},
	/**
	 * This function initialize necessary components for showing pop
	 * up dialog
	 */
	createPopUpDialog: function(files) {
		var me = this;
		if(CWHF.isNull(files)) {
			me.isFromDragAndDrop = false;
			var windowParameters = {
				title: "",
				width: me.dialogWidth,
				height: me.dialogHeight,
				overrideButtons: me.getDialogButtons(),
				items: me.getWizardPanel()
			};
			me.window = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
			me.window.showWindowByConfig(me);
			me.actualizeToolbar(me.wizardPanel);
		}else {
			me.file = null;
			me.isFromDragAndDrop = true;
			if(files  && files.length > 0){
				me.file = files[0];
			}
			var continueToUpload = true;
			if (!me.validateFileExtension(me.file.name)) {
				Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileWrongType'),
					getText('common.err.fileExpectedType', me.importExcelWizard.getFileTypeLabel()));
				continueToUpload = false;
			}
			if (me.uploadDone) {
				Ext.MessageBox.alert(getText('admin.actions.importTp.err.uploadAgain'),
						getText('admin.actions.importTp.err.uploadAgain', this.getFileTypeLabel()));
				continueToUpload = false;
			}
			if(continueToUpload) {
				me.uploadDone = true;
				var formData = new FormData();
				formData.append('uploadFile', me.file);
				formData.append('uploadFileFileName', "MyName!");
				var windowParameters = {
					title: "",
					width: me.dialogWidth,
					height: me.dialogHeight,
					overrideButtons: me.getDialogButtons(),
					items: me.getWizardPanel()
				};
				me.window = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
			    var card1 = me.wizardPanel.getComponent("card1");
			    var fileUploader = card1.getComponent("uploadFile");
			    me.window.showWindowByConfig(me);
				me.actualizeToolbar(me.wizardPanel);
			}
		}
	},
	/**
	 * The following method uploads dropped excel file, and
	 * opens excel import wizard pop up dialog
	 */
	uploadMsProjFile: function() {
		var me = this;
		var formData = new FormData();
		formData.append('uploadFile', me.file);
		formData.append('uploadFileFileName', me.file.name);
	    var card1 = me.wizardPanel.getComponent("card1");
		var projectReleasesPicker = card1.getComponent("projectOrReleaseID");
		me.projectID = projectReleasesPicker.getValue();
		formData.append('projectOrReleaseID', me.projectID);
		var xhr = new XMLHttpRequest();
		var urlStr='msProjectUpload.action';
		xhr.open('POST', urlStr);
		xhr.onload = function () {
			if (xhr.status === 200) {
				var panelFrom = me.wizardPanel.getComponent("card" + 1);
				var panelTo = me.wizardPanel.getComponent("card" + 2);
				panelTo.removeAll(true);
				var panel = me.getImportWizardItemsForCard(2);
				panelTo.add(panel);
				var decodedString = Ext.decode(xhr.response);
				var jsonResult = {};
				jsonResult.data = decodedString.data;
				me.postDataProcess(panelTo, jsonResult, 2, 1);
				me.uploadDone = true;
				me.wizardPanel.layout.setActiveItem(1);
				me.actualizeToolbar(me.wizardPanel);
			} else {
				alert('Something went terribly wrong...');
			}
		};
		xhr.onerror=function(e){
			borderLayout.setLoading(false);
			alert("Error uploading!" + e);
		};
		xhr.upload.onprogress = function (event) {
		};
		xhr.onerror=function(e){
			borderLayout.setLoading(false);
			alert("Error: " + e);
		}
		xhr.send(formData);
	},
	onNavigate: function(btn, panel) {
		var me = this;
		var layout = panel.getLayout();
		var activeItem = layout.getActiveItem();
		var index = panel.items.indexOf(activeItem);
		var numItems = panel.items.getCount() - 1;
		if (btn) {
	        var params = null;
			if (btn.itemId === 'next' || btn.itemId === 'finish' && index <= numItems) {
				if(index === 0 && me.isFromDragAndDrop) {
						me.uploadMsProjFile();
				}else {
					//+ 2 because index is 0 based and the data for the next card is loaded
					var reload = false;
					if (index===numItems) {
						//reload the error handling card
						index = index-1;
						reload = true;
	                    //two forms should be submitted by conflict handling: the second one is "serialized" in params
	                    params = this.getDataBeforeCardDelete(index+2, reload);
					}
					//TODO: redundantly initializes the next cards.
					//After a form is submitted and we go back to the previous card
					//the field values of the already submitted data is somehow stored/cached in the Ext.form.Basic
					//(even if the Ext.form.Panel form with all his fields is removed). Consequently when the form will be sumbitted
					//next time all form field values are duplicated in submit resulting in server side errors.
					//To avoid this initialize all next cards after each next.
					this.initCards(index+2);
					var dataIsValid = this.loadDataForCard(index+2, reload, params);
					if (dataIsValid!==false) {
						//if data is valid then change to the next card
						panel.layout.setActiveItem(index + 1);
					}
				}
			} else {
				if (btn.itemId === 'previous' && index > 0) {
					var activeItem = layout.getActiveItem();
					//remove all data from the current card before moving back to the previous card: next always starts from an empty card
					activeItem.removeAll();
					panel.layout.setActiveItem(index - 1);
				}
			}
		}
		this.actualizeToolbar(panel);
	},
	getWizardPanel: function() {
		var me = this;
		var toolbarItems = [];
		this.wizardPanel = Ext.create('Ext.panel.Panel', {
			title: '',
			layout: 'card',
			region: 'left',
			//margin: '2 0 0 -10',
			cls: 'importWizard',
//			bodyStyle: 'padding:15px; border-left:none',
			//bodyStyle: 'border-left:none',
			defaults: {
				// applied to each contained panel
				border: false
//				autoScroll: false,
//				scroll:false
			},
			// the panels (or "cards") within the layout
			items: [this.createEmptyCard("card1", true)]
		});
		this.initCards(2);
		this.loadDataForCard(1);
		return this.wizardPanel;
	},
	getDialogButtons: function() {
		var me = this;
		var toolbarItems = [];
		var numberOfCards = this.getNumberOfCards();
		if (numberOfCards>1) {
			toolbarItems.push({
				itemId: 'previous',
				text:'&laquo; '+ getText('common.lbl.wizard.previous'),
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, me.wizardPanel);
				},
				//at the beginning disabled
				disabled: true
			});
			toolbarItems.push('-');
			toolbarItems.push({
				itemId: 'next',
				text: getText('common.lbl.wizard.next')+' &raquo;',
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, me.wizardPanel);
				}
			});
			toolbarItems.push('-');
			toolbarItems.push({
				itemId: 'finish',
				iconCls: 'import16',
				text: getText('common.btn.import'),
				scope: this,
				handler: function(btn) {
					this.onNavigate(btn, me.wizardPanel);
				},
				disabled: true
				});
		} else {
			//for direct import no navigation is needed
			toolbarItems.push({	itemId: 'finish',
				text: getText('common.btn.import'),
				scope: this,
				handler: function(btn) {
					this.loadDataForCard(1, true);
				},
				disabled: false
			});
		}
		return toolbarItems;
	},
	/**
	 * Actualize the toolbar settings according to the current index
	 */
	actualizeToolbar: function(panel) {
		var me = this;
		if(me.win) {
			var layout = panel.getLayout();
			var activeItem = layout.getActiveItem();
			var index = panel.items.indexOf(activeItem);
			var numItems = panel.items.getCount();
			var toolbar = me.win.getDockedItems('toolbar[dock="bottom"]');
			var previous = toolbar[0].getComponent('previous');
			if (previous) {
				previous.setDisabled(!layout.getPrev());
			}
			var next = toolbar[0].getComponent('next');
			if (next) {
				next.setDisabled((index+1)>=(numItems-1));
			}
			var finish = toolbar[0].getComponent('finish');
			if (finish) {
				finish.setDisabled((index+1)!==(numItems-1));
			}
		}
		if(me.win) {
			me.win.setTitle(this.getTitle(index + 1));
		}
	},
	closeWindow: function() {
	},
	getWindowComponent: function() {
		var me = this;
		return me.window;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ExportMsProject',{
	extend:'Ext.Base',
	config: {
		projectID: null
	},
	constructor : function(config) {
		var me = this;
		var config = config || {};
		this.initConfig(config);
	},
	exportButton:null,
	panelForm:null,
	dialogHeight:470,
	dialogWidth:785,
	/**
	 * Initialize all actions and return the toolbar actions
	 */
	getToolbarActions: function() {
		if (CWHF.isNull(this.exportButton)) {
			this.exportButton = new Ext.Button({
					text:getText('common.btn.export'),
					tooltip:getText('common.btn.export'),
					iconCls: 'export',
					disabled:false,
					scope: this,
					handler:function(){
						this.exportToMsProject.call(this);
					}
				});
			}
		return [this.exportButton];
	},
	exportToMsProject:function() {
		//standardSubmit, no success and failure handlers are called
		this.panelForm.getForm().submit({
			method :'POST',
			scope:this
			/*success: function(form, action) {
			},
			failure: function(form, action) {
				Ext.Msg.alert(getText("common.err.failure"), action.result.errorMessage);
			}*/
		});
	},
	getDetailPanel: function() {
	    var releasePicker = CWHF.createSingleTreePicker("admin.actions.importTp.lbl.fromProjectRelease",
	        "projectOrReleaseID", [], null,
	        {itemId:'projectOrReleaseID',
	    	allowBlank:false,
	         labelWidth:200,
	         width:500,
	         padding: '10 0 0 0'
	        }, {select:{fn: this.onProjectReleaseSelect, scope:this}})
		var notClosedCheckBox = CWHF.createCheckbox("admin.actions.exportMSProject.lbl.notClosed", "notClosed", {itemId:"notClosed", labelWidth:200, width:250});
		var importFileInfo = {xtype:"label", itemId:"importFileInfo", cls:"infoBox_bottomBorder",
				border:true, html: "MsProject", anchor:'100%'};
		this.panelForm= new Ext.form.FormPanel({
			url:"msProjectExport!export.action",
			region: 'center',
			border: false,
			//autoScroll: true,
			standardSubmit: true,
			//bodyStyle: 'padding:10px',
			margin:'-10 0 0 -10',
			items: [importFileInfo, releasePicker, notClosedCheckBox]
		});
		this.panelLoad();
		return this.panelForm;
	},
	/**
	 * Change event, not
	 * @param projectPicker
	 * @param selectedProjects
	 * @param oldValue
	 * @param options
	 */
	onProjectReleaseSelect: function(releasePicker, selectedRelease, options) {
	    Ext.Ajax.request({
	            url:"msProjectExport!importFileInfo.action",
	            params: {projectOrReleaseID: releasePicker.getValue()},
	            scope: this,
	            disableCaching:true,
	            success: function(response) {
	                var panel = releasePicker.up("panel");
	                var data = Ext.decode(response.responseText);
	                this.replaceImportFileInfo(panel, data["importFileInfo"]);
	            },
	            failure:function(result){
	                com.trackplus.util.requestFailureHandler(response);
	            }
	        }
	    );
	},
	panelLoad: function() {
		params = {projectOrReleaseID:-this.getProjectID()};
		this.panelForm.getForm().load({
			url: "msProjectExport.action",
			scope: this,
			params: params,
			success : function(form, action) {
				try{
					this.postLoadProcess(this.panelForm, action.result.data);
				}catch(ex){}
			},
			failure: function(form, action) {
				Ext.MessageBox.show(getText("common.err.failure"), action.response.responseText);
			}
		})
	},
	postLoadProcess: function(panel, data) {
		var projectReleasesPicker = panel.getComponent("projectOrReleaseID");
	    //projectReleasesPicker.setSubmitValue(data["selectedProjectReleaseID"]);
	    projectReleasesPicker.updateMyOptions(data["projectReleaseTree"]);
	    projectReleasesPicker.setValue(data["selectedProjectReleaseID"]);
	    this.replaceImportFileInfo(panel, data["importFileInfo"]);
	    //this.replaceImportFileInfo(panel, data);
		/*var importFileInfo = panel.getComponent("importFileInfo");
		if (importFileInfo) {
			panel.remove(importFileInfo);
		}
		panel.insert(0, {
			xtype: "component",
			itemId: "importFileInfo",
			cls:"infoBox_bottomBorder",
			border:true,
			html: data["importFileInfo"]
		});
		//importFileInfo = panel.getComponent("importFileInfo");
		//importFileInfo.setText(data["importFileInfo"]);*/
	},
	replaceImportFileInfo: function(panel, importFileInfo) {
	    var importFileInfoComponent = panel.getComponent("importFileInfo");
	    if (importFileInfoComponent) {
	        panel.remove(importFileInfoComponent);
	    }
	    panel.insert(0, {
	        xtype: "component",
	        itemId: "importFileInfo",
	        cls:"infoBox_bottomBorder",
	        border:true,
	        html: importFileInfo
	    });
	},
	/**
	 * This function initialize necessary components for showing pop
	 * up dialog
	 */
	createPopUpDialog: function() {
		var me = this;
			me.isFromDragAndDrop = false;
			var windowParameters = {
				title: getText('itemov.btn.exportMSProject'),
				width: me.dialogWidth,
				height: me.dialogHeight,
				overrideButtons: me.getToolbarActions(),
				items: me.getDetailPanel()
			};
			var window = Ext.create('com.trackplus.util.WindowConfig', windowParameters);
			window.showWindowByConfig(me);
//			me.actualizeToolbar(me.wizardPanel);
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.admin.action.ImportTrackplus',{
	extend:'Ext.Base',
	config: {
	},
	mainComponent: null,
	createToolbar:function(){
		var btnImport=new Ext.Button({
				text:getText('common.btn.import'),
				overflowText:getText('common.btn.import'),
				tooltip:getText('common.btn.import'),
				iconCls: 'import',
				disabled:false,
				scope:this,
				handler:function(){
					this.startImport();
				}
			});
		return [btnImport];
	},
	createMainComponent: function() {
		var panelConfig = {
			fileUpload:	true,
			//bodyStyle:	'padding: 5px',
			border: false,
			/*defaults: {
				labelStyle:'overflow: hidden;',
				//margin:"5 5 0 0",
				msgTarget:	'side',
				anchor:	'-20',
			},*/
			method: "POST",
			autoScroll:	true,
			items: [{xtype: 'component',
					cls:"infoBox_bottomBorder",
					border:true,
					html: getText("admin.actions.importTp.warning")
					},
					CWHF.createFileField(
						getText("common.lbl.file", getText("admin.actions.importTp.lbl.uploadFile")), "uploadFile",
						{itemId:"uploadFile", allowBlank:false, labelWidth:250, width: 700, labelIsLocalized: true, padding: '5 5 5 5'})]
			};
		this.mainComponent = Ext.create('Ext.form.Panel', panelConfig);
		return this.mainComponent;
	},
	validateFileExtension: function(fileName) {
		var exp = /^.*\.(zip|ZIP)$/;
		return exp.test(fileName);
	},
	startImport: function() {
		if (!this.mainComponent.getForm().isValid()) {
			Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileNotSpecified'),
					getText('admin.actions.importTp.lbl.uploadFileNotSpecified'));
			return false;
		}
		var importFile = this.mainComponent.getComponent('uploadFile');
		if (!this.validateFileExtension(importFile.getRawValue())) {
			Ext.MessageBox.alert(getText('admin.actions.importTp.lbl.uploadFileWrongType'),
				getText('common.err.fileExpectedType', "zip"));
			return false;
		}
		this.mainComponent.setLoading(getText("admin.actions.importTp.lbl.waitMessage"));
		this.mainComponent.getForm().submit({
			url: "trackplusUpload.action",
			scope: this,
			method: "POST",
			success: function(form, action) {
				this.mainComponent.setLoading(false);
				Ext.MessageBox.alert(action.result["title"], action.result["message"]);
			},
			failure: function(form, action) {
				this.mainComponent.setLoading(false);
				com.trackplus.util.submitFailureHandler(form, action);
			}
		})
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.MasterHomeLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	//selectedGroup:'wiki',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.borderLayoutController.setHelpContext("masterHome");
		//me.wikiController=Ext.create('com.trackplus.wiki.WikiController',{
		//	data:me.initData
		//});
		me.onReady(function() {
			//borderLayout.setActiveToolbarList([]);
			//borderLayout.setVisibleToolbar(false);
		});
	},
	createCenterPanel:function(){
		var me=this;
		var data=me.initData.modules;
		var items=new Array();
		for(var i=0;i<data.length;i++){
			items.push(Ext.create('com.trackplus.master.AppBoxView',{
				width:100,
				height:100,
				appID:data[i].id,
				appUrl:data[i].url,
				appTitle:data[i].name,
				appIcon:"appJenkins" //data[i].iconCls
			}));
		}
		me.view=Ext.create('Ext.panel.Panel',{
			border:false,
			bodyBorder:false,
			bodyCls:'appPanel',
			height:200,
			layout:'column',
			items:items
		});
		var maxWidth=125*data.length;
		if(maxWidth>1000){
			maxWidth=1000;
		}
		return  Ext.create('Ext.panel.Panel',{
			region: 'center',
			border: false,
			baseCls:'x-plain',
			unstyled: true,
			layout:{
				type:'ux.center',
				maxWidth:maxWidth
			},
			items:[me.view]
		});
	}
});
Ext.define('com.trackplus.master.AppBoxView',{
	extend:'Ext.panel.Panel',
	layout:'border',
	border:false,
	bodyBorder:false,
	cls:'appBox',
	overCls:'appBoxOver',
	config:{
		appID:null,
		appUrl:null,
		appTitle:null,
		appIcon:null
	},
	initComponent: function(){
		var me=this;
		me.items=me.createChildren();
		me.addListener('afterrender',function(cmp){
			cmp.getEl().addListener('click',me.clickHandler,me);
		});
		me.callParent();
	},
	clickHandler:function(){
		var me=this;		
		window.location.href=me.appUrl;
	},
	createChildren:function(){
		var me=this;
		var items=new Array();
		var centerPanel=Ext.create('Ext.panel.Panel',{
			region:'center',
			border:false,
			bodyBorder:false,
			layout:'fit',
			id:'XXX',
			cls:'appBoxImage',
			items:[{xtype:'component',cls:me.appIcon}]
		});
		items.push(centerPanel);
		items.push({
			xtype:'component',
			cls:'appBoxTitle',
			html:me.appTitle,
			iconCls:me.appIcon,
			region:'south'
		});
		return items;
	}
});

/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions
 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* $Id:$ */
Ext.define('com.trackplus.layout.ExternalActionLayout',{
	extend:'com.trackplus.layout.BaseLayout',
	useToolbar:false,
	//selectedGroup:'wiki',
	constructor : function(config) {
		var me = this;
		me.callParent(arguments);
		me.onReady(function() {
		});
	},
	createCenterPanel: function(){
		var me=this;
		var module = me.initData.module;
		return me.getPanel(module.url);
	},
	createJenkinsSessionCookie: function(sessionID) {
	},
	getPanel: function(url) {
		return  Ext.create('Ext.panel.Panel',{
			region: 'center',
			border: false,
			baseCls:'x-plain',
			layout:'fit',
			items:[{
				xtype: 'box',
				autoEl: {
					tag: 'iframe',
					style:'width: 100%;height: 100%;border: medium none;',
					src: url
				}
			}]
		});
	}
});

