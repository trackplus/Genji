/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. parser\TqlParser.jj */
/*@egen*//*
 * $Id: TqlParser.jj 3495 2012-03-15 17:23:21Z tamas $
 */

options
{                
	STATIC = false;
	IGNORE_CASE = true;
}



PARSER_BEGIN(TqlParser)

package com.aurel.track.tql.parser;

/**
 * This class implements the TqlParser. It is used for transforming
 * a TQL statement into an equivalent abstract syntax tree.
 *
 * @author Clemens Fuchslocher &lt;clfuit00@fht-esslingen.de&gt;
 */
public class TqlParser/*@bgen(jjtree)*/implements TqlParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTTqlParserState jjtree = new JJTTqlParserState();

/*@egen*/
	public final static int ROOT = JJTROOT;
	public final static int OR_EXPRESSION = JJTOREXPRESSION;
	public final static int AND_EXPRESSION = JJTANDEXPRESSION;
	public final static int RELATIONAL_EXPRESSION = JJTRELATIONALEXPRESSION;
	public final static int LITERAL_EXPRESSION = JJTLITERALEXPRESSION;

	public final static int ORDER_BY_EXPRESSION = JJTORDERBY;
	public final static int ORDER_BY_DESCENDING = 1000;
	public final static int ORDER_BY_ASCENDING = 2000;
}

PARSER_END(TqlParser)



SKIP :
{
	" "
	| "\t"
	| "\n"
	| "\r"
}



// Boolean operators
TOKEN :
{
	< AND : "AND" >
	| < OR : "OR" >
}



// Relational operators
TOKEN :
{
	< EQUAL : "==" >
	| < NOT_EQUAL : "!=" >
	| < GREATER_EQUAL : ">=" >
	| < GREATER_THAN : ">" >
	| < LESS_EQUAL : "<=" >
	| < LESS_THAN : "<" >
	| < LIKE : "LIKE" >
	| < NOT_LIKE : "NOT_LIKE" >
	| < OLDER_THAN : "OLDER_THAN" >
	| < NEWER_THAN : "NEWER_THAN" >
}



// Date related tokens
TOKEN :
{
	< HOURS : "HOUR" ("S")?  >
	| < DAYS : "DAY" ("S")? >
	| < WEEKS : "WEEK" ("S")? >
	| < MONTHS : "MONTH" ("S")? >
	| < YEARS : "YEAR" ("S")? >
	| < START_DATE_LITERAL : "DATE" ([" "])* "(" > : IN_DATE_LITERAL
}



< IN_DATE_LITERAL > TOKEN:
{
	< DATE_LITERAL : (~[")"])+ >
	| < END_DATE_LITERAL : ")" > : DEFAULT
}



// ORDER_BY related tokens
TOKEN :
{
	< ORDER_BY : "ORDER_BY" >
	| < DESC : "DESC" >
	| < ASC : "ASC" >
	| < SEMICOLON : ";" >
    | < COMMA : "," > 
}



// Literals
TOKEN :
{
	< START_QUOTED_STRING_LITERAL : "\"" > : IN_QUOTED_STRING_LITERAL
	| < LITERAL : <CHARS> >
	| < #LETTER : ["a"-"z","A"-"Z","\u00e4","\u00c4","\u00f6","\u00d6","\u00fc","\u00dc","\u00df"] >
	| < #DIGITS : ["0"-"9"] >
	| < #MISC : ["_","-"] >
	| < #CHARS : (<LETTER>|<DIGITS>) (<LETTER>|<DIGITS>|<MISC>)* >
}



< IN_QUOTED_STRING_LITERAL > TOKEN :
{
	< QUOTED_STRING_LITERAL : (~["\""])+ >
	| < END_QUOTED_STRING_LITERAL : "\"" > : DEFAULT
}



// Non terminals
SimpleNode start ()       :
{/*@bgen(jjtree) Root */
  ASTRoot jjtn000 = new ASTRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Root */
        try {
/*@egen*/
	(OrderBy ())? OrExpression ()/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/ {
		jjtn000.setType (ROOT);
		jjtn000.setValue ("ROOT");
		return jjtn000;
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}



void OrExpression ()                   :
{/*@bgen(jjtree) #OrExpression(> 1) */
  ASTOrExpression jjtn000 = new ASTOrExpression(JJTOREXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) #OrExpression(> 1) */
        try {
/*@egen*/
	AndExpression () (<OR> {
		jjtn000.setType (OR_EXPRESSION);
		jjtn000.setOperator (OR_EXPRESSION);
		jjtn000.setValue ("OR");
	} AndExpression ())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}



void AndExpression ()                    :
{/*@bgen(jjtree) #AndExpression(> 1) */
  ASTAndExpression jjtn000 = new ASTAndExpression(JJTANDEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) #AndExpression(> 1) */
        try {
/*@egen*/
	RelationalExpression () (<AND> {
		jjtn000.setType (AND_EXPRESSION);
		jjtn000.setOperator (AND_EXPRESSION);
		jjtn000.setValue ("AND");
	} RelationalExpression ())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}



void RelationalExpression ()                           :
{/*@bgen(jjtree) #RelationalExpression(> 1) */
  ASTRelationalExpression jjtn000 = new ASTRelationalExpression(JJTRELATIONALEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) #RelationalExpression(> 1) */
        try {
/*@egen*/
	LiteralExpression () (
		<EQUAL> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (EQUAL);
			jjtn000.setValue ("==");
		}
		| <NOT_EQUAL> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (NOT_EQUAL);
			jjtn000.setValue ("!=");
		}
		| <GREATER_EQUAL> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (GREATER_EQUAL);
			jjtn000.setValue (">=");
		}
		| <GREATER_THAN> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (GREATER_THAN);
			jjtn000.setValue (">");
		}
		| <LESS_EQUAL> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (LESS_EQUAL);
			jjtn000.setValue ("<=");
		}
		| <LESS_THAN> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (LESS_THAN);
			jjtn000.setValue ("<");
		}
		| <LIKE> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (LIKE);
			jjtn000.setValue ("LIKE");
		}
		| <NOT_LIKE> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (NOT_LIKE);
			jjtn000.setValue ("NOT_LIKE");
		}
		| (<OLDER_THAN> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (OLDER_THAN);
			jjtn000.setValue ("OLDER_THAN");
		}
		| <NEWER_THAN> {
			jjtn000.setType (RELATIONAL_EXPRESSION);
			jjtn000.setOperator (NEWER_THAN);
			jjtn000.setValue ("NEWER_THAN");
		})) LiteralExpression () (
			<HOURS> {
				jjtn000.setTimeUnit (HOURS);
			}
			| <DAYS> {
				jjtn000.setTimeUnit (DAYS);
			}
			| <WEEKS> {
				jjtn000.setTimeUnit (WEEKS);
			}
			| <MONTHS> {
				jjtn000.setTimeUnit (MONTHS);
			}
			| <YEARS> {
				jjtn000.setTimeUnit (YEARS);
			}
		)?
	| "(" OrExpression () ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, jjtree.nodeArity() > 1);
          }
        }
/*@egen*/
}



void LiteralExpression () :
{/*@bgen(jjtree) LiteralExpression */
        ASTLiteralExpression jjtn000 = new ASTLiteralExpression(JJTLITERALEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token token = null;
}
{/*@bgen(jjtree) LiteralExpression */
        try {
/*@egen*/
	token = <LITERAL>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {
		jjtn000.setType (LITERAL_EXPRESSION);
		jjtn000.setValue (token.image);
	}
	| <START_QUOTED_STRING_LITERAL> (token = <QUOTED_STRING_LITERAL>)? <END_QUOTED_STRING_LITERAL>/*@bgen(jjtree)*/
                                                                                                       {
                                                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                                                         jjtc000 = false;
                                                                                                       }
/*@egen*/ {
		jjtn000.setType (LITERAL_EXPRESSION);
		jjtn000.setValue (token == null ? "" : token.image);
	}
	| <START_DATE_LITERAL> (token = <DATE_LITERAL>)? <END_DATE_LITERAL>/*@bgen(jjtree)*/
                                                                            {
                                                                              jjtree.closeNodeScope(jjtn000, true);
                                                                              jjtc000 = false;
                                                                            }
/*@egen*/ {
		jjtn000.setType (DATE_LITERAL);
		jjtn000.setValue (token == null ? "" : token.image);
	}/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}


void SortExpression () : 
{/*@bgen(jjtree) SortExpression */
        ASTSortExpression jjtn000 = new ASTSortExpression(JJTSORTEXPRESSION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token token = null;
}
{/*@bgen(jjtree) SortExpression */
  try {
/*@egen*/
  token = <LITERAL> {
		jjtn000.setType (ORDER_BY_EXPRESSION);
		jjtn000.setValue (token.image);
		jjtn000.setOperator (ORDER_BY_ASCENDING);
	} (
		<DESC> {
			jjtn000.setOperator (ORDER_BY_DESCENDING);
		}
		| <ASC> {
			jjtn000.setOperator (ORDER_BY_ASCENDING);
		}
	)?/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void OrderBy ()          :
{/*@bgen(jjtree) OrderBy */
        ASTOrderBy jjtn000 = new ASTOrderBy(JJTORDERBY);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token token = null;
}
{/*@bgen(jjtree) OrderBy */
        try {
/*@egen*/
	<ORDER_BY> SortExpression() {
    } (<COMMA> SortExpression())? <SEMICOLON>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

/*
void OrderBy () #OrderBy :
{
	Token token = null;
}
{
	<ORDER_BY> token = <LITERAL> {
		jjtThis.setType (ORDER_BY_EXPRESSION);
		jjtThis.setValue (token.image);
		jjtThis.setOperator (ORDER_BY_ASCENDING);
	} (
		<DESC> {
			jjtThis.setOperator (ORDER_BY_DESCENDING);
		}
		| <ASC> {
			jjtThis.setOperator (ORDER_BY_ASCENDING);
		}
	)? <SEMICOLON>
}
*/
