/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions

 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* $Id:$ */

package com.aurel.track.persist;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.torque.TorqueException;
import org.apache.torque.util.Criteria;

import com.aurel.track.beans.TGroupMemberBean;
import com.aurel.track.dao.GroupMemberDAO;
import com.aurel.track.util.GeneralUtils;
import com.workingdogs.village.DataSetException;
import com.workingdogs.village.Record;

/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Thu Jan 12 11:29:01 CET 2006]
 *
 *  You should add additional methods to this class to meet the
 *  application requirements.  This class will only be generated as
 *  long as it does not already exist in the output directory.
 */
public class TGroupMemberPeer
	extends com.aurel.track.persist.BaseTGroupMemberPeer
	implements GroupMemberDAO
{

	private static final long serialVersionUID = 8677428656433769535L;
	
	private static final Logger LOGGER = LogManager.getLogger(TGroupMemberPeer.class); 
	
	/**
	 * Load all assignments
	 * @return
	 */
	public List<TGroupMemberBean> loadAll() {
		Criteria crit = new Criteria();
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch(Exception e) {
			LOGGER.warn("Loading all group - person associations failed with " + e.getMessage(), e);
			return null;
		}
	}
	
	/**
	 * Loads the number of persons in groups 
	 * @return
	 */
	public Map<Integer, Integer> loadNumberOfPersonsInAllGroups() {
		Map<Integer, Integer> numberOfPersonsInGroups = new HashMap<Integer, Integer>();
		Criteria crit = new Criteria();
		String countPersons = "COUNT(" + PERSON + ")";
		crit.addSelectColumn(countPersons);
		crit.addSelectColumn(THEGROUP);
		crit.addGroupByColumn(THEGROUP);
		List<Record> records = new LinkedList<Record>();
		try {
			records = doSelectVillageRecords(crit);
		} catch(Exception e) {
			LOGGER.error("Groupping the persons by groups failed with " + e.getMessage(), e);
		}
		try {
			if (records!=null && !records.isEmpty()) {
				for (Record record : records) {
					Integer numberOfPersons = record.getValue(1).asIntegerObj();
					Integer groupID = record.getValue(2).asIntegerObj();
					numberOfPersonsInGroups.put(groupID, numberOfPersons); 
				}
			}
		} catch (Exception e) {
			LOGGER.error("Getting the number of persons by groups failed with " + e.getMessage(), e);
		}
		return numberOfPersonsInGroups;
	}
	
	/**
	 * Loads the number of persons in groups
	 * @param groupID 
	 * @return
	 */
	public Integer loadNumberOfPersonsInGroup(Integer groupID) {
		Criteria crit = new Criteria();
		crit.add(THEGROUP, groupID);
		String countPersons = "COUNT(" + PERSON + ")";
		crit.addSelectColumn(countPersons);
		try {
			return ((Record) doSelectVillageRecords(crit).get(0)).getValue(1).asIntegerObj();
		} catch (TorqueException e) {
			LOGGER.error("Counting the persons in group " + groupID + " failed with TorqueException " + e.getMessage(), e);
		} catch (DataSetException e) {
			LOGGER.error("Counting the persons in group " + groupID + " failed with TorqueException " + e.getMessage(), e);
		}
		return Integer.valueOf(0);
	}
	
	/**
	 * Loads the GroupMemberBeans for a person 
	 * @param personID
	 * @return
	 */
	public List<TGroupMemberBean> loadGroupsForPerson(Integer personID) {
		Criteria crit = new Criteria();
		crit.add(PERSON, personID);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch(Exception e) {
			LOGGER.error("Loading the groups by person " + personID + " failed with " + e);
			return null;
		}
	}

	/**
	 * Loads the GroupMemberBeans for a group 
	 * @param personID
	 * @return
	 */
	public List<TGroupMemberBean> loadPersonsForGroups(List<Integer> groupIDs) {
		if (groupIDs==null || groupIDs.isEmpty()) {
			return new LinkedList<TGroupMemberBean>();
		}
		Criteria crit = new Criteria();
		crit.addIn(THEGROUP, groupIDs);
		crit.setDistinct();
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch(Exception e) {
			LOGGER.error("Loading the persons by group " + groupIDs + " failed with " + e);
			return null;
		}
	}


	/*public static List loadPersonsForGroups(int[] groupKeys)  {
		List list = new ArrayList();
		
		Criteria crit = new Criteria();
		
		if (groupKeys!=null && groupKeys.length!=0)
		{
			crit.addIn(THEGROUP, groupKeys);			
			crit.addSelectColumn(PERSON);
			crit.setDistinct();			
			try
		   	{
				list = doSelectVillageRecords(crit);			
			}
			catch(Exception e)
			{
				LOGGER.error("Loading the persons by groups failed with " + e);			
			}
		}
		return list;	
	}*/
	
	
	
	/*public static List loadAll()  {
		List list = new ArrayList();
		
		Criteria crit = new Criteria();						
		try
	   	{
			list = doSelect(crit);			
		}
		catch(Exception e)
		{
			LOGGER.error("Loading all group members failed with " + e);			
		}

		return list;	
	}*/
	
	/*public void insertByGroupAndPerson(Integer group, Integer person) {
		Criteria crit = new Criteria();
		crit.add(THEGROUP, group);
		crit.add(PERSON, person);
		try {
			
			List personToGroup = doSelect(crit);
			if (personToGroup == null || personToGroup.isEmpty())
			{
				TGroupMemberBean groupMemberBean = new TGroupMemberBean();
				groupMemberBean.setTheGroup(group);
				groupMemberBean.setPerson(person);				
				save(groupMemberBean);
				//doInsert(crit);
			}
		}
		catch (Exception e) {
			log.error("Inserting a TGROUPMEMBER entry by keys " + group + ", " + person + " failed with " + e);
		}
	}*/

	/**
	 * Saves a groupMemberBean in the TGroupMember table
	 * @param fieldBean
	 * @return
	 */
	public Integer save(TGroupMemberBean groupMemberBean) {
		TGroupMember tGroupMember;
		try {
			tGroupMember = BaseTGroupMember.createTGroupMember(groupMemberBean);
			tGroupMember.save();
			return tGroupMember.getObjectId();
		} catch (Exception e) {
			LOGGER.error("Saving of a groupMemberBean failed with " + e.getMessage(), e);
			return null;
		}		
	}
	
	public void delete(Integer group, Integer person) {
		Criteria crit = new Criteria();
		crit.add(THEGROUP, group);
		crit.add(PERSON, person);
		try {			
			doDelete(crit);
		} catch (Exception e) {
			log.error("Deleting a TGROUPMEMBER entry by keys " + group + " " + person + " failed with " + e);
		}
	}

	/*public static void deleteByGroupAndPersons(Integer group, int[] persons)
	{
		if (persons==null || persons.length==0)
		{
			return;
		}
		Criteria crit = new Criteria();
		crit.add(THEGROUP, group);
		crit.addIn(PERSON, persons);
		try {			
				doDelete(crit);
		}
		catch (Exception e) {
			log.error("Deleting a TGROUPMEMBER entries for group keys " + group + " failed with " + e);
		}
	}*/
	  
	/*private static void addExcludeCurrent(Criteria criteria, boolean excludeInactive, Integer currentOption) {		
		if (excludeInactive && currentOption!=null) {
			Criterion criterionInactive = criteria.getNewCriterion(TPersonPeer.DELETED, (Object)BooleanFields.TRUE_VALUE, Criteria.NOT_EQUAL);			
			Criterion criterionCurrentOption = criteria.getNewCriterion(TPersonPeer.PKEY, currentOption, Criteria.EQUAL);
			criteria.add(criterionInactive.or(criterionCurrentOption));
		} else {
			if (excludeInactive) {
				criteria.add(TPersonPeer.DELETED, (Object)BooleanFields.TRUE_VALUE, Criteria.NOT_EQUAL);
			} 
		}
	}*/
	
	/**
	 * Returns the real groups which are directly present in the object array
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeInactive
	 * @return
	 */
	/*public static List getDirectGroups(Object[] personKeys, boolean excludeInactive)  {
		List list = new ArrayList();		
		if (personKeys==null || personKeys.length==0) {
			return list;
		}		
		Criteria crit = new Criteria();				
		crit.addIn(BaseTPersonPeer.PKEY, personKeys);
		//get only the groups
		crit.add(BaseTPersonPeer.ISGROUP, BooleanFields.TRUE_VALUE);		
		crit.addAscendingOrderByColumn(BaseTPersonPeer.LOGINNAME);
		if (excludeInactive) {
			crit.add(BaseTPersonPeer.DELETED, (Object)BooleanFields.TRUE_VALUE, Criteria.NOT_EQUAL);
		}
		//crit.setDistinct();			
		try {
			list = BaseTPersonPeer.doSelect(crit);			
		} catch(Exception e) {
			LOGGER.error("Loading the direct groups failed with " + e);			
		}		
		return list;	
	}*/
	
	/**
	 * Returns the real persons which are directly present in the object array
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeInactive
	 * @return
	 */
	/*public static List getDirectPersons(Object[] personKeys, boolean excludeInactive, Integer currentOption)  {
		List list = new ArrayList();		
		if (personKeys==null || personKeys.length==0) {
			return list;
		}
		
		Criteria crit = new Criteria();				
		crit.addIn(BaseTPersonPeer.PKEY, personKeys);
		//get only the persons
		crit.add(BaseTPersonPeer.ISGROUP, (Object)BooleanFields.TRUE_VALUE, Criteria.NOT_EQUAL);		
		crit.addAscendingOrderByColumn(BaseTPersonPeer.LASTNAME);
		crit.addAscendingOrderByColumn(BaseTPersonPeer.FIRSTNAME);
		
		addExcludeCurrent(crit, excludeInactive, currentOption);
		
		
		try {
			list = BaseTPersonPeer.doSelect(crit);
		}
		catch(Exception e) {
			LOGGER.error("Loading the direct persons failed with " + e);			
		}		
		return list;	
	}*/
	
	
	
	/**
	 * Returns the real persons which are indirectly (through group) present in the object array
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param includeInactive
	 * @return
	 */
	/*public static List getIndirectPersons(Object[] personKeys, 
			boolean excludeInactive, Integer currentOption)  {
		List list = new ArrayList();
		if (personKeys==null || personKeys.length==0) {
			return list;
		}		
		Criteria crit = new Criteria();
		crit.addJoin(BaseTGroupMemberPeer.PERSON, BaseTPersonPeer.PKEY);
		//get only the persons through group
		crit.addIn(BaseTGroupMemberPeer.THEGROUP, personKeys);
		if (excludeInactive) {
			crit.add(BaseTPersonPeer.DELETED, (Object)BooleanFields.TRUE_VALUE, Criteria.NOT_EQUAL);
		}
		crit.setDistinct();
		addExcludeCurrent(crit, excludeInactive, currentOption);
		try {
			list = BaseTPersonPeer.doSelect(crit);
		}
		catch(Exception e) {
			LOGGER.error("Loading the indirect persons failed with " + e);
		}
		return list;
	}*/
		
	/**
	 * Returns the real persons which are directly or indirectly (through group) present in the object array
	 * The object array may contain both personID-s and groupID-s 
	 * @param personKeys
	 * @param excludeDirectInactive
	 * @param excludeIndirectInactive
	 * @return
	 */
	/*public static List getDirectAndIndirectPersons(Object[] personKeys, 
			boolean excludeDirectInactive, boolean excludeIndirectInactive, Integer currentOption) {
		TPerson person;
		List personsDirect = getDirectPersons(personKeys, excludeDirectInactive, currentOption);
		List personsIndirect = getIndirectPersons(personKeys, excludeIndirectInactive, currentOption);
		Set personsSet = new HashSet();
		if (personsDirect!=null) {
			Iterator itrPersonsDirect = personsDirect.iterator();
			while(itrPersonsDirect.hasNext())
			{
				person = (TPerson)itrPersonsDirect.next();
				personsSet.add(person.getObjectID());
			}			
		}
		if (personsIndirect!=null) {
			Iterator itrPersonsIndirect = personsIndirect.iterator();
			while(itrPersonsIndirect.hasNext()) {
				person = (TPerson)itrPersonsIndirect.next();
				personsSet.add(person.getObjectID());				
			}			
		}		
		return TPersonPeer.loadByKeys(personsSet.toArray());
		
	}*/
	
	/**
	 * Returns the real persons which are directly or indirectly (through group) present in 
	 * the object array and the real groups which are directly present in the object array 
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeDirectInactive
	 * @param excludeIndirectInactive
	 * @return
	 */
	/*public static List getDirectAndIndirectPersonsAndGroups(Object[] personKeys,
			boolean excludeDirectInactive, boolean excludeIndirectInactive, Integer currentOption) {
		TPerson person;
		List personsDirect = getDirectPersons(personKeys, excludeDirectInactive, currentOption);
		List personsIndirect = getIndirectPersons(personKeys, excludeIndirectInactive, currentOption);
		List groups = getDirectGroups(personKeys, excludeDirectInactive);
		Set personsSet = new HashSet();
		if (personsDirect!=null)
		{
			Iterator itrPersonsDirect = personsDirect.iterator();
			while(itrPersonsDirect.hasNext())
			{
				person = (TPerson)itrPersonsDirect.next();
				personsSet.add(person.getObjectID());
			}			
		}
		if (personsIndirect!=null)
		{
			Iterator itrPersonsIndirect = personsIndirect.iterator();
			while(itrPersonsIndirect.hasNext())
			{
				person = (TPerson)itrPersonsIndirect.next();
				personsSet.add(person.getObjectID());				
			}			
		} 
		if (groups!=null)
		{
			Iterator itrGroups = groups.iterator();
			while(itrGroups.hasNext())
			{
				person = (TPerson)itrGroups.next();
				personsSet.add(person.getObjectID());				
			}			
		}  
		return TPersonPeer.loadByKeys(personsSet.toArray());		
	}*/
	
	/************************************************************************
	 *************************Bean methods***********************************
	 ************************************************************************/
	
	/**
	 * Returns the real groups which are directly present in the object array
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeInactive
	 * @return
	 */
	/*public List getDirectGroups1(Object[] personKeys, boolean excludeInactive) {
		return TPersonPeer.convertTorqueListToBeanList(getDirectGroups(personKeys, excludeInactive));
	}*/
	
	/**
	 * Returns the real persons which are directly present in the object array
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeInactive
	 * @return
	 */
	/*public List getDirectPersons1(Object[] personKeys, boolean excludeInactive) {
		return TPersonPeer.convertTorqueListToBeanList(getDirectPersons(personKeys, excludeInactive));
	}*/
	
	/**
	 * Returns the real persons which are directly or indirectly (through group) present in the object array
	 * The object array may contain both personID-s and groupID-s 
	 * @param personKeys
	 * @param excludeDirectInactive
	 * @param excludeIndirectInactive
	 * @return
	 */
	/*public List getDirectAndIndirectPersons1(Object[] personKeys, boolean excludeDirectInactive, boolean excludeIndirectInactive) {
		return TPersonPeer.convertTorqueListToBeanList(getDirectAndIndirectPersons(personKeys, excludeDirectInactive, excludeIndirectInactive, null));
	}*/
	
	/**
	 * Returns the real persons which are directly or indirectly (through group) present in 
	 * the object array and the real groups which are directly present in the object array 
	 * The object array may contain both personID-s and groupID-s
	 * @param personKeys
	 * @param excludeDirectInactive
	 * @param excludeIndirectInactive
	 * @return
	 */
	/*public List getDirectAndIndirectPersonsAndGroups1(Object[] personKeys, boolean excludeDirectInactive, boolean excludeIndirectInactive) {
		return TPersonPeer.convertTorqueListToBeanList(getDirectAndIndirectPersonsAndGroups(personKeys, excludeDirectInactive, excludeIndirectInactive, null));
	}*/
	
	/**
	 * Returns the TGroupMemberBeans for a the groupID array 
	 * @param groupKeys
	 * @return
	 */
	/*public List loadByGroups(Object[] groupKeys)  {
		List list = new ArrayList();		
		if (groupKeys==null || groupKeys.length==0) {
			return list;
		}		
		Criteria crit = new Criteria();		
		//get only the persons through group
		crit.addIn(BaseTGroupMemberPeer.THEGROUP, groupKeys);		
		//crit.addSelectColumn(TGroupMemberPeer.PERSON);
		crit.setDistinct();			
		try {
			list = doSelect(crit);			
		}
		catch(Exception e) {
			LOGGER.error("Loading the TGroupMemberBeans by groups failed with " + e);			
		}		
		return convertTorqueListToBeanList(list);	
	}*/
	
	/**
	 * Whether a person is member in a group
	 * @param person
	 * @param group
	 * @return
	 */
	public boolean isPersonMemberInGroup(Integer person, Integer group) {
		List list = null;
		Criteria crit = new Criteria();
		crit.add(PERSON, person);
		crit.add(THEGROUP, group);
		try {
			list = doSelect(crit);
		} catch (TorqueException e) {
			LOGGER.error("Verifying the group membership of the person " + person + 
					" in the group " + group + " failed with " + e.getMessage(), e);
		}
		return list!=null && !list.isEmpty();
	}
	
	/**
	 * Whether any person from list person is member in the group 
	 * @param personIDs
	 * @param groupID
	 * @return
	 */
	public boolean isAnyPersonMemberInGroup(List<Integer> personIDs, Integer groupID) {
		if (personIDs!=null && !personIDs.isEmpty() && groupID!=null) {
			List list = null;
			Criteria crit = new Criteria();
			crit.addIn(PERSON, personIDs);
			crit.add(THEGROUP, groupID);
			try {
				list = doSelect(crit);
			} catch (TorqueException e) {
				LOGGER.error("Verifying the group membership of  " + personIDs.size() + 
						" persons in the group " + groupID + " failed with " + e.getMessage(), e);
			}
			return list!=null && !list.isEmpty();
		} else {
			return false;
		}
	}
	
	/**
	* Whether a person is member in any group from list
	* @param personID
	* @param groupIDs
	* @return
	*/
	public boolean isPersonMemberInAnyGroup(Integer personID, List<Integer> groupIDs) {
		List list = null;
		if (personID!=null && groupIDs!=null && !groupIDs.isEmpty()) {
			Criteria crit = new Criteria();
			crit.add(PERSON, personID);
			crit.addIn(THEGROUP, groupIDs);
			try {
				list = doSelect(crit);
			} catch (TorqueException e) {
				LOGGER.error("Verifying the group membership of the person " + personID + 
						" in groups " + groupIDs.size() + " failed with " + e.getMessage(), e);
			}
		}
		return list!=null && !list.isEmpty();
	}

	/**
	* Whether any person from list is member in any group from list
	* @param personIDs
	* @param groupIDs
	* @return
	*/
	public boolean isAnyPersonMemberInAnyGroup(List<Integer> personIDs, List<Integer> groupIDs) {
		List list = null;
		if (personIDs!=null && !personIDs.isEmpty() && groupIDs!=null && !groupIDs.isEmpty()) {
			Criteria crit = new Criteria();
			crit.addIn(PERSON, personIDs);
			crit.addIn(THEGROUP, groupIDs);
			try {
				list = doSelect(crit);
			} catch (TorqueException e) {
				LOGGER.error("Verifying the group membership of the persons " + personIDs.size() + 
						" in groups " + groupIDs.size() + " failed with " + e.getMessage(), e);
			}
		}
		return list!=null && !list.isEmpty();
	}
	
	/**
	 * Get the list of group IDs the person is member of  
	 * @param personID
	 * @return
	 */
	public List<Integer> getGroupsIDsForPerson(Integer personID) {
		List<Integer> groupIDList = new LinkedList<Integer>();
		List<TGroupMember> groupMemberList = null;
		Criteria crit = new Criteria();
		crit.add(PERSON, personID);
		try {
			groupMemberList = doSelect(crit);
		} catch(Exception e) {
			LOGGER.error("Loading the groups by person " + personID + " failed with " + e);
		}
		if (groupMemberList!=null) {
			for (TGroupMember groupMember : groupMemberList) {
				groupIDList.add(groupMember.getTheGroup());	
			}
		}
		return groupIDList;
	}
	
	/**
	 * Get the list of group IDs the person is member of  
	 * @param personID
	 * @return
	 */
	public Set<Integer> getGroupsIDsForPersons(Integer[] personIDs) {
		Set<Integer> groupIDList = new HashSet<Integer>();
		if (personIDs!=null && personIDs.length>0) {
			List<int[]> personChunks = GeneralUtils.getListOfChunks(personIDs);
			Criteria crit = null;
			if (personChunks!=null) {
				for (int[] personChunk : personChunks) {
					crit = new Criteria();
					crit.addIn(PERSON, personChunk);
					try {
						List<TGroupMember> groupMemberList = doSelect(crit);
						if (groupMemberList!=null) {
							for (TGroupMember groupMember : groupMemberList) {
								groupIDList.add(groupMember.getTheGroup());
							}
						}
					} catch(Exception e) {
						LOGGER.error("Loading the groups by persons " + personChunk.length + " failed with " + e);
					}
				}
			}
		}
		return groupIDList;
	}
	

	public static List<TGroupMemberBean> convertTorqueListToBeanList(List<TGroupMember> torqueList) {
		List<TGroupMemberBean> beanList = new LinkedList<TGroupMemberBean>();
		if (torqueList!=null){
			for (TGroupMember tGroupMember : torqueList) {
				beanList.add(tGroupMember.getBean());
			}
		}
		return beanList;
	}

}
