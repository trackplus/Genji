/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions

 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* $Id:$ */

package com.aurel.track.persist;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.torque.TorqueException;
import org.apache.torque.util.Criteria;

import com.aurel.track.beans.TPlistTypeBean;
import com.aurel.track.dao.PIssueTypeDAO;


/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Tue Jun 15 21:31:34 CEST 2004]
 *
 *  You should add additional methods to this class to meet the
 *  application requirements.  This class will only be generated as
 *  long as it does not already exist in the output directory.
 */
public class TPlistTypePeer
    extends com.aurel.track.persist.BaseTPlistTypePeer
    implements PIssueTypeDAO
{

    private static final long serialVersionUID = 8196867443969665148L;
    private static final Logger LOGGER = LogManager.getLogger(TPlistTypePeer.class);
    /**
     * @return list with all list types in the system
     */
    /*public static List getColumnObjects(Locale locale) {
        List list = null;
        try {
            list = TListTypePeer.load(); // exclude zero
        }
        catch (Exception e) {
           LOGGER.debug(org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace(e)); 
        }
        return list;
    }*/

    /**
     * @return list of all project types in the system
     */
    /*public static List getRowObjects(Locale locale) {
        List list = null;
        try {
            list = TProjectTypePeer.load();  // including zero (Generic Project)
        }
        catch (Exception e) {
           LOGGER.debug(org.apache.commons.lang3.exception.ExceptionUtils.getStackTrace(e)); 
        }
        return list;
    }*/
    
    /**
     * @param theRelatedObjectKey object identifier for TProjectType.
     * Example: for a specific project type, this function returns
     * all entries in this n:m relationship table that connect
     * state option values with list types.
     * @return all entries into the n:m relationship table with this related
     * object associated. Example: returns TPState objects for this related
     * object based on the select project type key.
     */
    /*public static List loadByRelatedObject(Object projectTypeKey) {
        // theRelatedObject must be a TProjectType object
        // it is ignored here, however
        Criteria crit = new Criteria();
        try {
            return BaseTPlistTypePeer.doSelect(crit);
        }
        catch (Exception e) {
            log.error("Exception when loading by related object: " 
                          + e.getMessage(), e);
            return null;
        }
    }*/
    

    /**
     * clears the list of relationships for this object. This can be used
     * before a new list is written to the database.
     */
    /*public static void clearByRelatedObject(Integer projectTypeKey) {
        Criteria crit = new Criteria();
        crit.add(BaseTPlistTypePeer.PROJECTTYPE, 
                 new Integer(-1), Criteria.GREATER_THAN);
        try {
            BaseTPlistTypePeer.doDelete(crit);
        }
        catch (Exception e) {
            log.error("Exception when deleting by related object: " 
                          + e.getMessage(), e);
        } 
    }*/
    
    /**
     * @param obj the object that is related between row and column. 
     * For example this can be a TState or TPriority.
     * @param rowObjectId the object id of the row object. For example
     * this can be the project type.
     * @param columnObjectId the object id of the column object. For example
     * this can be the list type.
     */
    /*public static void addRelatedObject(Integer projectTypeKey, 
                                 Integer projectTypeValueId, 
                                 Integer listTypeId) {
        // first check if it is not already there
        Criteria crit = new Criteria();
        crit.add(BaseTPlistTypePeer.PROJECTTYPE, 
                projectTypeValueId, 
                Criteria.EQUAL);
        crit.add(BaseTPlistTypePeer.CATEGORY, 
                listTypeId, 
                Criteria.EQUAL); 
        try {
            List empty = BaseTPlistTypePeer.doSelect(crit);
            if (empty == null || empty.isEmpty()) {
                TPlistType tps = new TPlistType();
                tps.setCategory(listTypeId);
                tps.setProjectType(projectTypeValueId);
                tps.save();
            }
        }
        catch (Exception e) {
            log.error("Exception when creating new entry by related object: " 
                          + e.getMessage(), e);
        }        
         
    }*/
    
    
    
    /**
	 * Loads all TPlistTypeBean 
	 * @return
	 */
	public List<TPlistTypeBean> loadAll() {		
        Criteria crit = new Criteria();            		
        try {
        	return convertTorqueListToBeanList(doSelect(crit));
		} catch (TorqueException e) {
			LOGGER.error("Loading all pissuetypes failed with " + e.getMessage(), e);
			  return new LinkedList<TPlistTypeBean>();
		}		
	}
    
	/**
	 * Load the TPlistTypeBean for a projectTypeID
	 * @param projectTypeID
	 * @return
	 */
	public List<TPlistTypeBean> loadByProjectType(Integer projectTypeID) {				
        Criteria crit = new Criteria();
        crit.add(PROJECTTYPE, projectTypeID);                
    	try {
    		return convertTorqueListToBeanList(doSelect(crit));
        } catch (Exception e) {
            LOGGER.error("Loading issueTypes associated with projectType " + projectTypeID + " failed with " + e.getMessage(), e);
            return new LinkedList<TPlistTypeBean>();
        }
	}
	
	/**
	 * Load the TPlistTypeBean for a itemTypeID
	 * @param itemTypeID
	 * @return
	 */
	public List<TPlistTypeBean> loadByItemType(Integer itemTypeID) {
		Criteria crit = new Criteria();
        crit.add(CATEGORY, itemTypeID);                
    	try {
    		return convertTorqueListToBeanList(doSelect(crit));
        } catch (Exception e) {
            LOGGER.error("Loading issueTypes associated with itemType " + itemTypeID + " failed with " + e.getMessage(), e);
            return new LinkedList<TPlistTypeBean>();
        }
	}
	
	/**
	 * Load the TPlistTypeBean for a itemTypeFlags
	 * @param itemTypeFlags
	 * @return
	 */
	public List<TPlistTypeBean> loadByItemTypeFlags(int[] itemTypeFlags) {
		if (itemTypeFlags!=null && itemTypeFlags.length>0) {
			Criteria crit = new Criteria();
			crit.addJoin(CATEGORY, TListTypePeer.PKEY);
	        crit.addIn(TListTypePeer.TYPEFLAG, itemTypeFlags);                
	    	try {
	    		return convertTorqueListToBeanList(doSelect(crit));
	        } catch (Exception e) {
	            LOGGER.error("Loading issueTypes associated with itemTypeFlags " + itemTypeFlags + " failed with " + e.getMessage(), e);
	        }
		}
    	return new LinkedList<TPlistTypeBean>();
	}
	
    /**
	 * Load the TPlistTypeBean for projectTypeIDs
	 * @param projectTypeIDs
	 * @return
	 */
	public List<TPlistTypeBean> loadByProjectTypes(Object[] projectTypeIDs) {		
		if (projectTypeIDs!=null && projectTypeIDs.length>0) {
	        Criteria crit = new Criteria();
	        crit.addIn(PROJECTTYPE, projectTypeIDs);	               
	    	try {
	    		return convertTorqueListToBeanList(doSelect(crit));
	        } catch (Exception e) {
	            LOGGER.error("Loading issueTypes associated with projectTypes failed with " + e.getMessage(), e);	            
	        }
		}
		return new LinkedList<TPlistTypeBean>();
	}
	
	/**
	 * Save  TPlistTypeBean in the TPlistType table
	 * @param pissueTypeBean
	 * @return
	 */
	public Integer save(TPlistTypeBean plistTypeBean) {
		TPlistType tPlistType;		
		try {						
			tPlistType = BaseTPlistType.createTPlistType(plistTypeBean);			
			tPlistType.save();
			return tPlistType.getObjectID();			
		} catch (Exception e) {
			LOGGER.error("Saving of an plistTypeBean failed with " + e.getMessage(), e);
			return null;
		}	
	}
	
	/**
	 * Deletes a TPlistTypeBean from the TPlistType table 
	 * @param objectID
	 * @return
	 */
	public void delete(Integer objectID) {
		Criteria crit = new Criteria();
        crit.add(OBJECTID, objectID);
        try {
            doDelete(crit);
        } catch (TorqueException e) {
        	LOGGER.error("Deleting the TPlistTypeBean " + objectID + " failed with: " + e);
        }
	}
	
	/**
	 * Deletes TPlistTypeBean(s) from the TPlistType table 
	 * @param projectTypeID
	 * @param issueTypeIDs
	 */
	public void delete(Integer projectTypeID, List<Integer> issueTypeIDs) {
		if (projectTypeID==null || issueTypeIDs==null || issueTypeIDs.isEmpty()) {
			return;
		}
		Criteria crit = new Criteria();
        crit.add(PROJECTTYPE, projectTypeID);
        crit.addIn(CATEGORY, issueTypeIDs);
        try {
            doDelete(crit);
        } catch (TorqueException e) {
        	LOGGER.error("Deleting item types " + issueTypeIDs.size() + " from projectType " + projectTypeID +  " failed with: " + e);
        }
	}
	
	private List<TPlistTypeBean> convertTorqueListToBeanList(List<TPlistType> torqueList) {		
		List<TPlistTypeBean> beanList = new LinkedList<TPlistTypeBean>();
		if (torqueList!=null){
			Iterator<TPlistType> itrTorqueList = torqueList.iterator();
			while (itrTorqueList.hasNext()){
				beanList.add(itrTorqueList.next().getBean());
			}
		}
		return beanList;
	}
}
