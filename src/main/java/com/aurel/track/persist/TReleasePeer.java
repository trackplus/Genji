/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions

 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* $Id:$ */


package com.aurel.track.persist;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.exception.ExceptionUtils;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.torque.TorqueException;
import org.apache.torque.util.Criteria;
import org.apache.torque.util.Criteria.Criterion;

import com.aurel.track.beans.TReleaseBean;
import com.aurel.track.beans.TSystemStateBean;
import com.aurel.track.cluster.ClusterMarkChangesBL;
import com.aurel.track.dao.ReleaseDAO;
import com.aurel.track.fieldType.constants.SystemFields;
import com.aurel.track.itemNavigator.ItemNavigatorBL.QUERY_TYPE;
import com.aurel.track.itemNavigator.lastExecuted.LastExecutedBL;
import com.aurel.track.lucene.LuceneUtil;
import com.aurel.track.lucene.index.listFields.NotLocalizedListIndexer;
import com.aurel.track.util.GeneralUtils;

/** 
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Fri Jun 14 20:06:48 GMT+02:00 2002]
 *
 *  You should add additional methods to this class to meet the
 *  application requirements.  This class will only be generated as
 *  long as it does not already exist in the output directory.
 */
public class TReleasePeer 
	extends com.aurel.track.persist.BaseTReleasePeer
	implements ReleaseDAO
{

	private static final long serialVersionUID = -3976614605372262160L;

	private static final Logger LOGGER = LogManager.getLogger(TReleasePeer.class); 
	
	private static Class[] replacePeerClasses = {
		TWorkItemPeer.class,
		TWorkItemPeer.class,
		TReleasePeer.class
	};
	
	private static String[] replaceFields = {
		TWorkItemPeer.RELNOTICEDKEY,
		TWorkItemPeer.RELSCHEDULEDKEY,
		TReleasePeer.PARENT
	};
		
	private static Class[] deleteWithWorkitemPeerClasses = {
		//TWorkItemPeer.class, //overloaded doDelete
		//TWorkItemPeer.class, //overloaded doDelete
		//use the superclass doDelete() methode!!! 
		TReleasePeer.class,
		BaseTReleasePeer.class
	};
	
	private static String[] deleteWithWorkitemFields = {
		//TWorkItemPeer.RELNOTICEDKEY, 
		//TWorkItemPeer.RELSCHEDULEDKEY,
		TReleasePeer.PARENT,
		BaseTReleasePeer.PKEY
	};
	
	
	/**
	 * Deletes the TReleases satisfying a certain criteria 
	 * together with the dependent database entries 
	 * @param crit
	 */
	public static void doDelete(Criteria crit) {
		try {
			List<TRelease> releaseList = doSelect(crit);
			if (releaseList == null || releaseList.isEmpty()) {
				return;
			}
			for (TRelease tRelease : releaseList) {
				Integer releaseID = tRelease.getObjectID();
				LastExecutedBL.deleteByFilterIDAndFilterType(releaseID, QUERY_TYPE.PROJECT_RELEASE);
				new TCardFieldOptionPeer().deleteOptionForField(SystemFields.INTEGER_RELEASENOTICED, releaseID);
				new TCardFieldOptionPeer().deleteOptionForField(SystemFields.INTEGER_RELEASESCHEDULED, releaseID);
				ReflectionHelper.delete(deleteWithWorkitemPeerClasses, deleteWithWorkitemFields, releaseID);
				//delete from lucene index
				NotLocalizedListIndexer.getInstance().deleteByKeyAndType(releaseID, LuceneUtil.LOOKUPENTITYTYPES.RELEASE);
				//cache and possible lucene update in other nodes
				ClusterMarkChangesBL.markDirtySystemListEntryInCluster(SystemFields.INTEGER_RELEASE, tRelease.getObjectID(), ClusterMarkChangesBL.getChangeTypeByDelete());
			}
		} catch (TorqueException e) {
			LOGGER.error("Deleting the release by criteria " + crit.toString() + " failed with " + e.getMessage());
		}
	}
	
	/**
	 * Loads a ReleaseBean by primary key 
	 * @param objectID
	 * @return
	 */
	@Override
	public TReleaseBean loadByPrimaryKey(Integer objectID) {
		TRelease tRelease = null;
		try {
			tRelease = retrieveByPK(objectID);
		} catch(Exception e) {
			LOGGER.info("Loading the release by primary key " + objectID + " failed with " + e.getMessage());
			LOGGER.debug(ExceptionUtils.getStackTrace(e));
		}
		if (tRelease!=null) {
			return tRelease.getBean();
		}
		return null;
	}
	
	/** 
	 * Loads all releaseBeans for a project (also the child releases)  
	 * @param projectID 
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadAllByProject(Integer projectID) {
		Criteria crit = new Criteria();
		crit.add(PROJKEY, projectID);
		crit.addAscendingOrderByColumn(LABEL);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading the release from project " + projectID + 
					" failed with " + e.getMessage(), e);
			return null;
		}
	}
	
	/** 
	 * Loads the main releaseBeans for a project (no child releases) 
	 * @param projectID 
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadMainByProject(Integer projectID) {
		Criteria crit = new Criteria();
		crit.add(PROJKEY, projectID);
		crit.add(PARENT, (Object)null, Criteria.ISNULL);
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading the release from project " + projectID + 
					" failed with " + e.getMessage(), e);
			return null;
		}
	}

	/** 
	 * Loads all releaseBeans for a project with specific states 
	 * Gets all (main and child) independently of hierarchy
	 * @param projectID
	 * @param states
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadAllByProjectAndStates(Integer projectID, int[] states) {
		Criteria crit = new Criteria();
		if(projectID!=null){
			crit.add(PROJKEY, projectID);
		}
		if (states!=null && states.length>0) {
			crit.addIn(STATUS, states);
		}
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading all releases from project " + projectID + 
					" and states " + states + " failed with " + e.getMessage(), e);
			return null;
		}
	}
	
	/**
	 * Loads the main (no child) releaseBeans with specific states for a project 
	 * @param projectID
	 * @param states
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadMainByProjectAndStates(Integer projectID, int[] states) {
		Criteria crit = new Criteria();
		crit.add(PROJKEY, projectID);
		crit.add(PARENT, (Object)null, Criteria.ISNULL);
		if (states!=null && states.length>0) {
			crit.addIn(STATUS, states);
		}
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading the main releases from project " + projectID + 
					" and states " + states + " failed with " + e.getMessage(), e);
			return null;
		}
	}
	
	/**
	 * Loads the main (no child) releaseBeans with specific states 
	 * @param projectIDs
	 * @param states
	 * @param selectedReleaseIDsSet
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadMainByProjectsAndStates(List<Integer> projectIDs, int[] states, Set<Integer> selectedReleaseIDsSet) {
		List<TReleaseBean> releasesList = new LinkedList<TReleaseBean>();
		if (projectIDs==null || projectIDs.isEmpty()) {
			return releasesList;
		}
		List<int[]> projectIDChunksList = GeneralUtils.getListOfChunks(projectIDs);
		if (projectIDChunksList==null) {
			return releasesList;
		}		
		Iterator<int[]> iterator = projectIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] projectIDChunk = iterator.next();
			Criteria criteria = new Criteria();
			criteria.addIn(PROJKEY, projectIDChunk);
			criteria.add(PARENT, (Object)null, Criteria.ISNULL);
			addStatusOrSelection(criteria, states, selectedReleaseIDsSet);
			//criteria.addJoin(PROJKEY, TProjectPeer.PKEY);
			//criteria.addAscendingOrderByColumn(TProjectPeer.LABEL);
			criteria.addAscendingOrderByColumn(SORTORDER);
			try {
				releasesList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
			} catch(Exception e) {
				if (states != null) {
					LOGGER.error("Loading the main releases from projects " + projectIDs.size() +
						" and states " + states.length + "  failed with " + e.getMessage(), e);
				} else {
					LOGGER.error("Loading the main releases from projects " + projectIDs.size() +
							" and all states failed with " + e.getMessage(), e);
				}
			}
		}
		return releasesList;
	}
	
	/**
	 * Add the status or selection condition. The selected releases should be included independently of status
	 * @param criteria
	 * @param states
	 * @param selectedReleaseIDsSet
	 */
	private static void addStatusOrSelection(Criteria criteria, int[] states, Set<Integer> selectedReleaseIDsSet) {
		boolean hasStatuses = false;
		if (states!=null && states.length>0) {
			hasStatuses = true;
		}
		boolean hasSelections = false;
		if (selectedReleaseIDsSet!=null && !selectedReleaseIDsSet.isEmpty()) {
			hasSelections = true;
		}
		if (hasStatuses && hasSelections) {
			Criterion statusCriterion = criteria.getNewCriterion(STATUS, states, Criteria.IN);
			Criterion selectedCriterion = criteria.getNewCriterion(PKEY, selectedReleaseIDsSet.toArray(), Criteria.IN);
			criteria.add(statusCriterion.or(selectedCriterion));
		} else {
			if (hasStatuses) {
				criteria.addIn(STATUS, states);
			} else {
				if (hasSelections) {
					criteria.addIn(PKEY, selectedReleaseIDsSet.toArray());
				}
			}
		}
	}
	
	/**
	 * Loads all children for a release
	 * @param releaseID
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadChildren(Integer releaseID) {
		Criteria crit = new Criteria();
		crit.add(PARENT, releaseID);
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading of all children of the release " + releaseID +  " failed with " + e.getMessage());
			return null;
		}
	}
	
	/**
	 * Loads the child releaseBeans with specific states for a parent release
	 * @param releaseID
	 * @param states
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadChildrenByParentAndStates(Integer releaseID, int[] states) {
		Criteria crit = new Criteria();
		crit.add(PARENT, releaseID);
		if (states!=null && states.length>0) {
			crit.addIn(STATUS, states);
		}
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading the child not closed releases for release " + releaseID + 
					" and states " + states + " failed with " + e.getMessage(), e);
			return null;
		}
	}
	
	/**
	 * Loads the child releaseBeans with specific states for parent releases
	 * @param releaseIDs
	 * @param states
	 * @param selectedReleaseIDsSet
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadChildrenByParentsAndStates(List<Integer> releaseIDs, int[] states, Set<Integer> selectedReleaseIDsSet) {
		List<TReleaseBean> releasesList = new LinkedList<TReleaseBean>();
		if (releaseIDs==null || releaseIDs.isEmpty()) {
			return releasesList;
		}
		List<int[]> releaseIDChunksList = GeneralUtils.getListOfChunks(releaseIDs);
		if (releaseIDChunksList==null) {
			return releasesList;
		}
		Iterator<int[]> iterator = releaseIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] relaseIDChunk = iterator.next();
			Criteria criteria = new Criteria();
			criteria.addIn(PARENT, relaseIDChunk);
			addStatusOrSelection(criteria, states, selectedReleaseIDsSet);
			criteria.addAscendingOrderByColumn(SORTORDER);
			try {
				releasesList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
			} catch(Exception e) {
				if (states != null) {
					LOGGER.error("Loading the child releases from main releases " + releaseIDs.size() +
							" and states " + states.length + "  failed with " + e.getMessage(), e);
				} else {
					LOGGER.error("Loading the child releases from main releases " + releaseIDs.size() +
							" and all states failed with " + e.getMessage(), e);
				}
			}
		}
		return releasesList;
	}
	
	/**
	 * Gets the sort order column name 
	 * @return
	 */
	@Override
	public String getSortOrderColumn() {
		return "SORTORDER";
	}
	
	/**
	 * Returns the table name
	 * @return
	 */
	@Override
	public String getTableName() {
		return TABLE_NAME;
	}
	
	/**
	 * Gets an subprojectBean from a project by label
	 * @param projectID
	 * @param label
	 * @return
	 */
	@Override
	public TReleaseBean loadByProjectAndLabel(Integer projectID, String label) {
		List<TRelease> torqueList = null;
		Criteria crit = new Criteria();
		crit.add(PROJKEY, projectID);
		crit.add(LABEL, label);
		try {
			torqueList =  doSelect(crit);
		} catch (Exception e) {
			LOGGER.error("Loading the release by label from project " + projectID + 
					" by label " + label + " failed with " + e.getMessage(), e);
			return null;
		}
		if (torqueList==null || torqueList.isEmpty()) {
			return null;
		}
		return torqueList.get(0).getBean();
	}
	
	/**
	 * Gets the releaseBeans by uuid list
	 * @param uuids
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadByUUIDs(List<String> uuids) {
		return loadByFieldValues(uuids, TPUUID);
	}
	
	/**
	 * Gets the releaseBeans by labels list
	 * @param labels
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadByLabels(List<String> labels) {
		return loadByFieldValues(labels, LABEL);
	}
		
	/**
	 * Load the release by a String field
	 * @param fieldValues
	 * @param fieldName
	 * @return
	 */
	private List<TReleaseBean> loadByFieldValues(List<String> fieldValues, String fieldName) {
		List<TReleaseBean> releaseList = new LinkedList<TReleaseBean>();
		if (fieldValues==null || fieldValues.isEmpty()) {
			return releaseList;
		}
		Criteria criteria;
		List<List<String>> chunksList = GeneralUtils.getListOfStringChunks(fieldValues);
		if (chunksList==null) {
			return releaseList;
		}
		Iterator<List<String>> iterator = chunksList.iterator();
		int i = 0;
		
		while (iterator.hasNext()) {
			i++;
			List<String> chunk = iterator.next();
			criteria = new Criteria();
			criteria.addIn(fieldName, chunk);
			try {
				releaseList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
			} catch(Exception e) {
				LOGGER.error("Loading the releaseBeans by " + fieldName + " and the chunk number " + 
						i + " of length  "  + chunk.size() + " failed with " + e.getMessage(), e);
			}
		}
		return releaseList;
	}
	
	/**
	 * Loads a ReleaseBean list by releaseIDs
	 * @param releaseIDs
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadByReleaseIDs(List<Integer> releaseIDs) {
		if (releaseIDs==null || releaseIDs.isEmpty()) {
			LOGGER.warn("No releaseIDs specified " + releaseIDs);
			return new LinkedList<TReleaseBean>();
		}
		Criteria crit = new Criteria();
		crit.addAscendingOrderByColumn(SORTORDER);
		crit.addIn(PKEY, releaseIDs); 
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch (Exception e) {
			LOGGER.error("Loading of releases by IDs failed with " + e.getMessage());
			return null;
		}
	}
		
	/**
	 * Loads all ReleaseBeans
	 * @return 
	 */
	@Override
	public List<TReleaseBean> loadAll() {
		Criteria crit = new Criteria();
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		}
		catch (Exception e) {
			LOGGER.error("Loading of all releases failed with " + e.getMessage());
			return null;
		}
	}
	
	/**
	 * Loads the noticed ReleaseBeans by workItemKeys
	 * @param workItemIDs
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadNoticedByWorkItemKeys(int[] workItemIDs) {
		if (workItemIDs==null || workItemIDs.length==0) {
			return new LinkedList<TReleaseBean>();
		}	
		Criteria criteria;
		List<int[]> workItemIDChunksList = GeneralUtils.getListOfChunks(workItemIDs);
		if (workItemIDChunksList==null) {
			return new LinkedList<TReleaseBean>();
		}
		List<TRelease> releases = new LinkedList<TRelease>();
		Iterator<int[]> iterator = workItemIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] workItemIDChunk = iterator.next();
			criteria = new Criteria();
			criteria.addJoin(BaseTWorkItemPeer.RELNOTICEDKEY, PKEY);
			criteria.addIn(BaseTWorkItemPeer.WORKITEMKEY, workItemIDChunk);
			try {
				releases.addAll(doSelect(criteria));
			} catch(Exception e) {
				LOGGER.error("Loading the noticed releaseBeans by workItemKeys failed with " + e.getMessage());
			}			
		}
		return convertTorqueListToBeanList(releases);
	}
	
	/**
	 * Loads the scheduled ReleaseBeans by workItemKeys
	 * @param workItemIDs
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadScheduledByWorkItemKeys(int[] workItemIDs) {
		if (workItemIDs==null || workItemIDs.length==0) {
			return new LinkedList<TReleaseBean>();
		}	
		Criteria criteria;
		List<int[]> workItemIDChunksList = GeneralUtils.getListOfChunks(workItemIDs);
		if (workItemIDChunksList==null) {
			return new LinkedList<TReleaseBean>();
		}
		List<TRelease> releases = new LinkedList<TRelease>();
		Iterator<int[]> iterator = workItemIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] workItemIDChunk = iterator.next();
			criteria = new Criteria();
			criteria.addJoin(BaseTWorkItemPeer.RELSCHEDULEDKEY, PKEY);
			criteria.addIn(BaseTWorkItemPeer.WORKITEMKEY, workItemIDChunk);
			try {
				releases.addAll(doSelect(criteria));
			} catch(Exception e) {
				LOGGER.error("Loading the scheduled releaseBeans by workItemKeys failed with " + e.getMessage());
			}
		}
		return convertTorqueListToBeanList(releases);
	}
	
	/**
	 * Loads a list of active and inactive releases 
	 * for the active and inactive projects
	 * @return
	 */
	/*public List loadNotClosed() {
		List releases = new ArrayList();
		Criteria crit = new Criteria(); 
		crit.add(PKEY, 0, Criteria.NOT_EQUAL);
		String projectState = "PROJECTSTATE";
		String releaseState = "RELEASESTATE";
		
		crit.addAlias(projectState, TSystemStatePeer.TABLE_NAME);
		crit.addAlias(releaseState, TSystemStatePeer.TABLE_NAME);					
				
		crit.addJoin(TProjectPeer.PKEY, PROJKEY);
		
		crit.addJoin(releaseState + "." + "OBJECTID", STATUS);		
		crit.add(releaseState + "." + "ENTITYFLAG", TSystemStateBean.ENTITYFLAGS.RELEASESTATE);
		//we are interested only in not closed releases
		crit.addIn(releaseState + "." + "STATEFLAG", new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, 
				TSystemStateBean.STATEFLAGS.INACTIVE, TSystemStateBean.STATEFLAGS.NOT_PLANNED});

		crit.addJoin(projectState + "." + "OBJECTID", TProjectPeer.STATUS);
		crit.add(projectState + "." + "ENTITYFLAG", TSystemStateBean.ENTITYFLAGS.PROJECTSTATE);
		//we are interested only in not closed projects
		crit.addIn(projectState + "." + "STATEFLAG", new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, TSystemStateBean.STATEFLAGS.INACTIVE});

		crit.addAscendingOrderByColumn(TProjectPeer.LABEL);
		crit.addAscendingOrderByColumn(SORTORDER);		
		try
		{
			releases = doSelect(crit);
		}
		catch(Exception e)
		{
			LOGGER.error("Loading the active and inactive releases failed with " + e.getMessage());
		} 
		
		Map projectsMap = TProjectPeer.loadActiveInactiveProjectsMap();
		
		if (releases!=null) {
			Iterator iterator = releases.iterator();
			while (iterator.hasNext()) {
				TRelease release = (TRelease) iterator.next();
				release.setLabel(
						((TProject)projectsMap.get(release.getProjectID())).getLabel() + MatcherConstants.MATCH_VALUE_LINK_STRING + release.getLabel());
			}
		}		
		return convertTorqueListToBeanList(releases);
	}*/
	
	/*public List<TReleaseBean> loadActiveInactiveByProject(Integer projectKey, Integer release)
	{		
		return loadByProjectAndReleaseStatesWithCurrentValue(projectKey, 
				new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, 
					TSystemStateBean.STATEFLAGS.INACTIVE},
				release);
	}*/
	
	/*public List<TReleaseBean> loadNotClosedByProject(Integer projectKey)	{			
		int[] stateFlags =  
				new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, 
					TSystemStateBean.STATEFLAGS.INACTIVE, TSystemStateBean.STATEFLAGS.NOT_PLANNED};		
		return convertTorqueListToBeanList(loadByProjectAndReleaseStates(projectKey, stateFlags));
	}*/
	
	/*public List<TReleaseBean> loadActiveOrNotPlannedByProject(Integer projectKey, Integer release) {
		return loadByProjectAndReleaseStatesWithCurrentValue(projectKey, 
				new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, TSystemStateBean.STATEFLAGS.NOT_PLANNED},
				release);
	}*/	
	
	/**
	 * Loads the active or not planned releaseBeans for a project
	 * @param projectID
	 * @return
	 */
	/*public List<TReleaseBean> loadNotPlannedByProject(Integer projectID) {
		return loadByProjectAndReleaseStatesWithCurrentValue(projectID, 
				new int[] {TSystemStateBean.STATEFLAGS.NOT_PLANNED},
				null);
	}*/
	
	/*private static List<TRelease> loadByProjectAndReleaseStates(
			Integer projectKey, int[] stateFlags) {	
		Criteria crit = new Criteria(); 		
		crit.add(PROJKEY, projectKey);		
		crit.addJoin(TSystemStatePeer.OBJECTID, STATUS);
		crit.add(TSystemStatePeer.ENTITYFLAG, TSystemStateBean.ENTITYFLAGS.RELEASESTATE);
		crit.addIn(TSystemStatePeer.STATEFLAG, stateFlags);
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return doSelect(crit);
		} catch(Exception e) {
			LOGGER.error("Loading releases by project " + projectKey + " and release states " + stateFlags + " failed with " + e.getMessage());
			return new ArrayList<TRelease>();
		}						
	}*/
	
	/*private static List<TReleaseBean> loadByProjectAndReleaseStatesWithCurrentValue(
			Integer projectKey, int[] stateFlags, Integer currentRelease) {
		List<TRelease> releases = loadByProjectAndReleaseStates(projectKey, stateFlags);		 
		//TODO add it according to the sortorder
		if (currentRelease!=null) {
			TRelease tRelease;
			Iterator<TRelease> itrReleases = releases.iterator();
			boolean found = false;
			while (itrReleases.hasNext()) {
				tRelease = (TRelease)itrReleases.next();
				if (tRelease.getObjectID().equals(currentRelease)) {
					found = true;
					break;					
				}
			}
			//the release's status was set to closed
			if (!found) {
				releases.add(loadByPrimaryKey(currentRelease));
			}		
		}		
		return convertTorqueListToBeanList(releases);
	}*/
		
   	
	/**
	 * Loads a list with releaseBeans with the used scheduled release for a project
	 * (scheduled releases which are assigned to at least one workItem) 
	 * @param projectID
	 * @return
	 */
	/*public List loadUsedScheduledByProject(Integer projectID) {
		List releases = new ArrayList();
		Criteria crit = new Criteria(); 		
		crit.add(PROJKEY, projectID);
		crit.addJoin(TWorkItemPeer.RELSCHEDULEDKEY, PKEY);
		crit.addJoin(TSystemStatePeer.OBJECTID, STATUS);		
		crit.add(TSystemStatePeer.ENTITYFLAG, TSystemStateBean.ENTITYFLAGS.RELEASESTATE);
		//we are interested only in not closed releases
		crit.addIn(TSystemStatePeer.STATEFLAG, new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, 
				TSystemStateBean.STATEFLAGS.INACTIVE, TSystemStateBean.STATEFLAGS.NOT_PLANNED});
		crit.addAscendingOrderByColumn(SORTORDER);
		crit.setDistinct();
		try
		{
			releases = doSelect(crit);
		}
		catch(Exception e)
		{
			LOGGER.error("Loading used releases by project " + projectID + " failed with " + e.getMessage());
		}				
		return convertTorqueListToBeanList(releases);
	}*/
	
	/**
	 * Load all active and inactive releases for a list of projects
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadNotClosedByProjectIDs(List<Integer> projectIDs) {
		if (projectIDs==null || projectIDs.isEmpty()) {
			return new LinkedList<TReleaseBean>();
		}
		Criteria crit = new Criteria();
		crit.addIn(PROJKEY, projectIDs);
		crit.addJoin(BaseTSystemStatePeer.OBJECTID, STATUS);
		crit.add(BaseTSystemStatePeer.ENTITYFLAG, TSystemStateBean.ENTITYFLAGS.RELEASESTATE);
		int[] statusFlags = new int[] {TSystemStateBean.STATEFLAGS.ACTIVE, 
				TSystemStateBean.STATEFLAGS.INACTIVE, TSystemStateBean.STATEFLAGS.NOT_PLANNED};
		crit.addIn(BaseTSystemStatePeer.STATEFLAG, statusFlags);
		crit.addJoin(BaseTProjectPeer.PKEY, PROJKEY);
		crit.addAscendingOrderByColumn(BaseTProjectPeer.LABEL);
		crit.addAscendingOrderByColumn(SORTORDER);
		try {
			return convertTorqueListToBeanList(doSelect(crit));
		} catch(Exception e) {
			LOGGER.error("Loading releases by projects " + projectIDs + "and release states " + statusFlags + " failed with " + e.getMessage());
			return null;
		}
	}
	
	/**
	 * Loads a ClassBean list by projectIDs
	 * @param projectIDs
	 * @return
	 */
	@Override
	public List<TReleaseBean> loadByProjectKeys(List<Integer> projectIDs) {
		if (projectIDs==null || projectIDs.isEmpty()) {
			return new LinkedList<TReleaseBean>();
		}			 
		Criteria criteria;
		List<int[]> projectIDChunksList = GeneralUtils.getListOfChunks(projectIDs);
		if (projectIDChunksList==null) {
			return new LinkedList<TReleaseBean>();
		}
		List<TRelease> releasesList = new LinkedList<TRelease>();
		Iterator<int[]> iterator = projectIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] projectIDChunk = iterator.next();
			criteria = new Criteria();
			criteria.addIn(PROJKEY, projectIDChunk);
			criteria.addJoin(TProjectPeer.PKEY, PROJKEY);
			criteria.addAscendingOrderByColumn(TProjectPeer.LABEL);
			criteria.addAscendingOrderByColumn(LABEL);
			try {
				releasesList.addAll(doSelect(criteria));
			} catch(Exception e) {
				LOGGER.error("Loading the defined releases for " + projectIDs.size() +  " projects failed with " + e.getMessage());
			}
		}
		return convertTorqueListToBeanList(releasesList);
	}
	
	/**
	 * Saves a releaseBean in the TRelease table
	 * @param releaseBean
	 * @return
	 */
	/*public Integer save(TReleaseBean releaseBean) {
		boolean isNew = false;
		TRelease tRelease;
		try {
			isNew = (releaseBean.getObjectID() == null);
			tRelease = BaseTRelease.createTRelease(releaseBean);
			tRelease.save();
			Integer objectID = tRelease.getObjectID();
			if (isNew) {
				releaseBean.setObjectID(objectID);
				LuceneIndexer.addToNotLocalizedLookupIndex(releaseBean,
					LuceneUtil.LOOKUPENTITYTYPES.RELEASE);
			} else {
				LuceneIndexer.updateNotLocalizedLookupIndex(releaseBean,
					LuceneUtil.LOOKUPENTITYTYPES.RELEASE);
			}
			return objectID;
		} catch (Exception e) {
			LOGGER.error("Saving of a release failed with " + e.getMessage());
			return null;
		}
	}*/
	
	/**
	 * Saves a releaseBean in the TRelease table
	 * @param releaseBean
	 * @return
	 */
	@Override
	public Integer save(TReleaseBean releaseBean) {
		try {
			TRelease tRelease = BaseTRelease.createTRelease(releaseBean);
			tRelease.save();
			return tRelease.getObjectID();
		} catch (Exception e) {
			LOGGER.error("Saving of release failed with " + e.getMessage());
			return null;
		}
	}
	
	/**
	 * Copies a relaseBean
	 * @param releaseBean
	 * @param deep
	 */
	@Override
	public TReleaseBean copy(TReleaseBean releaseBean, boolean deep) {
		try {
			return  (BaseTRelease.createTRelease(releaseBean).copy(deep)).getBean();
		} catch (TorqueException e) {
			LOGGER.error("Deep " + deep + " copying a release failed with " + e.getMessage());
			return null;
		}
	}
	
	/**
	 * Whether there are workItems with this release
	 * @param objectID
	 * @return
	 */
	@Override
	public boolean hasDependentIssues(Integer objectID) {
		return ReflectionHelper.hasDependentData(replacePeerClasses, replaceFields, objectID);
	}
		
	
	/**
	 * Deletes a list by primary key
	 * @param objectID
	 */
	@Override
	public void delete(Integer objectID) {
		Criteria crit = new Criteria();
		crit.add(PKEY, objectID);
		try {
			doDelete(crit);
		} catch (Exception e) {
			LOGGER.error("Deleting a release by key " + objectID + " failed with: " + e);
		}		
	}
	
	/**
	 * Replaces the dependences with a new releaseID and 
	 * deletes the old releaseID from the TRelease table 
	 * @param oldReleaseID
	 * @param newReleaseID
	 */
	@Override
	public void replace(Integer oldReleaseID, Integer newReleaseID) {
		ReflectionHelper.replace(replacePeerClasses, replaceFields, oldReleaseID, newReleaseID);
		replaceHistoryRelease(oldReleaseID, newReleaseID, true);
		replaceHistoryRelease(oldReleaseID, newReleaseID, false);
	}
	
	/**
	 * The reflection does not work because an additional condition 
	 * should be satisfied (no direct foreign key relationship exists)
	 * @param oldReleaseID
	 * @param newReleaseID
	 */
	public static void replaceHistoryRelease(Integer oldReleaseID, Integer newReleaseID, boolean newValues) {
		Criteria selectCriteria = new Criteria();
		Criteria updateCriteria = new Criteria();
		if (newValues) {
			selectCriteria.add(BaseTFieldChangePeer.NEWSYSTEMOPTIONID, oldReleaseID);
			updateCriteria.add(BaseTFieldChangePeer.NEWSYSTEMOPTIONID, newReleaseID);
		} else {
			selectCriteria.add(BaseTFieldChangePeer.OLDSYSTEMOPTIONID, oldReleaseID);
			updateCriteria.add(BaseTFieldChangePeer.OLDSYSTEMOPTIONID, newReleaseID);
		}		
		selectCriteria.add(BaseTFieldChangePeer.SYSTEMOPTIONTYPE, SystemFields.RELEASE);
		try {
			doUpdate(selectCriteria, updateCriteria);
		}
		catch (Exception e) {
			LOGGER.error("Trying to replace " +
					"oldReleaseID " + oldReleaseID + " with " +
					"newReleaseID  " + newReleaseID + " in the history releases " +
					newValues +  " values failed with " + e.getMessage(), e);
		}
	}
	
	/*********************************************************
	* Manager-, Responsible-, My- and Custom Reports methods * 
	*********************************************************/
	
	/**
	 * Gets the scheduled releaseBeans for a prepared criteria
	 * @param preparedCriteria
	 * @return
	 * @throws TorqueException
	 */
	/*private static List<TReleaseBean> getReportReleasesScheduled(Criteria preparedCriteria) throws TorqueException {
		preparedCriteria.addJoin(BaseTWorkItemPeer.RELSCHEDULEDKEY,  PKEY);
		return convertTorqueListToBeanList(doSelect(preparedCriteria));
	}*/

	/**
	 * Gets the noticed releaseBeans for a prepared criteria
	 * @param preparedCriteria
	 * @return
	 * @throws TorqueException
	 */
	/*private static List<TReleaseBean> getReportReleasesNoticed(Criteria preparedCriteria) throws TorqueException {
		preparedCriteria.addJoin(BaseTWorkItemPeer.RELNOTICEDKEY,  PKEY);
		return convertTorqueListToBeanList(doSelect(preparedCriteria));
	}*/

	/**
	 * Gets the picker releaseBeans for a prepared criteria
	 * @param preparedCriteria
	 * @return
	 * @throws TorqueException
	 */
	/*private static List<TReleaseBean> getReportPickerReleases(Criteria preparedCriteria) throws TorqueException {
		preparedCriteria.addJoin(BaseTWorkItemPeer.WORKITEMKEY,  BaseTAttributeValuePeer.WORKITEM);
		preparedCriteria.addJoin(BaseTAttributeValuePeer.SYSTEMOPTIONID,  BaseTReleasePeer.PKEY);
		int[] systemRelease = new int[] {SystemFields.RELEASENOTICED, SystemFields.RELEASESCHEDULED};
		preparedCriteria.addIn(BaseTAttributeValuePeer.SYSTEMOPTIONTYPE, systemRelease);
		return convertTorqueListToBeanList(doSelect(preparedCriteria));
	}*/
	
	/*************************Release scheduled dropdown****************************/
	
	/**
	 * Get the scheduled releaseBeans associated with workItems the person is manager for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadManagerReleasesScheduled(Integer personID) {		
		Criteria crit = ReportBeanLoader.prepareManagerCriteria(personID);
		try {
			return getReportReleasesScheduled(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the manager scheduled releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}		
	}*/

	/**
	 * Get the scheduled releaseBeans associated with workItems the person is responsible for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadResponsibleReleasesScheduled(Integer personID) {		
		Criteria crit = ReportBeanLoader.prepareResponsibleCriteria(personID);
		try {
			return getReportReleasesScheduled(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the responsible scheduled releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}
	}*/
	
	/**
	 * Get the scheduled releaseBeans associated with workItems the person is manager or responsible or owner for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadMyReleasesScheduled(Integer personID) {		
		Criteria crit = ReportBeanLoader.prepareMyCriteria(personID);
		try {
			return getReportReleasesScheduled(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the my scheduled releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}
	}*/
		
	/**
	 * Get the scheduled releaseBeans associated 
	 * with workItems the person is originator for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadReporterReleasesScheduled(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareReporterCriteria(personID);
		try {
			return getReportReleasesScheduled(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the reporter scheduled releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}	
	}*/
	
	/**
	 * Get the scheduled releaseBeans filtered by the FilterSelectsTO
	 * @param filterSelectsTO
	 * @return
	 */
	/*public List<TReleaseBean> loadCustomReportReleasesScheduled(FilterUpperTO filterSelectsTO) {
		Criteria crit;		
		Integer[] selectedReleaseScheduled = filterSelectsTO.getSelectedReleases();
		if (selectedReleaseScheduled!=null && selectedReleaseScheduled.length>0) {
			crit = new Criteria();
			crit.addIn(PKEY, selectedReleaseScheduled);
		} else {
			crit = ReportBeanLoader.prepareCustomReportCriteria(filterSelectsTO);
		}
		try {
			return getReportReleasesScheduled(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the scheduled releases for custom report failed with failed with " + e.getMessage());
			return null;
		}		
	}*/
	
	/**
	 * Get the scheduled releaseBeans filtered by a TQL expression
	 * It is made static and not memeber of the ReleaseDAO 
	 * because the Criteria parameter would make
	 * the DAO interface dependent on Torque 
	 * @param tqlCriteria
	 * @return
	 */
	/*public static List<TReleaseBean> loadTQLReportReleasesScheduled(Criteria tqlCriteria) {
		try {
			return getReportReleasesScheduled(tqlCriteria);
		} catch (TorqueException e) {
			LOGGER.error("Loading the scheduled releases for TQL report failed with failed with " + e.getMessage());
			return null;
		}		
	}*/
	
	/*************************Release noticed dropdown****************************/
	
	/**
	 * Get the noticed releaseBeans associated with workItems the person is manager for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadManagerReleasesNoticed(Integer personID) {		
		Criteria crit = ReportBeanLoader.prepareManagerCriteria(personID);
		try {
			return getReportReleasesNoticed(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the manager noticed releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}			
	}*/

	/**
	 * Get the noticed releaseBeans associated with workItems the person is responsible for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadResponsibleReleasesNoticed(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareResponsibleCriteria(personID);
		try {
			return getReportReleasesNoticed(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the responsible noticed releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}			
	}*/
	
	/**
	 * Get the noticed releaseBeans associated with workItems the person is originator for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadReporterReleasesNoticed(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareReporterCriteria(personID);
		try {
			return getReportReleasesNoticed(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the reporter noticed releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}	
	}*/
	
	/**
	 * Get the noticed releaseBeans associated with workItems the person is manager or responsible or owner for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadMyReleasesNoticed(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareMyCriteria(personID);
		try {
			return getReportReleasesNoticed(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the my noticed releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}			
	}*/
		
	/**
	 * Get the noticed releaseBeans filtered by the filterSelectsTO
	 * @param filterSelectsTO
	 * @return
	 */
	/*public List<TReleaseBean> loadCustomReportReleasesNoticed(FilterUpperTO filterSelectsTO) {		
		//TODO selected release noticed??? 
		Criteria crit = ReportBeanLoader.prepareCustomReportCriteria(filterSelectsTO);		
		try {
			return getReportReleasesNoticed(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the noticed releases for custom report failed with " + e.getMessage());
			return null;
		}		
	}*/
	
	/**
	 * Get the noticed releaseBeans filtered by a TQL expression
	 * It is made static and not memeber of the ReleaseDAO 
	 * because the Criteria parameter would make
	 * the DAO interface dependent on Torque 
	 * @param tqlCriteria
	 * @return
	 */
	/*public static List<TReleaseBean> loadTQLReportReleasesNoticed(Criteria tqlCriteria) {
		try {
			return getReportReleasesNoticed(tqlCriteria);
		} catch (TorqueException e) {
			LOGGER.error("Loading the noticed releases for TQL report failed with failed with " + e.getMessage());
			return null;
		}		
	}*/
	
	/*************************Further picker releases****************************/
	
	/**
	 * Get the picker releaseBeans associated 
	 * with workItems the person is manager for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadManagerPickerReleases(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareManagerCriteria(personID);
		try {
			return getReportPickerReleases(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the manager picker releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}		
	}*/

	/**
	 * Get the releaseBeans associated 
	 * with workItems the person is responsible for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadResponsiblePickerReleases(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareResponsibleCriteria(personID);
		try {
			return getReportPickerReleases(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the responsible picker releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}		
	}*/
	
	/**
	 * Get the picker releaseBeans associated 
	 * with workItems the person is manager or responsible or owner for
	 * @param personID
	 * @return
	 */
	/*public List<TReleaseBean> loadMyPickerReleases(Integer personID) {
		Criteria crit = ReportBeanLoader.prepareMyCriteria(personID);
		try {
			return getReportPickerReleases(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the my picker releases for person " + personID + " failed with " + e.getMessage());
			return null;
		}	
	}*/
	
	/**
	 * Get the picker releaseBeans filtered by the FilterSelectsTO
	 * @param filterSelectsTO
	 * @return
	 */
	/*public List<TReleaseBean> loadCustomReportPickerReleases(FilterUpperTO filterSelectsTO) {
		Criteria crit = ReportBeanLoader.prepareCustomReportCriteria(filterSelectsTO);		
		try {
			return getReportPickerReleases(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the picker releases for custom report failed with failed with " + e.getMessage());
			return null;
		}	
	}*/
		
	/**
	 * Get the picker releaseBeans filtered by a TQL expression
	 * It is made static and not memeber of the ReleaseDAO 
	 * because the Criteria parameter would make
	 * the DAO interface dependent on Torque 
	 * @param tqlCriteria
	 * @return
	 */
	/*public static List<TReleaseBean> loadTQLReportPickerReleases(Criteria tqlCriteria) {			
		try {
			return getReportPickerReleases(tqlCriteria);
		} catch (TorqueException e) {
			LOGGER.error("Loading the picker releases for TQL report failed with failed with " + e.getMessage());
			return null;
		}	
	}*/
	
	/**
	 * Get the releaseBeans associated through a release picker 
	 * for an array of workItemIDs
	 * @param workItemIDs
	 * @return
	 */
	/*public List<TReleaseBean> loadLucenePickerReleases(int[] workItemIDs) {
		List<TReleaseBean> releases = new LinkedList<TReleaseBean>();
		if (workItemIDs==null || workItemIDs.length==0) {
			return releases;
		}	
		Criteria criteria;
		List<int[]> workItemIDChunksList = GeneralUtils.getListOfChunks(workItemIDs);
		if (workItemIDChunksList==null) {
			return releases;
		}
		Iterator<int[]> iterator = workItemIDChunksList.iterator();
		while (iterator.hasNext()) {
			int[] workItemIDChunk = iterator.next();
			criteria = new Criteria();			
			criteria.addIn(BaseTWorkItemPeer.WORKITEMKEY, workItemIDChunk);
			try {
				releases.addAll(getReportPickerReleases(criteria));
			} catch(Exception e) {
				LOGGER.error("Loading the picker releaseBeans by workItemKeys failed with " + e.getMessage());
			}			
		}
		return releases;
	}*/
	
	/*public List loadActiveReleasesByProject(Integer projectID) {
		List torqueList = loadActiveByProject(projectID);
		return convertTorqueListToBeanList(torqueList);
	}*/
	
	/**
	 * Get the Map of releaseBeans from the history of the workItemIDs added by personID
	 * @param workItemIDs
	 * @param personID in null do not filter by personID
	 * @return
	 */
	@Override
	public Map<Integer, TReleaseBean> loadHistoryReleases(int[] workItemIDs) {
		List<TReleaseBean> releaseBeanList = new LinkedList<TReleaseBean>();
		List<int[]> workItemIDChunksList = GeneralUtils.getListOfChunks(workItemIDs);
		if (workItemIDChunksList!=null && !workItemIDChunksList.isEmpty()) {
			Criteria criteria;
			Iterator<int[]> iterator = workItemIDChunksList.iterator();
			while (iterator.hasNext()) {
				int[] workItemIDChunk = iterator.next();
				criteria = HistoryDropdownContainerLoader.prepareHistorySystemOptionCriteria(
						workItemIDChunk, true, PKEY, SystemFields.RELEASE);
				try {
					releaseBeanList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
				} catch(Exception e) {
					LOGGER.error("Loading the new history releaseBeans  for workItems failed with " + e.getMessage());
				}
				criteria = HistoryDropdownContainerLoader.prepareHistorySystemOptionCriteria(
						workItemIDChunk, false, PKEY, SystemFields.RELEASE);
				try {
					releaseBeanList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
				} catch(Exception e) {
					LOGGER.error("Loading the old history releaseBeans for workItems failed with " + e.getMessage());
				}
				
			}
		}		
		return GeneralUtils.createMapFromList(releaseBeanList);
	}
	
	private static List<TReleaseBean> convertTorqueListToBeanList(List<TRelease> torqueList) {		
		List<TReleaseBean> beanList = new LinkedList<TReleaseBean>();
		if (torqueList!=null){
			for (TRelease tRelease : torqueList) {
				beanList.add(tRelease.getBean());
			}			
		}
		return beanList;
	}
}
