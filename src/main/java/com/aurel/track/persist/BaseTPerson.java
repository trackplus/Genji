/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions

 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* $Id:$ */

package com.aurel.track.persist;


import java.math.BigDecimal;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import org.apache.commons.lang.ObjectUtils;
import org.apache.torque.TorqueException;
import org.apache.torque.map.TableMap;
import org.apache.torque.om.BaseObject;
import org.apache.torque.om.ComboKey;
import org.apache.torque.om.DateKey;
import org.apache.torque.om.NumberKey;
import org.apache.torque.om.ObjectKey;
import org.apache.torque.om.SimpleKey;
import org.apache.torque.om.StringKey;
import org.apache.torque.om.Persistent;
import org.apache.torque.util.Criteria;
import org.apache.torque.util.Transaction;



import com.aurel.track.persist.TDepartment;
import com.aurel.track.persist.TDepartmentPeer;
import com.aurel.track.persist.TPrivateReportRepository;
import com.aurel.track.persist.TPrivateReportRepositoryPeer;
import com.aurel.track.persist.TBLOB;
import com.aurel.track.persist.TBLOBPeer;
import com.aurel.track.persist.TPerson;
import com.aurel.track.persist.TPersonPeer;

  import org.apache.commons.collections.map.IdentityMap;
import java.util.Iterator;
import com.aurel.track.beans.TPersonBean;
import com.aurel.track.beans.TDepartmentBean;
import com.aurel.track.beans.TPrivateReportRepositoryBean;
import com.aurel.track.beans.TBLOBBean;
import com.aurel.track.beans.TPersonBean;

import com.aurel.track.beans.TAccessControlListBean;
import com.aurel.track.beans.TBaseLineBean;
import com.aurel.track.beans.TNotifyBean;
import com.aurel.track.beans.TProjectBean;
import com.aurel.track.beans.TProjectBean;
import com.aurel.track.beans.TStateChangeBean;
import com.aurel.track.beans.TTrailBean;
import com.aurel.track.beans.TWorkItemBean;
import com.aurel.track.beans.TWorkItemBean;
import com.aurel.track.beans.TWorkItemBean;
import com.aurel.track.beans.TWorkItemBean;
import com.aurel.track.beans.TComputedValuesBean;
import com.aurel.track.beans.TPrivateReportRepositoryBean;
import com.aurel.track.beans.TPublicReportRepositoryBean;
import com.aurel.track.beans.TAttachmentBean;
import com.aurel.track.beans.TCostBean;
import com.aurel.track.beans.TWorkFlowBean;
import com.aurel.track.beans.TIssueAttributeValueBean;
import com.aurel.track.beans.TReportLayoutBean;
import com.aurel.track.beans.TSchedulerBean;
import com.aurel.track.beans.TGroupMemberBean;
import com.aurel.track.beans.TGroupMemberBean;
import com.aurel.track.beans.TBudgetBean;
import com.aurel.track.beans.TActualEstimatedBudgetBean;
import com.aurel.track.beans.TDashboardScreenBean;
import com.aurel.track.beans.TDashboardScreenBean;
import com.aurel.track.beans.TFieldBean;
import com.aurel.track.beans.TListBean;
import com.aurel.track.beans.TScreenBean;
import com.aurel.track.beans.TNotifyTriggerBean;
import com.aurel.track.beans.TNotifySettingsBean;
import com.aurel.track.beans.TQueryRepositoryBean;
import com.aurel.track.beans.TWorkItemLinkBean;
import com.aurel.track.beans.TWorkItemLockBean;
import com.aurel.track.beans.TExportTemplateBean;
import com.aurel.track.beans.TLoggedInUsersBean;
import com.aurel.track.beans.TSummaryMailBean;
import com.aurel.track.beans.TSummaryMailBean;
import com.aurel.track.beans.THistoryTransactionBean;
import com.aurel.track.beans.TScriptsBean;
import com.aurel.track.beans.TTemplatePersonBean;
import com.aurel.track.beans.TReportPersonSettingsBean;
import com.aurel.track.beans.TMSProjectExchangeBean;
import com.aurel.track.beans.TFilterCategoryBean;
import com.aurel.track.beans.TReportCategoryBean;
import com.aurel.track.beans.TMenuitemQueryBean;
import com.aurel.track.beans.TPersonBasketBean;
import com.aurel.track.beans.TBasketBean;
import com.aurel.track.beans.TLastVisitedItemBean;
import com.aurel.track.beans.TWorkflowDefBean;
import com.aurel.track.beans.TWorkflowActivityBean;
import com.aurel.track.beans.TWorkflowActivityBean;
import com.aurel.track.beans.TWorkflowGuardBean;
import com.aurel.track.beans.TEscalationEntryBean;
import com.aurel.track.beans.TReadIssueBean;
import com.aurel.track.beans.TLastExecutedQueryBean;
import com.aurel.track.beans.TReportSubscribeBean;
import com.aurel.track.beans.TGridLayoutBean;
import com.aurel.track.beans.TNavigatorLayoutBean;
import com.aurel.track.beans.TMailTextBlockBean;
import com.aurel.track.beans.TPersonInDomainBean;
import com.aurel.track.beans.TAttachmentVersionBean;
import com.aurel.track.beans.TUserFeatureBean;


/**
 * This table holds all user related information, like user name, e-mail, etc.
 *
 * You should not use this class directly.  It should not even be
 * extended all references should be to TPerson
 */
public abstract class BaseTPerson extends TpBaseObject
{
    /** The Peer class */
    private static final TPersonPeer peer =
        new TPersonPeer();


    /** The value for the objectID field */
    private Integer objectID;

    /** The value for the firstName field */
    private String firstName;

    /** The value for the lastName field */
    private String lastName;

    /** The value for the loginName field */
    private String loginName;

    /** The value for the email field */
    private String email;

    /** The value for the passwd field */
    private String passwd;

    /** The value for the salt field */
    private String salt;

    /** The value for the forgotPasswordKey field */
    private String forgotPasswordKey;

    /** The value for the phone field */
    private String phone;

    /** The value for the departmentID field */
    private Integer departmentID;

    /** The value for the validUntil field */
    private Date validUntil;

    /** The value for the preferences field */
    private String preferences;

    /** The value for the lastEdit field */
    private Date lastEdit;

    /** The value for the created field */
    private Date created;

    /** The value for the deleted field */
    private String deleted = "N";

    /** The value for the tokenPasswd field */
    private String tokenPasswd;

    /** The value for the tokenExpDate field */
    private Date tokenExpDate;

    /** The value for the emailFrequency field */
    private Integer emailFrequency;

    /** The value for the emailLead field */
    private Integer emailLead;

    /** The value for the emailLastReminded field */
    private Date emailLastReminded;

    /** The value for the emailRemindMe field */
    private String emailRemindMe = "N";

    /** The value for the prefEmailType field */
    private String prefEmailType = "Plain";

    /** The value for the prefLocale field */
    private String prefLocale;

    /** The value for the myDefaultReport field */
    private Integer myDefaultReport;

    /** The value for the noEmailPlease field */
    private Integer noEmailPlease;

    /** The value for the remindMeAsOriginator field */
    private String remindMeAsOriginator = "N";

    /** The value for the remindMeAsManager field */
    private String remindMeAsManager = "Y";

    /** The value for the remindMeAsResponsible field */
    private String remindMeAsResponsible = "Y";

    /** The value for the emailRemindPriorityLevel field */
    private Integer emailRemindPriorityLevel;

    /** The value for the emailRemindSeverityLevel field */
    private Integer emailRemindSeverityLevel;

    /** The value for the hoursPerWorkDay field */
    private Double hoursPerWorkDay;

    /** The value for the hourlyWage field */
    private Double hourlyWage;

    /** The value for the extraHourWage field */
    private Double extraHourWage;

    /** The value for the employeeID field */
    private String employeeID;

    /** The value for the isgroup field */
    private String isgroup = "N";

    /** The value for the userLevel field */
    private Integer userLevel;

    /** The value for the maxAssignedItems field */
    private Integer maxAssignedItems;

    /** The value for the messengerURL field */
    private String messengerURL;

    /** The value for the cALLURL field */
    private String cALLURL;

    /** The value for the symbol field */
    private String symbol;

    /** The value for the iconKey field */
    private Integer iconKey;

    /** The value for the substituteID field */
    private Integer substituteID;

    /** The value for the substituteActive field */
    private String substituteActive = "N";

    /** The value for the uuid field */
    private String uuid;


    /**
     * Get the ObjectID
     *
     * @return Integer
     */
    public Integer getObjectID()
    {
        return objectID;
    }


    /**
     * Set the value of ObjectID
     *
     * @param v new value
     */
    public void setObjectID(Integer v) throws TorqueException
    {

        if (!ObjectUtils.equals(this.objectID, v))
        {
            this.objectID = v;
            setModified(true);
        }



        // update associated TAccessControlList
        if (collTAccessControlLists != null)
        {
            for (int i = 0; i < collTAccessControlLists.size(); i++)
            {
                ((TAccessControlList) collTAccessControlLists.get(i))
                        .setPersonID(v);
            }
        }

        // update associated TBaseLine
        if (collTBaseLines != null)
        {
            for (int i = 0; i < collTBaseLines.size(); i++)
            {
                ((TBaseLine) collTBaseLines.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TNotify
        if (collTNotifys != null)
        {
            for (int i = 0; i < collTNotifys.size(); i++)
            {
                ((TNotify) collTNotifys.get(i))
                        .setPersonID(v);
            }
        }

        // update associated TProject
        if (collTProjectsRelatedByDefaultOwnerID != null)
        {
            for (int i = 0; i < collTProjectsRelatedByDefaultOwnerID.size(); i++)
            {
                ((TProject) collTProjectsRelatedByDefaultOwnerID.get(i))
                        .setDefaultOwnerID(v);
            }
        }

        // update associated TProject
        if (collTProjectsRelatedByDefaultManagerID != null)
        {
            for (int i = 0; i < collTProjectsRelatedByDefaultManagerID.size(); i++)
            {
                ((TProject) collTProjectsRelatedByDefaultManagerID.get(i))
                        .setDefaultManagerID(v);
            }
        }

        // update associated TStateChange
        if (collTStateChanges != null)
        {
            for (int i = 0; i < collTStateChanges.size(); i++)
            {
                ((TStateChange) collTStateChanges.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TTrail
        if (collTTrails != null)
        {
            for (int i = 0; i < collTTrails.size(); i++)
            {
                ((TTrail) collTTrails.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TWorkItem
        if (collTWorkItemsRelatedByOwnerID != null)
        {
            for (int i = 0; i < collTWorkItemsRelatedByOwnerID.size(); i++)
            {
                ((TWorkItem) collTWorkItemsRelatedByOwnerID.get(i))
                        .setOwnerID(v);
            }
        }

        // update associated TWorkItem
        if (collTWorkItemsRelatedByChangedByID != null)
        {
            for (int i = 0; i < collTWorkItemsRelatedByChangedByID.size(); i++)
            {
                ((TWorkItem) collTWorkItemsRelatedByChangedByID.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TWorkItem
        if (collTWorkItemsRelatedByOriginatorID != null)
        {
            for (int i = 0; i < collTWorkItemsRelatedByOriginatorID.size(); i++)
            {
                ((TWorkItem) collTWorkItemsRelatedByOriginatorID.get(i))
                        .setOriginatorID(v);
            }
        }

        // update associated TWorkItem
        if (collTWorkItemsRelatedByResponsibleID != null)
        {
            for (int i = 0; i < collTWorkItemsRelatedByResponsibleID.size(); i++)
            {
                ((TWorkItem) collTWorkItemsRelatedByResponsibleID.get(i))
                        .setResponsibleID(v);
            }
        }

        // update associated TComputedValues
        if (collTComputedValuess != null)
        {
            for (int i = 0; i < collTComputedValuess.size(); i++)
            {
                ((TComputedValues) collTComputedValuess.get(i))
                        .setPerson(v);
            }
        }

        // update associated TPrivateReportRepository
        if (collTPrivateReportRepositorys != null)
        {
            for (int i = 0; i < collTPrivateReportRepositorys.size(); i++)
            {
                ((TPrivateReportRepository) collTPrivateReportRepositorys.get(i))
                        .setOwnerID(v);
            }
        }

        // update associated TPublicReportRepository
        if (collTPublicReportRepositorys != null)
        {
            for (int i = 0; i < collTPublicReportRepositorys.size(); i++)
            {
                ((TPublicReportRepository) collTPublicReportRepositorys.get(i))
                        .setOwnerID(v);
            }
        }

        // update associated TAttachment
        if (collTAttachments != null)
        {
            for (int i = 0; i < collTAttachments.size(); i++)
            {
                ((TAttachment) collTAttachments.get(i))
                        .setChangedBy(v);
            }
        }

        // update associated TCost
        if (collTCosts != null)
        {
            for (int i = 0; i < collTCosts.size(); i++)
            {
                ((TCost) collTCosts.get(i))
                        .setPerson(v);
            }
        }

        // update associated TWorkFlow
        if (collTWorkFlows != null)
        {
            for (int i = 0; i < collTWorkFlows.size(); i++)
            {
                ((TWorkFlow) collTWorkFlows.get(i))
                        .setResponsible(v);
            }
        }

        // update associated TIssueAttributeValue
        if (collTIssueAttributeValues != null)
        {
            for (int i = 0; i < collTIssueAttributeValues.size(); i++)
            {
                ((TIssueAttributeValue) collTIssueAttributeValues.get(i))
                        .setPerson(v);
            }
        }

        // update associated TReportLayout
        if (collTReportLayouts != null)
        {
            for (int i = 0; i < collTReportLayouts.size(); i++)
            {
                ((TReportLayout) collTReportLayouts.get(i))
                        .setPerson(v);
            }
        }

        // update associated TScheduler
        if (collTSchedulers != null)
        {
            for (int i = 0; i < collTSchedulers.size(); i++)
            {
                ((TScheduler) collTSchedulers.get(i))
                        .setPerson(v);
            }
        }

        // update associated TGroupMember
        if (collTGroupMembersRelatedByTheGroup != null)
        {
            for (int i = 0; i < collTGroupMembersRelatedByTheGroup.size(); i++)
            {
                ((TGroupMember) collTGroupMembersRelatedByTheGroup.get(i))
                        .setTheGroup(v);
            }
        }

        // update associated TGroupMember
        if (collTGroupMembersRelatedByPerson != null)
        {
            for (int i = 0; i < collTGroupMembersRelatedByPerson.size(); i++)
            {
                ((TGroupMember) collTGroupMembersRelatedByPerson.get(i))
                        .setPerson(v);
            }
        }

        // update associated TBudget
        if (collTBudgets != null)
        {
            for (int i = 0; i < collTBudgets.size(); i++)
            {
                ((TBudget) collTBudgets.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TActualEstimatedBudget
        if (collTActualEstimatedBudgets != null)
        {
            for (int i = 0; i < collTActualEstimatedBudgets.size(); i++)
            {
                ((TActualEstimatedBudget) collTActualEstimatedBudgets.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TDashboardScreen
        if (collTDashboardScreensRelatedByPerson != null)
        {
            for (int i = 0; i < collTDashboardScreensRelatedByPerson.size(); i++)
            {
                ((TDashboardScreen) collTDashboardScreensRelatedByPerson.get(i))
                        .setPerson(v);
            }
        }

        // update associated TDashboardScreen
        if (collTDashboardScreensRelatedByOwner != null)
        {
            for (int i = 0; i < collTDashboardScreensRelatedByOwner.size(); i++)
            {
                ((TDashboardScreen) collTDashboardScreensRelatedByOwner.get(i))
                        .setOwner(v);
            }
        }

        // update associated TField
        if (collTFields != null)
        {
            for (int i = 0; i < collTFields.size(); i++)
            {
                ((TField) collTFields.get(i))
                        .setOwner(v);
            }
        }

        // update associated TList
        if (collTLists != null)
        {
            for (int i = 0; i < collTLists.size(); i++)
            {
                ((TList) collTLists.get(i))
                        .setOwner(v);
            }
        }

        // update associated TScreen
        if (collTScreens != null)
        {
            for (int i = 0; i < collTScreens.size(); i++)
            {
                ((TScreen) collTScreens.get(i))
                        .setOwner(v);
            }
        }

        // update associated TNotifyTrigger
        if (collTNotifyTriggers != null)
        {
            for (int i = 0; i < collTNotifyTriggers.size(); i++)
            {
                ((TNotifyTrigger) collTNotifyTriggers.get(i))
                        .setPerson(v);
            }
        }

        // update associated TNotifySettings
        if (collTNotifySettingss != null)
        {
            for (int i = 0; i < collTNotifySettingss.size(); i++)
            {
                ((TNotifySettings) collTNotifySettingss.get(i))
                        .setPerson(v);
            }
        }

        // update associated TQueryRepository
        if (collTQueryRepositorys != null)
        {
            for (int i = 0; i < collTQueryRepositorys.size(); i++)
            {
                ((TQueryRepository) collTQueryRepositorys.get(i))
                        .setPerson(v);
            }
        }

        // update associated TWorkItemLink
        if (collTWorkItemLinks != null)
        {
            for (int i = 0; i < collTWorkItemLinks.size(); i++)
            {
                ((TWorkItemLink) collTWorkItemLinks.get(i))
                        .setChangedBy(v);
            }
        }

        // update associated TWorkItemLock
        if (collTWorkItemLocks != null)
        {
            for (int i = 0; i < collTWorkItemLocks.size(); i++)
            {
                ((TWorkItemLock) collTWorkItemLocks.get(i))
                        .setPerson(v);
            }
        }

        // update associated TExportTemplate
        if (collTExportTemplates != null)
        {
            for (int i = 0; i < collTExportTemplates.size(); i++)
            {
                ((TExportTemplate) collTExportTemplates.get(i))
                        .setPerson(v);
            }
        }

        // update associated TLoggedInUsers
        if (collTLoggedInUserss != null)
        {
            for (int i = 0; i < collTLoggedInUserss.size(); i++)
            {
                ((TLoggedInUsers) collTLoggedInUserss.get(i))
                        .setLoggedUser(v);
            }
        }

        // update associated TSummaryMail
        if (collTSummaryMailsRelatedByPERSONFROM != null)
        {
            for (int i = 0; i < collTSummaryMailsRelatedByPERSONFROM.size(); i++)
            {
                ((TSummaryMail) collTSummaryMailsRelatedByPERSONFROM.get(i))
                        .setPERSONFROM(v);
            }
        }

        // update associated TSummaryMail
        if (collTSummaryMailsRelatedByPERSONTO != null)
        {
            for (int i = 0; i < collTSummaryMailsRelatedByPERSONTO.size(); i++)
            {
                ((TSummaryMail) collTSummaryMailsRelatedByPERSONTO.get(i))
                        .setPERSONTO(v);
            }
        }

        // update associated THistoryTransaction
        if (collTHistoryTransactions != null)
        {
            for (int i = 0; i < collTHistoryTransactions.size(); i++)
            {
                ((THistoryTransaction) collTHistoryTransactions.get(i))
                        .setChangedByID(v);
            }
        }

        // update associated TScripts
        if (collTScriptss != null)
        {
            for (int i = 0; i < collTScriptss.size(); i++)
            {
                ((TScripts) collTScriptss.get(i))
                        .setPerson(v);
            }
        }

        // update associated TTemplatePerson
        if (collTTemplatePersons != null)
        {
            for (int i = 0; i < collTTemplatePersons.size(); i++)
            {
                ((TTemplatePerson) collTTemplatePersons.get(i))
                        .setPerson(v);
            }
        }

        // update associated TReportPersonSettings
        if (collTReportPersonSettingss != null)
        {
            for (int i = 0; i < collTReportPersonSettingss.size(); i++)
            {
                ((TReportPersonSettings) collTReportPersonSettingss.get(i))
                        .setPerson(v);
            }
        }

        // update associated TMSProjectExchange
        if (collTMSProjectExchanges != null)
        {
            for (int i = 0; i < collTMSProjectExchanges.size(); i++)
            {
                ((TMSProjectExchange) collTMSProjectExchanges.get(i))
                        .setChangedBy(v);
            }
        }

        // update associated TFilterCategory
        if (collTFilterCategorys != null)
        {
            for (int i = 0; i < collTFilterCategorys.size(); i++)
            {
                ((TFilterCategory) collTFilterCategorys.get(i))
                        .setCreatedBy(v);
            }
        }

        // update associated TReportCategory
        if (collTReportCategorys != null)
        {
            for (int i = 0; i < collTReportCategorys.size(); i++)
            {
                ((TReportCategory) collTReportCategorys.get(i))
                        .setCreatedBy(v);
            }
        }

        // update associated TMenuitemQuery
        if (collTMenuitemQuerys != null)
        {
            for (int i = 0; i < collTMenuitemQuerys.size(); i++)
            {
                ((TMenuitemQuery) collTMenuitemQuerys.get(i))
                        .setPerson(v);
            }
        }

        // update associated TPersonBasket
        if (collTPersonBaskets != null)
        {
            for (int i = 0; i < collTPersonBaskets.size(); i++)
            {
                ((TPersonBasket) collTPersonBaskets.get(i))
                        .setPerson(v);
            }
        }

        // update associated TBasket
        if (collTBaskets != null)
        {
            for (int i = 0; i < collTBaskets.size(); i++)
            {
                ((TBasket) collTBaskets.get(i))
                        .setPerson(v);
            }
        }

        // update associated TLastVisitedItem
        if (collTLastVisitedItems != null)
        {
            for (int i = 0; i < collTLastVisitedItems.size(); i++)
            {
                ((TLastVisitedItem) collTLastVisitedItems.get(i))
                        .setPerson(v);
            }
        }

        // update associated TWorkflowDef
        if (collTWorkflowDefs != null)
        {
            for (int i = 0; i < collTWorkflowDefs.size(); i++)
            {
                ((TWorkflowDef) collTWorkflowDefs.get(i))
                        .setOwner(v);
            }
        }

        // update associated TWorkflowActivity
        if (collTWorkflowActivitysRelatedByNewMan != null)
        {
            for (int i = 0; i < collTWorkflowActivitysRelatedByNewMan.size(); i++)
            {
                ((TWorkflowActivity) collTWorkflowActivitysRelatedByNewMan.get(i))
                        .setNewMan(v);
            }
        }

        // update associated TWorkflowActivity
        if (collTWorkflowActivitysRelatedByNewResp != null)
        {
            for (int i = 0; i < collTWorkflowActivitysRelatedByNewResp.size(); i++)
            {
                ((TWorkflowActivity) collTWorkflowActivitysRelatedByNewResp.get(i))
                        .setNewResp(v);
            }
        }

        // update associated TWorkflowGuard
        if (collTWorkflowGuards != null)
        {
            for (int i = 0; i < collTWorkflowGuards.size(); i++)
            {
                ((TWorkflowGuard) collTWorkflowGuards.get(i))
                        .setPerson(v);
            }
        }

        // update associated TEscalationEntry
        if (collTEscalationEntrys != null)
        {
            for (int i = 0; i < collTEscalationEntrys.size(); i++)
            {
                ((TEscalationEntry) collTEscalationEntrys.get(i))
                        .setEscalateTo(v);
            }
        }

        // update associated TReadIssue
        if (collTReadIssues != null)
        {
            for (int i = 0; i < collTReadIssues.size(); i++)
            {
                ((TReadIssue) collTReadIssues.get(i))
                        .setPerson(v);
            }
        }

        // update associated TLastExecutedQuery
        if (collTLastExecutedQuerys != null)
        {
            for (int i = 0; i < collTLastExecutedQuerys.size(); i++)
            {
                ((TLastExecutedQuery) collTLastExecutedQuerys.get(i))
                        .setPerson(v);
            }
        }

        // update associated TReportSubscribe
        if (collTReportSubscribes != null)
        {
            for (int i = 0; i < collTReportSubscribes.size(); i++)
            {
                ((TReportSubscribe) collTReportSubscribes.get(i))
                        .setPerson(v);
            }
        }

        // update associated TGridLayout
        if (collTGridLayouts != null)
        {
            for (int i = 0; i < collTGridLayouts.size(); i++)
            {
                ((TGridLayout) collTGridLayouts.get(i))
                        .setPerson(v);
            }
        }

        // update associated TNavigatorLayout
        if (collTNavigatorLayouts != null)
        {
            for (int i = 0; i < collTNavigatorLayouts.size(); i++)
            {
                ((TNavigatorLayout) collTNavigatorLayouts.get(i))
                        .setPerson(v);
            }
        }

        // update associated TMailTextBlock
        if (collTMailTextBlocks != null)
        {
            for (int i = 0; i < collTMailTextBlocks.size(); i++)
            {
                ((TMailTextBlock) collTMailTextBlocks.get(i))
                        .setPerson(v);
            }
        }

        // update associated TPersonInDomain
        if (collTPersonInDomains != null)
        {
            for (int i = 0; i < collTPersonInDomains.size(); i++)
            {
                ((TPersonInDomain) collTPersonInDomains.get(i))
                        .setPerson(v);
            }
        }

        // update associated TAttachmentVersion
        if (collTAttachmentVersions != null)
        {
            for (int i = 0; i < collTAttachmentVersions.size(); i++)
            {
                ((TAttachmentVersion) collTAttachmentVersions.get(i))
                        .setChangedBy(v);
            }
        }

        // update associated TUserFeature
        if (collTUserFeatures != null)
        {
            for (int i = 0; i < collTUserFeatures.size(); i++)
            {
                ((TUserFeature) collTUserFeatures.get(i))
                        .setPerson(v);
            }
        }
    }

    /**
     * Get the FirstName
     *
     * @return String
     */
    public String getFirstName()
    {
        return firstName;
    }


    /**
     * Set the value of FirstName
     *
     * @param v new value
     */
    public void setFirstName(String v) 
    {

        if (!ObjectUtils.equals(this.firstName, v))
        {
            this.firstName = v;
            setModified(true);
        }


    }

    /**
     * Get the LastName
     *
     * @return String
     */
    public String getLastName()
    {
        return lastName;
    }


    /**
     * Set the value of LastName
     *
     * @param v new value
     */
    public void setLastName(String v) 
    {

        if (!ObjectUtils.equals(this.lastName, v))
        {
            this.lastName = v;
            setModified(true);
        }


    }

    /**
     * Get the LoginName
     *
     * @return String
     */
    public String getLoginName()
    {
        return loginName;
    }


    /**
     * Set the value of LoginName
     *
     * @param v new value
     */
    public void setLoginName(String v) 
    {

        if (!ObjectUtils.equals(this.loginName, v))
        {
            this.loginName = v;
            setModified(true);
        }


    }

    /**
     * Get the Email
     *
     * @return String
     */
    public String getEmail()
    {
        return email;
    }


    /**
     * Set the value of Email
     *
     * @param v new value
     */
    public void setEmail(String v) 
    {

        if (!ObjectUtils.equals(this.email, v))
        {
            this.email = v;
            setModified(true);
        }


    }

    /**
     * Get the Passwd
     *
     * @return String
     */
    public String getPasswd()
    {
        return passwd;
    }


    /**
     * Set the value of Passwd
     *
     * @param v new value
     */
    public void setPasswd(String v) 
    {

        if (!ObjectUtils.equals(this.passwd, v))
        {
            this.passwd = v;
            setModified(true);
        }


    }

    /**
     * Get the Salt
     *
     * @return String
     */
    public String getSalt()
    {
        return salt;
    }


    /**
     * Set the value of Salt
     *
     * @param v new value
     */
    public void setSalt(String v) 
    {

        if (!ObjectUtils.equals(this.salt, v))
        {
            this.salt = v;
            setModified(true);
        }


    }

    /**
     * Get the ForgotPasswordKey
     *
     * @return String
     */
    public String getForgotPasswordKey()
    {
        return forgotPasswordKey;
    }


    /**
     * Set the value of ForgotPasswordKey
     *
     * @param v new value
     */
    public void setForgotPasswordKey(String v) 
    {

        if (!ObjectUtils.equals(this.forgotPasswordKey, v))
        {
            this.forgotPasswordKey = v;
            setModified(true);
        }


    }

    /**
     * Get the Phone
     *
     * @return String
     */
    public String getPhone()
    {
        return phone;
    }


    /**
     * Set the value of Phone
     *
     * @param v new value
     */
    public void setPhone(String v) 
    {

        if (!ObjectUtils.equals(this.phone, v))
        {
            this.phone = v;
            setModified(true);
        }


    }

    /**
     * Get the DepartmentID
     *
     * @return Integer
     */
    public Integer getDepartmentID()
    {
        return departmentID;
    }


    /**
     * Set the value of DepartmentID
     *
     * @param v new value
     */
    public void setDepartmentID(Integer v) throws TorqueException
    {

        if (!ObjectUtils.equals(this.departmentID, v))
        {
            this.departmentID = v;
            setModified(true);
        }


        if (aTDepartment != null && !ObjectUtils.equals(aTDepartment.getObjectID(), v))
        {
            aTDepartment = null;
        }

    }

    /**
     * Get the ValidUntil
     *
     * @return Date
     */
    public Date getValidUntil()
    {
        return validUntil;
    }


    /**
     * Set the value of ValidUntil
     *
     * @param v new value
     */
    public void setValidUntil(Date v) 
    {

        if (!ObjectUtils.equals(this.validUntil, v))
        {
            this.validUntil = v;
            setModified(true);
        }


    }

    /**
     * Get the Preferences
     *
     * @return String
     */
    public String getPreferences()
    {
        return preferences;
    }


    /**
     * Set the value of Preferences
     *
     * @param v new value
     */
    public void setPreferences(String v) 
    {

        if (!ObjectUtils.equals(this.preferences, v))
        {
            this.preferences = v;
            setModified(true);
        }


    }

    /**
     * Get the LastEdit
     *
     * @return Date
     */
    public Date getLastEdit()
    {
        return lastEdit;
    }


    /**
     * Set the value of LastEdit
     *
     * @param v new value
     */
    public void setLastEdit(Date v) 
    {

        if (!ObjectUtils.equals(this.lastEdit, v))
        {
            this.lastEdit = v;
            setModified(true);
        }


    }

    /**
     * Get the Created
     *
     * @return Date
     */
    public Date getCreated()
    {
        return created;
    }


    /**
     * Set the value of Created
     *
     * @param v new value
     */
    public void setCreated(Date v) 
    {

        if (!ObjectUtils.equals(this.created, v))
        {
            this.created = v;
            setModified(true);
        }


    }

    /**
     * Get the Deleted
     *
     * @return String
     */
    public String getDeleted()
    {
        return deleted;
    }


    /**
     * Set the value of Deleted
     *
     * @param v new value
     */
    public void setDeleted(String v) 
    {

        if (!ObjectUtils.equals(this.deleted, v))
        {
            this.deleted = v;
            setModified(true);
        }


    }

    /**
     * Get the TokenPasswd
     *
     * @return String
     */
    public String getTokenPasswd()
    {
        return tokenPasswd;
    }


    /**
     * Set the value of TokenPasswd
     *
     * @param v new value
     */
    public void setTokenPasswd(String v) 
    {

        if (!ObjectUtils.equals(this.tokenPasswd, v))
        {
            this.tokenPasswd = v;
            setModified(true);
        }


    }

    /**
     * Get the TokenExpDate
     *
     * @return Date
     */
    public Date getTokenExpDate()
    {
        return tokenExpDate;
    }


    /**
     * Set the value of TokenExpDate
     *
     * @param v new value
     */
    public void setTokenExpDate(Date v) 
    {

        if (!ObjectUtils.equals(this.tokenExpDate, v))
        {
            this.tokenExpDate = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailFrequency
     *
     * @return Integer
     */
    public Integer getEmailFrequency()
    {
        return emailFrequency;
    }


    /**
     * Set the value of EmailFrequency
     *
     * @param v new value
     */
    public void setEmailFrequency(Integer v) 
    {

        if (!ObjectUtils.equals(this.emailFrequency, v))
        {
            this.emailFrequency = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailLead
     *
     * @return Integer
     */
    public Integer getEmailLead()
    {
        return emailLead;
    }


    /**
     * Set the value of EmailLead
     *
     * @param v new value
     */
    public void setEmailLead(Integer v) 
    {

        if (!ObjectUtils.equals(this.emailLead, v))
        {
            this.emailLead = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailLastReminded
     *
     * @return Date
     */
    public Date getEmailLastReminded()
    {
        return emailLastReminded;
    }


    /**
     * Set the value of EmailLastReminded
     *
     * @param v new value
     */
    public void setEmailLastReminded(Date v) 
    {

        if (!ObjectUtils.equals(this.emailLastReminded, v))
        {
            this.emailLastReminded = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailRemindMe
     *
     * @return String
     */
    public String getEmailRemindMe()
    {
        return emailRemindMe;
    }


    /**
     * Set the value of EmailRemindMe
     *
     * @param v new value
     */
    public void setEmailRemindMe(String v) 
    {

        if (!ObjectUtils.equals(this.emailRemindMe, v))
        {
            this.emailRemindMe = v;
            setModified(true);
        }


    }

    /**
     * Get the PrefEmailType
     *
     * @return String
     */
    public String getPrefEmailType()
    {
        return prefEmailType;
    }


    /**
     * Set the value of PrefEmailType
     *
     * @param v new value
     */
    public void setPrefEmailType(String v) 
    {

        if (!ObjectUtils.equals(this.prefEmailType, v))
        {
            this.prefEmailType = v;
            setModified(true);
        }


    }

    /**
     * Get the PrefLocale
     *
     * @return String
     */
    public String getPrefLocale()
    {
        return prefLocale;
    }


    /**
     * Set the value of PrefLocale
     *
     * @param v new value
     */
    public void setPrefLocale(String v) 
    {

        if (!ObjectUtils.equals(this.prefLocale, v))
        {
            this.prefLocale = v;
            setModified(true);
        }


    }

    /**
     * Get the MyDefaultReport
     *
     * @return Integer
     */
    public Integer getMyDefaultReport()
    {
        return myDefaultReport;
    }


    /**
     * Set the value of MyDefaultReport
     *
     * @param v new value
     */
    public void setMyDefaultReport(Integer v) throws TorqueException
    {

        if (!ObjectUtils.equals(this.myDefaultReport, v))
        {
            this.myDefaultReport = v;
            setModified(true);
        }


        if (aTPrivateReportRepository != null && !ObjectUtils.equals(aTPrivateReportRepository.getObjectID(), v))
        {
            aTPrivateReportRepository = null;
        }

    }

    /**
     * Get the NoEmailPlease
     *
     * @return Integer
     */
    public Integer getNoEmailPlease()
    {
        return noEmailPlease;
    }


    /**
     * Set the value of NoEmailPlease
     *
     * @param v new value
     */
    public void setNoEmailPlease(Integer v) 
    {

        if (!ObjectUtils.equals(this.noEmailPlease, v))
        {
            this.noEmailPlease = v;
            setModified(true);
        }


    }

    /**
     * Get the RemindMeAsOriginator
     *
     * @return String
     */
    public String getRemindMeAsOriginator()
    {
        return remindMeAsOriginator;
    }


    /**
     * Set the value of RemindMeAsOriginator
     *
     * @param v new value
     */
    public void setRemindMeAsOriginator(String v) 
    {

        if (!ObjectUtils.equals(this.remindMeAsOriginator, v))
        {
            this.remindMeAsOriginator = v;
            setModified(true);
        }


    }

    /**
     * Get the RemindMeAsManager
     *
     * @return String
     */
    public String getRemindMeAsManager()
    {
        return remindMeAsManager;
    }


    /**
     * Set the value of RemindMeAsManager
     *
     * @param v new value
     */
    public void setRemindMeAsManager(String v) 
    {

        if (!ObjectUtils.equals(this.remindMeAsManager, v))
        {
            this.remindMeAsManager = v;
            setModified(true);
        }


    }

    /**
     * Get the RemindMeAsResponsible
     *
     * @return String
     */
    public String getRemindMeAsResponsible()
    {
        return remindMeAsResponsible;
    }


    /**
     * Set the value of RemindMeAsResponsible
     *
     * @param v new value
     */
    public void setRemindMeAsResponsible(String v) 
    {

        if (!ObjectUtils.equals(this.remindMeAsResponsible, v))
        {
            this.remindMeAsResponsible = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailRemindPriorityLevel
     *
     * @return Integer
     */
    public Integer getEmailRemindPriorityLevel()
    {
        return emailRemindPriorityLevel;
    }


    /**
     * Set the value of EmailRemindPriorityLevel
     *
     * @param v new value
     */
    public void setEmailRemindPriorityLevel(Integer v) 
    {

        if (!ObjectUtils.equals(this.emailRemindPriorityLevel, v))
        {
            this.emailRemindPriorityLevel = v;
            setModified(true);
        }


    }

    /**
     * Get the EmailRemindSeverityLevel
     *
     * @return Integer
     */
    public Integer getEmailRemindSeverityLevel()
    {
        return emailRemindSeverityLevel;
    }


    /**
     * Set the value of EmailRemindSeverityLevel
     *
     * @param v new value
     */
    public void setEmailRemindSeverityLevel(Integer v) 
    {

        if (!ObjectUtils.equals(this.emailRemindSeverityLevel, v))
        {
            this.emailRemindSeverityLevel = v;
            setModified(true);
        }


    }

    /**
     * Get the HoursPerWorkDay
     *
     * @return Double
     */
    public Double getHoursPerWorkDay()
    {
        return hoursPerWorkDay;
    }


    /**
     * Set the value of HoursPerWorkDay
     *
     * @param v new value
     */
    public void setHoursPerWorkDay(Double v) 
    {

        if (!ObjectUtils.equals(this.hoursPerWorkDay, v))
        {
            this.hoursPerWorkDay = v;
            setModified(true);
        }


    }

    /**
     * Get the HourlyWage
     *
     * @return Double
     */
    public Double getHourlyWage()
    {
        return hourlyWage;
    }


    /**
     * Set the value of HourlyWage
     *
     * @param v new value
     */
    public void setHourlyWage(Double v) 
    {

        if (!ObjectUtils.equals(this.hourlyWage, v))
        {
            this.hourlyWage = v;
            setModified(true);
        }


    }

    /**
     * Get the ExtraHourWage
     *
     * @return Double
     */
    public Double getExtraHourWage()
    {
        return extraHourWage;
    }


    /**
     * Set the value of ExtraHourWage
     *
     * @param v new value
     */
    public void setExtraHourWage(Double v) 
    {

        if (!ObjectUtils.equals(this.extraHourWage, v))
        {
            this.extraHourWage = v;
            setModified(true);
        }


    }

    /**
     * Get the EmployeeID
     *
     * @return String
     */
    public String getEmployeeID()
    {
        return employeeID;
    }


    /**
     * Set the value of EmployeeID
     *
     * @param v new value
     */
    public void setEmployeeID(String v) 
    {

        if (!ObjectUtils.equals(this.employeeID, v))
        {
            this.employeeID = v;
            setModified(true);
        }


    }

    /**
     * Get the Isgroup
     *
     * @return String
     */
    public String getIsgroup()
    {
        return isgroup;
    }


    /**
     * Set the value of Isgroup
     *
     * @param v new value
     */
    public void setIsgroup(String v) 
    {

        if (!ObjectUtils.equals(this.isgroup, v))
        {
            this.isgroup = v;
            setModified(true);
        }


    }

    /**
     * Get the UserLevel
     *
     * @return Integer
     */
    public Integer getUserLevel()
    {
        return userLevel;
    }


    /**
     * Set the value of UserLevel
     *
     * @param v new value
     */
    public void setUserLevel(Integer v) 
    {

        if (!ObjectUtils.equals(this.userLevel, v))
        {
            this.userLevel = v;
            setModified(true);
        }


    }

    /**
     * Get the MaxAssignedItems
     *
     * @return Integer
     */
    public Integer getMaxAssignedItems()
    {
        return maxAssignedItems;
    }


    /**
     * Set the value of MaxAssignedItems
     *
     * @param v new value
     */
    public void setMaxAssignedItems(Integer v) 
    {

        if (!ObjectUtils.equals(this.maxAssignedItems, v))
        {
            this.maxAssignedItems = v;
            setModified(true);
        }


    }

    /**
     * Get the MessengerURL
     *
     * @return String
     */
    public String getMessengerURL()
    {
        return messengerURL;
    }


    /**
     * Set the value of MessengerURL
     *
     * @param v new value
     */
    public void setMessengerURL(String v) 
    {

        if (!ObjectUtils.equals(this.messengerURL, v))
        {
            this.messengerURL = v;
            setModified(true);
        }


    }

    /**
     * Get the CALLURL
     *
     * @return String
     */
    public String getCALLURL()
    {
        return cALLURL;
    }


    /**
     * Set the value of CALLURL
     *
     * @param v new value
     */
    public void setCALLURL(String v) 
    {

        if (!ObjectUtils.equals(this.cALLURL, v))
        {
            this.cALLURL = v;
            setModified(true);
        }


    }

    /**
     * Get the Symbol
     *
     * @return String
     */
    public String getSymbol()
    {
        return symbol;
    }


    /**
     * Set the value of Symbol
     *
     * @param v new value
     */
    public void setSymbol(String v) 
    {

        if (!ObjectUtils.equals(this.symbol, v))
        {
            this.symbol = v;
            setModified(true);
        }


    }

    /**
     * Get the IconKey
     *
     * @return Integer
     */
    public Integer getIconKey()
    {
        return iconKey;
    }


    /**
     * Set the value of IconKey
     *
     * @param v new value
     */
    public void setIconKey(Integer v) throws TorqueException
    {

        if (!ObjectUtils.equals(this.iconKey, v))
        {
            this.iconKey = v;
            setModified(true);
        }


        if (aTBLOB != null && !ObjectUtils.equals(aTBLOB.getObjectID(), v))
        {
            aTBLOB = null;
        }

    }

    /**
     * Get the SubstituteID
     *
     * @return Integer
     */
    public Integer getSubstituteID()
    {
        return substituteID;
    }


    /**
     * Set the value of SubstituteID
     *
     * @param v new value
     */
    public void setSubstituteID(Integer v) throws TorqueException
    {

        if (!ObjectUtils.equals(this.substituteID, v))
        {
            this.substituteID = v;
            setModified(true);
        }


        if (aTPersonRelatedBySubstituteID != null && !ObjectUtils.equals(aTPersonRelatedBySubstituteID.getObjectID(), v))
        {
            aTPersonRelatedBySubstituteID = null;
        }

    }

    /**
     * Get the SubstituteActive
     *
     * @return String
     */
    public String getSubstituteActive()
    {
        return substituteActive;
    }


    /**
     * Set the value of SubstituteActive
     *
     * @param v new value
     */
    public void setSubstituteActive(String v) 
    {

        if (!ObjectUtils.equals(this.substituteActive, v))
        {
            this.substituteActive = v;
            setModified(true);
        }


    }

    /**
     * Get the Uuid
     *
     * @return String
     */
    public String getUuid()
    {
        return uuid;
    }


    /**
     * Set the value of Uuid
     *
     * @param v new value
     */
    public void setUuid(String v) 
    {

        if (!ObjectUtils.equals(this.uuid, v))
        {
            this.uuid = v;
            setModified(true);
        }


    }

    



    private TDepartment aTDepartment;

    /**
     * Declares an association between this object and a TDepartment object
     *
     * @param v TDepartment
     * @throws TorqueException
     */
    public void setTDepartment(TDepartment v) throws TorqueException
    {
        if (v == null)
        {
            setDepartmentID((Integer) null);
        }
        else
        {
            setDepartmentID(v.getObjectID());
        }
        aTDepartment = v;
    }


    /**
     * Returns the associated TDepartment object.
     * If it was not retrieved before, the object is retrieved from
     * the database
     *
     * @return the associated TDepartment object
     * @throws TorqueException
     */
    public TDepartment getTDepartment()
        throws TorqueException
    {
        if (aTDepartment == null && (!ObjectUtils.equals(this.departmentID, null)))
        {
            aTDepartment = TDepartmentPeer.retrieveByPK(SimpleKey.keyFor(this.departmentID));
        }
        return aTDepartment;
    }

    /**
     * Return the associated TDepartment object
     * If it was not retrieved before, the object is retrieved from
     * the database using the passed connection
     *
     * @param connection the connection used to retrieve the associated object
     *        from the database, if it was not retrieved before
     * @return the associated TDepartment object
     * @throws TorqueException
     */
    public TDepartment getTDepartment(Connection connection)
        throws TorqueException
    {
        if (aTDepartment == null && (!ObjectUtils.equals(this.departmentID, null)))
        {
            aTDepartment = TDepartmentPeer.retrieveByPK(SimpleKey.keyFor(this.departmentID), connection);
        }
        return aTDepartment;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * ObjectKey, for example
     * <code>bar.setFooKey(foo.getPrimaryKey())</code>
     *
     */
    public void setTDepartmentKey(ObjectKey key) throws TorqueException
    {

        setDepartmentID(new Integer(((NumberKey) key).intValue()));
    }




    private TPrivateReportRepository aTPrivateReportRepository;

    /**
     * Declares an association between this object and a TPrivateReportRepository object
     *
     * @param v TPrivateReportRepository
     * @throws TorqueException
     */
    public void setTPrivateReportRepository(TPrivateReportRepository v) throws TorqueException
    {
        if (v == null)
        {
            setMyDefaultReport((Integer) null);
        }
        else
        {
            setMyDefaultReport(v.getObjectID());
        }
        aTPrivateReportRepository = v;
    }


    /**
     * Returns the associated TPrivateReportRepository object.
     * If it was not retrieved before, the object is retrieved from
     * the database
     *
     * @return the associated TPrivateReportRepository object
     * @throws TorqueException
     */
    public TPrivateReportRepository getTPrivateReportRepository()
        throws TorqueException
    {
        if (aTPrivateReportRepository == null && (!ObjectUtils.equals(this.myDefaultReport, null)))
        {
            aTPrivateReportRepository = TPrivateReportRepositoryPeer.retrieveByPK(SimpleKey.keyFor(this.myDefaultReport));
        }
        return aTPrivateReportRepository;
    }

    /**
     * Return the associated TPrivateReportRepository object
     * If it was not retrieved before, the object is retrieved from
     * the database using the passed connection
     *
     * @param connection the connection used to retrieve the associated object
     *        from the database, if it was not retrieved before
     * @return the associated TPrivateReportRepository object
     * @throws TorqueException
     */
    public TPrivateReportRepository getTPrivateReportRepository(Connection connection)
        throws TorqueException
    {
        if (aTPrivateReportRepository == null && (!ObjectUtils.equals(this.myDefaultReport, null)))
        {
            aTPrivateReportRepository = TPrivateReportRepositoryPeer.retrieveByPK(SimpleKey.keyFor(this.myDefaultReport), connection);
        }
        return aTPrivateReportRepository;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * ObjectKey, for example
     * <code>bar.setFooKey(foo.getPrimaryKey())</code>
     *
     */
    public void setTPrivateReportRepositoryKey(ObjectKey key) throws TorqueException
    {

        setMyDefaultReport(new Integer(((NumberKey) key).intValue()));
    }




    private TBLOB aTBLOB;

    /**
     * Declares an association between this object and a TBLOB object
     *
     * @param v TBLOB
     * @throws TorqueException
     */
    public void setTBLOB(TBLOB v) throws TorqueException
    {
        if (v == null)
        {
            setIconKey((Integer) null);
        }
        else
        {
            setIconKey(v.getObjectID());
        }
        aTBLOB = v;
    }


    /**
     * Returns the associated TBLOB object.
     * If it was not retrieved before, the object is retrieved from
     * the database
     *
     * @return the associated TBLOB object
     * @throws TorqueException
     */
    public TBLOB getTBLOB()
        throws TorqueException
    {
        if (aTBLOB == null && (!ObjectUtils.equals(this.iconKey, null)))
        {
            aTBLOB = TBLOBPeer.retrieveByPK(SimpleKey.keyFor(this.iconKey));
        }
        return aTBLOB;
    }

    /**
     * Return the associated TBLOB object
     * If it was not retrieved before, the object is retrieved from
     * the database using the passed connection
     *
     * @param connection the connection used to retrieve the associated object
     *        from the database, if it was not retrieved before
     * @return the associated TBLOB object
     * @throws TorqueException
     */
    public TBLOB getTBLOB(Connection connection)
        throws TorqueException
    {
        if (aTBLOB == null && (!ObjectUtils.equals(this.iconKey, null)))
        {
            aTBLOB = TBLOBPeer.retrieveByPK(SimpleKey.keyFor(this.iconKey), connection);
        }
        return aTBLOB;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * ObjectKey, for example
     * <code>bar.setFooKey(foo.getPrimaryKey())</code>
     *
     */
    public void setTBLOBKey(ObjectKey key) throws TorqueException
    {

        setIconKey(new Integer(((NumberKey) key).intValue()));
    }




    private TPerson aTPersonRelatedBySubstituteID;

    /**
     * Declares an association between this object and a TPerson object
     *
     * @param v TPerson
     * @throws TorqueException
     */
    public void setTPersonRelatedBySubstituteID(TPerson v) throws TorqueException
    {
        if (v == null)
        {
            setSubstituteID((Integer) null);
        }
        else
        {
            setSubstituteID(v.getObjectID());
        }
        aTPersonRelatedBySubstituteID = v;
    }


    /**
     * Returns the associated TPerson object.
     * If it was not retrieved before, the object is retrieved from
     * the database
     *
     * @return the associated TPerson object
     * @throws TorqueException
     */
    public TPerson getTPersonRelatedBySubstituteID()
        throws TorqueException
    {
        if (aTPersonRelatedBySubstituteID == null && (!ObjectUtils.equals(this.substituteID, null)))
        {
            aTPersonRelatedBySubstituteID = TPersonPeer.retrieveByPK(SimpleKey.keyFor(this.substituteID));
        }
        return aTPersonRelatedBySubstituteID;
    }

    /**
     * Return the associated TPerson object
     * If it was not retrieved before, the object is retrieved from
     * the database using the passed connection
     *
     * @param connection the connection used to retrieve the associated object
     *        from the database, if it was not retrieved before
     * @return the associated TPerson object
     * @throws TorqueException
     */
    public TPerson getTPersonRelatedBySubstituteID(Connection connection)
        throws TorqueException
    {
        if (aTPersonRelatedBySubstituteID == null && (!ObjectUtils.equals(this.substituteID, null)))
        {
            aTPersonRelatedBySubstituteID = TPersonPeer.retrieveByPK(SimpleKey.keyFor(this.substituteID), connection);
        }
        return aTPersonRelatedBySubstituteID;
    }

    /**
     * Provides convenient way to set a relationship based on a
     * ObjectKey, for example
     * <code>bar.setFooKey(foo.getPrimaryKey())</code>
     *
     */
    public void setTPersonRelatedBySubstituteIDKey(ObjectKey key) throws TorqueException
    {

        setSubstituteID(new Integer(((NumberKey) key).intValue()));
    }
   


    /**
     * Collection to store aggregation of collTAccessControlLists
     */
    protected List<TAccessControlList> collTAccessControlLists;

    /**
     * Temporary storage of collTAccessControlLists to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTAccessControlLists()
    {
        if (collTAccessControlLists == null)
        {
            collTAccessControlLists = new ArrayList<TAccessControlList>();
        }
    }


    /**
     * Method called to associate a TAccessControlList object to this object
     * through the TAccessControlList foreign key attribute
     *
     * @param l TAccessControlList
     * @throws TorqueException
     */
    public void addTAccessControlList(TAccessControlList l) throws TorqueException
    {
        getTAccessControlLists().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TAccessControlList object to this object
     * through the TAccessControlList foreign key attribute using connection.
     *
     * @param l TAccessControlList
     * @throws TorqueException
     */
    public void addTAccessControlList(TAccessControlList l, Connection con) throws TorqueException
    {
        getTAccessControlLists(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTAccessControlLists
     */
    private Criteria lastTAccessControlListsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAccessControlLists(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TAccessControlList> getTAccessControlLists()
        throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            collTAccessControlLists = getTAccessControlLists(new Criteria(10));
        }
        return collTAccessControlLists;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAccessControlLists from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TAccessControlList> getTAccessControlLists(Criteria criteria) throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            if (isNew())
            {
               collTAccessControlLists = new ArrayList<TAccessControlList>();
            }
            else
            {
                criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID() );
                collTAccessControlLists = TAccessControlListPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                if (!lastTAccessControlListsCriteria.equals(criteria))
                {
                    collTAccessControlLists = TAccessControlListPeer.doSelect(criteria);
                }
            }
        }
        lastTAccessControlListsCriteria = criteria;

        return collTAccessControlLists;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAccessControlLists(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAccessControlList> getTAccessControlLists(Connection con) throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            collTAccessControlLists = getTAccessControlLists(new Criteria(10), con);
        }
        return collTAccessControlLists;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAccessControlLists from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAccessControlList> getTAccessControlLists(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            if (isNew())
            {
               collTAccessControlLists = new ArrayList<TAccessControlList>();
            }
            else
            {
                 criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                 collTAccessControlLists = TAccessControlListPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                 if (!lastTAccessControlListsCriteria.equals(criteria))
                 {
                     collTAccessControlLists = TAccessControlListPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTAccessControlListsCriteria = criteria;

         return collTAccessControlLists;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAccessControlLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAccessControlList> getTAccessControlListsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            if (isNew())
            {
               collTAccessControlLists = new ArrayList<TAccessControlList>();
            }
            else
            {
                criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
            if (!lastTAccessControlListsCriteria.equals(criteria))
            {
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTAccessControlListsCriteria = criteria;

        return collTAccessControlLists;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAccessControlLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAccessControlList> getTAccessControlListsJoinTRole(Criteria criteria)
        throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            if (isNew())
            {
               collTAccessControlLists = new ArrayList<TAccessControlList>();
            }
            else
            {
                criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTRole(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
            if (!lastTAccessControlListsCriteria.equals(criteria))
            {
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTRole(criteria);
            }
        }
        lastTAccessControlListsCriteria = criteria;

        return collTAccessControlLists;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAccessControlLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAccessControlList> getTAccessControlListsJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTAccessControlLists == null)
        {
            if (isNew())
            {
               collTAccessControlLists = new ArrayList<TAccessControlList>();
            }
            else
            {
                criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAccessControlListPeer.PERSONKEY, getObjectID());
            if (!lastTAccessControlListsCriteria.equals(criteria))
            {
                collTAccessControlLists = TAccessControlListPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTAccessControlListsCriteria = criteria;

        return collTAccessControlLists;
    }





    /**
     * Collection to store aggregation of collTBaseLines
     */
    protected List<TBaseLine> collTBaseLines;

    /**
     * Temporary storage of collTBaseLines to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTBaseLines()
    {
        if (collTBaseLines == null)
        {
            collTBaseLines = new ArrayList<TBaseLine>();
        }
    }


    /**
     * Method called to associate a TBaseLine object to this object
     * through the TBaseLine foreign key attribute
     *
     * @param l TBaseLine
     * @throws TorqueException
     */
    public void addTBaseLine(TBaseLine l) throws TorqueException
    {
        getTBaseLines().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TBaseLine object to this object
     * through the TBaseLine foreign key attribute using connection.
     *
     * @param l TBaseLine
     * @throws TorqueException
     */
    public void addTBaseLine(TBaseLine l, Connection con) throws TorqueException
    {
        getTBaseLines(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTBaseLines
     */
    private Criteria lastTBaseLinesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBaseLines(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TBaseLine> getTBaseLines()
        throws TorqueException
    {
        if (collTBaseLines == null)
        {
            collTBaseLines = getTBaseLines(new Criteria(10));
        }
        return collTBaseLines;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBaseLines from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TBaseLine> getTBaseLines(Criteria criteria) throws TorqueException
    {
        if (collTBaseLines == null)
        {
            if (isNew())
            {
               collTBaseLines = new ArrayList<TBaseLine>();
            }
            else
            {
                criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID() );
                collTBaseLines = TBaseLinePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
                if (!lastTBaseLinesCriteria.equals(criteria))
                {
                    collTBaseLines = TBaseLinePeer.doSelect(criteria);
                }
            }
        }
        lastTBaseLinesCriteria = criteria;

        return collTBaseLines;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBaseLines(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBaseLine> getTBaseLines(Connection con) throws TorqueException
    {
        if (collTBaseLines == null)
        {
            collTBaseLines = getTBaseLines(new Criteria(10), con);
        }
        return collTBaseLines;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBaseLines from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBaseLine> getTBaseLines(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTBaseLines == null)
        {
            if (isNew())
            {
               collTBaseLines = new ArrayList<TBaseLine>();
            }
            else
            {
                 criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
                 collTBaseLines = TBaseLinePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
                 if (!lastTBaseLinesCriteria.equals(criteria))
                 {
                     collTBaseLines = TBaseLinePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTBaseLinesCriteria = criteria;

         return collTBaseLines;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TBaseLines from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TBaseLine> getTBaseLinesJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTBaseLines == null)
        {
            if (isNew())
            {
               collTBaseLines = new ArrayList<TBaseLine>();
            }
            else
            {
                criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
                collTBaseLines = TBaseLinePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
            if (!lastTBaseLinesCriteria.equals(criteria))
            {
                collTBaseLines = TBaseLinePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTBaseLinesCriteria = criteria;

        return collTBaseLines;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TBaseLines from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TBaseLine> getTBaseLinesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTBaseLines == null)
        {
            if (isNew())
            {
               collTBaseLines = new ArrayList<TBaseLine>();
            }
            else
            {
                criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
                collTBaseLines = TBaseLinePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TBaseLinePeer.CHANGEDBY, getObjectID());
            if (!lastTBaseLinesCriteria.equals(criteria))
            {
                collTBaseLines = TBaseLinePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTBaseLinesCriteria = criteria;

        return collTBaseLines;
    }





    /**
     * Collection to store aggregation of collTNotifys
     */
    protected List<TNotify> collTNotifys;

    /**
     * Temporary storage of collTNotifys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTNotifys()
    {
        if (collTNotifys == null)
        {
            collTNotifys = new ArrayList<TNotify>();
        }
    }


    /**
     * Method called to associate a TNotify object to this object
     * through the TNotify foreign key attribute
     *
     * @param l TNotify
     * @throws TorqueException
     */
    public void addTNotify(TNotify l) throws TorqueException
    {
        getTNotifys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TNotify object to this object
     * through the TNotify foreign key attribute using connection.
     *
     * @param l TNotify
     * @throws TorqueException
     */
    public void addTNotify(TNotify l, Connection con) throws TorqueException
    {
        getTNotifys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTNotifys
     */
    private Criteria lastTNotifysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TNotify> getTNotifys()
        throws TorqueException
    {
        if (collTNotifys == null)
        {
            collTNotifys = getTNotifys(new Criteria(10));
        }
        return collTNotifys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TNotify> getTNotifys(Criteria criteria) throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID() );
                collTNotifys = TNotifyPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                if (!lastTNotifysCriteria.equals(criteria))
                {
                    collTNotifys = TNotifyPeer.doSelect(criteria);
                }
            }
        }
        lastTNotifysCriteria = criteria;

        return collTNotifys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotify> getTNotifys(Connection con) throws TorqueException
    {
        if (collTNotifys == null)
        {
            collTNotifys = getTNotifys(new Criteria(10), con);
        }
        return collTNotifys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotify> getTNotifys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                 criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                 collTNotifys = TNotifyPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                 if (!lastTNotifysCriteria.equals(criteria))
                 {
                     collTNotifys = TNotifyPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTNotifysCriteria = criteria;

         return collTNotifys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotify> getTNotifysJoinTProjectCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                collTNotifys = TNotifyPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
            if (!lastTNotifysCriteria.equals(criteria))
            {
                collTNotifys = TNotifyPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        lastTNotifysCriteria = criteria;

        return collTNotifys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotify> getTNotifysJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                collTNotifys = TNotifyPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
            if (!lastTNotifysCriteria.equals(criteria))
            {
                collTNotifys = TNotifyPeer.doSelectJoinTState(criteria);
            }
        }
        lastTNotifysCriteria = criteria;

        return collTNotifys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotify> getTNotifysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                collTNotifys = TNotifyPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
            if (!lastTNotifysCriteria.equals(criteria))
            {
                collTNotifys = TNotifyPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTNotifysCriteria = criteria;

        return collTNotifys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotify> getTNotifysJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifys == null)
        {
            if (isNew())
            {
               collTNotifys = new ArrayList<TNotify>();
            }
            else
            {
                criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
                collTNotifys = TNotifyPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifyPeer.PERSONKEY, getObjectID());
            if (!lastTNotifysCriteria.equals(criteria))
            {
                collTNotifys = TNotifyPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTNotifysCriteria = criteria;

        return collTNotifys;
    }








    /**
     * Collection to store aggregation of collTProjectsRelatedByDefaultOwnerID
     */
    protected List<TProject> collTProjectsRelatedByDefaultOwnerID;

    /**
     * Temporary storage of collTProjectsRelatedByDefaultOwnerID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTProjectsRelatedByDefaultOwnerID()
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
        }
    }


    /**
     * Method called to associate a TProject object to this object
     * through the TProject foreign key attribute
     *
     * @param l TProject
     * @throws TorqueException
     */
    public void addTProjectRelatedByDefaultOwnerID(TProject l) throws TorqueException
    {
        getTProjectsRelatedByDefaultOwnerID().add(l);
        l.setTPersonRelatedByDefaultOwnerID((TPerson) this);
    }

    /**
     * Method called to associate a TProject object to this object
     * through the TProject foreign key attribute using connection.
     *
     * @param l TProject
     * @throws TorqueException
     */
    public void addTProjectRelatedByDefaultOwnerID(TProject l, Connection con) throws TorqueException
    {
        getTProjectsRelatedByDefaultOwnerID(con).add(l);
        l.setTPersonRelatedByDefaultOwnerID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTProjectsRelatedByDefaultOwnerID
     */
    private Criteria lastTProjectsRelatedByDefaultOwnerIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTProjectsRelatedByDefaultOwnerID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TProject> getTProjectsRelatedByDefaultOwnerID()
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            collTProjectsRelatedByDefaultOwnerID = getTProjectsRelatedByDefaultOwnerID(new Criteria(10));
        }
        return collTProjectsRelatedByDefaultOwnerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TProject> getTProjectsRelatedByDefaultOwnerID(Criteria criteria) throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID() );
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
                {
                    collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelect(criteria);
                }
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTProjectsRelatedByDefaultOwnerID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TProject> getTProjectsRelatedByDefaultOwnerID(Connection con) throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            collTProjectsRelatedByDefaultOwnerID = getTProjectsRelatedByDefaultOwnerID(new Criteria(10), con);
        }
        return collTProjectsRelatedByDefaultOwnerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TProject> getTProjectsRelatedByDefaultOwnerID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                 criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                 collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                 if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
                 {
                     collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

         return collTProjectsRelatedByDefaultOwnerID;
     }



















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultOwnerIDJoinTPersonRelatedByDefaultManagerID(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTPersonRelatedByDefaultManagerID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFOWNER, getObjectID());
            if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTPersonRelatedByDefaultManagerID(criteria);
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultOwnerIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFOWNER, getObjectID());
            if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTState(criteria);
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultOwnerIDJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFOWNER, getObjectID());
            if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultOwnerIDJoinTSystemState(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTSystemState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFOWNER, getObjectID());
            if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTSystemState(criteria);
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultOwnerIDJoinTDomain(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultOwnerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultOwnerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFOWNER, getObjectID());
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTDomain(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFOWNER, getObjectID());
            if (!lastTProjectsRelatedByDefaultOwnerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultOwnerID = TProjectPeer.doSelectJoinTDomain(criteria);
            }
        }
        lastTProjectsRelatedByDefaultOwnerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultOwnerID;
    }





    /**
     * Collection to store aggregation of collTProjectsRelatedByDefaultManagerID
     */
    protected List<TProject> collTProjectsRelatedByDefaultManagerID;

    /**
     * Temporary storage of collTProjectsRelatedByDefaultManagerID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTProjectsRelatedByDefaultManagerID()
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
        }
    }


    /**
     * Method called to associate a TProject object to this object
     * through the TProject foreign key attribute
     *
     * @param l TProject
     * @throws TorqueException
     */
    public void addTProjectRelatedByDefaultManagerID(TProject l) throws TorqueException
    {
        getTProjectsRelatedByDefaultManagerID().add(l);
        l.setTPersonRelatedByDefaultManagerID((TPerson) this);
    }

    /**
     * Method called to associate a TProject object to this object
     * through the TProject foreign key attribute using connection.
     *
     * @param l TProject
     * @throws TorqueException
     */
    public void addTProjectRelatedByDefaultManagerID(TProject l, Connection con) throws TorqueException
    {
        getTProjectsRelatedByDefaultManagerID(con).add(l);
        l.setTPersonRelatedByDefaultManagerID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTProjectsRelatedByDefaultManagerID
     */
    private Criteria lastTProjectsRelatedByDefaultManagerIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTProjectsRelatedByDefaultManagerID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TProject> getTProjectsRelatedByDefaultManagerID()
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            collTProjectsRelatedByDefaultManagerID = getTProjectsRelatedByDefaultManagerID(new Criteria(10));
        }
        return collTProjectsRelatedByDefaultManagerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TProject> getTProjectsRelatedByDefaultManagerID(Criteria criteria) throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID() );
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
                {
                    collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelect(criteria);
                }
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTProjectsRelatedByDefaultManagerID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TProject> getTProjectsRelatedByDefaultManagerID(Connection con) throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            collTProjectsRelatedByDefaultManagerID = getTProjectsRelatedByDefaultManagerID(new Criteria(10), con);
        }
        return collTProjectsRelatedByDefaultManagerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TProject> getTProjectsRelatedByDefaultManagerID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                 criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                 collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                 if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
                 {
                     collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

         return collTProjectsRelatedByDefaultManagerID;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultManagerIDJoinTPersonRelatedByDefaultOwnerID(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTPersonRelatedByDefaultOwnerID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
            if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTPersonRelatedByDefaultOwnerID(criteria);
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultManagerIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
            if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTState(criteria);
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultManagerIDJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
            if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultManagerIDJoinTSystemState(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTSystemState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
            if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTSystemState(criteria);
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TProjectsRelatedByDefaultManagerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TProject> getTProjectsRelatedByDefaultManagerIDJoinTDomain(Criteria criteria)
        throws TorqueException
    {
        if (collTProjectsRelatedByDefaultManagerID == null)
        {
            if (isNew())
            {
               collTProjectsRelatedByDefaultManagerID = new ArrayList<TProject>();
            }
            else
            {
                criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTDomain(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TProjectPeer.DEFMANAGER, getObjectID());
            if (!lastTProjectsRelatedByDefaultManagerIDCriteria.equals(criteria))
            {
                collTProjectsRelatedByDefaultManagerID = TProjectPeer.doSelectJoinTDomain(criteria);
            }
        }
        lastTProjectsRelatedByDefaultManagerIDCriteria = criteria;

        return collTProjectsRelatedByDefaultManagerID;
    }





    /**
     * Collection to store aggregation of collTStateChanges
     */
    protected List<TStateChange> collTStateChanges;

    /**
     * Temporary storage of collTStateChanges to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTStateChanges()
    {
        if (collTStateChanges == null)
        {
            collTStateChanges = new ArrayList<TStateChange>();
        }
    }


    /**
     * Method called to associate a TStateChange object to this object
     * through the TStateChange foreign key attribute
     *
     * @param l TStateChange
     * @throws TorqueException
     */
    public void addTStateChange(TStateChange l) throws TorqueException
    {
        getTStateChanges().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TStateChange object to this object
     * through the TStateChange foreign key attribute using connection.
     *
     * @param l TStateChange
     * @throws TorqueException
     */
    public void addTStateChange(TStateChange l, Connection con) throws TorqueException
    {
        getTStateChanges(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTStateChanges
     */
    private Criteria lastTStateChangesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTStateChanges(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TStateChange> getTStateChanges()
        throws TorqueException
    {
        if (collTStateChanges == null)
        {
            collTStateChanges = getTStateChanges(new Criteria(10));
        }
        return collTStateChanges;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TStateChanges from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TStateChange> getTStateChanges(Criteria criteria) throws TorqueException
    {
        if (collTStateChanges == null)
        {
            if (isNew())
            {
               collTStateChanges = new ArrayList<TStateChange>();
            }
            else
            {
                criteria.add(TStateChangePeer.CHANGEDBY, getObjectID() );
                collTStateChanges = TStateChangePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                if (!lastTStateChangesCriteria.equals(criteria))
                {
                    collTStateChanges = TStateChangePeer.doSelect(criteria);
                }
            }
        }
        lastTStateChangesCriteria = criteria;

        return collTStateChanges;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTStateChanges(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TStateChange> getTStateChanges(Connection con) throws TorqueException
    {
        if (collTStateChanges == null)
        {
            collTStateChanges = getTStateChanges(new Criteria(10), con);
        }
        return collTStateChanges;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TStateChanges from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TStateChange> getTStateChanges(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTStateChanges == null)
        {
            if (isNew())
            {
               collTStateChanges = new ArrayList<TStateChange>();
            }
            else
            {
                 criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                 collTStateChanges = TStateChangePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                 if (!lastTStateChangesCriteria.equals(criteria))
                 {
                     collTStateChanges = TStateChangePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTStateChangesCriteria = criteria;

         return collTStateChanges;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TStateChanges from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TStateChange> getTStateChangesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTStateChanges == null)
        {
            if (isNew())
            {
               collTStateChanges = new ArrayList<TStateChange>();
            }
            else
            {
                criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                collTStateChanges = TStateChangePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
            if (!lastTStateChangesCriteria.equals(criteria))
            {
                collTStateChanges = TStateChangePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTStateChangesCriteria = criteria;

        return collTStateChanges;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TStateChanges from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TStateChange> getTStateChangesJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTStateChanges == null)
        {
            if (isNew())
            {
               collTStateChanges = new ArrayList<TStateChange>();
            }
            else
            {
                criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                collTStateChanges = TStateChangePeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
            if (!lastTStateChangesCriteria.equals(criteria))
            {
                collTStateChanges = TStateChangePeer.doSelectJoinTState(criteria);
            }
        }
        lastTStateChangesCriteria = criteria;

        return collTStateChanges;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TStateChanges from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TStateChange> getTStateChangesJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTStateChanges == null)
        {
            if (isNew())
            {
               collTStateChanges = new ArrayList<TStateChange>();
            }
            else
            {
                criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
                collTStateChanges = TStateChangePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TStateChangePeer.CHANGEDBY, getObjectID());
            if (!lastTStateChangesCriteria.equals(criteria))
            {
                collTStateChanges = TStateChangePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTStateChangesCriteria = criteria;

        return collTStateChanges;
    }





    /**
     * Collection to store aggregation of collTTrails
     */
    protected List<TTrail> collTTrails;

    /**
     * Temporary storage of collTTrails to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTTrails()
    {
        if (collTTrails == null)
        {
            collTTrails = new ArrayList<TTrail>();
        }
    }


    /**
     * Method called to associate a TTrail object to this object
     * through the TTrail foreign key attribute
     *
     * @param l TTrail
     * @throws TorqueException
     */
    public void addTTrail(TTrail l) throws TorqueException
    {
        getTTrails().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TTrail object to this object
     * through the TTrail foreign key attribute using connection.
     *
     * @param l TTrail
     * @throws TorqueException
     */
    public void addTTrail(TTrail l, Connection con) throws TorqueException
    {
        getTTrails(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTTrails
     */
    private Criteria lastTTrailsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTTrails(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TTrail> getTTrails()
        throws TorqueException
    {
        if (collTTrails == null)
        {
            collTTrails = getTTrails(new Criteria(10));
        }
        return collTTrails;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TTrails from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TTrail> getTTrails(Criteria criteria) throws TorqueException
    {
        if (collTTrails == null)
        {
            if (isNew())
            {
               collTTrails = new ArrayList<TTrail>();
            }
            else
            {
                criteria.add(TTrailPeer.CHANGEDBY, getObjectID() );
                collTTrails = TTrailPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
                if (!lastTTrailsCriteria.equals(criteria))
                {
                    collTTrails = TTrailPeer.doSelect(criteria);
                }
            }
        }
        lastTTrailsCriteria = criteria;

        return collTTrails;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTTrails(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TTrail> getTTrails(Connection con) throws TorqueException
    {
        if (collTTrails == null)
        {
            collTTrails = getTTrails(new Criteria(10), con);
        }
        return collTTrails;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TTrails from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TTrail> getTTrails(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTTrails == null)
        {
            if (isNew())
            {
               collTTrails = new ArrayList<TTrail>();
            }
            else
            {
                 criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
                 collTTrails = TTrailPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
                 if (!lastTTrailsCriteria.equals(criteria))
                 {
                     collTTrails = TTrailPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTTrailsCriteria = criteria;

         return collTTrails;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TTrails from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TTrail> getTTrailsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTTrails == null)
        {
            if (isNew())
            {
               collTTrails = new ArrayList<TTrail>();
            }
            else
            {
                criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
                collTTrails = TTrailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
            if (!lastTTrailsCriteria.equals(criteria))
            {
                collTTrails = TTrailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTTrailsCriteria = criteria;

        return collTTrails;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TTrails from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TTrail> getTTrailsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTTrails == null)
        {
            if (isNew())
            {
               collTTrails = new ArrayList<TTrail>();
            }
            else
            {
                criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
                collTTrails = TTrailPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TTrailPeer.CHANGEDBY, getObjectID());
            if (!lastTTrailsCriteria.equals(criteria))
            {
                collTTrails = TTrailPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTTrailsCriteria = criteria;

        return collTTrails;
    }





    /**
     * Collection to store aggregation of collTWorkItemsRelatedByOwnerID
     */
    protected List<TWorkItem> collTWorkItemsRelatedByOwnerID;

    /**
     * Temporary storage of collTWorkItemsRelatedByOwnerID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemsRelatedByOwnerID()
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
        }
    }


    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByOwnerID(TWorkItem l) throws TorqueException
    {
        getTWorkItemsRelatedByOwnerID().add(l);
        l.setTPersonRelatedByOwnerID((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute using connection.
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByOwnerID(TWorkItem l, Connection con) throws TorqueException
    {
        getTWorkItemsRelatedByOwnerID(con).add(l);
        l.setTPersonRelatedByOwnerID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemsRelatedByOwnerID
     */
    private Criteria lastTWorkItemsRelatedByOwnerIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByOwnerID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByOwnerID()
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            collTWorkItemsRelatedByOwnerID = getTWorkItemsRelatedByOwnerID(new Criteria(10));
        }
        return collTWorkItemsRelatedByOwnerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByOwnerID(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID() );
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
                {
                    collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByOwnerID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByOwnerID(Connection con) throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            collTWorkItemsRelatedByOwnerID = getTWorkItemsRelatedByOwnerID(new Criteria(10), con);
        }
        return collTWorkItemsRelatedByOwnerID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByOwnerID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                 criteria.add(TWorkItemPeer.OWNER, getObjectID());
                 collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemPeer.OWNER, getObjectID());
                 if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
                 {
                     collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

         return collTWorkItemsRelatedByOwnerID;
     }



















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTPersonRelatedByChangedByID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTPersonRelatedByOriginatorID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTPersonRelatedByResponsibleID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTProjectCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTListType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTClass(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTPriority(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTSeverity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTReleaseRelatedByReleaseNoticedID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTReleaseRelatedByReleaseScheduledID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOwnerID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOwnerIDJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOwnerID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOwnerID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.OWNER, getObjectID());
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.OWNER, getObjectID());
            if (!lastTWorkItemsRelatedByOwnerIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOwnerID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTWorkItemsRelatedByOwnerIDCriteria = criteria;

        return collTWorkItemsRelatedByOwnerID;
    }













    /**
     * Collection to store aggregation of collTWorkItemsRelatedByChangedByID
     */
    protected List<TWorkItem> collTWorkItemsRelatedByChangedByID;

    /**
     * Temporary storage of collTWorkItemsRelatedByChangedByID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemsRelatedByChangedByID()
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
        }
    }


    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByChangedByID(TWorkItem l) throws TorqueException
    {
        getTWorkItemsRelatedByChangedByID().add(l);
        l.setTPersonRelatedByChangedByID((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute using connection.
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByChangedByID(TWorkItem l, Connection con) throws TorqueException
    {
        getTWorkItemsRelatedByChangedByID(con).add(l);
        l.setTPersonRelatedByChangedByID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemsRelatedByChangedByID
     */
    private Criteria lastTWorkItemsRelatedByChangedByIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByChangedByID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByChangedByID()
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            collTWorkItemsRelatedByChangedByID = getTWorkItemsRelatedByChangedByID(new Criteria(10));
        }
        return collTWorkItemsRelatedByChangedByID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByChangedByID(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID() );
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
                {
                    collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByChangedByID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByChangedByID(Connection con) throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            collTWorkItemsRelatedByChangedByID = getTWorkItemsRelatedByChangedByID(new Criteria(10), con);
        }
        return collTWorkItemsRelatedByChangedByID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByChangedByID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                 criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                 collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                 if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
                 {
                     collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

         return collTWorkItemsRelatedByChangedByID;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTPersonRelatedByOwnerID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTPersonRelatedByOriginatorID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTPersonRelatedByResponsibleID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTProjectCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTListType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTClass(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTPriority(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTSeverity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTReleaseRelatedByReleaseNoticedID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTReleaseRelatedByReleaseScheduledID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByChangedByID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByChangedByIDJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByChangedByID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByChangedByID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemsRelatedByChangedByIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByChangedByID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTWorkItemsRelatedByChangedByIDCriteria = criteria;

        return collTWorkItemsRelatedByChangedByID;
    }













    /**
     * Collection to store aggregation of collTWorkItemsRelatedByOriginatorID
     */
    protected List<TWorkItem> collTWorkItemsRelatedByOriginatorID;

    /**
     * Temporary storage of collTWorkItemsRelatedByOriginatorID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemsRelatedByOriginatorID()
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
        }
    }


    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByOriginatorID(TWorkItem l) throws TorqueException
    {
        getTWorkItemsRelatedByOriginatorID().add(l);
        l.setTPersonRelatedByOriginatorID((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute using connection.
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByOriginatorID(TWorkItem l, Connection con) throws TorqueException
    {
        getTWorkItemsRelatedByOriginatorID(con).add(l);
        l.setTPersonRelatedByOriginatorID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemsRelatedByOriginatorID
     */
    private Criteria lastTWorkItemsRelatedByOriginatorIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByOriginatorID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByOriginatorID()
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            collTWorkItemsRelatedByOriginatorID = getTWorkItemsRelatedByOriginatorID(new Criteria(10));
        }
        return collTWorkItemsRelatedByOriginatorID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByOriginatorID(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID() );
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
                {
                    collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByOriginatorID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByOriginatorID(Connection con) throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            collTWorkItemsRelatedByOriginatorID = getTWorkItemsRelatedByOriginatorID(new Criteria(10), con);
        }
        return collTWorkItemsRelatedByOriginatorID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByOriginatorID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                 criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                 collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                 if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
                 {
                     collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

         return collTWorkItemsRelatedByOriginatorID;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTPersonRelatedByOwnerID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTPersonRelatedByChangedByID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTPersonRelatedByResponsibleID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPersonRelatedByResponsibleID(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTProjectCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTListType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTClass(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTPriority(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTSeverity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTReleaseRelatedByReleaseNoticedID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTReleaseRelatedByReleaseScheduledID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByOriginatorID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByOriginatorIDJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByOriginatorID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByOriginatorID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.ORIGINATOR, getObjectID());
            if (!lastTWorkItemsRelatedByOriginatorIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByOriginatorID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTWorkItemsRelatedByOriginatorIDCriteria = criteria;

        return collTWorkItemsRelatedByOriginatorID;
    }













    /**
     * Collection to store aggregation of collTWorkItemsRelatedByResponsibleID
     */
    protected List<TWorkItem> collTWorkItemsRelatedByResponsibleID;

    /**
     * Temporary storage of collTWorkItemsRelatedByResponsibleID to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemsRelatedByResponsibleID()
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
        }
    }


    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByResponsibleID(TWorkItem l) throws TorqueException
    {
        getTWorkItemsRelatedByResponsibleID().add(l);
        l.setTPersonRelatedByResponsibleID((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItem object to this object
     * through the TWorkItem foreign key attribute using connection.
     *
     * @param l TWorkItem
     * @throws TorqueException
     */
    public void addTWorkItemRelatedByResponsibleID(TWorkItem l, Connection con) throws TorqueException
    {
        getTWorkItemsRelatedByResponsibleID(con).add(l);
        l.setTPersonRelatedByResponsibleID((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemsRelatedByResponsibleID
     */
    private Criteria lastTWorkItemsRelatedByResponsibleIDCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByResponsibleID(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByResponsibleID()
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            collTWorkItemsRelatedByResponsibleID = getTWorkItemsRelatedByResponsibleID(new Criteria(10));
        }
        return collTWorkItemsRelatedByResponsibleID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItem> getTWorkItemsRelatedByResponsibleID(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID() );
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
                {
                    collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemsRelatedByResponsibleID(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByResponsibleID(Connection con) throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            collTWorkItemsRelatedByResponsibleID = getTWorkItemsRelatedByResponsibleID(new Criteria(10), con);
        }
        return collTWorkItemsRelatedByResponsibleID;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItem> getTWorkItemsRelatedByResponsibleID(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                 criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                 collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                 if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
                 {
                     collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

         return collTWorkItemsRelatedByResponsibleID;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTPersonRelatedByOwnerID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByOwnerID(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTPersonRelatedByChangedByID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByChangedByID(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTPersonRelatedByOriginatorID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPersonRelatedByOriginatorID(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTProjectCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTProjectCategory(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTListType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTListType(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTClass(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTClass(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTPriority(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTPriority(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTSeverity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTSeverity(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTReleaseRelatedByReleaseNoticedID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseNoticedID(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTReleaseRelatedByReleaseScheduledID(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTReleaseRelatedByReleaseScheduledID(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTState(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTState(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemsRelatedByResponsibleID from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItem> getTWorkItemsRelatedByResponsibleIDJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemsRelatedByResponsibleID == null)
        {
            if (isNew())
            {
               collTWorkItemsRelatedByResponsibleID = new ArrayList<TWorkItem>();
            }
            else
            {
                criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkItemsRelatedByResponsibleIDCriteria.equals(criteria))
            {
                collTWorkItemsRelatedByResponsibleID = TWorkItemPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTWorkItemsRelatedByResponsibleIDCriteria = criteria;

        return collTWorkItemsRelatedByResponsibleID;
    }













    /**
     * Collection to store aggregation of collTComputedValuess
     */
    protected List<TComputedValues> collTComputedValuess;

    /**
     * Temporary storage of collTComputedValuess to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTComputedValuess()
    {
        if (collTComputedValuess == null)
        {
            collTComputedValuess = new ArrayList<TComputedValues>();
        }
    }


    /**
     * Method called to associate a TComputedValues object to this object
     * through the TComputedValues foreign key attribute
     *
     * @param l TComputedValues
     * @throws TorqueException
     */
    public void addTComputedValues(TComputedValues l) throws TorqueException
    {
        getTComputedValuess().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TComputedValues object to this object
     * through the TComputedValues foreign key attribute using connection.
     *
     * @param l TComputedValues
     * @throws TorqueException
     */
    public void addTComputedValues(TComputedValues l, Connection con) throws TorqueException
    {
        getTComputedValuess(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTComputedValuess
     */
    private Criteria lastTComputedValuessCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTComputedValuess(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TComputedValues> getTComputedValuess()
        throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            collTComputedValuess = getTComputedValuess(new Criteria(10));
        }
        return collTComputedValuess;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TComputedValuess from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TComputedValues> getTComputedValuess(Criteria criteria) throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            if (isNew())
            {
               collTComputedValuess = new ArrayList<TComputedValues>();
            }
            else
            {
                criteria.add(TComputedValuesPeer.PERSON, getObjectID() );
                collTComputedValuess = TComputedValuesPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TComputedValuesPeer.PERSON, getObjectID());
                if (!lastTComputedValuessCriteria.equals(criteria))
                {
                    collTComputedValuess = TComputedValuesPeer.doSelect(criteria);
                }
            }
        }
        lastTComputedValuessCriteria = criteria;

        return collTComputedValuess;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTComputedValuess(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TComputedValues> getTComputedValuess(Connection con) throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            collTComputedValuess = getTComputedValuess(new Criteria(10), con);
        }
        return collTComputedValuess;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TComputedValuess from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TComputedValues> getTComputedValuess(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            if (isNew())
            {
               collTComputedValuess = new ArrayList<TComputedValues>();
            }
            else
            {
                 criteria.add(TComputedValuesPeer.PERSON, getObjectID());
                 collTComputedValuess = TComputedValuesPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TComputedValuesPeer.PERSON, getObjectID());
                 if (!lastTComputedValuessCriteria.equals(criteria))
                 {
                     collTComputedValuess = TComputedValuesPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTComputedValuessCriteria = criteria;

         return collTComputedValuess;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TComputedValuess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TComputedValues> getTComputedValuessJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            if (isNew())
            {
               collTComputedValuess = new ArrayList<TComputedValues>();
            }
            else
            {
                criteria.add(TComputedValuesPeer.PERSON, getObjectID());
                collTComputedValuess = TComputedValuesPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TComputedValuesPeer.PERSON, getObjectID());
            if (!lastTComputedValuessCriteria.equals(criteria))
            {
                collTComputedValuess = TComputedValuesPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTComputedValuessCriteria = criteria;

        return collTComputedValuess;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TComputedValuess from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TComputedValues> getTComputedValuessJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTComputedValuess == null)
        {
            if (isNew())
            {
               collTComputedValuess = new ArrayList<TComputedValues>();
            }
            else
            {
                criteria.add(TComputedValuesPeer.PERSON, getObjectID());
                collTComputedValuess = TComputedValuesPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TComputedValuesPeer.PERSON, getObjectID());
            if (!lastTComputedValuessCriteria.equals(criteria))
            {
                collTComputedValuess = TComputedValuesPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTComputedValuessCriteria = criteria;

        return collTComputedValuess;
    }





    /**
     * Collection to store aggregation of collTPrivateReportRepositorys
     */
    protected List<TPrivateReportRepository> collTPrivateReportRepositorys;

    /**
     * Temporary storage of collTPrivateReportRepositorys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTPrivateReportRepositorys()
    {
        if (collTPrivateReportRepositorys == null)
        {
            collTPrivateReportRepositorys = new ArrayList<TPrivateReportRepository>();
        }
    }


    /**
     * Method called to associate a TPrivateReportRepository object to this object
     * through the TPrivateReportRepository foreign key attribute
     *
     * @param l TPrivateReportRepository
     * @throws TorqueException
     */
    public void addTPrivateReportRepository(TPrivateReportRepository l) throws TorqueException
    {
        getTPrivateReportRepositorys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TPrivateReportRepository object to this object
     * through the TPrivateReportRepository foreign key attribute using connection.
     *
     * @param l TPrivateReportRepository
     * @throws TorqueException
     */
    public void addTPrivateReportRepository(TPrivateReportRepository l, Connection con) throws TorqueException
    {
        getTPrivateReportRepositorys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTPrivateReportRepositorys
     */
    private Criteria lastTPrivateReportRepositorysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPrivateReportRepositorys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TPrivateReportRepository> getTPrivateReportRepositorys()
        throws TorqueException
    {
        if (collTPrivateReportRepositorys == null)
        {
            collTPrivateReportRepositorys = getTPrivateReportRepositorys(new Criteria(10));
        }
        return collTPrivateReportRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPrivateReportRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TPrivateReportRepository> getTPrivateReportRepositorys(Criteria criteria) throws TorqueException
    {
        if (collTPrivateReportRepositorys == null)
        {
            if (isNew())
            {
               collTPrivateReportRepositorys = new ArrayList<TPrivateReportRepository>();
            }
            else
            {
                criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID() );
                collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID());
                if (!lastTPrivateReportRepositorysCriteria.equals(criteria))
                {
                    collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelect(criteria);
                }
            }
        }
        lastTPrivateReportRepositorysCriteria = criteria;

        return collTPrivateReportRepositorys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPrivateReportRepositorys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPrivateReportRepository> getTPrivateReportRepositorys(Connection con) throws TorqueException
    {
        if (collTPrivateReportRepositorys == null)
        {
            collTPrivateReportRepositorys = getTPrivateReportRepositorys(new Criteria(10), con);
        }
        return collTPrivateReportRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPrivateReportRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPrivateReportRepository> getTPrivateReportRepositorys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTPrivateReportRepositorys == null)
        {
            if (isNew())
            {
               collTPrivateReportRepositorys = new ArrayList<TPrivateReportRepository>();
            }
            else
            {
                 criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID());
                 collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID());
                 if (!lastTPrivateReportRepositorysCriteria.equals(criteria))
                 {
                     collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTPrivateReportRepositorysCriteria = criteria;

         return collTPrivateReportRepositorys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPrivateReportRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPrivateReportRepository> getTPrivateReportRepositorysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTPrivateReportRepositorys == null)
        {
            if (isNew())
            {
               collTPrivateReportRepositorys = new ArrayList<TPrivateReportRepository>();
            }
            else
            {
                criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID());
                collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPrivateReportRepositoryPeer.OWNER, getObjectID());
            if (!lastTPrivateReportRepositorysCriteria.equals(criteria))
            {
                collTPrivateReportRepositorys = TPrivateReportRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTPrivateReportRepositorysCriteria = criteria;

        return collTPrivateReportRepositorys;
    }





    /**
     * Collection to store aggregation of collTPublicReportRepositorys
     */
    protected List<TPublicReportRepository> collTPublicReportRepositorys;

    /**
     * Temporary storage of collTPublicReportRepositorys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTPublicReportRepositorys()
    {
        if (collTPublicReportRepositorys == null)
        {
            collTPublicReportRepositorys = new ArrayList<TPublicReportRepository>();
        }
    }


    /**
     * Method called to associate a TPublicReportRepository object to this object
     * through the TPublicReportRepository foreign key attribute
     *
     * @param l TPublicReportRepository
     * @throws TorqueException
     */
    public void addTPublicReportRepository(TPublicReportRepository l) throws TorqueException
    {
        getTPublicReportRepositorys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TPublicReportRepository object to this object
     * through the TPublicReportRepository foreign key attribute using connection.
     *
     * @param l TPublicReportRepository
     * @throws TorqueException
     */
    public void addTPublicReportRepository(TPublicReportRepository l, Connection con) throws TorqueException
    {
        getTPublicReportRepositorys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTPublicReportRepositorys
     */
    private Criteria lastTPublicReportRepositorysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPublicReportRepositorys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TPublicReportRepository> getTPublicReportRepositorys()
        throws TorqueException
    {
        if (collTPublicReportRepositorys == null)
        {
            collTPublicReportRepositorys = getTPublicReportRepositorys(new Criteria(10));
        }
        return collTPublicReportRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPublicReportRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TPublicReportRepository> getTPublicReportRepositorys(Criteria criteria) throws TorqueException
    {
        if (collTPublicReportRepositorys == null)
        {
            if (isNew())
            {
               collTPublicReportRepositorys = new ArrayList<TPublicReportRepository>();
            }
            else
            {
                criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID() );
                collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID());
                if (!lastTPublicReportRepositorysCriteria.equals(criteria))
                {
                    collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelect(criteria);
                }
            }
        }
        lastTPublicReportRepositorysCriteria = criteria;

        return collTPublicReportRepositorys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPublicReportRepositorys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPublicReportRepository> getTPublicReportRepositorys(Connection con) throws TorqueException
    {
        if (collTPublicReportRepositorys == null)
        {
            collTPublicReportRepositorys = getTPublicReportRepositorys(new Criteria(10), con);
        }
        return collTPublicReportRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPublicReportRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPublicReportRepository> getTPublicReportRepositorys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTPublicReportRepositorys == null)
        {
            if (isNew())
            {
               collTPublicReportRepositorys = new ArrayList<TPublicReportRepository>();
            }
            else
            {
                 criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID());
                 collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID());
                 if (!lastTPublicReportRepositorysCriteria.equals(criteria))
                 {
                     collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTPublicReportRepositorysCriteria = criteria;

         return collTPublicReportRepositorys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPublicReportRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPublicReportRepository> getTPublicReportRepositorysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTPublicReportRepositorys == null)
        {
            if (isNew())
            {
               collTPublicReportRepositorys = new ArrayList<TPublicReportRepository>();
            }
            else
            {
                criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID());
                collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPublicReportRepositoryPeer.OWNER, getObjectID());
            if (!lastTPublicReportRepositorysCriteria.equals(criteria))
            {
                collTPublicReportRepositorys = TPublicReportRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTPublicReportRepositorysCriteria = criteria;

        return collTPublicReportRepositorys;
    }





    /**
     * Collection to store aggregation of collTAttachments
     */
    protected List<TAttachment> collTAttachments;

    /**
     * Temporary storage of collTAttachments to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTAttachments()
    {
        if (collTAttachments == null)
        {
            collTAttachments = new ArrayList<TAttachment>();
        }
    }


    /**
     * Method called to associate a TAttachment object to this object
     * through the TAttachment foreign key attribute
     *
     * @param l TAttachment
     * @throws TorqueException
     */
    public void addTAttachment(TAttachment l) throws TorqueException
    {
        getTAttachments().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TAttachment object to this object
     * through the TAttachment foreign key attribute using connection.
     *
     * @param l TAttachment
     * @throws TorqueException
     */
    public void addTAttachment(TAttachment l, Connection con) throws TorqueException
    {
        getTAttachments(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTAttachments
     */
    private Criteria lastTAttachmentsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAttachments(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TAttachment> getTAttachments()
        throws TorqueException
    {
        if (collTAttachments == null)
        {
            collTAttachments = getTAttachments(new Criteria(10));
        }
        return collTAttachments;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAttachments from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TAttachment> getTAttachments(Criteria criteria) throws TorqueException
    {
        if (collTAttachments == null)
        {
            if (isNew())
            {
               collTAttachments = new ArrayList<TAttachment>();
            }
            else
            {
                criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID() );
                collTAttachments = TAttachmentPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                if (!lastTAttachmentsCriteria.equals(criteria))
                {
                    collTAttachments = TAttachmentPeer.doSelect(criteria);
                }
            }
        }
        lastTAttachmentsCriteria = criteria;

        return collTAttachments;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAttachments(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAttachment> getTAttachments(Connection con) throws TorqueException
    {
        if (collTAttachments == null)
        {
            collTAttachments = getTAttachments(new Criteria(10), con);
        }
        return collTAttachments;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAttachments from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAttachment> getTAttachments(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTAttachments == null)
        {
            if (isNew())
            {
               collTAttachments = new ArrayList<TAttachment>();
            }
            else
            {
                 criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                 collTAttachments = TAttachmentPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                 if (!lastTAttachmentsCriteria.equals(criteria))
                 {
                     collTAttachments = TAttachmentPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTAttachmentsCriteria = criteria;

         return collTAttachments;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachment> getTAttachmentsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachments == null)
        {
            if (isNew())
            {
               collTAttachments = new ArrayList<TAttachment>();
            }
            else
            {
                criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                collTAttachments = TAttachmentPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentsCriteria.equals(criteria))
            {
                collTAttachments = TAttachmentPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTAttachmentsCriteria = criteria;

        return collTAttachments;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachment> getTAttachmentsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachments == null)
        {
            if (isNew())
            {
               collTAttachments = new ArrayList<TAttachment>();
            }
            else
            {
                criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                collTAttachments = TAttachmentPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentsCriteria.equals(criteria))
            {
                collTAttachments = TAttachmentPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTAttachmentsCriteria = criteria;

        return collTAttachments;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachments from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachment> getTAttachmentsJoinTDocState(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachments == null)
        {
            if (isNew())
            {
               collTAttachments = new ArrayList<TAttachment>();
            }
            else
            {
                criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
                collTAttachments = TAttachmentPeer.doSelectJoinTDocState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentsCriteria.equals(criteria))
            {
                collTAttachments = TAttachmentPeer.doSelectJoinTDocState(criteria);
            }
        }
        lastTAttachmentsCriteria = criteria;

        return collTAttachments;
    }





    /**
     * Collection to store aggregation of collTCosts
     */
    protected List<TCost> collTCosts;

    /**
     * Temporary storage of collTCosts to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTCosts()
    {
        if (collTCosts == null)
        {
            collTCosts = new ArrayList<TCost>();
        }
    }


    /**
     * Method called to associate a TCost object to this object
     * through the TCost foreign key attribute
     *
     * @param l TCost
     * @throws TorqueException
     */
    public void addTCost(TCost l) throws TorqueException
    {
        getTCosts().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TCost object to this object
     * through the TCost foreign key attribute using connection.
     *
     * @param l TCost
     * @throws TorqueException
     */
    public void addTCost(TCost l, Connection con) throws TorqueException
    {
        getTCosts(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTCosts
     */
    private Criteria lastTCostsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTCosts(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TCost> getTCosts()
        throws TorqueException
    {
        if (collTCosts == null)
        {
            collTCosts = getTCosts(new Criteria(10));
        }
        return collTCosts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TCost> getTCosts(Criteria criteria) throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                criteria.add(TCostPeer.PERSON, getObjectID() );
                collTCosts = TCostPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TCostPeer.PERSON, getObjectID());
                if (!lastTCostsCriteria.equals(criteria))
                {
                    collTCosts = TCostPeer.doSelect(criteria);
                }
            }
        }
        lastTCostsCriteria = criteria;

        return collTCosts;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTCosts(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TCost> getTCosts(Connection con) throws TorqueException
    {
        if (collTCosts == null)
        {
            collTCosts = getTCosts(new Criteria(10), con);
        }
        return collTCosts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TCost> getTCosts(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                 criteria.add(TCostPeer.PERSON, getObjectID());
                 collTCosts = TCostPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TCostPeer.PERSON, getObjectID());
                 if (!lastTCostsCriteria.equals(criteria))
                 {
                     collTCosts = TCostPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTCostsCriteria = criteria;

         return collTCosts;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TCost> getTCostsJoinTAccount(Criteria criteria)
        throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                criteria.add(TCostPeer.PERSON, getObjectID());
                collTCosts = TCostPeer.doSelectJoinTAccount(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TCostPeer.PERSON, getObjectID());
            if (!lastTCostsCriteria.equals(criteria))
            {
                collTCosts = TCostPeer.doSelectJoinTAccount(criteria);
            }
        }
        lastTCostsCriteria = criteria;

        return collTCosts;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TCost> getTCostsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                criteria.add(TCostPeer.PERSON, getObjectID());
                collTCosts = TCostPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TCostPeer.PERSON, getObjectID());
            if (!lastTCostsCriteria.equals(criteria))
            {
                collTCosts = TCostPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTCostsCriteria = criteria;

        return collTCosts;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TCost> getTCostsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                criteria.add(TCostPeer.PERSON, getObjectID());
                collTCosts = TCostPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TCostPeer.PERSON, getObjectID());
            if (!lastTCostsCriteria.equals(criteria))
            {
                collTCosts = TCostPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTCostsCriteria = criteria;

        return collTCosts;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TCosts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TCost> getTCostsJoinTEffortType(Criteria criteria)
        throws TorqueException
    {
        if (collTCosts == null)
        {
            if (isNew())
            {
               collTCosts = new ArrayList<TCost>();
            }
            else
            {
                criteria.add(TCostPeer.PERSON, getObjectID());
                collTCosts = TCostPeer.doSelectJoinTEffortType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TCostPeer.PERSON, getObjectID());
            if (!lastTCostsCriteria.equals(criteria))
            {
                collTCosts = TCostPeer.doSelectJoinTEffortType(criteria);
            }
        }
        lastTCostsCriteria = criteria;

        return collTCosts;
    }





    /**
     * Collection to store aggregation of collTWorkFlows
     */
    protected List<TWorkFlow> collTWorkFlows;

    /**
     * Temporary storage of collTWorkFlows to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkFlows()
    {
        if (collTWorkFlows == null)
        {
            collTWorkFlows = new ArrayList<TWorkFlow>();
        }
    }


    /**
     * Method called to associate a TWorkFlow object to this object
     * through the TWorkFlow foreign key attribute
     *
     * @param l TWorkFlow
     * @throws TorqueException
     */
    public void addTWorkFlow(TWorkFlow l) throws TorqueException
    {
        getTWorkFlows().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TWorkFlow object to this object
     * through the TWorkFlow foreign key attribute using connection.
     *
     * @param l TWorkFlow
     * @throws TorqueException
     */
    public void addTWorkFlow(TWorkFlow l, Connection con) throws TorqueException
    {
        getTWorkFlows(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkFlows
     */
    private Criteria lastTWorkFlowsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkFlows(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkFlow> getTWorkFlows()
        throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            collTWorkFlows = getTWorkFlows(new Criteria(10));
        }
        return collTWorkFlows;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkFlow> getTWorkFlows(Criteria criteria) throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID() );
                collTWorkFlows = TWorkFlowPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                if (!lastTWorkFlowsCriteria.equals(criteria))
                {
                    collTWorkFlows = TWorkFlowPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkFlowsCriteria = criteria;

        return collTWorkFlows;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkFlows(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkFlow> getTWorkFlows(Connection con) throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            collTWorkFlows = getTWorkFlows(new Criteria(10), con);
        }
        return collTWorkFlows;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkFlow> getTWorkFlows(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                 criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                 collTWorkFlows = TWorkFlowPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                 if (!lastTWorkFlowsCriteria.equals(criteria))
                 {
                     collTWorkFlows = TWorkFlowPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkFlowsCriteria = criteria;

         return collTWorkFlows;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkFlow> getTWorkFlowsJoinTStateRelatedByStateFrom(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTStateRelatedByStateFrom(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkFlowsCriteria.equals(criteria))
            {
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTStateRelatedByStateFrom(criteria);
            }
        }
        lastTWorkFlowsCriteria = criteria;

        return collTWorkFlows;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkFlow> getTWorkFlowsJoinTStateRelatedByStateTo(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTStateRelatedByStateTo(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkFlowsCriteria.equals(criteria))
            {
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTStateRelatedByStateTo(criteria);
            }
        }
        lastTWorkFlowsCriteria = criteria;

        return collTWorkFlows;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkFlow> getTWorkFlowsJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkFlowsCriteria.equals(criteria))
            {
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTWorkFlowsCriteria = criteria;

        return collTWorkFlows;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkFlows from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkFlow> getTWorkFlowsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkFlows == null)
        {
            if (isNew())
            {
               collTWorkFlows = new ArrayList<TWorkFlow>();
            }
            else
            {
                criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkFlowPeer.RESPONSIBLE, getObjectID());
            if (!lastTWorkFlowsCriteria.equals(criteria))
            {
                collTWorkFlows = TWorkFlowPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTWorkFlowsCriteria = criteria;

        return collTWorkFlows;
    }





    /**
     * Collection to store aggregation of collTIssueAttributeValues
     */
    protected List<TIssueAttributeValue> collTIssueAttributeValues;

    /**
     * Temporary storage of collTIssueAttributeValues to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTIssueAttributeValues()
    {
        if (collTIssueAttributeValues == null)
        {
            collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
        }
    }


    /**
     * Method called to associate a TIssueAttributeValue object to this object
     * through the TIssueAttributeValue foreign key attribute
     *
     * @param l TIssueAttributeValue
     * @throws TorqueException
     */
    public void addTIssueAttributeValue(TIssueAttributeValue l) throws TorqueException
    {
        getTIssueAttributeValues().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TIssueAttributeValue object to this object
     * through the TIssueAttributeValue foreign key attribute using connection.
     *
     * @param l TIssueAttributeValue
     * @throws TorqueException
     */
    public void addTIssueAttributeValue(TIssueAttributeValue l, Connection con) throws TorqueException
    {
        getTIssueAttributeValues(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTIssueAttributeValues
     */
    private Criteria lastTIssueAttributeValuesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTIssueAttributeValues(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TIssueAttributeValue> getTIssueAttributeValues()
        throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            collTIssueAttributeValues = getTIssueAttributeValues(new Criteria(10));
        }
        return collTIssueAttributeValues;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TIssueAttributeValue> getTIssueAttributeValues(Criteria criteria) throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID() );
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                if (!lastTIssueAttributeValuesCriteria.equals(criteria))
                {
                    collTIssueAttributeValues = TIssueAttributeValuePeer.doSelect(criteria);
                }
            }
        }
        lastTIssueAttributeValuesCriteria = criteria;

        return collTIssueAttributeValues;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTIssueAttributeValues(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TIssueAttributeValue> getTIssueAttributeValues(Connection con) throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            collTIssueAttributeValues = getTIssueAttributeValues(new Criteria(10), con);
        }
        return collTIssueAttributeValues;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TIssueAttributeValue> getTIssueAttributeValues(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                 criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                 collTIssueAttributeValues = TIssueAttributeValuePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                 if (!lastTIssueAttributeValuesCriteria.equals(criteria))
                 {
                     collTIssueAttributeValues = TIssueAttributeValuePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTIssueAttributeValuesCriteria = criteria;

         return collTIssueAttributeValues;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TIssueAttributeValue> getTIssueAttributeValuesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
            if (!lastTIssueAttributeValuesCriteria.equals(criteria))
            {
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTIssueAttributeValuesCriteria = criteria;

        return collTIssueAttributeValues;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TIssueAttributeValue> getTIssueAttributeValuesJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
            if (!lastTIssueAttributeValuesCriteria.equals(criteria))
            {
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTIssueAttributeValuesCriteria = criteria;

        return collTIssueAttributeValues;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TIssueAttributeValue> getTIssueAttributeValuesJoinTAttribute(Criteria criteria)
        throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTAttribute(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
            if (!lastTIssueAttributeValuesCriteria.equals(criteria))
            {
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTAttribute(criteria);
            }
        }
        lastTIssueAttributeValuesCriteria = criteria;

        return collTIssueAttributeValues;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TIssueAttributeValues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TIssueAttributeValue> getTIssueAttributeValuesJoinTAttributeOption(Criteria criteria)
        throws TorqueException
    {
        if (collTIssueAttributeValues == null)
        {
            if (isNew())
            {
               collTIssueAttributeValues = new ArrayList<TIssueAttributeValue>();
            }
            else
            {
                criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTAttributeOption(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TIssueAttributeValuePeer.PERSON, getObjectID());
            if (!lastTIssueAttributeValuesCriteria.equals(criteria))
            {
                collTIssueAttributeValues = TIssueAttributeValuePeer.doSelectJoinTAttributeOption(criteria);
            }
        }
        lastTIssueAttributeValuesCriteria = criteria;

        return collTIssueAttributeValues;
    }





    /**
     * Collection to store aggregation of collTReportLayouts
     */
    protected List<TReportLayout> collTReportLayouts;

    /**
     * Temporary storage of collTReportLayouts to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTReportLayouts()
    {
        if (collTReportLayouts == null)
        {
            collTReportLayouts = new ArrayList<TReportLayout>();
        }
    }


    /**
     * Method called to associate a TReportLayout object to this object
     * through the TReportLayout foreign key attribute
     *
     * @param l TReportLayout
     * @throws TorqueException
     */
    public void addTReportLayout(TReportLayout l) throws TorqueException
    {
        getTReportLayouts().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TReportLayout object to this object
     * through the TReportLayout foreign key attribute using connection.
     *
     * @param l TReportLayout
     * @throws TorqueException
     */
    public void addTReportLayout(TReportLayout l, Connection con) throws TorqueException
    {
        getTReportLayouts(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTReportLayouts
     */
    private Criteria lastTReportLayoutsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportLayouts(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TReportLayout> getTReportLayouts()
        throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            collTReportLayouts = getTReportLayouts(new Criteria(10));
        }
        return collTReportLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TReportLayout> getTReportLayouts(Criteria criteria) throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            if (isNew())
            {
               collTReportLayouts = new ArrayList<TReportLayout>();
            }
            else
            {
                criteria.add(TReportLayoutPeer.PERSON, getObjectID() );
                collTReportLayouts = TReportLayoutPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                if (!lastTReportLayoutsCriteria.equals(criteria))
                {
                    collTReportLayouts = TReportLayoutPeer.doSelect(criteria);
                }
            }
        }
        lastTReportLayoutsCriteria = criteria;

        return collTReportLayouts;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportLayouts(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportLayout> getTReportLayouts(Connection con) throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            collTReportLayouts = getTReportLayouts(new Criteria(10), con);
        }
        return collTReportLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportLayout> getTReportLayouts(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            if (isNew())
            {
               collTReportLayouts = new ArrayList<TReportLayout>();
            }
            else
            {
                 criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                 collTReportLayouts = TReportLayoutPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                 if (!lastTReportLayoutsCriteria.equals(criteria))
                 {
                     collTReportLayouts = TReportLayoutPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTReportLayoutsCriteria = criteria;

         return collTReportLayouts;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportLayouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportLayout> getTReportLayoutsJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            if (isNew())
            {
               collTReportLayouts = new ArrayList<TReportLayout>();
            }
            else
            {
                criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportLayoutPeer.PERSON, getObjectID());
            if (!lastTReportLayoutsCriteria.equals(criteria))
            {
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTReportLayoutsCriteria = criteria;

        return collTReportLayouts;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportLayouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportLayout> getTReportLayoutsJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            if (isNew())
            {
               collTReportLayouts = new ArrayList<TReportLayout>();
            }
            else
            {
                criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportLayoutPeer.PERSON, getObjectID());
            if (!lastTReportLayoutsCriteria.equals(criteria))
            {
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTReportLayoutsCriteria = criteria;

        return collTReportLayouts;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportLayouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportLayout> getTReportLayoutsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTReportLayouts == null)
        {
            if (isNew())
            {
               collTReportLayouts = new ArrayList<TReportLayout>();
            }
            else
            {
                criteria.add(TReportLayoutPeer.PERSON, getObjectID());
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportLayoutPeer.PERSON, getObjectID());
            if (!lastTReportLayoutsCriteria.equals(criteria))
            {
                collTReportLayouts = TReportLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTReportLayoutsCriteria = criteria;

        return collTReportLayouts;
    }





    /**
     * Collection to store aggregation of collTSchedulers
     */
    protected List<TScheduler> collTSchedulers;

    /**
     * Temporary storage of collTSchedulers to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTSchedulers()
    {
        if (collTSchedulers == null)
        {
            collTSchedulers = new ArrayList<TScheduler>();
        }
    }


    /**
     * Method called to associate a TScheduler object to this object
     * through the TScheduler foreign key attribute
     *
     * @param l TScheduler
     * @throws TorqueException
     */
    public void addTScheduler(TScheduler l) throws TorqueException
    {
        getTSchedulers().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TScheduler object to this object
     * through the TScheduler foreign key attribute using connection.
     *
     * @param l TScheduler
     * @throws TorqueException
     */
    public void addTScheduler(TScheduler l, Connection con) throws TorqueException
    {
        getTSchedulers(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTSchedulers
     */
    private Criteria lastTSchedulersCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSchedulers(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TScheduler> getTSchedulers()
        throws TorqueException
    {
        if (collTSchedulers == null)
        {
            collTSchedulers = getTSchedulers(new Criteria(10));
        }
        return collTSchedulers;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSchedulers from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TScheduler> getTSchedulers(Criteria criteria) throws TorqueException
    {
        if (collTSchedulers == null)
        {
            if (isNew())
            {
               collTSchedulers = new ArrayList<TScheduler>();
            }
            else
            {
                criteria.add(TSchedulerPeer.PERSON, getObjectID() );
                collTSchedulers = TSchedulerPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TSchedulerPeer.PERSON, getObjectID());
                if (!lastTSchedulersCriteria.equals(criteria))
                {
                    collTSchedulers = TSchedulerPeer.doSelect(criteria);
                }
            }
        }
        lastTSchedulersCriteria = criteria;

        return collTSchedulers;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSchedulers(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScheduler> getTSchedulers(Connection con) throws TorqueException
    {
        if (collTSchedulers == null)
        {
            collTSchedulers = getTSchedulers(new Criteria(10), con);
        }
        return collTSchedulers;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSchedulers from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScheduler> getTSchedulers(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTSchedulers == null)
        {
            if (isNew())
            {
               collTSchedulers = new ArrayList<TScheduler>();
            }
            else
            {
                 criteria.add(TSchedulerPeer.PERSON, getObjectID());
                 collTSchedulers = TSchedulerPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TSchedulerPeer.PERSON, getObjectID());
                 if (!lastTSchedulersCriteria.equals(criteria))
                 {
                     collTSchedulers = TSchedulerPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTSchedulersCriteria = criteria;

         return collTSchedulers;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TSchedulers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScheduler> getTSchedulersJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTSchedulers == null)
        {
            if (isNew())
            {
               collTSchedulers = new ArrayList<TScheduler>();
            }
            else
            {
                criteria.add(TSchedulerPeer.PERSON, getObjectID());
                collTSchedulers = TSchedulerPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TSchedulerPeer.PERSON, getObjectID());
            if (!lastTSchedulersCriteria.equals(criteria))
            {
                collTSchedulers = TSchedulerPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTSchedulersCriteria = criteria;

        return collTSchedulers;
    }





    /**
     * Collection to store aggregation of collTGroupMembersRelatedByTheGroup
     */
    protected List<TGroupMember> collTGroupMembersRelatedByTheGroup;

    /**
     * Temporary storage of collTGroupMembersRelatedByTheGroup to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTGroupMembersRelatedByTheGroup()
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            collTGroupMembersRelatedByTheGroup = new ArrayList<TGroupMember>();
        }
    }


    /**
     * Method called to associate a TGroupMember object to this object
     * through the TGroupMember foreign key attribute
     *
     * @param l TGroupMember
     * @throws TorqueException
     */
    public void addTGroupMemberRelatedByTheGroup(TGroupMember l) throws TorqueException
    {
        getTGroupMembersRelatedByTheGroup().add(l);
        l.setTPersonRelatedByTheGroup((TPerson) this);
    }

    /**
     * Method called to associate a TGroupMember object to this object
     * through the TGroupMember foreign key attribute using connection.
     *
     * @param l TGroupMember
     * @throws TorqueException
     */
    public void addTGroupMemberRelatedByTheGroup(TGroupMember l, Connection con) throws TorqueException
    {
        getTGroupMembersRelatedByTheGroup(con).add(l);
        l.setTPersonRelatedByTheGroup((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTGroupMembersRelatedByTheGroup
     */
    private Criteria lastTGroupMembersRelatedByTheGroupCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGroupMembersRelatedByTheGroup(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TGroupMember> getTGroupMembersRelatedByTheGroup()
        throws TorqueException
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            collTGroupMembersRelatedByTheGroup = getTGroupMembersRelatedByTheGroup(new Criteria(10));
        }
        return collTGroupMembersRelatedByTheGroup;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByTheGroup from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TGroupMember> getTGroupMembersRelatedByTheGroup(Criteria criteria) throws TorqueException
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByTheGroup = new ArrayList<TGroupMember>();
            }
            else
            {
                criteria.add(TGroupMemberPeer.THEGROUP, getObjectID() );
                collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TGroupMemberPeer.THEGROUP, getObjectID());
                if (!lastTGroupMembersRelatedByTheGroupCriteria.equals(criteria))
                {
                    collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelect(criteria);
                }
            }
        }
        lastTGroupMembersRelatedByTheGroupCriteria = criteria;

        return collTGroupMembersRelatedByTheGroup;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGroupMembersRelatedByTheGroup(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGroupMember> getTGroupMembersRelatedByTheGroup(Connection con) throws TorqueException
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            collTGroupMembersRelatedByTheGroup = getTGroupMembersRelatedByTheGroup(new Criteria(10), con);
        }
        return collTGroupMembersRelatedByTheGroup;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByTheGroup from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGroupMember> getTGroupMembersRelatedByTheGroup(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByTheGroup = new ArrayList<TGroupMember>();
            }
            else
            {
                 criteria.add(TGroupMemberPeer.THEGROUP, getObjectID());
                 collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TGroupMemberPeer.THEGROUP, getObjectID());
                 if (!lastTGroupMembersRelatedByTheGroupCriteria.equals(criteria))
                 {
                     collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTGroupMembersRelatedByTheGroupCriteria = criteria;

         return collTGroupMembersRelatedByTheGroup;
     }



















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByTheGroup from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TGroupMember> getTGroupMembersRelatedByTheGroupJoinTPersonRelatedByPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTGroupMembersRelatedByTheGroup == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByTheGroup = new ArrayList<TGroupMember>();
            }
            else
            {
                criteria.add(TGroupMemberPeer.THEGROUP, getObjectID());
                collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelectJoinTPersonRelatedByPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TGroupMemberPeer.THEGROUP, getObjectID());
            if (!lastTGroupMembersRelatedByTheGroupCriteria.equals(criteria))
            {
                collTGroupMembersRelatedByTheGroup = TGroupMemberPeer.doSelectJoinTPersonRelatedByPerson(criteria);
            }
        }
        lastTGroupMembersRelatedByTheGroupCriteria = criteria;

        return collTGroupMembersRelatedByTheGroup;
    }





    /**
     * Collection to store aggregation of collTGroupMembersRelatedByPerson
     */
    protected List<TGroupMember> collTGroupMembersRelatedByPerson;

    /**
     * Temporary storage of collTGroupMembersRelatedByPerson to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTGroupMembersRelatedByPerson()
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            collTGroupMembersRelatedByPerson = new ArrayList<TGroupMember>();
        }
    }


    /**
     * Method called to associate a TGroupMember object to this object
     * through the TGroupMember foreign key attribute
     *
     * @param l TGroupMember
     * @throws TorqueException
     */
    public void addTGroupMemberRelatedByPerson(TGroupMember l) throws TorqueException
    {
        getTGroupMembersRelatedByPerson().add(l);
        l.setTPersonRelatedByPerson((TPerson) this);
    }

    /**
     * Method called to associate a TGroupMember object to this object
     * through the TGroupMember foreign key attribute using connection.
     *
     * @param l TGroupMember
     * @throws TorqueException
     */
    public void addTGroupMemberRelatedByPerson(TGroupMember l, Connection con) throws TorqueException
    {
        getTGroupMembersRelatedByPerson(con).add(l);
        l.setTPersonRelatedByPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTGroupMembersRelatedByPerson
     */
    private Criteria lastTGroupMembersRelatedByPersonCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGroupMembersRelatedByPerson(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TGroupMember> getTGroupMembersRelatedByPerson()
        throws TorqueException
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            collTGroupMembersRelatedByPerson = getTGroupMembersRelatedByPerson(new Criteria(10));
        }
        return collTGroupMembersRelatedByPerson;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByPerson from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TGroupMember> getTGroupMembersRelatedByPerson(Criteria criteria) throws TorqueException
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByPerson = new ArrayList<TGroupMember>();
            }
            else
            {
                criteria.add(TGroupMemberPeer.PERSON, getObjectID() );
                collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TGroupMemberPeer.PERSON, getObjectID());
                if (!lastTGroupMembersRelatedByPersonCriteria.equals(criteria))
                {
                    collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelect(criteria);
                }
            }
        }
        lastTGroupMembersRelatedByPersonCriteria = criteria;

        return collTGroupMembersRelatedByPerson;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGroupMembersRelatedByPerson(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGroupMember> getTGroupMembersRelatedByPerson(Connection con) throws TorqueException
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            collTGroupMembersRelatedByPerson = getTGroupMembersRelatedByPerson(new Criteria(10), con);
        }
        return collTGroupMembersRelatedByPerson;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByPerson from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGroupMember> getTGroupMembersRelatedByPerson(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByPerson = new ArrayList<TGroupMember>();
            }
            else
            {
                 criteria.add(TGroupMemberPeer.PERSON, getObjectID());
                 collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TGroupMemberPeer.PERSON, getObjectID());
                 if (!lastTGroupMembersRelatedByPersonCriteria.equals(criteria))
                 {
                     collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTGroupMembersRelatedByPersonCriteria = criteria;

         return collTGroupMembersRelatedByPerson;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TGroupMembersRelatedByPerson from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TGroupMember> getTGroupMembersRelatedByPersonJoinTPersonRelatedByTheGroup(Criteria criteria)
        throws TorqueException
    {
        if (collTGroupMembersRelatedByPerson == null)
        {
            if (isNew())
            {
               collTGroupMembersRelatedByPerson = new ArrayList<TGroupMember>();
            }
            else
            {
                criteria.add(TGroupMemberPeer.PERSON, getObjectID());
                collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelectJoinTPersonRelatedByTheGroup(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TGroupMemberPeer.PERSON, getObjectID());
            if (!lastTGroupMembersRelatedByPersonCriteria.equals(criteria))
            {
                collTGroupMembersRelatedByPerson = TGroupMemberPeer.doSelectJoinTPersonRelatedByTheGroup(criteria);
            }
        }
        lastTGroupMembersRelatedByPersonCriteria = criteria;

        return collTGroupMembersRelatedByPerson;
    }













    /**
     * Collection to store aggregation of collTBudgets
     */
    protected List<TBudget> collTBudgets;

    /**
     * Temporary storage of collTBudgets to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTBudgets()
    {
        if (collTBudgets == null)
        {
            collTBudgets = new ArrayList<TBudget>();
        }
    }


    /**
     * Method called to associate a TBudget object to this object
     * through the TBudget foreign key attribute
     *
     * @param l TBudget
     * @throws TorqueException
     */
    public void addTBudget(TBudget l) throws TorqueException
    {
        getTBudgets().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TBudget object to this object
     * through the TBudget foreign key attribute using connection.
     *
     * @param l TBudget
     * @throws TorqueException
     */
    public void addTBudget(TBudget l, Connection con) throws TorqueException
    {
        getTBudgets(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTBudgets
     */
    private Criteria lastTBudgetsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBudgets(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TBudget> getTBudgets()
        throws TorqueException
    {
        if (collTBudgets == null)
        {
            collTBudgets = getTBudgets(new Criteria(10));
        }
        return collTBudgets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBudgets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TBudget> getTBudgets(Criteria criteria) throws TorqueException
    {
        if (collTBudgets == null)
        {
            if (isNew())
            {
               collTBudgets = new ArrayList<TBudget>();
            }
            else
            {
                criteria.add(TBudgetPeer.CHANGEDBY, getObjectID() );
                collTBudgets = TBudgetPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
                if (!lastTBudgetsCriteria.equals(criteria))
                {
                    collTBudgets = TBudgetPeer.doSelect(criteria);
                }
            }
        }
        lastTBudgetsCriteria = criteria;

        return collTBudgets;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBudgets(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBudget> getTBudgets(Connection con) throws TorqueException
    {
        if (collTBudgets == null)
        {
            collTBudgets = getTBudgets(new Criteria(10), con);
        }
        return collTBudgets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBudgets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBudget> getTBudgets(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTBudgets == null)
        {
            if (isNew())
            {
               collTBudgets = new ArrayList<TBudget>();
            }
            else
            {
                 criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
                 collTBudgets = TBudgetPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
                 if (!lastTBudgetsCriteria.equals(criteria))
                 {
                     collTBudgets = TBudgetPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTBudgetsCriteria = criteria;

         return collTBudgets;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TBudgets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TBudget> getTBudgetsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTBudgets == null)
        {
            if (isNew())
            {
               collTBudgets = new ArrayList<TBudget>();
            }
            else
            {
                criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
                collTBudgets = TBudgetPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
            if (!lastTBudgetsCriteria.equals(criteria))
            {
                collTBudgets = TBudgetPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTBudgetsCriteria = criteria;

        return collTBudgets;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TBudgets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TBudget> getTBudgetsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTBudgets == null)
        {
            if (isNew())
            {
               collTBudgets = new ArrayList<TBudget>();
            }
            else
            {
                criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
                collTBudgets = TBudgetPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TBudgetPeer.CHANGEDBY, getObjectID());
            if (!lastTBudgetsCriteria.equals(criteria))
            {
                collTBudgets = TBudgetPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTBudgetsCriteria = criteria;

        return collTBudgets;
    }





    /**
     * Collection to store aggregation of collTActualEstimatedBudgets
     */
    protected List<TActualEstimatedBudget> collTActualEstimatedBudgets;

    /**
     * Temporary storage of collTActualEstimatedBudgets to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTActualEstimatedBudgets()
    {
        if (collTActualEstimatedBudgets == null)
        {
            collTActualEstimatedBudgets = new ArrayList<TActualEstimatedBudget>();
        }
    }


    /**
     * Method called to associate a TActualEstimatedBudget object to this object
     * through the TActualEstimatedBudget foreign key attribute
     *
     * @param l TActualEstimatedBudget
     * @throws TorqueException
     */
    public void addTActualEstimatedBudget(TActualEstimatedBudget l) throws TorqueException
    {
        getTActualEstimatedBudgets().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TActualEstimatedBudget object to this object
     * through the TActualEstimatedBudget foreign key attribute using connection.
     *
     * @param l TActualEstimatedBudget
     * @throws TorqueException
     */
    public void addTActualEstimatedBudget(TActualEstimatedBudget l, Connection con) throws TorqueException
    {
        getTActualEstimatedBudgets(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTActualEstimatedBudgets
     */
    private Criteria lastTActualEstimatedBudgetsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTActualEstimatedBudgets(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TActualEstimatedBudget> getTActualEstimatedBudgets()
        throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            collTActualEstimatedBudgets = getTActualEstimatedBudgets(new Criteria(10));
        }
        return collTActualEstimatedBudgets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TActualEstimatedBudgets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TActualEstimatedBudget> getTActualEstimatedBudgets(Criteria criteria) throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            if (isNew())
            {
               collTActualEstimatedBudgets = new ArrayList<TActualEstimatedBudget>();
            }
            else
            {
                criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID() );
                collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
                if (!lastTActualEstimatedBudgetsCriteria.equals(criteria))
                {
                    collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelect(criteria);
                }
            }
        }
        lastTActualEstimatedBudgetsCriteria = criteria;

        return collTActualEstimatedBudgets;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTActualEstimatedBudgets(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TActualEstimatedBudget> getTActualEstimatedBudgets(Connection con) throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            collTActualEstimatedBudgets = getTActualEstimatedBudgets(new Criteria(10), con);
        }
        return collTActualEstimatedBudgets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TActualEstimatedBudgets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TActualEstimatedBudget> getTActualEstimatedBudgets(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            if (isNew())
            {
               collTActualEstimatedBudgets = new ArrayList<TActualEstimatedBudget>();
            }
            else
            {
                 criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
                 collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
                 if (!lastTActualEstimatedBudgetsCriteria.equals(criteria))
                 {
                     collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTActualEstimatedBudgetsCriteria = criteria;

         return collTActualEstimatedBudgets;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TActualEstimatedBudgets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TActualEstimatedBudget> getTActualEstimatedBudgetsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            if (isNew())
            {
               collTActualEstimatedBudgets = new ArrayList<TActualEstimatedBudget>();
            }
            else
            {
                criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
                collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
            if (!lastTActualEstimatedBudgetsCriteria.equals(criteria))
            {
                collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTActualEstimatedBudgetsCriteria = criteria;

        return collTActualEstimatedBudgets;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TActualEstimatedBudgets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TActualEstimatedBudget> getTActualEstimatedBudgetsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTActualEstimatedBudgets == null)
        {
            if (isNew())
            {
               collTActualEstimatedBudgets = new ArrayList<TActualEstimatedBudget>();
            }
            else
            {
                criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
                collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TActualEstimatedBudgetPeer.CHANGEDBY, getObjectID());
            if (!lastTActualEstimatedBudgetsCriteria.equals(criteria))
            {
                collTActualEstimatedBudgets = TActualEstimatedBudgetPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTActualEstimatedBudgetsCriteria = criteria;

        return collTActualEstimatedBudgets;
    }





    /**
     * Collection to store aggregation of collTDashboardScreensRelatedByPerson
     */
    protected List<TDashboardScreen> collTDashboardScreensRelatedByPerson;

    /**
     * Temporary storage of collTDashboardScreensRelatedByPerson to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTDashboardScreensRelatedByPerson()
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            collTDashboardScreensRelatedByPerson = new ArrayList<TDashboardScreen>();
        }
    }


    /**
     * Method called to associate a TDashboardScreen object to this object
     * through the TDashboardScreen foreign key attribute
     *
     * @param l TDashboardScreen
     * @throws TorqueException
     */
    public void addTDashboardScreenRelatedByPerson(TDashboardScreen l) throws TorqueException
    {
        getTDashboardScreensRelatedByPerson().add(l);
        l.setTPersonRelatedByPerson((TPerson) this);
    }

    /**
     * Method called to associate a TDashboardScreen object to this object
     * through the TDashboardScreen foreign key attribute using connection.
     *
     * @param l TDashboardScreen
     * @throws TorqueException
     */
    public void addTDashboardScreenRelatedByPerson(TDashboardScreen l, Connection con) throws TorqueException
    {
        getTDashboardScreensRelatedByPerson(con).add(l);
        l.setTPersonRelatedByPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTDashboardScreensRelatedByPerson
     */
    private Criteria lastTDashboardScreensRelatedByPersonCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTDashboardScreensRelatedByPerson(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByPerson()
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            collTDashboardScreensRelatedByPerson = getTDashboardScreensRelatedByPerson(new Criteria(10));
        }
        return collTDashboardScreensRelatedByPerson;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByPerson from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByPerson(Criteria criteria) throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByPerson = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID() );
                collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
                if (!lastTDashboardScreensRelatedByPersonCriteria.equals(criteria))
                {
                    collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelect(criteria);
                }
            }
        }
        lastTDashboardScreensRelatedByPersonCriteria = criteria;

        return collTDashboardScreensRelatedByPerson;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTDashboardScreensRelatedByPerson(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByPerson(Connection con) throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            collTDashboardScreensRelatedByPerson = getTDashboardScreensRelatedByPerson(new Criteria(10), con);
        }
        return collTDashboardScreensRelatedByPerson;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByPerson from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByPerson(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByPerson = new ArrayList<TDashboardScreen>();
            }
            else
            {
                 criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
                 collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
                 if (!lastTDashboardScreensRelatedByPersonCriteria.equals(criteria))
                 {
                     collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTDashboardScreensRelatedByPersonCriteria = criteria;

         return collTDashboardScreensRelatedByPerson;
     }



















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByPerson from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TDashboardScreen> getTDashboardScreensRelatedByPersonJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByPerson = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
                collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
            if (!lastTDashboardScreensRelatedByPersonCriteria.equals(criteria))
            {
                collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTDashboardScreensRelatedByPersonCriteria = criteria;

        return collTDashboardScreensRelatedByPerson;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByPerson from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TDashboardScreen> getTDashboardScreensRelatedByPersonJoinTPersonRelatedByOwner(Criteria criteria)
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByPerson == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByPerson = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
                collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelectJoinTPersonRelatedByOwner(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TDashboardScreenPeer.PERSONPKEY, getObjectID());
            if (!lastTDashboardScreensRelatedByPersonCriteria.equals(criteria))
            {
                collTDashboardScreensRelatedByPerson = TDashboardScreenPeer.doSelectJoinTPersonRelatedByOwner(criteria);
            }
        }
        lastTDashboardScreensRelatedByPersonCriteria = criteria;

        return collTDashboardScreensRelatedByPerson;
    }





    /**
     * Collection to store aggregation of collTDashboardScreensRelatedByOwner
     */
    protected List<TDashboardScreen> collTDashboardScreensRelatedByOwner;

    /**
     * Temporary storage of collTDashboardScreensRelatedByOwner to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTDashboardScreensRelatedByOwner()
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            collTDashboardScreensRelatedByOwner = new ArrayList<TDashboardScreen>();
        }
    }


    /**
     * Method called to associate a TDashboardScreen object to this object
     * through the TDashboardScreen foreign key attribute
     *
     * @param l TDashboardScreen
     * @throws TorqueException
     */
    public void addTDashboardScreenRelatedByOwner(TDashboardScreen l) throws TorqueException
    {
        getTDashboardScreensRelatedByOwner().add(l);
        l.setTPersonRelatedByOwner((TPerson) this);
    }

    /**
     * Method called to associate a TDashboardScreen object to this object
     * through the TDashboardScreen foreign key attribute using connection.
     *
     * @param l TDashboardScreen
     * @throws TorqueException
     */
    public void addTDashboardScreenRelatedByOwner(TDashboardScreen l, Connection con) throws TorqueException
    {
        getTDashboardScreensRelatedByOwner(con).add(l);
        l.setTPersonRelatedByOwner((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTDashboardScreensRelatedByOwner
     */
    private Criteria lastTDashboardScreensRelatedByOwnerCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTDashboardScreensRelatedByOwner(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByOwner()
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            collTDashboardScreensRelatedByOwner = getTDashboardScreensRelatedByOwner(new Criteria(10));
        }
        return collTDashboardScreensRelatedByOwner;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByOwner from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByOwner(Criteria criteria) throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByOwner = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.OWNER, getObjectID() );
                collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
                if (!lastTDashboardScreensRelatedByOwnerCriteria.equals(criteria))
                {
                    collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelect(criteria);
                }
            }
        }
        lastTDashboardScreensRelatedByOwnerCriteria = criteria;

        return collTDashboardScreensRelatedByOwner;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTDashboardScreensRelatedByOwner(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByOwner(Connection con) throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            collTDashboardScreensRelatedByOwner = getTDashboardScreensRelatedByOwner(new Criteria(10), con);
        }
        return collTDashboardScreensRelatedByOwner;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByOwner from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TDashboardScreen> getTDashboardScreensRelatedByOwner(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByOwner = new ArrayList<TDashboardScreen>();
            }
            else
            {
                 criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
                 collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
                 if (!lastTDashboardScreensRelatedByOwnerCriteria.equals(criteria))
                 {
                     collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTDashboardScreensRelatedByOwnerCriteria = criteria;

         return collTDashboardScreensRelatedByOwner;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByOwner from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TDashboardScreen> getTDashboardScreensRelatedByOwnerJoinTPersonRelatedByPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByOwner = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
                collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelectJoinTPersonRelatedByPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
            if (!lastTDashboardScreensRelatedByOwnerCriteria.equals(criteria))
            {
                collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelectJoinTPersonRelatedByPerson(criteria);
            }
        }
        lastTDashboardScreensRelatedByOwnerCriteria = criteria;

        return collTDashboardScreensRelatedByOwner;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TDashboardScreensRelatedByOwner from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TDashboardScreen> getTDashboardScreensRelatedByOwnerJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTDashboardScreensRelatedByOwner == null)
        {
            if (isNew())
            {
               collTDashboardScreensRelatedByOwner = new ArrayList<TDashboardScreen>();
            }
            else
            {
                criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
                collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TDashboardScreenPeer.OWNER, getObjectID());
            if (!lastTDashboardScreensRelatedByOwnerCriteria.equals(criteria))
            {
                collTDashboardScreensRelatedByOwner = TDashboardScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTDashboardScreensRelatedByOwnerCriteria = criteria;

        return collTDashboardScreensRelatedByOwner;
    }













    /**
     * Collection to store aggregation of collTFields
     */
    protected List<TField> collTFields;

    /**
     * Temporary storage of collTFields to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTFields()
    {
        if (collTFields == null)
        {
            collTFields = new ArrayList<TField>();
        }
    }


    /**
     * Method called to associate a TField object to this object
     * through the TField foreign key attribute
     *
     * @param l TField
     * @throws TorqueException
     */
    public void addTField(TField l) throws TorqueException
    {
        getTFields().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TField object to this object
     * through the TField foreign key attribute using connection.
     *
     * @param l TField
     * @throws TorqueException
     */
    public void addTField(TField l, Connection con) throws TorqueException
    {
        getTFields(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTFields
     */
    private Criteria lastTFieldsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTFields(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TField> getTFields()
        throws TorqueException
    {
        if (collTFields == null)
        {
            collTFields = getTFields(new Criteria(10));
        }
        return collTFields;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TFields from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TField> getTFields(Criteria criteria) throws TorqueException
    {
        if (collTFields == null)
        {
            if (isNew())
            {
               collTFields = new ArrayList<TField>();
            }
            else
            {
                criteria.add(TFieldPeer.OWNER, getObjectID() );
                collTFields = TFieldPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TFieldPeer.OWNER, getObjectID());
                if (!lastTFieldsCriteria.equals(criteria))
                {
                    collTFields = TFieldPeer.doSelect(criteria);
                }
            }
        }
        lastTFieldsCriteria = criteria;

        return collTFields;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTFields(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TField> getTFields(Connection con) throws TorqueException
    {
        if (collTFields == null)
        {
            collTFields = getTFields(new Criteria(10), con);
        }
        return collTFields;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TFields from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TField> getTFields(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTFields == null)
        {
            if (isNew())
            {
               collTFields = new ArrayList<TField>();
            }
            else
            {
                 criteria.add(TFieldPeer.OWNER, getObjectID());
                 collTFields = TFieldPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TFieldPeer.OWNER, getObjectID());
                 if (!lastTFieldsCriteria.equals(criteria))
                 {
                     collTFields = TFieldPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTFieldsCriteria = criteria;

         return collTFields;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TFields from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TField> getTFieldsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTFields == null)
        {
            if (isNew())
            {
               collTFields = new ArrayList<TField>();
            }
            else
            {
                criteria.add(TFieldPeer.OWNER, getObjectID());
                collTFields = TFieldPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TFieldPeer.OWNER, getObjectID());
            if (!lastTFieldsCriteria.equals(criteria))
            {
                collTFields = TFieldPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTFieldsCriteria = criteria;

        return collTFields;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TFields from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TField> getTFieldsJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTFields == null)
        {
            if (isNew())
            {
               collTFields = new ArrayList<TField>();
            }
            else
            {
                criteria.add(TFieldPeer.OWNER, getObjectID());
                collTFields = TFieldPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TFieldPeer.OWNER, getObjectID());
            if (!lastTFieldsCriteria.equals(criteria))
            {
                collTFields = TFieldPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTFieldsCriteria = criteria;

        return collTFields;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TFields from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TField> getTFieldsJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTFields == null)
        {
            if (isNew())
            {
               collTFields = new ArrayList<TField>();
            }
            else
            {
                criteria.add(TFieldPeer.OWNER, getObjectID());
                collTFields = TFieldPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TFieldPeer.OWNER, getObjectID());
            if (!lastTFieldsCriteria.equals(criteria))
            {
                collTFields = TFieldPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTFieldsCriteria = criteria;

        return collTFields;
    }





    /**
     * Collection to store aggregation of collTLists
     */
    protected List<TList> collTLists;

    /**
     * Temporary storage of collTLists to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTLists()
    {
        if (collTLists == null)
        {
            collTLists = new ArrayList<TList>();
        }
    }


    /**
     * Method called to associate a TList object to this object
     * through the TList foreign key attribute
     *
     * @param l TList
     * @throws TorqueException
     */
    public void addTList(TList l) throws TorqueException
    {
        getTLists().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TList object to this object
     * through the TList foreign key attribute using connection.
     *
     * @param l TList
     * @throws TorqueException
     */
    public void addTList(TList l, Connection con) throws TorqueException
    {
        getTLists(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTLists
     */
    private Criteria lastTListsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLists(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TList> getTLists()
        throws TorqueException
    {
        if (collTLists == null)
        {
            collTLists = getTLists(new Criteria(10));
        }
        return collTLists;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLists from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TList> getTLists(Criteria criteria) throws TorqueException
    {
        if (collTLists == null)
        {
            if (isNew())
            {
               collTLists = new ArrayList<TList>();
            }
            else
            {
                criteria.add(TListPeer.OWNER, getObjectID() );
                collTLists = TListPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TListPeer.OWNER, getObjectID());
                if (!lastTListsCriteria.equals(criteria))
                {
                    collTLists = TListPeer.doSelect(criteria);
                }
            }
        }
        lastTListsCriteria = criteria;

        return collTLists;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLists(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TList> getTLists(Connection con) throws TorqueException
    {
        if (collTLists == null)
        {
            collTLists = getTLists(new Criteria(10), con);
        }
        return collTLists;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLists from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TList> getTLists(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTLists == null)
        {
            if (isNew())
            {
               collTLists = new ArrayList<TList>();
            }
            else
            {
                 criteria.add(TListPeer.OWNER, getObjectID());
                 collTLists = TListPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TListPeer.OWNER, getObjectID());
                 if (!lastTListsCriteria.equals(criteria))
                 {
                     collTLists = TListPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTListsCriteria = criteria;

         return collTLists;
     }



















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TList> getTListsJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTLists == null)
        {
            if (isNew())
            {
               collTLists = new ArrayList<TList>();
            }
            else
            {
                criteria.add(TListPeer.OWNER, getObjectID());
                collTLists = TListPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TListPeer.OWNER, getObjectID());
            if (!lastTListsCriteria.equals(criteria))
            {
                collTLists = TListPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTListsCriteria = criteria;

        return collTLists;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLists from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TList> getTListsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTLists == null)
        {
            if (isNew())
            {
               collTLists = new ArrayList<TList>();
            }
            else
            {
                criteria.add(TListPeer.OWNER, getObjectID());
                collTLists = TListPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TListPeer.OWNER, getObjectID());
            if (!lastTListsCriteria.equals(criteria))
            {
                collTLists = TListPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTListsCriteria = criteria;

        return collTLists;
    }





    /**
     * Collection to store aggregation of collTScreens
     */
    protected List<TScreen> collTScreens;

    /**
     * Temporary storage of collTScreens to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTScreens()
    {
        if (collTScreens == null)
        {
            collTScreens = new ArrayList<TScreen>();
        }
    }


    /**
     * Method called to associate a TScreen object to this object
     * through the TScreen foreign key attribute
     *
     * @param l TScreen
     * @throws TorqueException
     */
    public void addTScreen(TScreen l) throws TorqueException
    {
        getTScreens().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TScreen object to this object
     * through the TScreen foreign key attribute using connection.
     *
     * @param l TScreen
     * @throws TorqueException
     */
    public void addTScreen(TScreen l, Connection con) throws TorqueException
    {
        getTScreens(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTScreens
     */
    private Criteria lastTScreensCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTScreens(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TScreen> getTScreens()
        throws TorqueException
    {
        if (collTScreens == null)
        {
            collTScreens = getTScreens(new Criteria(10));
        }
        return collTScreens;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TScreens from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TScreen> getTScreens(Criteria criteria) throws TorqueException
    {
        if (collTScreens == null)
        {
            if (isNew())
            {
               collTScreens = new ArrayList<TScreen>();
            }
            else
            {
                criteria.add(TScreenPeer.OWNER, getObjectID() );
                collTScreens = TScreenPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TScreenPeer.OWNER, getObjectID());
                if (!lastTScreensCriteria.equals(criteria))
                {
                    collTScreens = TScreenPeer.doSelect(criteria);
                }
            }
        }
        lastTScreensCriteria = criteria;

        return collTScreens;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTScreens(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScreen> getTScreens(Connection con) throws TorqueException
    {
        if (collTScreens == null)
        {
            collTScreens = getTScreens(new Criteria(10), con);
        }
        return collTScreens;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TScreens from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScreen> getTScreens(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTScreens == null)
        {
            if (isNew())
            {
               collTScreens = new ArrayList<TScreen>();
            }
            else
            {
                 criteria.add(TScreenPeer.OWNER, getObjectID());
                 collTScreens = TScreenPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TScreenPeer.OWNER, getObjectID());
                 if (!lastTScreensCriteria.equals(criteria))
                 {
                     collTScreens = TScreenPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTScreensCriteria = criteria;

         return collTScreens;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScreens from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScreen> getTScreensJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTScreens == null)
        {
            if (isNew())
            {
               collTScreens = new ArrayList<TScreen>();
            }
            else
            {
                criteria.add(TScreenPeer.OWNER, getObjectID());
                collTScreens = TScreenPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScreenPeer.OWNER, getObjectID());
            if (!lastTScreensCriteria.equals(criteria))
            {
                collTScreens = TScreenPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTScreensCriteria = criteria;

        return collTScreens;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScreens from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScreen> getTScreensJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTScreens == null)
        {
            if (isNew())
            {
               collTScreens = new ArrayList<TScreen>();
            }
            else
            {
                criteria.add(TScreenPeer.OWNER, getObjectID());
                collTScreens = TScreenPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScreenPeer.OWNER, getObjectID());
            if (!lastTScreensCriteria.equals(criteria))
            {
                collTScreens = TScreenPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTScreensCriteria = criteria;

        return collTScreens;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScreens from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScreen> getTScreensJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTScreens == null)
        {
            if (isNew())
            {
               collTScreens = new ArrayList<TScreen>();
            }
            else
            {
                criteria.add(TScreenPeer.OWNER, getObjectID());
                collTScreens = TScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScreenPeer.OWNER, getObjectID());
            if (!lastTScreensCriteria.equals(criteria))
            {
                collTScreens = TScreenPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTScreensCriteria = criteria;

        return collTScreens;
    }





    /**
     * Collection to store aggregation of collTNotifyTriggers
     */
    protected List<TNotifyTrigger> collTNotifyTriggers;

    /**
     * Temporary storage of collTNotifyTriggers to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTNotifyTriggers()
    {
        if (collTNotifyTriggers == null)
        {
            collTNotifyTriggers = new ArrayList<TNotifyTrigger>();
        }
    }


    /**
     * Method called to associate a TNotifyTrigger object to this object
     * through the TNotifyTrigger foreign key attribute
     *
     * @param l TNotifyTrigger
     * @throws TorqueException
     */
    public void addTNotifyTrigger(TNotifyTrigger l) throws TorqueException
    {
        getTNotifyTriggers().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TNotifyTrigger object to this object
     * through the TNotifyTrigger foreign key attribute using connection.
     *
     * @param l TNotifyTrigger
     * @throws TorqueException
     */
    public void addTNotifyTrigger(TNotifyTrigger l, Connection con) throws TorqueException
    {
        getTNotifyTriggers(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTNotifyTriggers
     */
    private Criteria lastTNotifyTriggersCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifyTriggers(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TNotifyTrigger> getTNotifyTriggers()
        throws TorqueException
    {
        if (collTNotifyTriggers == null)
        {
            collTNotifyTriggers = getTNotifyTriggers(new Criteria(10));
        }
        return collTNotifyTriggers;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifyTriggers from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TNotifyTrigger> getTNotifyTriggers(Criteria criteria) throws TorqueException
    {
        if (collTNotifyTriggers == null)
        {
            if (isNew())
            {
               collTNotifyTriggers = new ArrayList<TNotifyTrigger>();
            }
            else
            {
                criteria.add(TNotifyTriggerPeer.PERSON, getObjectID() );
                collTNotifyTriggers = TNotifyTriggerPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TNotifyTriggerPeer.PERSON, getObjectID());
                if (!lastTNotifyTriggersCriteria.equals(criteria))
                {
                    collTNotifyTriggers = TNotifyTriggerPeer.doSelect(criteria);
                }
            }
        }
        lastTNotifyTriggersCriteria = criteria;

        return collTNotifyTriggers;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifyTriggers(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotifyTrigger> getTNotifyTriggers(Connection con) throws TorqueException
    {
        if (collTNotifyTriggers == null)
        {
            collTNotifyTriggers = getTNotifyTriggers(new Criteria(10), con);
        }
        return collTNotifyTriggers;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifyTriggers from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotifyTrigger> getTNotifyTriggers(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTNotifyTriggers == null)
        {
            if (isNew())
            {
               collTNotifyTriggers = new ArrayList<TNotifyTrigger>();
            }
            else
            {
                 criteria.add(TNotifyTriggerPeer.PERSON, getObjectID());
                 collTNotifyTriggers = TNotifyTriggerPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TNotifyTriggerPeer.PERSON, getObjectID());
                 if (!lastTNotifyTriggersCriteria.equals(criteria))
                 {
                     collTNotifyTriggers = TNotifyTriggerPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTNotifyTriggersCriteria = criteria;

         return collTNotifyTriggers;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifyTriggers from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotifyTrigger> getTNotifyTriggersJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifyTriggers == null)
        {
            if (isNew())
            {
               collTNotifyTriggers = new ArrayList<TNotifyTrigger>();
            }
            else
            {
                criteria.add(TNotifyTriggerPeer.PERSON, getObjectID());
                collTNotifyTriggers = TNotifyTriggerPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifyTriggerPeer.PERSON, getObjectID());
            if (!lastTNotifyTriggersCriteria.equals(criteria))
            {
                collTNotifyTriggers = TNotifyTriggerPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTNotifyTriggersCriteria = criteria;

        return collTNotifyTriggers;
    }





    /**
     * Collection to store aggregation of collTNotifySettingss
     */
    protected List<TNotifySettings> collTNotifySettingss;

    /**
     * Temporary storage of collTNotifySettingss to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTNotifySettingss()
    {
        if (collTNotifySettingss == null)
        {
            collTNotifySettingss = new ArrayList<TNotifySettings>();
        }
    }


    /**
     * Method called to associate a TNotifySettings object to this object
     * through the TNotifySettings foreign key attribute
     *
     * @param l TNotifySettings
     * @throws TorqueException
     */
    public void addTNotifySettings(TNotifySettings l) throws TorqueException
    {
        getTNotifySettingss().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TNotifySettings object to this object
     * through the TNotifySettings foreign key attribute using connection.
     *
     * @param l TNotifySettings
     * @throws TorqueException
     */
    public void addTNotifySettings(TNotifySettings l, Connection con) throws TorqueException
    {
        getTNotifySettingss(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTNotifySettingss
     */
    private Criteria lastTNotifySettingssCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifySettingss(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TNotifySettings> getTNotifySettingss()
        throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            collTNotifySettingss = getTNotifySettingss(new Criteria(10));
        }
        return collTNotifySettingss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TNotifySettings> getTNotifySettingss(Criteria criteria) throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID() );
                collTNotifySettingss = TNotifySettingsPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                if (!lastTNotifySettingssCriteria.equals(criteria))
                {
                    collTNotifySettingss = TNotifySettingsPeer.doSelect(criteria);
                }
            }
        }
        lastTNotifySettingssCriteria = criteria;

        return collTNotifySettingss;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNotifySettingss(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotifySettings> getTNotifySettingss(Connection con) throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            collTNotifySettingss = getTNotifySettingss(new Criteria(10), con);
        }
        return collTNotifySettingss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNotifySettings> getTNotifySettingss(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                 criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                 collTNotifySettingss = TNotifySettingsPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                 if (!lastTNotifySettingssCriteria.equals(criteria))
                 {
                     collTNotifySettingss = TNotifySettingsPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTNotifySettingssCriteria = criteria;

         return collTNotifySettingss;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotifySettings> getTNotifySettingssJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
            if (!lastTNotifySettingssCriteria.equals(criteria))
            {
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTNotifySettingssCriteria = criteria;

        return collTNotifySettingss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotifySettings> getTNotifySettingssJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
            if (!lastTNotifySettingssCriteria.equals(criteria))
            {
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTNotifySettingssCriteria = criteria;

        return collTNotifySettingss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotifySettings> getTNotifySettingssJoinTNotifyTrigger(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTNotifyTrigger(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
            if (!lastTNotifySettingssCriteria.equals(criteria))
            {
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTNotifyTrigger(criteria);
            }
        }
        lastTNotifySettingssCriteria = criteria;

        return collTNotifySettingss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNotifySettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNotifySettings> getTNotifySettingssJoinTQueryRepository(Criteria criteria)
        throws TorqueException
    {
        if (collTNotifySettingss == null)
        {
            if (isNew())
            {
               collTNotifySettingss = new ArrayList<TNotifySettings>();
            }
            else
            {
                criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTQueryRepository(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNotifySettingsPeer.PERSON, getObjectID());
            if (!lastTNotifySettingssCriteria.equals(criteria))
            {
                collTNotifySettingss = TNotifySettingsPeer.doSelectJoinTQueryRepository(criteria);
            }
        }
        lastTNotifySettingssCriteria = criteria;

        return collTNotifySettingss;
    }





    /**
     * Collection to store aggregation of collTQueryRepositorys
     */
    protected List<TQueryRepository> collTQueryRepositorys;

    /**
     * Temporary storage of collTQueryRepositorys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTQueryRepositorys()
    {
        if (collTQueryRepositorys == null)
        {
            collTQueryRepositorys = new ArrayList<TQueryRepository>();
        }
    }


    /**
     * Method called to associate a TQueryRepository object to this object
     * through the TQueryRepository foreign key attribute
     *
     * @param l TQueryRepository
     * @throws TorqueException
     */
    public void addTQueryRepository(TQueryRepository l) throws TorqueException
    {
        getTQueryRepositorys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TQueryRepository object to this object
     * through the TQueryRepository foreign key attribute using connection.
     *
     * @param l TQueryRepository
     * @throws TorqueException
     */
    public void addTQueryRepository(TQueryRepository l, Connection con) throws TorqueException
    {
        getTQueryRepositorys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTQueryRepositorys
     */
    private Criteria lastTQueryRepositorysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTQueryRepositorys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TQueryRepository> getTQueryRepositorys()
        throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            collTQueryRepositorys = getTQueryRepositorys(new Criteria(10));
        }
        return collTQueryRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TQueryRepository> getTQueryRepositorys(Criteria criteria) throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID() );
                collTQueryRepositorys = TQueryRepositoryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                if (!lastTQueryRepositorysCriteria.equals(criteria))
                {
                    collTQueryRepositorys = TQueryRepositoryPeer.doSelect(criteria);
                }
            }
        }
        lastTQueryRepositorysCriteria = criteria;

        return collTQueryRepositorys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTQueryRepositorys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TQueryRepository> getTQueryRepositorys(Connection con) throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            collTQueryRepositorys = getTQueryRepositorys(new Criteria(10), con);
        }
        return collTQueryRepositorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TQueryRepository> getTQueryRepositorys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                 criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                 collTQueryRepositorys = TQueryRepositoryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                 if (!lastTQueryRepositorysCriteria.equals(criteria))
                 {
                     collTQueryRepositorys = TQueryRepositoryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTQueryRepositorysCriteria = criteria;

         return collTQueryRepositorys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TQueryRepository> getTQueryRepositorysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
            if (!lastTQueryRepositorysCriteria.equals(criteria))
            {
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTQueryRepositorysCriteria = criteria;

        return collTQueryRepositorys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TQueryRepository> getTQueryRepositorysJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
            if (!lastTQueryRepositorysCriteria.equals(criteria))
            {
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTQueryRepositorysCriteria = criteria;

        return collTQueryRepositorys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TQueryRepository> getTQueryRepositorysJoinTCLOB(Criteria criteria)
        throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTCLOB(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
            if (!lastTQueryRepositorysCriteria.equals(criteria))
            {
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTCLOB(criteria);
            }
        }
        lastTQueryRepositorysCriteria = criteria;

        return collTQueryRepositorys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TQueryRepositorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TQueryRepository> getTQueryRepositorysJoinTFilterCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTQueryRepositorys == null)
        {
            if (isNew())
            {
               collTQueryRepositorys = new ArrayList<TQueryRepository>();
            }
            else
            {
                criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTFilterCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TQueryRepositoryPeer.PERSON, getObjectID());
            if (!lastTQueryRepositorysCriteria.equals(criteria))
            {
                collTQueryRepositorys = TQueryRepositoryPeer.doSelectJoinTFilterCategory(criteria);
            }
        }
        lastTQueryRepositorysCriteria = criteria;

        return collTQueryRepositorys;
    }





    /**
     * Collection to store aggregation of collTWorkItemLinks
     */
    protected List<TWorkItemLink> collTWorkItemLinks;

    /**
     * Temporary storage of collTWorkItemLinks to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemLinks()
    {
        if (collTWorkItemLinks == null)
        {
            collTWorkItemLinks = new ArrayList<TWorkItemLink>();
        }
    }


    /**
     * Method called to associate a TWorkItemLink object to this object
     * through the TWorkItemLink foreign key attribute
     *
     * @param l TWorkItemLink
     * @throws TorqueException
     */
    public void addTWorkItemLink(TWorkItemLink l) throws TorqueException
    {
        getTWorkItemLinks().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItemLink object to this object
     * through the TWorkItemLink foreign key attribute using connection.
     *
     * @param l TWorkItemLink
     * @throws TorqueException
     */
    public void addTWorkItemLink(TWorkItemLink l, Connection con) throws TorqueException
    {
        getTWorkItemLinks(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemLinks
     */
    private Criteria lastTWorkItemLinksCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemLinks(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItemLink> getTWorkItemLinks()
        throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            collTWorkItemLinks = getTWorkItemLinks(new Criteria(10));
        }
        return collTWorkItemLinks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItemLink> getTWorkItemLinks(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID() );
                collTWorkItemLinks = TWorkItemLinkPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                if (!lastTWorkItemLinksCriteria.equals(criteria))
                {
                    collTWorkItemLinks = TWorkItemLinkPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemLinksCriteria = criteria;

        return collTWorkItemLinks;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemLinks(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItemLink> getTWorkItemLinks(Connection con) throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            collTWorkItemLinks = getTWorkItemLinks(new Criteria(10), con);
        }
        return collTWorkItemLinks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItemLink> getTWorkItemLinks(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                 criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                 collTWorkItemLinks = TWorkItemLinkPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                 if (!lastTWorkItemLinksCriteria.equals(criteria))
                 {
                     collTWorkItemLinks = TWorkItemLinkPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemLinksCriteria = criteria;

         return collTWorkItemLinks;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLink> getTWorkItemLinksJoinTWorkItemRelatedByLinkPred(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTWorkItemRelatedByLinkPred(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemLinksCriteria.equals(criteria))
            {
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTWorkItemRelatedByLinkPred(criteria);
            }
        }
        lastTWorkItemLinksCriteria = criteria;

        return collTWorkItemLinks;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLink> getTWorkItemLinksJoinTWorkItemRelatedByLinkSucc(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTWorkItemRelatedByLinkSucc(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemLinksCriteria.equals(criteria))
            {
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTWorkItemRelatedByLinkSucc(criteria);
            }
        }
        lastTWorkItemLinksCriteria = criteria;

        return collTWorkItemLinks;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLink> getTWorkItemLinksJoinTLinkType(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTLinkType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemLinksCriteria.equals(criteria))
            {
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTLinkType(criteria);
            }
        }
        lastTWorkItemLinksCriteria = criteria;

        return collTWorkItemLinks;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLinks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLink> getTWorkItemLinksJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLinks == null)
        {
            if (isNew())
            {
               collTWorkItemLinks = new ArrayList<TWorkItemLink>();
            }
            else
            {
                criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLinkPeer.CHANGEDBY, getObjectID());
            if (!lastTWorkItemLinksCriteria.equals(criteria))
            {
                collTWorkItemLinks = TWorkItemLinkPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTWorkItemLinksCriteria = criteria;

        return collTWorkItemLinks;
    }





    /**
     * Collection to store aggregation of collTWorkItemLocks
     */
    protected List<TWorkItemLock> collTWorkItemLocks;

    /**
     * Temporary storage of collTWorkItemLocks to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkItemLocks()
    {
        if (collTWorkItemLocks == null)
        {
            collTWorkItemLocks = new ArrayList<TWorkItemLock>();
        }
    }


    /**
     * Method called to associate a TWorkItemLock object to this object
     * through the TWorkItemLock foreign key attribute
     *
     * @param l TWorkItemLock
     * @throws TorqueException
     */
    public void addTWorkItemLock(TWorkItemLock l) throws TorqueException
    {
        getTWorkItemLocks().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TWorkItemLock object to this object
     * through the TWorkItemLock foreign key attribute using connection.
     *
     * @param l TWorkItemLock
     * @throws TorqueException
     */
    public void addTWorkItemLock(TWorkItemLock l, Connection con) throws TorqueException
    {
        getTWorkItemLocks(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkItemLocks
     */
    private Criteria lastTWorkItemLocksCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemLocks(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkItemLock> getTWorkItemLocks()
        throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            collTWorkItemLocks = getTWorkItemLocks(new Criteria(10));
        }
        return collTWorkItemLocks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLocks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkItemLock> getTWorkItemLocks(Criteria criteria) throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            if (isNew())
            {
               collTWorkItemLocks = new ArrayList<TWorkItemLock>();
            }
            else
            {
                criteria.add(TWorkItemLockPeer.PERSON, getObjectID() );
                collTWorkItemLocks = TWorkItemLockPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
                if (!lastTWorkItemLocksCriteria.equals(criteria))
                {
                    collTWorkItemLocks = TWorkItemLockPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkItemLocksCriteria = criteria;

        return collTWorkItemLocks;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkItemLocks(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItemLock> getTWorkItemLocks(Connection con) throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            collTWorkItemLocks = getTWorkItemLocks(new Criteria(10), con);
        }
        return collTWorkItemLocks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLocks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkItemLock> getTWorkItemLocks(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            if (isNew())
            {
               collTWorkItemLocks = new ArrayList<TWorkItemLock>();
            }
            else
            {
                 criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
                 collTWorkItemLocks = TWorkItemLockPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
                 if (!lastTWorkItemLocksCriteria.equals(criteria))
                 {
                     collTWorkItemLocks = TWorkItemLockPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkItemLocksCriteria = criteria;

         return collTWorkItemLocks;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLock> getTWorkItemLocksJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            if (isNew())
            {
               collTWorkItemLocks = new ArrayList<TWorkItemLock>();
            }
            else
            {
                criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
                collTWorkItemLocks = TWorkItemLockPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
            if (!lastTWorkItemLocksCriteria.equals(criteria))
            {
                collTWorkItemLocks = TWorkItemLockPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTWorkItemLocksCriteria = criteria;

        return collTWorkItemLocks;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkItemLocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkItemLock> getTWorkItemLocksJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkItemLocks == null)
        {
            if (isNew())
            {
               collTWorkItemLocks = new ArrayList<TWorkItemLock>();
            }
            else
            {
                criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
                collTWorkItemLocks = TWorkItemLockPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkItemLockPeer.PERSON, getObjectID());
            if (!lastTWorkItemLocksCriteria.equals(criteria))
            {
                collTWorkItemLocks = TWorkItemLockPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTWorkItemLocksCriteria = criteria;

        return collTWorkItemLocks;
    }





    /**
     * Collection to store aggregation of collTExportTemplates
     */
    protected List<TExportTemplate> collTExportTemplates;

    /**
     * Temporary storage of collTExportTemplates to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTExportTemplates()
    {
        if (collTExportTemplates == null)
        {
            collTExportTemplates = new ArrayList<TExportTemplate>();
        }
    }


    /**
     * Method called to associate a TExportTemplate object to this object
     * through the TExportTemplate foreign key attribute
     *
     * @param l TExportTemplate
     * @throws TorqueException
     */
    public void addTExportTemplate(TExportTemplate l) throws TorqueException
    {
        getTExportTemplates().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TExportTemplate object to this object
     * through the TExportTemplate foreign key attribute using connection.
     *
     * @param l TExportTemplate
     * @throws TorqueException
     */
    public void addTExportTemplate(TExportTemplate l, Connection con) throws TorqueException
    {
        getTExportTemplates(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTExportTemplates
     */
    private Criteria lastTExportTemplatesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTExportTemplates(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TExportTemplate> getTExportTemplates()
        throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            collTExportTemplates = getTExportTemplates(new Criteria(10));
        }
        return collTExportTemplates;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TExportTemplates from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TExportTemplate> getTExportTemplates(Criteria criteria) throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            if (isNew())
            {
               collTExportTemplates = new ArrayList<TExportTemplate>();
            }
            else
            {
                criteria.add(TExportTemplatePeer.PERSON, getObjectID() );
                collTExportTemplates = TExportTemplatePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                if (!lastTExportTemplatesCriteria.equals(criteria))
                {
                    collTExportTemplates = TExportTemplatePeer.doSelect(criteria);
                }
            }
        }
        lastTExportTemplatesCriteria = criteria;

        return collTExportTemplates;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTExportTemplates(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TExportTemplate> getTExportTemplates(Connection con) throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            collTExportTemplates = getTExportTemplates(new Criteria(10), con);
        }
        return collTExportTemplates;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TExportTemplates from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TExportTemplate> getTExportTemplates(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            if (isNew())
            {
               collTExportTemplates = new ArrayList<TExportTemplate>();
            }
            else
            {
                 criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                 collTExportTemplates = TExportTemplatePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                 if (!lastTExportTemplatesCriteria.equals(criteria))
                 {
                     collTExportTemplates = TExportTemplatePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTExportTemplatesCriteria = criteria;

         return collTExportTemplates;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TExportTemplates from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TExportTemplate> getTExportTemplatesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            if (isNew())
            {
               collTExportTemplates = new ArrayList<TExportTemplate>();
            }
            else
            {
                criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TExportTemplatePeer.PERSON, getObjectID());
            if (!lastTExportTemplatesCriteria.equals(criteria))
            {
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTExportTemplatesCriteria = criteria;

        return collTExportTemplates;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TExportTemplates from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TExportTemplate> getTExportTemplatesJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            if (isNew())
            {
               collTExportTemplates = new ArrayList<TExportTemplate>();
            }
            else
            {
                criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TExportTemplatePeer.PERSON, getObjectID());
            if (!lastTExportTemplatesCriteria.equals(criteria))
            {
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTProject(criteria);
            }
        }
        lastTExportTemplatesCriteria = criteria;

        return collTExportTemplates;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TExportTemplates from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TExportTemplate> getTExportTemplatesJoinTReportCategory(Criteria criteria)
        throws TorqueException
    {
        if (collTExportTemplates == null)
        {
            if (isNew())
            {
               collTExportTemplates = new ArrayList<TExportTemplate>();
            }
            else
            {
                criteria.add(TExportTemplatePeer.PERSON, getObjectID());
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTReportCategory(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TExportTemplatePeer.PERSON, getObjectID());
            if (!lastTExportTemplatesCriteria.equals(criteria))
            {
                collTExportTemplates = TExportTemplatePeer.doSelectJoinTReportCategory(criteria);
            }
        }
        lastTExportTemplatesCriteria = criteria;

        return collTExportTemplates;
    }













    /**
     * Collection to store aggregation of collTLoggedInUserss
     */
    protected List<TLoggedInUsers> collTLoggedInUserss;

    /**
     * Temporary storage of collTLoggedInUserss to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTLoggedInUserss()
    {
        if (collTLoggedInUserss == null)
        {
            collTLoggedInUserss = new ArrayList<TLoggedInUsers>();
        }
    }


    /**
     * Method called to associate a TLoggedInUsers object to this object
     * through the TLoggedInUsers foreign key attribute
     *
     * @param l TLoggedInUsers
     * @throws TorqueException
     */
    public void addTLoggedInUsers(TLoggedInUsers l) throws TorqueException
    {
        getTLoggedInUserss().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TLoggedInUsers object to this object
     * through the TLoggedInUsers foreign key attribute using connection.
     *
     * @param l TLoggedInUsers
     * @throws TorqueException
     */
    public void addTLoggedInUsers(TLoggedInUsers l, Connection con) throws TorqueException
    {
        getTLoggedInUserss(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTLoggedInUserss
     */
    private Criteria lastTLoggedInUserssCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLoggedInUserss(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TLoggedInUsers> getTLoggedInUserss()
        throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            collTLoggedInUserss = getTLoggedInUserss(new Criteria(10));
        }
        return collTLoggedInUserss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLoggedInUserss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TLoggedInUsers> getTLoggedInUserss(Criteria criteria) throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            if (isNew())
            {
               collTLoggedInUserss = new ArrayList<TLoggedInUsers>();
            }
            else
            {
                criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID() );
                collTLoggedInUserss = TLoggedInUsersPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
                if (!lastTLoggedInUserssCriteria.equals(criteria))
                {
                    collTLoggedInUserss = TLoggedInUsersPeer.doSelect(criteria);
                }
            }
        }
        lastTLoggedInUserssCriteria = criteria;

        return collTLoggedInUserss;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLoggedInUserss(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLoggedInUsers> getTLoggedInUserss(Connection con) throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            collTLoggedInUserss = getTLoggedInUserss(new Criteria(10), con);
        }
        return collTLoggedInUserss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLoggedInUserss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLoggedInUsers> getTLoggedInUserss(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            if (isNew())
            {
               collTLoggedInUserss = new ArrayList<TLoggedInUsers>();
            }
            else
            {
                 criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
                 collTLoggedInUserss = TLoggedInUsersPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
                 if (!lastTLoggedInUserssCriteria.equals(criteria))
                 {
                     collTLoggedInUserss = TLoggedInUsersPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTLoggedInUserssCriteria = criteria;

         return collTLoggedInUserss;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLoggedInUserss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLoggedInUsers> getTLoggedInUserssJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            if (isNew())
            {
               collTLoggedInUserss = new ArrayList<TLoggedInUsers>();
            }
            else
            {
                criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
                collTLoggedInUserss = TLoggedInUsersPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
            if (!lastTLoggedInUserssCriteria.equals(criteria))
            {
                collTLoggedInUserss = TLoggedInUsersPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTLoggedInUserssCriteria = criteria;

        return collTLoggedInUserss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLoggedInUserss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLoggedInUsers> getTLoggedInUserssJoinTClusterNode(Criteria criteria)
        throws TorqueException
    {
        if (collTLoggedInUserss == null)
        {
            if (isNew())
            {
               collTLoggedInUserss = new ArrayList<TLoggedInUsers>();
            }
            else
            {
                criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
                collTLoggedInUserss = TLoggedInUsersPeer.doSelectJoinTClusterNode(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLoggedInUsersPeer.LOGGEDUSER, getObjectID());
            if (!lastTLoggedInUserssCriteria.equals(criteria))
            {
                collTLoggedInUserss = TLoggedInUsersPeer.doSelectJoinTClusterNode(criteria);
            }
        }
        lastTLoggedInUserssCriteria = criteria;

        return collTLoggedInUserss;
    }





    /**
     * Collection to store aggregation of collTSummaryMailsRelatedByPERSONFROM
     */
    protected List<TSummaryMail> collTSummaryMailsRelatedByPERSONFROM;

    /**
     * Temporary storage of collTSummaryMailsRelatedByPERSONFROM to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTSummaryMailsRelatedByPERSONFROM()
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            collTSummaryMailsRelatedByPERSONFROM = new ArrayList<TSummaryMail>();
        }
    }


    /**
     * Method called to associate a TSummaryMail object to this object
     * through the TSummaryMail foreign key attribute
     *
     * @param l TSummaryMail
     * @throws TorqueException
     */
    public void addTSummaryMailRelatedByPERSONFROM(TSummaryMail l) throws TorqueException
    {
        getTSummaryMailsRelatedByPERSONFROM().add(l);
        l.setTPersonRelatedByPERSONFROM((TPerson) this);
    }

    /**
     * Method called to associate a TSummaryMail object to this object
     * through the TSummaryMail foreign key attribute using connection.
     *
     * @param l TSummaryMail
     * @throws TorqueException
     */
    public void addTSummaryMailRelatedByPERSONFROM(TSummaryMail l, Connection con) throws TorqueException
    {
        getTSummaryMailsRelatedByPERSONFROM(con).add(l);
        l.setTPersonRelatedByPERSONFROM((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTSummaryMailsRelatedByPERSONFROM
     */
    private Criteria lastTSummaryMailsRelatedByPERSONFROMCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSummaryMailsRelatedByPERSONFROM(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROM()
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            collTSummaryMailsRelatedByPERSONFROM = getTSummaryMailsRelatedByPERSONFROM(new Criteria(10));
        }
        return collTSummaryMailsRelatedByPERSONFROM;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONFROM from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROM(Criteria criteria) throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONFROM = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID() );
                collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
                if (!lastTSummaryMailsRelatedByPERSONFROMCriteria.equals(criteria))
                {
                    collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelect(criteria);
                }
            }
        }
        lastTSummaryMailsRelatedByPERSONFROMCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONFROM;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSummaryMailsRelatedByPERSONFROM(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROM(Connection con) throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            collTSummaryMailsRelatedByPERSONFROM = getTSummaryMailsRelatedByPERSONFROM(new Criteria(10), con);
        }
        return collTSummaryMailsRelatedByPERSONFROM;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONFROM from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROM(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONFROM = new ArrayList<TSummaryMail>();
            }
            else
            {
                 criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
                 collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
                 if (!lastTSummaryMailsRelatedByPERSONFROMCriteria.equals(criteria))
                 {
                     collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTSummaryMailsRelatedByPERSONFROMCriteria = criteria;

         return collTSummaryMailsRelatedByPERSONFROM;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONFROM from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROMJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONFROM = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
                collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
            if (!lastTSummaryMailsRelatedByPERSONFROMCriteria.equals(criteria))
            {
                collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTSummaryMailsRelatedByPERSONFROMCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONFROM;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONFROM from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TSummaryMail> getTSummaryMailsRelatedByPERSONFROMJoinTPersonRelatedByPERSONTO(Criteria criteria)
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONFROM == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONFROM = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
                collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelectJoinTPersonRelatedByPERSONTO(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TSummaryMailPeer.PERSONFROM, getObjectID());
            if (!lastTSummaryMailsRelatedByPERSONFROMCriteria.equals(criteria))
            {
                collTSummaryMailsRelatedByPERSONFROM = TSummaryMailPeer.doSelectJoinTPersonRelatedByPERSONTO(criteria);
            }
        }
        lastTSummaryMailsRelatedByPERSONFROMCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONFROM;
    }





    /**
     * Collection to store aggregation of collTSummaryMailsRelatedByPERSONTO
     */
    protected List<TSummaryMail> collTSummaryMailsRelatedByPERSONTO;

    /**
     * Temporary storage of collTSummaryMailsRelatedByPERSONTO to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTSummaryMailsRelatedByPERSONTO()
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            collTSummaryMailsRelatedByPERSONTO = new ArrayList<TSummaryMail>();
        }
    }


    /**
     * Method called to associate a TSummaryMail object to this object
     * through the TSummaryMail foreign key attribute
     *
     * @param l TSummaryMail
     * @throws TorqueException
     */
    public void addTSummaryMailRelatedByPERSONTO(TSummaryMail l) throws TorqueException
    {
        getTSummaryMailsRelatedByPERSONTO().add(l);
        l.setTPersonRelatedByPERSONTO((TPerson) this);
    }

    /**
     * Method called to associate a TSummaryMail object to this object
     * through the TSummaryMail foreign key attribute using connection.
     *
     * @param l TSummaryMail
     * @throws TorqueException
     */
    public void addTSummaryMailRelatedByPERSONTO(TSummaryMail l, Connection con) throws TorqueException
    {
        getTSummaryMailsRelatedByPERSONTO(con).add(l);
        l.setTPersonRelatedByPERSONTO((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTSummaryMailsRelatedByPERSONTO
     */
    private Criteria lastTSummaryMailsRelatedByPERSONTOCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSummaryMailsRelatedByPERSONTO(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONTO()
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            collTSummaryMailsRelatedByPERSONTO = getTSummaryMailsRelatedByPERSONTO(new Criteria(10));
        }
        return collTSummaryMailsRelatedByPERSONTO;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONTO from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONTO(Criteria criteria) throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONTO = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONTO, getObjectID() );
                collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
                if (!lastTSummaryMailsRelatedByPERSONTOCriteria.equals(criteria))
                {
                    collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelect(criteria);
                }
            }
        }
        lastTSummaryMailsRelatedByPERSONTOCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONTO;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTSummaryMailsRelatedByPERSONTO(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONTO(Connection con) throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            collTSummaryMailsRelatedByPERSONTO = getTSummaryMailsRelatedByPERSONTO(new Criteria(10), con);
        }
        return collTSummaryMailsRelatedByPERSONTO;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONTO from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TSummaryMail> getTSummaryMailsRelatedByPERSONTO(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONTO = new ArrayList<TSummaryMail>();
            }
            else
            {
                 criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
                 collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
                 if (!lastTSummaryMailsRelatedByPERSONTOCriteria.equals(criteria))
                 {
                     collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTSummaryMailsRelatedByPERSONTOCriteria = criteria;

         return collTSummaryMailsRelatedByPERSONTO;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONTO from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TSummaryMail> getTSummaryMailsRelatedByPERSONTOJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONTO = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
                collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
            if (!lastTSummaryMailsRelatedByPERSONTOCriteria.equals(criteria))
            {
                collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTSummaryMailsRelatedByPERSONTOCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONTO;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TSummaryMailsRelatedByPERSONTO from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TSummaryMail> getTSummaryMailsRelatedByPERSONTOJoinTPersonRelatedByPERSONFROM(Criteria criteria)
        throws TorqueException
    {
        if (collTSummaryMailsRelatedByPERSONTO == null)
        {
            if (isNew())
            {
               collTSummaryMailsRelatedByPERSONTO = new ArrayList<TSummaryMail>();
            }
            else
            {
                criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
                collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelectJoinTPersonRelatedByPERSONFROM(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TSummaryMailPeer.PERSONTO, getObjectID());
            if (!lastTSummaryMailsRelatedByPERSONTOCriteria.equals(criteria))
            {
                collTSummaryMailsRelatedByPERSONTO = TSummaryMailPeer.doSelectJoinTPersonRelatedByPERSONFROM(criteria);
            }
        }
        lastTSummaryMailsRelatedByPERSONTOCriteria = criteria;

        return collTSummaryMailsRelatedByPERSONTO;
    }













    /**
     * Collection to store aggregation of collTHistoryTransactions
     */
    protected List<THistoryTransaction> collTHistoryTransactions;

    /**
     * Temporary storage of collTHistoryTransactions to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTHistoryTransactions()
    {
        if (collTHistoryTransactions == null)
        {
            collTHistoryTransactions = new ArrayList<THistoryTransaction>();
        }
    }


    /**
     * Method called to associate a THistoryTransaction object to this object
     * through the THistoryTransaction foreign key attribute
     *
     * @param l THistoryTransaction
     * @throws TorqueException
     */
    public void addTHistoryTransaction(THistoryTransaction l) throws TorqueException
    {
        getTHistoryTransactions().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a THistoryTransaction object to this object
     * through the THistoryTransaction foreign key attribute using connection.
     *
     * @param l THistoryTransaction
     * @throws TorqueException
     */
    public void addTHistoryTransaction(THistoryTransaction l, Connection con) throws TorqueException
    {
        getTHistoryTransactions(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTHistoryTransactions
     */
    private Criteria lastTHistoryTransactionsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTHistoryTransactions(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<THistoryTransaction> getTHistoryTransactions()
        throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            collTHistoryTransactions = getTHistoryTransactions(new Criteria(10));
        }
        return collTHistoryTransactions;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related THistoryTransactions from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<THistoryTransaction> getTHistoryTransactions(Criteria criteria) throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            if (isNew())
            {
               collTHistoryTransactions = new ArrayList<THistoryTransaction>();
            }
            else
            {
                criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID() );
                collTHistoryTransactions = THistoryTransactionPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
                if (!lastTHistoryTransactionsCriteria.equals(criteria))
                {
                    collTHistoryTransactions = THistoryTransactionPeer.doSelect(criteria);
                }
            }
        }
        lastTHistoryTransactionsCriteria = criteria;

        return collTHistoryTransactions;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTHistoryTransactions(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<THistoryTransaction> getTHistoryTransactions(Connection con) throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            collTHistoryTransactions = getTHistoryTransactions(new Criteria(10), con);
        }
        return collTHistoryTransactions;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related THistoryTransactions from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<THistoryTransaction> getTHistoryTransactions(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            if (isNew())
            {
               collTHistoryTransactions = new ArrayList<THistoryTransaction>();
            }
            else
            {
                 criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
                 collTHistoryTransactions = THistoryTransactionPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
                 if (!lastTHistoryTransactionsCriteria.equals(criteria))
                 {
                     collTHistoryTransactions = THistoryTransactionPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTHistoryTransactionsCriteria = criteria;

         return collTHistoryTransactions;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related THistoryTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<THistoryTransaction> getTHistoryTransactionsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            if (isNew())
            {
               collTHistoryTransactions = new ArrayList<THistoryTransaction>();
            }
            else
            {
                criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
                collTHistoryTransactions = THistoryTransactionPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
            if (!lastTHistoryTransactionsCriteria.equals(criteria))
            {
                collTHistoryTransactions = THistoryTransactionPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTHistoryTransactionsCriteria = criteria;

        return collTHistoryTransactions;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related THistoryTransactions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<THistoryTransaction> getTHistoryTransactionsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTHistoryTransactions == null)
        {
            if (isNew())
            {
               collTHistoryTransactions = new ArrayList<THistoryTransaction>();
            }
            else
            {
                criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
                collTHistoryTransactions = THistoryTransactionPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(THistoryTransactionPeer.CHANGEDBY, getObjectID());
            if (!lastTHistoryTransactionsCriteria.equals(criteria))
            {
                collTHistoryTransactions = THistoryTransactionPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTHistoryTransactionsCriteria = criteria;

        return collTHistoryTransactions;
    }





    /**
     * Collection to store aggregation of collTScriptss
     */
    protected List<TScripts> collTScriptss;

    /**
     * Temporary storage of collTScriptss to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTScriptss()
    {
        if (collTScriptss == null)
        {
            collTScriptss = new ArrayList<TScripts>();
        }
    }


    /**
     * Method called to associate a TScripts object to this object
     * through the TScripts foreign key attribute
     *
     * @param l TScripts
     * @throws TorqueException
     */
    public void addTScripts(TScripts l) throws TorqueException
    {
        getTScriptss().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TScripts object to this object
     * through the TScripts foreign key attribute using connection.
     *
     * @param l TScripts
     * @throws TorqueException
     */
    public void addTScripts(TScripts l, Connection con) throws TorqueException
    {
        getTScriptss(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTScriptss
     */
    private Criteria lastTScriptssCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTScriptss(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TScripts> getTScriptss()
        throws TorqueException
    {
        if (collTScriptss == null)
        {
            collTScriptss = getTScriptss(new Criteria(10));
        }
        return collTScriptss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TScriptss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TScripts> getTScriptss(Criteria criteria) throws TorqueException
    {
        if (collTScriptss == null)
        {
            if (isNew())
            {
               collTScriptss = new ArrayList<TScripts>();
            }
            else
            {
                criteria.add(TScriptsPeer.CHANGEDBY, getObjectID() );
                collTScriptss = TScriptsPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                if (!lastTScriptssCriteria.equals(criteria))
                {
                    collTScriptss = TScriptsPeer.doSelect(criteria);
                }
            }
        }
        lastTScriptssCriteria = criteria;

        return collTScriptss;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTScriptss(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScripts> getTScriptss(Connection con) throws TorqueException
    {
        if (collTScriptss == null)
        {
            collTScriptss = getTScriptss(new Criteria(10), con);
        }
        return collTScriptss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TScriptss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TScripts> getTScriptss(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTScriptss == null)
        {
            if (isNew())
            {
               collTScriptss = new ArrayList<TScripts>();
            }
            else
            {
                 criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                 collTScriptss = TScriptsPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                 if (!lastTScriptssCriteria.equals(criteria))
                 {
                     collTScriptss = TScriptsPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTScriptssCriteria = criteria;

         return collTScriptss;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScriptss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScripts> getTScriptssJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTScriptss == null)
        {
            if (isNew())
            {
               collTScriptss = new ArrayList<TScripts>();
            }
            else
            {
                criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                collTScriptss = TScriptsPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
            if (!lastTScriptssCriteria.equals(criteria))
            {
                collTScriptss = TScriptsPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTScriptssCriteria = criteria;

        return collTScriptss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScriptss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScripts> getTScriptssJoinTProjectType(Criteria criteria)
        throws TorqueException
    {
        if (collTScriptss == null)
        {
            if (isNew())
            {
               collTScriptss = new ArrayList<TScripts>();
            }
            else
            {
                criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                collTScriptss = TScriptsPeer.doSelectJoinTProjectType(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
            if (!lastTScriptssCriteria.equals(criteria))
            {
                collTScriptss = TScriptsPeer.doSelectJoinTProjectType(criteria);
            }
        }
        lastTScriptssCriteria = criteria;

        return collTScriptss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TScriptss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TScripts> getTScriptssJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTScriptss == null)
        {
            if (isNew())
            {
               collTScriptss = new ArrayList<TScripts>();
            }
            else
            {
                criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
                collTScriptss = TScriptsPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TScriptsPeer.CHANGEDBY, getObjectID());
            if (!lastTScriptssCriteria.equals(criteria))
            {
                collTScriptss = TScriptsPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTScriptssCriteria = criteria;

        return collTScriptss;
    }





    /**
     * Collection to store aggregation of collTTemplatePersons
     */
    protected List<TTemplatePerson> collTTemplatePersons;

    /**
     * Temporary storage of collTTemplatePersons to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTTemplatePersons()
    {
        if (collTTemplatePersons == null)
        {
            collTTemplatePersons = new ArrayList<TTemplatePerson>();
        }
    }


    /**
     * Method called to associate a TTemplatePerson object to this object
     * through the TTemplatePerson foreign key attribute
     *
     * @param l TTemplatePerson
     * @throws TorqueException
     */
    public void addTTemplatePerson(TTemplatePerson l) throws TorqueException
    {
        getTTemplatePersons().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TTemplatePerson object to this object
     * through the TTemplatePerson foreign key attribute using connection.
     *
     * @param l TTemplatePerson
     * @throws TorqueException
     */
    public void addTTemplatePerson(TTemplatePerson l, Connection con) throws TorqueException
    {
        getTTemplatePersons(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTTemplatePersons
     */
    private Criteria lastTTemplatePersonsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTTemplatePersons(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TTemplatePerson> getTTemplatePersons()
        throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            collTTemplatePersons = getTTemplatePersons(new Criteria(10));
        }
        return collTTemplatePersons;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TTemplatePersons from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TTemplatePerson> getTTemplatePersons(Criteria criteria) throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            if (isNew())
            {
               collTTemplatePersons = new ArrayList<TTemplatePerson>();
            }
            else
            {
                criteria.add(TTemplatePersonPeer.PERSON, getObjectID() );
                collTTemplatePersons = TTemplatePersonPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
                if (!lastTTemplatePersonsCriteria.equals(criteria))
                {
                    collTTemplatePersons = TTemplatePersonPeer.doSelect(criteria);
                }
            }
        }
        lastTTemplatePersonsCriteria = criteria;

        return collTTemplatePersons;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTTemplatePersons(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TTemplatePerson> getTTemplatePersons(Connection con) throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            collTTemplatePersons = getTTemplatePersons(new Criteria(10), con);
        }
        return collTTemplatePersons;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TTemplatePersons from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TTemplatePerson> getTTemplatePersons(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            if (isNew())
            {
               collTTemplatePersons = new ArrayList<TTemplatePerson>();
            }
            else
            {
                 criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
                 collTTemplatePersons = TTemplatePersonPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
                 if (!lastTTemplatePersonsCriteria.equals(criteria))
                 {
                     collTTemplatePersons = TTemplatePersonPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTTemplatePersonsCriteria = criteria;

         return collTTemplatePersons;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TTemplatePersons from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TTemplatePerson> getTTemplatePersonsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            if (isNew())
            {
               collTTemplatePersons = new ArrayList<TTemplatePerson>();
            }
            else
            {
                criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
                collTTemplatePersons = TTemplatePersonPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
            if (!lastTTemplatePersonsCriteria.equals(criteria))
            {
                collTTemplatePersons = TTemplatePersonPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTTemplatePersonsCriteria = criteria;

        return collTTemplatePersons;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TTemplatePersons from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TTemplatePerson> getTTemplatePersonsJoinTExportTemplate(Criteria criteria)
        throws TorqueException
    {
        if (collTTemplatePersons == null)
        {
            if (isNew())
            {
               collTTemplatePersons = new ArrayList<TTemplatePerson>();
            }
            else
            {
                criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
                collTTemplatePersons = TTemplatePersonPeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TTemplatePersonPeer.PERSON, getObjectID());
            if (!lastTTemplatePersonsCriteria.equals(criteria))
            {
                collTTemplatePersons = TTemplatePersonPeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        lastTTemplatePersonsCriteria = criteria;

        return collTTemplatePersons;
    }





    /**
     * Collection to store aggregation of collTReportPersonSettingss
     */
    protected List<TReportPersonSettings> collTReportPersonSettingss;

    /**
     * Temporary storage of collTReportPersonSettingss to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTReportPersonSettingss()
    {
        if (collTReportPersonSettingss == null)
        {
            collTReportPersonSettingss = new ArrayList<TReportPersonSettings>();
        }
    }


    /**
     * Method called to associate a TReportPersonSettings object to this object
     * through the TReportPersonSettings foreign key attribute
     *
     * @param l TReportPersonSettings
     * @throws TorqueException
     */
    public void addTReportPersonSettings(TReportPersonSettings l) throws TorqueException
    {
        getTReportPersonSettingss().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TReportPersonSettings object to this object
     * through the TReportPersonSettings foreign key attribute using connection.
     *
     * @param l TReportPersonSettings
     * @throws TorqueException
     */
    public void addTReportPersonSettings(TReportPersonSettings l, Connection con) throws TorqueException
    {
        getTReportPersonSettingss(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTReportPersonSettingss
     */
    private Criteria lastTReportPersonSettingssCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportPersonSettingss(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TReportPersonSettings> getTReportPersonSettingss()
        throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            collTReportPersonSettingss = getTReportPersonSettingss(new Criteria(10));
        }
        return collTReportPersonSettingss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportPersonSettingss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TReportPersonSettings> getTReportPersonSettingss(Criteria criteria) throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            if (isNew())
            {
               collTReportPersonSettingss = new ArrayList<TReportPersonSettings>();
            }
            else
            {
                criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID() );
                collTReportPersonSettingss = TReportPersonSettingsPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
                if (!lastTReportPersonSettingssCriteria.equals(criteria))
                {
                    collTReportPersonSettingss = TReportPersonSettingsPeer.doSelect(criteria);
                }
            }
        }
        lastTReportPersonSettingssCriteria = criteria;

        return collTReportPersonSettingss;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportPersonSettingss(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportPersonSettings> getTReportPersonSettingss(Connection con) throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            collTReportPersonSettingss = getTReportPersonSettingss(new Criteria(10), con);
        }
        return collTReportPersonSettingss;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportPersonSettingss from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportPersonSettings> getTReportPersonSettingss(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            if (isNew())
            {
               collTReportPersonSettingss = new ArrayList<TReportPersonSettings>();
            }
            else
            {
                 criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
                 collTReportPersonSettingss = TReportPersonSettingsPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
                 if (!lastTReportPersonSettingssCriteria.equals(criteria))
                 {
                     collTReportPersonSettingss = TReportPersonSettingsPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTReportPersonSettingssCriteria = criteria;

         return collTReportPersonSettingss;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportPersonSettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportPersonSettings> getTReportPersonSettingssJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            if (isNew())
            {
               collTReportPersonSettingss = new ArrayList<TReportPersonSettings>();
            }
            else
            {
                criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
                collTReportPersonSettingss = TReportPersonSettingsPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
            if (!lastTReportPersonSettingssCriteria.equals(criteria))
            {
                collTReportPersonSettingss = TReportPersonSettingsPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTReportPersonSettingssCriteria = criteria;

        return collTReportPersonSettingss;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportPersonSettingss from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportPersonSettings> getTReportPersonSettingssJoinTExportTemplate(Criteria criteria)
        throws TorqueException
    {
        if (collTReportPersonSettingss == null)
        {
            if (isNew())
            {
               collTReportPersonSettingss = new ArrayList<TReportPersonSettings>();
            }
            else
            {
                criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
                collTReportPersonSettingss = TReportPersonSettingsPeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportPersonSettingsPeer.PERSON, getObjectID());
            if (!lastTReportPersonSettingssCriteria.equals(criteria))
            {
                collTReportPersonSettingss = TReportPersonSettingsPeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        lastTReportPersonSettingssCriteria = criteria;

        return collTReportPersonSettingss;
    }





    /**
     * Collection to store aggregation of collTMSProjectExchanges
     */
    protected List<TMSProjectExchange> collTMSProjectExchanges;

    /**
     * Temporary storage of collTMSProjectExchanges to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTMSProjectExchanges()
    {
        if (collTMSProjectExchanges == null)
        {
            collTMSProjectExchanges = new ArrayList<TMSProjectExchange>();
        }
    }


    /**
     * Method called to associate a TMSProjectExchange object to this object
     * through the TMSProjectExchange foreign key attribute
     *
     * @param l TMSProjectExchange
     * @throws TorqueException
     */
    public void addTMSProjectExchange(TMSProjectExchange l) throws TorqueException
    {
        getTMSProjectExchanges().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TMSProjectExchange object to this object
     * through the TMSProjectExchange foreign key attribute using connection.
     *
     * @param l TMSProjectExchange
     * @throws TorqueException
     */
    public void addTMSProjectExchange(TMSProjectExchange l, Connection con) throws TorqueException
    {
        getTMSProjectExchanges(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTMSProjectExchanges
     */
    private Criteria lastTMSProjectExchangesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMSProjectExchanges(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TMSProjectExchange> getTMSProjectExchanges()
        throws TorqueException
    {
        if (collTMSProjectExchanges == null)
        {
            collTMSProjectExchanges = getTMSProjectExchanges(new Criteria(10));
        }
        return collTMSProjectExchanges;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMSProjectExchanges from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TMSProjectExchange> getTMSProjectExchanges(Criteria criteria) throws TorqueException
    {
        if (collTMSProjectExchanges == null)
        {
            if (isNew())
            {
               collTMSProjectExchanges = new ArrayList<TMSProjectExchange>();
            }
            else
            {
                criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID() );
                collTMSProjectExchanges = TMSProjectExchangePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID());
                if (!lastTMSProjectExchangesCriteria.equals(criteria))
                {
                    collTMSProjectExchanges = TMSProjectExchangePeer.doSelect(criteria);
                }
            }
        }
        lastTMSProjectExchangesCriteria = criteria;

        return collTMSProjectExchanges;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMSProjectExchanges(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMSProjectExchange> getTMSProjectExchanges(Connection con) throws TorqueException
    {
        if (collTMSProjectExchanges == null)
        {
            collTMSProjectExchanges = getTMSProjectExchanges(new Criteria(10), con);
        }
        return collTMSProjectExchanges;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMSProjectExchanges from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMSProjectExchange> getTMSProjectExchanges(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTMSProjectExchanges == null)
        {
            if (isNew())
            {
               collTMSProjectExchanges = new ArrayList<TMSProjectExchange>();
            }
            else
            {
                 criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID());
                 collTMSProjectExchanges = TMSProjectExchangePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID());
                 if (!lastTMSProjectExchangesCriteria.equals(criteria))
                 {
                     collTMSProjectExchanges = TMSProjectExchangePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTMSProjectExchangesCriteria = criteria;

         return collTMSProjectExchanges;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TMSProjectExchanges from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TMSProjectExchange> getTMSProjectExchangesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTMSProjectExchanges == null)
        {
            if (isNew())
            {
               collTMSProjectExchanges = new ArrayList<TMSProjectExchange>();
            }
            else
            {
                criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID());
                collTMSProjectExchanges = TMSProjectExchangePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TMSProjectExchangePeer.CHANGEDBY, getObjectID());
            if (!lastTMSProjectExchangesCriteria.equals(criteria))
            {
                collTMSProjectExchanges = TMSProjectExchangePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTMSProjectExchangesCriteria = criteria;

        return collTMSProjectExchanges;
    }





    /**
     * Collection to store aggregation of collTFilterCategorys
     */
    protected List<TFilterCategory> collTFilterCategorys;

    /**
     * Temporary storage of collTFilterCategorys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTFilterCategorys()
    {
        if (collTFilterCategorys == null)
        {
            collTFilterCategorys = new ArrayList<TFilterCategory>();
        }
    }


    /**
     * Method called to associate a TFilterCategory object to this object
     * through the TFilterCategory foreign key attribute
     *
     * @param l TFilterCategory
     * @throws TorqueException
     */
    public void addTFilterCategory(TFilterCategory l) throws TorqueException
    {
        getTFilterCategorys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TFilterCategory object to this object
     * through the TFilterCategory foreign key attribute using connection.
     *
     * @param l TFilterCategory
     * @throws TorqueException
     */
    public void addTFilterCategory(TFilterCategory l, Connection con) throws TorqueException
    {
        getTFilterCategorys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTFilterCategorys
     */
    private Criteria lastTFilterCategorysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTFilterCategorys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TFilterCategory> getTFilterCategorys()
        throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            collTFilterCategorys = getTFilterCategorys(new Criteria(10));
        }
        return collTFilterCategorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TFilterCategorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TFilterCategory> getTFilterCategorys(Criteria criteria) throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            if (isNew())
            {
               collTFilterCategorys = new ArrayList<TFilterCategory>();
            }
            else
            {
                criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID() );
                collTFilterCategorys = TFilterCategoryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
                if (!lastTFilterCategorysCriteria.equals(criteria))
                {
                    collTFilterCategorys = TFilterCategoryPeer.doSelect(criteria);
                }
            }
        }
        lastTFilterCategorysCriteria = criteria;

        return collTFilterCategorys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTFilterCategorys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TFilterCategory> getTFilterCategorys(Connection con) throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            collTFilterCategorys = getTFilterCategorys(new Criteria(10), con);
        }
        return collTFilterCategorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TFilterCategorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TFilterCategory> getTFilterCategorys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            if (isNew())
            {
               collTFilterCategorys = new ArrayList<TFilterCategory>();
            }
            else
            {
                 criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
                 collTFilterCategorys = TFilterCategoryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
                 if (!lastTFilterCategorysCriteria.equals(criteria))
                 {
                     collTFilterCategorys = TFilterCategoryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTFilterCategorysCriteria = criteria;

         return collTFilterCategorys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TFilterCategorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TFilterCategory> getTFilterCategorysJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            if (isNew())
            {
               collTFilterCategorys = new ArrayList<TFilterCategory>();
            }
            else
            {
                criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
                collTFilterCategorys = TFilterCategoryPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
            if (!lastTFilterCategorysCriteria.equals(criteria))
            {
                collTFilterCategorys = TFilterCategoryPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTFilterCategorysCriteria = criteria;

        return collTFilterCategorys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TFilterCategorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TFilterCategory> getTFilterCategorysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTFilterCategorys == null)
        {
            if (isNew())
            {
               collTFilterCategorys = new ArrayList<TFilterCategory>();
            }
            else
            {
                criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
                collTFilterCategorys = TFilterCategoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TFilterCategoryPeer.CREATEDBY, getObjectID());
            if (!lastTFilterCategorysCriteria.equals(criteria))
            {
                collTFilterCategorys = TFilterCategoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTFilterCategorysCriteria = criteria;

        return collTFilterCategorys;
    }













    /**
     * Collection to store aggregation of collTReportCategorys
     */
    protected List<TReportCategory> collTReportCategorys;

    /**
     * Temporary storage of collTReportCategorys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTReportCategorys()
    {
        if (collTReportCategorys == null)
        {
            collTReportCategorys = new ArrayList<TReportCategory>();
        }
    }


    /**
     * Method called to associate a TReportCategory object to this object
     * through the TReportCategory foreign key attribute
     *
     * @param l TReportCategory
     * @throws TorqueException
     */
    public void addTReportCategory(TReportCategory l) throws TorqueException
    {
        getTReportCategorys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TReportCategory object to this object
     * through the TReportCategory foreign key attribute using connection.
     *
     * @param l TReportCategory
     * @throws TorqueException
     */
    public void addTReportCategory(TReportCategory l, Connection con) throws TorqueException
    {
        getTReportCategorys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTReportCategorys
     */
    private Criteria lastTReportCategorysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportCategorys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TReportCategory> getTReportCategorys()
        throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            collTReportCategorys = getTReportCategorys(new Criteria(10));
        }
        return collTReportCategorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportCategorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TReportCategory> getTReportCategorys(Criteria criteria) throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            if (isNew())
            {
               collTReportCategorys = new ArrayList<TReportCategory>();
            }
            else
            {
                criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID() );
                collTReportCategorys = TReportCategoryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
                if (!lastTReportCategorysCriteria.equals(criteria))
                {
                    collTReportCategorys = TReportCategoryPeer.doSelect(criteria);
                }
            }
        }
        lastTReportCategorysCriteria = criteria;

        return collTReportCategorys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportCategorys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportCategory> getTReportCategorys(Connection con) throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            collTReportCategorys = getTReportCategorys(new Criteria(10), con);
        }
        return collTReportCategorys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportCategorys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportCategory> getTReportCategorys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            if (isNew())
            {
               collTReportCategorys = new ArrayList<TReportCategory>();
            }
            else
            {
                 criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
                 collTReportCategorys = TReportCategoryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
                 if (!lastTReportCategorysCriteria.equals(criteria))
                 {
                     collTReportCategorys = TReportCategoryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTReportCategorysCriteria = criteria;

         return collTReportCategorys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportCategorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportCategory> getTReportCategorysJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            if (isNew())
            {
               collTReportCategorys = new ArrayList<TReportCategory>();
            }
            else
            {
                criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
                collTReportCategorys = TReportCategoryPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
            if (!lastTReportCategorysCriteria.equals(criteria))
            {
                collTReportCategorys = TReportCategoryPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTReportCategorysCriteria = criteria;

        return collTReportCategorys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportCategorys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportCategory> getTReportCategorysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTReportCategorys == null)
        {
            if (isNew())
            {
               collTReportCategorys = new ArrayList<TReportCategory>();
            }
            else
            {
                criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
                collTReportCategorys = TReportCategoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportCategoryPeer.CREATEDBY, getObjectID());
            if (!lastTReportCategorysCriteria.equals(criteria))
            {
                collTReportCategorys = TReportCategoryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTReportCategorysCriteria = criteria;

        return collTReportCategorys;
    }













    /**
     * Collection to store aggregation of collTMenuitemQuerys
     */
    protected List<TMenuitemQuery> collTMenuitemQuerys;

    /**
     * Temporary storage of collTMenuitemQuerys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTMenuitemQuerys()
    {
        if (collTMenuitemQuerys == null)
        {
            collTMenuitemQuerys = new ArrayList<TMenuitemQuery>();
        }
    }


    /**
     * Method called to associate a TMenuitemQuery object to this object
     * through the TMenuitemQuery foreign key attribute
     *
     * @param l TMenuitemQuery
     * @throws TorqueException
     */
    public void addTMenuitemQuery(TMenuitemQuery l) throws TorqueException
    {
        getTMenuitemQuerys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TMenuitemQuery object to this object
     * through the TMenuitemQuery foreign key attribute using connection.
     *
     * @param l TMenuitemQuery
     * @throws TorqueException
     */
    public void addTMenuitemQuery(TMenuitemQuery l, Connection con) throws TorqueException
    {
        getTMenuitemQuerys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTMenuitemQuerys
     */
    private Criteria lastTMenuitemQuerysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMenuitemQuerys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TMenuitemQuery> getTMenuitemQuerys()
        throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            collTMenuitemQuerys = getTMenuitemQuerys(new Criteria(10));
        }
        return collTMenuitemQuerys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMenuitemQuerys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TMenuitemQuery> getTMenuitemQuerys(Criteria criteria) throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            if (isNew())
            {
               collTMenuitemQuerys = new ArrayList<TMenuitemQuery>();
            }
            else
            {
                criteria.add(TMenuitemQueryPeer.PERSON, getObjectID() );
                collTMenuitemQuerys = TMenuitemQueryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
                if (!lastTMenuitemQuerysCriteria.equals(criteria))
                {
                    collTMenuitemQuerys = TMenuitemQueryPeer.doSelect(criteria);
                }
            }
        }
        lastTMenuitemQuerysCriteria = criteria;

        return collTMenuitemQuerys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMenuitemQuerys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMenuitemQuery> getTMenuitemQuerys(Connection con) throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            collTMenuitemQuerys = getTMenuitemQuerys(new Criteria(10), con);
        }
        return collTMenuitemQuerys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMenuitemQuerys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMenuitemQuery> getTMenuitemQuerys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            if (isNew())
            {
               collTMenuitemQuerys = new ArrayList<TMenuitemQuery>();
            }
            else
            {
                 criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
                 collTMenuitemQuerys = TMenuitemQueryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
                 if (!lastTMenuitemQuerysCriteria.equals(criteria))
                 {
                     collTMenuitemQuerys = TMenuitemQueryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTMenuitemQuerysCriteria = criteria;

         return collTMenuitemQuerys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TMenuitemQuerys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TMenuitemQuery> getTMenuitemQuerysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            if (isNew())
            {
               collTMenuitemQuerys = new ArrayList<TMenuitemQuery>();
            }
            else
            {
                criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
                collTMenuitemQuerys = TMenuitemQueryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
            if (!lastTMenuitemQuerysCriteria.equals(criteria))
            {
                collTMenuitemQuerys = TMenuitemQueryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTMenuitemQuerysCriteria = criteria;

        return collTMenuitemQuerys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TMenuitemQuerys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TMenuitemQuery> getTMenuitemQuerysJoinTQueryRepository(Criteria criteria)
        throws TorqueException
    {
        if (collTMenuitemQuerys == null)
        {
            if (isNew())
            {
               collTMenuitemQuerys = new ArrayList<TMenuitemQuery>();
            }
            else
            {
                criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
                collTMenuitemQuerys = TMenuitemQueryPeer.doSelectJoinTQueryRepository(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TMenuitemQueryPeer.PERSON, getObjectID());
            if (!lastTMenuitemQuerysCriteria.equals(criteria))
            {
                collTMenuitemQuerys = TMenuitemQueryPeer.doSelectJoinTQueryRepository(criteria);
            }
        }
        lastTMenuitemQuerysCriteria = criteria;

        return collTMenuitemQuerys;
    }





    /**
     * Collection to store aggregation of collTPersonBaskets
     */
    protected List<TPersonBasket> collTPersonBaskets;

    /**
     * Temporary storage of collTPersonBaskets to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTPersonBaskets()
    {
        if (collTPersonBaskets == null)
        {
            collTPersonBaskets = new ArrayList<TPersonBasket>();
        }
    }


    /**
     * Method called to associate a TPersonBasket object to this object
     * through the TPersonBasket foreign key attribute
     *
     * @param l TPersonBasket
     * @throws TorqueException
     */
    public void addTPersonBasket(TPersonBasket l) throws TorqueException
    {
        getTPersonBaskets().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TPersonBasket object to this object
     * through the TPersonBasket foreign key attribute using connection.
     *
     * @param l TPersonBasket
     * @throws TorqueException
     */
    public void addTPersonBasket(TPersonBasket l, Connection con) throws TorqueException
    {
        getTPersonBaskets(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTPersonBaskets
     */
    private Criteria lastTPersonBasketsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPersonBaskets(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TPersonBasket> getTPersonBaskets()
        throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            collTPersonBaskets = getTPersonBaskets(new Criteria(10));
        }
        return collTPersonBaskets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPersonBaskets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TPersonBasket> getTPersonBaskets(Criteria criteria) throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            if (isNew())
            {
               collTPersonBaskets = new ArrayList<TPersonBasket>();
            }
            else
            {
                criteria.add(TPersonBasketPeer.PERSON, getObjectID() );
                collTPersonBaskets = TPersonBasketPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                if (!lastTPersonBasketsCriteria.equals(criteria))
                {
                    collTPersonBaskets = TPersonBasketPeer.doSelect(criteria);
                }
            }
        }
        lastTPersonBasketsCriteria = criteria;

        return collTPersonBaskets;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPersonBaskets(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPersonBasket> getTPersonBaskets(Connection con) throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            collTPersonBaskets = getTPersonBaskets(new Criteria(10), con);
        }
        return collTPersonBaskets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPersonBaskets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPersonBasket> getTPersonBaskets(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            if (isNew())
            {
               collTPersonBaskets = new ArrayList<TPersonBasket>();
            }
            else
            {
                 criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                 collTPersonBaskets = TPersonBasketPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                 if (!lastTPersonBasketsCriteria.equals(criteria))
                 {
                     collTPersonBaskets = TPersonBasketPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTPersonBasketsCriteria = criteria;

         return collTPersonBaskets;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPersonBaskets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPersonBasket> getTPersonBasketsJoinTBasket(Criteria criteria)
        throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            if (isNew())
            {
               collTPersonBaskets = new ArrayList<TPersonBasket>();
            }
            else
            {
                criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTBasket(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPersonBasketPeer.PERSON, getObjectID());
            if (!lastTPersonBasketsCriteria.equals(criteria))
            {
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTBasket(criteria);
            }
        }
        lastTPersonBasketsCriteria = criteria;

        return collTPersonBaskets;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPersonBaskets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPersonBasket> getTPersonBasketsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            if (isNew())
            {
               collTPersonBaskets = new ArrayList<TPersonBasket>();
            }
            else
            {
                criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPersonBasketPeer.PERSON, getObjectID());
            if (!lastTPersonBasketsCriteria.equals(criteria))
            {
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTPersonBasketsCriteria = criteria;

        return collTPersonBaskets;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPersonBaskets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPersonBasket> getTPersonBasketsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTPersonBaskets == null)
        {
            if (isNew())
            {
               collTPersonBaskets = new ArrayList<TPersonBasket>();
            }
            else
            {
                criteria.add(TPersonBasketPeer.PERSON, getObjectID());
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPersonBasketPeer.PERSON, getObjectID());
            if (!lastTPersonBasketsCriteria.equals(criteria))
            {
                collTPersonBaskets = TPersonBasketPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTPersonBasketsCriteria = criteria;

        return collTPersonBaskets;
    }





    /**
     * Collection to store aggregation of collTBaskets
     */
    protected List<TBasket> collTBaskets;

    /**
     * Temporary storage of collTBaskets to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTBaskets()
    {
        if (collTBaskets == null)
        {
            collTBaskets = new ArrayList<TBasket>();
        }
    }


    /**
     * Method called to associate a TBasket object to this object
     * through the TBasket foreign key attribute
     *
     * @param l TBasket
     * @throws TorqueException
     */
    public void addTBasket(TBasket l) throws TorqueException
    {
        getTBaskets().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TBasket object to this object
     * through the TBasket foreign key attribute using connection.
     *
     * @param l TBasket
     * @throws TorqueException
     */
    public void addTBasket(TBasket l, Connection con) throws TorqueException
    {
        getTBaskets(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTBaskets
     */
    private Criteria lastTBasketsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBaskets(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TBasket> getTBaskets()
        throws TorqueException
    {
        if (collTBaskets == null)
        {
            collTBaskets = getTBaskets(new Criteria(10));
        }
        return collTBaskets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBaskets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TBasket> getTBaskets(Criteria criteria) throws TorqueException
    {
        if (collTBaskets == null)
        {
            if (isNew())
            {
               collTBaskets = new ArrayList<TBasket>();
            }
            else
            {
                criteria.add(TBasketPeer.PERSON, getObjectID() );
                collTBaskets = TBasketPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TBasketPeer.PERSON, getObjectID());
                if (!lastTBasketsCriteria.equals(criteria))
                {
                    collTBaskets = TBasketPeer.doSelect(criteria);
                }
            }
        }
        lastTBasketsCriteria = criteria;

        return collTBaskets;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTBaskets(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBasket> getTBaskets(Connection con) throws TorqueException
    {
        if (collTBaskets == null)
        {
            collTBaskets = getTBaskets(new Criteria(10), con);
        }
        return collTBaskets;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TBaskets from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TBasket> getTBaskets(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTBaskets == null)
        {
            if (isNew())
            {
               collTBaskets = new ArrayList<TBasket>();
            }
            else
            {
                 criteria.add(TBasketPeer.PERSON, getObjectID());
                 collTBaskets = TBasketPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TBasketPeer.PERSON, getObjectID());
                 if (!lastTBasketsCriteria.equals(criteria))
                 {
                     collTBaskets = TBasketPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTBasketsCriteria = criteria;

         return collTBaskets;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TBaskets from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TBasket> getTBasketsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTBaskets == null)
        {
            if (isNew())
            {
               collTBaskets = new ArrayList<TBasket>();
            }
            else
            {
                criteria.add(TBasketPeer.PERSON, getObjectID());
                collTBaskets = TBasketPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TBasketPeer.PERSON, getObjectID());
            if (!lastTBasketsCriteria.equals(criteria))
            {
                collTBaskets = TBasketPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTBasketsCriteria = criteria;

        return collTBaskets;
    }





    /**
     * Collection to store aggregation of collTLastVisitedItems
     */
    protected List<TLastVisitedItem> collTLastVisitedItems;

    /**
     * Temporary storage of collTLastVisitedItems to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTLastVisitedItems()
    {
        if (collTLastVisitedItems == null)
        {
            collTLastVisitedItems = new ArrayList<TLastVisitedItem>();
        }
    }


    /**
     * Method called to associate a TLastVisitedItem object to this object
     * through the TLastVisitedItem foreign key attribute
     *
     * @param l TLastVisitedItem
     * @throws TorqueException
     */
    public void addTLastVisitedItem(TLastVisitedItem l) throws TorqueException
    {
        getTLastVisitedItems().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TLastVisitedItem object to this object
     * through the TLastVisitedItem foreign key attribute using connection.
     *
     * @param l TLastVisitedItem
     * @throws TorqueException
     */
    public void addTLastVisitedItem(TLastVisitedItem l, Connection con) throws TorqueException
    {
        getTLastVisitedItems(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTLastVisitedItems
     */
    private Criteria lastTLastVisitedItemsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLastVisitedItems(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TLastVisitedItem> getTLastVisitedItems()
        throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            collTLastVisitedItems = getTLastVisitedItems(new Criteria(10));
        }
        return collTLastVisitedItems;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLastVisitedItems from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TLastVisitedItem> getTLastVisitedItems(Criteria criteria) throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            if (isNew())
            {
               collTLastVisitedItems = new ArrayList<TLastVisitedItem>();
            }
            else
            {
                criteria.add(TLastVisitedItemPeer.PERSON, getObjectID() );
                collTLastVisitedItems = TLastVisitedItemPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
                if (!lastTLastVisitedItemsCriteria.equals(criteria))
                {
                    collTLastVisitedItems = TLastVisitedItemPeer.doSelect(criteria);
                }
            }
        }
        lastTLastVisitedItemsCriteria = criteria;

        return collTLastVisitedItems;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLastVisitedItems(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLastVisitedItem> getTLastVisitedItems(Connection con) throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            collTLastVisitedItems = getTLastVisitedItems(new Criteria(10), con);
        }
        return collTLastVisitedItems;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLastVisitedItems from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLastVisitedItem> getTLastVisitedItems(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            if (isNew())
            {
               collTLastVisitedItems = new ArrayList<TLastVisitedItem>();
            }
            else
            {
                 criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
                 collTLastVisitedItems = TLastVisitedItemPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
                 if (!lastTLastVisitedItemsCriteria.equals(criteria))
                 {
                     collTLastVisitedItems = TLastVisitedItemPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTLastVisitedItemsCriteria = criteria;

         return collTLastVisitedItems;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLastVisitedItems from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLastVisitedItem> getTLastVisitedItemsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            if (isNew())
            {
               collTLastVisitedItems = new ArrayList<TLastVisitedItem>();
            }
            else
            {
                criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
                collTLastVisitedItems = TLastVisitedItemPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
            if (!lastTLastVisitedItemsCriteria.equals(criteria))
            {
                collTLastVisitedItems = TLastVisitedItemPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTLastVisitedItemsCriteria = criteria;

        return collTLastVisitedItems;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLastVisitedItems from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLastVisitedItem> getTLastVisitedItemsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTLastVisitedItems == null)
        {
            if (isNew())
            {
               collTLastVisitedItems = new ArrayList<TLastVisitedItem>();
            }
            else
            {
                criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
                collTLastVisitedItems = TLastVisitedItemPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLastVisitedItemPeer.PERSON, getObjectID());
            if (!lastTLastVisitedItemsCriteria.equals(criteria))
            {
                collTLastVisitedItems = TLastVisitedItemPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTLastVisitedItemsCriteria = criteria;

        return collTLastVisitedItems;
    }





    /**
     * Collection to store aggregation of collTWorkflowDefs
     */
    protected List<TWorkflowDef> collTWorkflowDefs;

    /**
     * Temporary storage of collTWorkflowDefs to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkflowDefs()
    {
        if (collTWorkflowDefs == null)
        {
            collTWorkflowDefs = new ArrayList<TWorkflowDef>();
        }
    }


    /**
     * Method called to associate a TWorkflowDef object to this object
     * through the TWorkflowDef foreign key attribute
     *
     * @param l TWorkflowDef
     * @throws TorqueException
     */
    public void addTWorkflowDef(TWorkflowDef l) throws TorqueException
    {
        getTWorkflowDefs().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TWorkflowDef object to this object
     * through the TWorkflowDef foreign key attribute using connection.
     *
     * @param l TWorkflowDef
     * @throws TorqueException
     */
    public void addTWorkflowDef(TWorkflowDef l, Connection con) throws TorqueException
    {
        getTWorkflowDefs(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkflowDefs
     */
    private Criteria lastTWorkflowDefsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowDefs(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkflowDef> getTWorkflowDefs()
        throws TorqueException
    {
        if (collTWorkflowDefs == null)
        {
            collTWorkflowDefs = getTWorkflowDefs(new Criteria(10));
        }
        return collTWorkflowDefs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowDefs from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkflowDef> getTWorkflowDefs(Criteria criteria) throws TorqueException
    {
        if (collTWorkflowDefs == null)
        {
            if (isNew())
            {
               collTWorkflowDefs = new ArrayList<TWorkflowDef>();
            }
            else
            {
                criteria.add(TWorkflowDefPeer.OWNER, getObjectID() );
                collTWorkflowDefs = TWorkflowDefPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkflowDefPeer.OWNER, getObjectID());
                if (!lastTWorkflowDefsCriteria.equals(criteria))
                {
                    collTWorkflowDefs = TWorkflowDefPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkflowDefsCriteria = criteria;

        return collTWorkflowDefs;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowDefs(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowDef> getTWorkflowDefs(Connection con) throws TorqueException
    {
        if (collTWorkflowDefs == null)
        {
            collTWorkflowDefs = getTWorkflowDefs(new Criteria(10), con);
        }
        return collTWorkflowDefs;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowDefs from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowDef> getTWorkflowDefs(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkflowDefs == null)
        {
            if (isNew())
            {
               collTWorkflowDefs = new ArrayList<TWorkflowDef>();
            }
            else
            {
                 criteria.add(TWorkflowDefPeer.OWNER, getObjectID());
                 collTWorkflowDefs = TWorkflowDefPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkflowDefPeer.OWNER, getObjectID());
                 if (!lastTWorkflowDefsCriteria.equals(criteria))
                 {
                     collTWorkflowDefs = TWorkflowDefPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkflowDefsCriteria = criteria;

         return collTWorkflowDefs;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowDefs from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowDef> getTWorkflowDefsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowDefs == null)
        {
            if (isNew())
            {
               collTWorkflowDefs = new ArrayList<TWorkflowDef>();
            }
            else
            {
                criteria.add(TWorkflowDefPeer.OWNER, getObjectID());
                collTWorkflowDefs = TWorkflowDefPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowDefPeer.OWNER, getObjectID());
            if (!lastTWorkflowDefsCriteria.equals(criteria))
            {
                collTWorkflowDefs = TWorkflowDefPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTWorkflowDefsCriteria = criteria;

        return collTWorkflowDefs;
    }





    /**
     * Collection to store aggregation of collTWorkflowActivitysRelatedByNewMan
     */
    protected List<TWorkflowActivity> collTWorkflowActivitysRelatedByNewMan;

    /**
     * Temporary storage of collTWorkflowActivitysRelatedByNewMan to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkflowActivitysRelatedByNewMan()
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
        }
    }


    /**
     * Method called to associate a TWorkflowActivity object to this object
     * through the TWorkflowActivity foreign key attribute
     *
     * @param l TWorkflowActivity
     * @throws TorqueException
     */
    public void addTWorkflowActivityRelatedByNewMan(TWorkflowActivity l) throws TorqueException
    {
        getTWorkflowActivitysRelatedByNewMan().add(l);
        l.setTPersonRelatedByNewMan((TPerson) this);
    }

    /**
     * Method called to associate a TWorkflowActivity object to this object
     * through the TWorkflowActivity foreign key attribute using connection.
     *
     * @param l TWorkflowActivity
     * @throws TorqueException
     */
    public void addTWorkflowActivityRelatedByNewMan(TWorkflowActivity l, Connection con) throws TorqueException
    {
        getTWorkflowActivitysRelatedByNewMan(con).add(l);
        l.setTPersonRelatedByNewMan((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkflowActivitysRelatedByNewMan
     */
    private Criteria lastTWorkflowActivitysRelatedByNewManCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowActivitysRelatedByNewMan(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewMan()
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            collTWorkflowActivitysRelatedByNewMan = getTWorkflowActivitysRelatedByNewMan(new Criteria(10));
        }
        return collTWorkflowActivitysRelatedByNewMan;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewMan(Criteria criteria) throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID() );
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
                {
                    collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowActivitysRelatedByNewMan(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewMan(Connection con) throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            collTWorkflowActivitysRelatedByNewMan = getTWorkflowActivitysRelatedByNewMan(new Criteria(10), con);
        }
        return collTWorkflowActivitysRelatedByNewMan;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewMan(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                 criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                 collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                 if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
                 {
                     collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

         return collTWorkflowActivitysRelatedByNewMan;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTWorkflowTransition(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTWorkflowStationRelatedByStationEntryActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationEntryActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationEntryActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTWorkflowStationRelatedByStationExitActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationExitActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationExitActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTWorkflowStationRelatedByStationDoActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationDoActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationDoActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTScripts(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTScripts(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTScripts(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTPersonRelatedByNewResp(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTPersonRelatedByNewResp(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTPersonRelatedByNewResp(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTSLA(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTSLA(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTSLA(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewMan from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewManJoinTScreen(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewMan == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewMan = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTScreen(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWMAN, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewManCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewMan = TWorkflowActivityPeer.doSelectJoinTScreen(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewManCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewMan;
    }





    /**
     * Collection to store aggregation of collTWorkflowActivitysRelatedByNewResp
     */
    protected List<TWorkflowActivity> collTWorkflowActivitysRelatedByNewResp;

    /**
     * Temporary storage of collTWorkflowActivitysRelatedByNewResp to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkflowActivitysRelatedByNewResp()
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
        }
    }


    /**
     * Method called to associate a TWorkflowActivity object to this object
     * through the TWorkflowActivity foreign key attribute
     *
     * @param l TWorkflowActivity
     * @throws TorqueException
     */
    public void addTWorkflowActivityRelatedByNewResp(TWorkflowActivity l) throws TorqueException
    {
        getTWorkflowActivitysRelatedByNewResp().add(l);
        l.setTPersonRelatedByNewResp((TPerson) this);
    }

    /**
     * Method called to associate a TWorkflowActivity object to this object
     * through the TWorkflowActivity foreign key attribute using connection.
     *
     * @param l TWorkflowActivity
     * @throws TorqueException
     */
    public void addTWorkflowActivityRelatedByNewResp(TWorkflowActivity l, Connection con) throws TorqueException
    {
        getTWorkflowActivitysRelatedByNewResp(con).add(l);
        l.setTPersonRelatedByNewResp((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkflowActivitysRelatedByNewResp
     */
    private Criteria lastTWorkflowActivitysRelatedByNewRespCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowActivitysRelatedByNewResp(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewResp()
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            collTWorkflowActivitysRelatedByNewResp = getTWorkflowActivitysRelatedByNewResp(new Criteria(10));
        }
        return collTWorkflowActivitysRelatedByNewResp;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewResp(Criteria criteria) throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID() );
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
                {
                    collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowActivitysRelatedByNewResp(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewResp(Connection con) throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            collTWorkflowActivitysRelatedByNewResp = getTWorkflowActivitysRelatedByNewResp(new Criteria(10), con);
        }
        return collTWorkflowActivitysRelatedByNewResp;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewResp(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                 criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                 collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                 if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
                 {
                     collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

         return collTWorkflowActivitysRelatedByNewResp;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTWorkflowTransition(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTWorkflowStationRelatedByStationEntryActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationEntryActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationEntryActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTWorkflowStationRelatedByStationExitActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationExitActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationExitActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTWorkflowStationRelatedByStationDoActivity(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationDoActivity(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTWorkflowStationRelatedByStationDoActivity(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTScripts(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTScripts(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTScripts(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTPersonRelatedByNewMan(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTPersonRelatedByNewMan(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTPersonRelatedByNewMan(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }

















    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTSLA(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTSLA(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTSLA(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowActivitysRelatedByNewResp from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowActivity> getTWorkflowActivitysRelatedByNewRespJoinTScreen(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowActivitysRelatedByNewResp == null)
        {
            if (isNew())
            {
               collTWorkflowActivitysRelatedByNewResp = new ArrayList<TWorkflowActivity>();
            }
            else
            {
                criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTScreen(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowActivityPeer.NEWRESP, getObjectID());
            if (!lastTWorkflowActivitysRelatedByNewRespCriteria.equals(criteria))
            {
                collTWorkflowActivitysRelatedByNewResp = TWorkflowActivityPeer.doSelectJoinTScreen(criteria);
            }
        }
        lastTWorkflowActivitysRelatedByNewRespCriteria = criteria;

        return collTWorkflowActivitysRelatedByNewResp;
    }





    /**
     * Collection to store aggregation of collTWorkflowGuards
     */
    protected List<TWorkflowGuard> collTWorkflowGuards;

    /**
     * Temporary storage of collTWorkflowGuards to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTWorkflowGuards()
    {
        if (collTWorkflowGuards == null)
        {
            collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
        }
    }


    /**
     * Method called to associate a TWorkflowGuard object to this object
     * through the TWorkflowGuard foreign key attribute
     *
     * @param l TWorkflowGuard
     * @throws TorqueException
     */
    public void addTWorkflowGuard(TWorkflowGuard l) throws TorqueException
    {
        getTWorkflowGuards().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TWorkflowGuard object to this object
     * through the TWorkflowGuard foreign key attribute using connection.
     *
     * @param l TWorkflowGuard
     * @throws TorqueException
     */
    public void addTWorkflowGuard(TWorkflowGuard l, Connection con) throws TorqueException
    {
        getTWorkflowGuards(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTWorkflowGuards
     */
    private Criteria lastTWorkflowGuardsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowGuards(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TWorkflowGuard> getTWorkflowGuards()
        throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            collTWorkflowGuards = getTWorkflowGuards(new Criteria(10));
        }
        return collTWorkflowGuards;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TWorkflowGuard> getTWorkflowGuards(Criteria criteria) throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID() );
                collTWorkflowGuards = TWorkflowGuardPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                if (!lastTWorkflowGuardsCriteria.equals(criteria))
                {
                    collTWorkflowGuards = TWorkflowGuardPeer.doSelect(criteria);
                }
            }
        }
        lastTWorkflowGuardsCriteria = criteria;

        return collTWorkflowGuards;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTWorkflowGuards(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowGuard> getTWorkflowGuards(Connection con) throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            collTWorkflowGuards = getTWorkflowGuards(new Criteria(10), con);
        }
        return collTWorkflowGuards;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TWorkflowGuard> getTWorkflowGuards(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                 criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                 collTWorkflowGuards = TWorkflowGuardPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                 if (!lastTWorkflowGuardsCriteria.equals(criteria))
                 {
                     collTWorkflowGuards = TWorkflowGuardPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTWorkflowGuardsCriteria = criteria;

         return collTWorkflowGuards;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowGuard> getTWorkflowGuardsJoinTWorkflowTransition(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
            if (!lastTWorkflowGuardsCriteria.equals(criteria))
            {
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTWorkflowTransition(criteria);
            }
        }
        lastTWorkflowGuardsCriteria = criteria;

        return collTWorkflowGuards;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowGuard> getTWorkflowGuardsJoinTRole(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTRole(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
            if (!lastTWorkflowGuardsCriteria.equals(criteria))
            {
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTRole(criteria);
            }
        }
        lastTWorkflowGuardsCriteria = criteria;

        return collTWorkflowGuards;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowGuard> getTWorkflowGuardsJoinTScripts(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTScripts(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
            if (!lastTWorkflowGuardsCriteria.equals(criteria))
            {
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTScripts(criteria);
            }
        }
        lastTWorkflowGuardsCriteria = criteria;

        return collTWorkflowGuards;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TWorkflowGuards from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TWorkflowGuard> getTWorkflowGuardsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTWorkflowGuards == null)
        {
            if (isNew())
            {
               collTWorkflowGuards = new ArrayList<TWorkflowGuard>();
            }
            else
            {
                criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TWorkflowGuardPeer.PERSON, getObjectID());
            if (!lastTWorkflowGuardsCriteria.equals(criteria))
            {
                collTWorkflowGuards = TWorkflowGuardPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTWorkflowGuardsCriteria = criteria;

        return collTWorkflowGuards;
    }





    /**
     * Collection to store aggregation of collTEscalationEntrys
     */
    protected List<TEscalationEntry> collTEscalationEntrys;

    /**
     * Temporary storage of collTEscalationEntrys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTEscalationEntrys()
    {
        if (collTEscalationEntrys == null)
        {
            collTEscalationEntrys = new ArrayList<TEscalationEntry>();
        }
    }


    /**
     * Method called to associate a TEscalationEntry object to this object
     * through the TEscalationEntry foreign key attribute
     *
     * @param l TEscalationEntry
     * @throws TorqueException
     */
    public void addTEscalationEntry(TEscalationEntry l) throws TorqueException
    {
        getTEscalationEntrys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TEscalationEntry object to this object
     * through the TEscalationEntry foreign key attribute using connection.
     *
     * @param l TEscalationEntry
     * @throws TorqueException
     */
    public void addTEscalationEntry(TEscalationEntry l, Connection con) throws TorqueException
    {
        getTEscalationEntrys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTEscalationEntrys
     */
    private Criteria lastTEscalationEntrysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTEscalationEntrys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TEscalationEntry> getTEscalationEntrys()
        throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            collTEscalationEntrys = getTEscalationEntrys(new Criteria(10));
        }
        return collTEscalationEntrys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TEscalationEntrys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TEscalationEntry> getTEscalationEntrys(Criteria criteria) throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            if (isNew())
            {
               collTEscalationEntrys = new ArrayList<TEscalationEntry>();
            }
            else
            {
                criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID() );
                collTEscalationEntrys = TEscalationEntryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                if (!lastTEscalationEntrysCriteria.equals(criteria))
                {
                    collTEscalationEntrys = TEscalationEntryPeer.doSelect(criteria);
                }
            }
        }
        lastTEscalationEntrysCriteria = criteria;

        return collTEscalationEntrys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTEscalationEntrys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TEscalationEntry> getTEscalationEntrys(Connection con) throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            collTEscalationEntrys = getTEscalationEntrys(new Criteria(10), con);
        }
        return collTEscalationEntrys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TEscalationEntrys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TEscalationEntry> getTEscalationEntrys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            if (isNew())
            {
               collTEscalationEntrys = new ArrayList<TEscalationEntry>();
            }
            else
            {
                 criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                 collTEscalationEntrys = TEscalationEntryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                 if (!lastTEscalationEntrysCriteria.equals(criteria))
                 {
                     collTEscalationEntrys = TEscalationEntryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTEscalationEntrysCriteria = criteria;

         return collTEscalationEntrys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TEscalationEntrys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TEscalationEntry> getTEscalationEntrysJoinTSLA(Criteria criteria)
        throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            if (isNew())
            {
               collTEscalationEntrys = new ArrayList<TEscalationEntry>();
            }
            else
            {
                criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTSLA(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
            if (!lastTEscalationEntrysCriteria.equals(criteria))
            {
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTSLA(criteria);
            }
        }
        lastTEscalationEntrysCriteria = criteria;

        return collTEscalationEntrys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TEscalationEntrys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TEscalationEntry> getTEscalationEntrysJoinTPriority(Criteria criteria)
        throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            if (isNew())
            {
               collTEscalationEntrys = new ArrayList<TEscalationEntry>();
            }
            else
            {
                criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTPriority(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
            if (!lastTEscalationEntrysCriteria.equals(criteria))
            {
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTPriority(criteria);
            }
        }
        lastTEscalationEntrysCriteria = criteria;

        return collTEscalationEntrys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TEscalationEntrys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TEscalationEntry> getTEscalationEntrysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTEscalationEntrys == null)
        {
            if (isNew())
            {
               collTEscalationEntrys = new ArrayList<TEscalationEntry>();
            }
            else
            {
                criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TEscalationEntryPeer.ESCALATETO, getObjectID());
            if (!lastTEscalationEntrysCriteria.equals(criteria))
            {
                collTEscalationEntrys = TEscalationEntryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTEscalationEntrysCriteria = criteria;

        return collTEscalationEntrys;
    }





    /**
     * Collection to store aggregation of collTReadIssues
     */
    protected List<TReadIssue> collTReadIssues;

    /**
     * Temporary storage of collTReadIssues to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTReadIssues()
    {
        if (collTReadIssues == null)
        {
            collTReadIssues = new ArrayList<TReadIssue>();
        }
    }


    /**
     * Method called to associate a TReadIssue object to this object
     * through the TReadIssue foreign key attribute
     *
     * @param l TReadIssue
     * @throws TorqueException
     */
    public void addTReadIssue(TReadIssue l) throws TorqueException
    {
        getTReadIssues().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TReadIssue object to this object
     * through the TReadIssue foreign key attribute using connection.
     *
     * @param l TReadIssue
     * @throws TorqueException
     */
    public void addTReadIssue(TReadIssue l, Connection con) throws TorqueException
    {
        getTReadIssues(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTReadIssues
     */
    private Criteria lastTReadIssuesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReadIssues(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TReadIssue> getTReadIssues()
        throws TorqueException
    {
        if (collTReadIssues == null)
        {
            collTReadIssues = getTReadIssues(new Criteria(10));
        }
        return collTReadIssues;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReadIssues from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TReadIssue> getTReadIssues(Criteria criteria) throws TorqueException
    {
        if (collTReadIssues == null)
        {
            if (isNew())
            {
               collTReadIssues = new ArrayList<TReadIssue>();
            }
            else
            {
                criteria.add(TReadIssuePeer.PERSON, getObjectID() );
                collTReadIssues = TReadIssuePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TReadIssuePeer.PERSON, getObjectID());
                if (!lastTReadIssuesCriteria.equals(criteria))
                {
                    collTReadIssues = TReadIssuePeer.doSelect(criteria);
                }
            }
        }
        lastTReadIssuesCriteria = criteria;

        return collTReadIssues;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReadIssues(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReadIssue> getTReadIssues(Connection con) throws TorqueException
    {
        if (collTReadIssues == null)
        {
            collTReadIssues = getTReadIssues(new Criteria(10), con);
        }
        return collTReadIssues;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReadIssues from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReadIssue> getTReadIssues(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTReadIssues == null)
        {
            if (isNew())
            {
               collTReadIssues = new ArrayList<TReadIssue>();
            }
            else
            {
                 criteria.add(TReadIssuePeer.PERSON, getObjectID());
                 collTReadIssues = TReadIssuePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TReadIssuePeer.PERSON, getObjectID());
                 if (!lastTReadIssuesCriteria.equals(criteria))
                 {
                     collTReadIssues = TReadIssuePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTReadIssuesCriteria = criteria;

         return collTReadIssues;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReadIssues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReadIssue> getTReadIssuesJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTReadIssues == null)
        {
            if (isNew())
            {
               collTReadIssues = new ArrayList<TReadIssue>();
            }
            else
            {
                criteria.add(TReadIssuePeer.PERSON, getObjectID());
                collTReadIssues = TReadIssuePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReadIssuePeer.PERSON, getObjectID());
            if (!lastTReadIssuesCriteria.equals(criteria))
            {
                collTReadIssues = TReadIssuePeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTReadIssuesCriteria = criteria;

        return collTReadIssues;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReadIssues from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReadIssue> getTReadIssuesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTReadIssues == null)
        {
            if (isNew())
            {
               collTReadIssues = new ArrayList<TReadIssue>();
            }
            else
            {
                criteria.add(TReadIssuePeer.PERSON, getObjectID());
                collTReadIssues = TReadIssuePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReadIssuePeer.PERSON, getObjectID());
            if (!lastTReadIssuesCriteria.equals(criteria))
            {
                collTReadIssues = TReadIssuePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTReadIssuesCriteria = criteria;

        return collTReadIssues;
    }





    /**
     * Collection to store aggregation of collTLastExecutedQuerys
     */
    protected List<TLastExecutedQuery> collTLastExecutedQuerys;

    /**
     * Temporary storage of collTLastExecutedQuerys to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTLastExecutedQuerys()
    {
        if (collTLastExecutedQuerys == null)
        {
            collTLastExecutedQuerys = new ArrayList<TLastExecutedQuery>();
        }
    }


    /**
     * Method called to associate a TLastExecutedQuery object to this object
     * through the TLastExecutedQuery foreign key attribute
     *
     * @param l TLastExecutedQuery
     * @throws TorqueException
     */
    public void addTLastExecutedQuery(TLastExecutedQuery l) throws TorqueException
    {
        getTLastExecutedQuerys().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TLastExecutedQuery object to this object
     * through the TLastExecutedQuery foreign key attribute using connection.
     *
     * @param l TLastExecutedQuery
     * @throws TorqueException
     */
    public void addTLastExecutedQuery(TLastExecutedQuery l, Connection con) throws TorqueException
    {
        getTLastExecutedQuerys(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTLastExecutedQuerys
     */
    private Criteria lastTLastExecutedQuerysCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLastExecutedQuerys(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TLastExecutedQuery> getTLastExecutedQuerys()
        throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            collTLastExecutedQuerys = getTLastExecutedQuerys(new Criteria(10));
        }
        return collTLastExecutedQuerys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLastExecutedQuerys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TLastExecutedQuery> getTLastExecutedQuerys(Criteria criteria) throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            if (isNew())
            {
               collTLastExecutedQuerys = new ArrayList<TLastExecutedQuery>();
            }
            else
            {
                criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID() );
                collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
                if (!lastTLastExecutedQuerysCriteria.equals(criteria))
                {
                    collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelect(criteria);
                }
            }
        }
        lastTLastExecutedQuerysCriteria = criteria;

        return collTLastExecutedQuerys;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTLastExecutedQuerys(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLastExecutedQuery> getTLastExecutedQuerys(Connection con) throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            collTLastExecutedQuerys = getTLastExecutedQuerys(new Criteria(10), con);
        }
        return collTLastExecutedQuerys;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TLastExecutedQuerys from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TLastExecutedQuery> getTLastExecutedQuerys(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            if (isNew())
            {
               collTLastExecutedQuerys = new ArrayList<TLastExecutedQuery>();
            }
            else
            {
                 criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
                 collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
                 if (!lastTLastExecutedQuerysCriteria.equals(criteria))
                 {
                     collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTLastExecutedQuerysCriteria = criteria;

         return collTLastExecutedQuerys;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLastExecutedQuerys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLastExecutedQuery> getTLastExecutedQuerysJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            if (isNew())
            {
               collTLastExecutedQuerys = new ArrayList<TLastExecutedQuery>();
            }
            else
            {
                criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
                collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
            if (!lastTLastExecutedQuerysCriteria.equals(criteria))
            {
                collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTLastExecutedQuerysCriteria = criteria;

        return collTLastExecutedQuerys;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TLastExecutedQuerys from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TLastExecutedQuery> getTLastExecutedQuerysJoinTCLOB(Criteria criteria)
        throws TorqueException
    {
        if (collTLastExecutedQuerys == null)
        {
            if (isNew())
            {
               collTLastExecutedQuerys = new ArrayList<TLastExecutedQuery>();
            }
            else
            {
                criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
                collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelectJoinTCLOB(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TLastExecutedQueryPeer.PERSON, getObjectID());
            if (!lastTLastExecutedQuerysCriteria.equals(criteria))
            {
                collTLastExecutedQuerys = TLastExecutedQueryPeer.doSelectJoinTCLOB(criteria);
            }
        }
        lastTLastExecutedQuerysCriteria = criteria;

        return collTLastExecutedQuerys;
    }





    /**
     * Collection to store aggregation of collTReportSubscribes
     */
    protected List<TReportSubscribe> collTReportSubscribes;

    /**
     * Temporary storage of collTReportSubscribes to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTReportSubscribes()
    {
        if (collTReportSubscribes == null)
        {
            collTReportSubscribes = new ArrayList<TReportSubscribe>();
        }
    }


    /**
     * Method called to associate a TReportSubscribe object to this object
     * through the TReportSubscribe foreign key attribute
     *
     * @param l TReportSubscribe
     * @throws TorqueException
     */
    public void addTReportSubscribe(TReportSubscribe l) throws TorqueException
    {
        getTReportSubscribes().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TReportSubscribe object to this object
     * through the TReportSubscribe foreign key attribute using connection.
     *
     * @param l TReportSubscribe
     * @throws TorqueException
     */
    public void addTReportSubscribe(TReportSubscribe l, Connection con) throws TorqueException
    {
        getTReportSubscribes(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTReportSubscribes
     */
    private Criteria lastTReportSubscribesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportSubscribes(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TReportSubscribe> getTReportSubscribes()
        throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            collTReportSubscribes = getTReportSubscribes(new Criteria(10));
        }
        return collTReportSubscribes;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportSubscribes from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TReportSubscribe> getTReportSubscribes(Criteria criteria) throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            if (isNew())
            {
               collTReportSubscribes = new ArrayList<TReportSubscribe>();
            }
            else
            {
                criteria.add(TReportSubscribePeer.PERSON, getObjectID() );
                collTReportSubscribes = TReportSubscribePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                if (!lastTReportSubscribesCriteria.equals(criteria))
                {
                    collTReportSubscribes = TReportSubscribePeer.doSelect(criteria);
                }
            }
        }
        lastTReportSubscribesCriteria = criteria;

        return collTReportSubscribes;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTReportSubscribes(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportSubscribe> getTReportSubscribes(Connection con) throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            collTReportSubscribes = getTReportSubscribes(new Criteria(10), con);
        }
        return collTReportSubscribes;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TReportSubscribes from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TReportSubscribe> getTReportSubscribes(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            if (isNew())
            {
               collTReportSubscribes = new ArrayList<TReportSubscribe>();
            }
            else
            {
                 criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                 collTReportSubscribes = TReportSubscribePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                 if (!lastTReportSubscribesCriteria.equals(criteria))
                 {
                     collTReportSubscribes = TReportSubscribePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTReportSubscribesCriteria = criteria;

         return collTReportSubscribes;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportSubscribes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportSubscribe> getTReportSubscribesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            if (isNew())
            {
               collTReportSubscribes = new ArrayList<TReportSubscribe>();
            }
            else
            {
                criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportSubscribePeer.PERSON, getObjectID());
            if (!lastTReportSubscribesCriteria.equals(criteria))
            {
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTReportSubscribesCriteria = criteria;

        return collTReportSubscribes;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportSubscribes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportSubscribe> getTReportSubscribesJoinTRecurrencePattern(Criteria criteria)
        throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            if (isNew())
            {
               collTReportSubscribes = new ArrayList<TReportSubscribe>();
            }
            else
            {
                criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTRecurrencePattern(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportSubscribePeer.PERSON, getObjectID());
            if (!lastTReportSubscribesCriteria.equals(criteria))
            {
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTRecurrencePattern(criteria);
            }
        }
        lastTReportSubscribesCriteria = criteria;

        return collTReportSubscribes;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TReportSubscribes from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TReportSubscribe> getTReportSubscribesJoinTExportTemplate(Criteria criteria)
        throws TorqueException
    {
        if (collTReportSubscribes == null)
        {
            if (isNew())
            {
               collTReportSubscribes = new ArrayList<TReportSubscribe>();
            }
            else
            {
                criteria.add(TReportSubscribePeer.PERSON, getObjectID());
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TReportSubscribePeer.PERSON, getObjectID());
            if (!lastTReportSubscribesCriteria.equals(criteria))
            {
                collTReportSubscribes = TReportSubscribePeer.doSelectJoinTExportTemplate(criteria);
            }
        }
        lastTReportSubscribesCriteria = criteria;

        return collTReportSubscribes;
    }





    /**
     * Collection to store aggregation of collTGridLayouts
     */
    protected List<TGridLayout> collTGridLayouts;

    /**
     * Temporary storage of collTGridLayouts to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTGridLayouts()
    {
        if (collTGridLayouts == null)
        {
            collTGridLayouts = new ArrayList<TGridLayout>();
        }
    }


    /**
     * Method called to associate a TGridLayout object to this object
     * through the TGridLayout foreign key attribute
     *
     * @param l TGridLayout
     * @throws TorqueException
     */
    public void addTGridLayout(TGridLayout l) throws TorqueException
    {
        getTGridLayouts().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TGridLayout object to this object
     * through the TGridLayout foreign key attribute using connection.
     *
     * @param l TGridLayout
     * @throws TorqueException
     */
    public void addTGridLayout(TGridLayout l, Connection con) throws TorqueException
    {
        getTGridLayouts(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTGridLayouts
     */
    private Criteria lastTGridLayoutsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGridLayouts(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TGridLayout> getTGridLayouts()
        throws TorqueException
    {
        if (collTGridLayouts == null)
        {
            collTGridLayouts = getTGridLayouts(new Criteria(10));
        }
        return collTGridLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGridLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TGridLayout> getTGridLayouts(Criteria criteria) throws TorqueException
    {
        if (collTGridLayouts == null)
        {
            if (isNew())
            {
               collTGridLayouts = new ArrayList<TGridLayout>();
            }
            else
            {
                criteria.add(TGridLayoutPeer.PERSON, getObjectID() );
                collTGridLayouts = TGridLayoutPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TGridLayoutPeer.PERSON, getObjectID());
                if (!lastTGridLayoutsCriteria.equals(criteria))
                {
                    collTGridLayouts = TGridLayoutPeer.doSelect(criteria);
                }
            }
        }
        lastTGridLayoutsCriteria = criteria;

        return collTGridLayouts;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTGridLayouts(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGridLayout> getTGridLayouts(Connection con) throws TorqueException
    {
        if (collTGridLayouts == null)
        {
            collTGridLayouts = getTGridLayouts(new Criteria(10), con);
        }
        return collTGridLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TGridLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TGridLayout> getTGridLayouts(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTGridLayouts == null)
        {
            if (isNew())
            {
               collTGridLayouts = new ArrayList<TGridLayout>();
            }
            else
            {
                 criteria.add(TGridLayoutPeer.PERSON, getObjectID());
                 collTGridLayouts = TGridLayoutPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TGridLayoutPeer.PERSON, getObjectID());
                 if (!lastTGridLayoutsCriteria.equals(criteria))
                 {
                     collTGridLayouts = TGridLayoutPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTGridLayoutsCriteria = criteria;

         return collTGridLayouts;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TGridLayouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TGridLayout> getTGridLayoutsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTGridLayouts == null)
        {
            if (isNew())
            {
               collTGridLayouts = new ArrayList<TGridLayout>();
            }
            else
            {
                criteria.add(TGridLayoutPeer.PERSON, getObjectID());
                collTGridLayouts = TGridLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TGridLayoutPeer.PERSON, getObjectID());
            if (!lastTGridLayoutsCriteria.equals(criteria))
            {
                collTGridLayouts = TGridLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTGridLayoutsCriteria = criteria;

        return collTGridLayouts;
    }





    /**
     * Collection to store aggregation of collTNavigatorLayouts
     */
    protected List<TNavigatorLayout> collTNavigatorLayouts;

    /**
     * Temporary storage of collTNavigatorLayouts to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTNavigatorLayouts()
    {
        if (collTNavigatorLayouts == null)
        {
            collTNavigatorLayouts = new ArrayList<TNavigatorLayout>();
        }
    }


    /**
     * Method called to associate a TNavigatorLayout object to this object
     * through the TNavigatorLayout foreign key attribute
     *
     * @param l TNavigatorLayout
     * @throws TorqueException
     */
    public void addTNavigatorLayout(TNavigatorLayout l) throws TorqueException
    {
        getTNavigatorLayouts().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TNavigatorLayout object to this object
     * through the TNavigatorLayout foreign key attribute using connection.
     *
     * @param l TNavigatorLayout
     * @throws TorqueException
     */
    public void addTNavigatorLayout(TNavigatorLayout l, Connection con) throws TorqueException
    {
        getTNavigatorLayouts(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTNavigatorLayouts
     */
    private Criteria lastTNavigatorLayoutsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNavigatorLayouts(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TNavigatorLayout> getTNavigatorLayouts()
        throws TorqueException
    {
        if (collTNavigatorLayouts == null)
        {
            collTNavigatorLayouts = getTNavigatorLayouts(new Criteria(10));
        }
        return collTNavigatorLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNavigatorLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TNavigatorLayout> getTNavigatorLayouts(Criteria criteria) throws TorqueException
    {
        if (collTNavigatorLayouts == null)
        {
            if (isNew())
            {
               collTNavigatorLayouts = new ArrayList<TNavigatorLayout>();
            }
            else
            {
                criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID() );
                collTNavigatorLayouts = TNavigatorLayoutPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID());
                if (!lastTNavigatorLayoutsCriteria.equals(criteria))
                {
                    collTNavigatorLayouts = TNavigatorLayoutPeer.doSelect(criteria);
                }
            }
        }
        lastTNavigatorLayoutsCriteria = criteria;

        return collTNavigatorLayouts;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTNavigatorLayouts(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNavigatorLayout> getTNavigatorLayouts(Connection con) throws TorqueException
    {
        if (collTNavigatorLayouts == null)
        {
            collTNavigatorLayouts = getTNavigatorLayouts(new Criteria(10), con);
        }
        return collTNavigatorLayouts;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TNavigatorLayouts from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TNavigatorLayout> getTNavigatorLayouts(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTNavigatorLayouts == null)
        {
            if (isNew())
            {
               collTNavigatorLayouts = new ArrayList<TNavigatorLayout>();
            }
            else
            {
                 criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID());
                 collTNavigatorLayouts = TNavigatorLayoutPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID());
                 if (!lastTNavigatorLayoutsCriteria.equals(criteria))
                 {
                     collTNavigatorLayouts = TNavigatorLayoutPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTNavigatorLayoutsCriteria = criteria;

         return collTNavigatorLayouts;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TNavigatorLayouts from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TNavigatorLayout> getTNavigatorLayoutsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTNavigatorLayouts == null)
        {
            if (isNew())
            {
               collTNavigatorLayouts = new ArrayList<TNavigatorLayout>();
            }
            else
            {
                criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID());
                collTNavigatorLayouts = TNavigatorLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TNavigatorLayoutPeer.PERSON, getObjectID());
            if (!lastTNavigatorLayoutsCriteria.equals(criteria))
            {
                collTNavigatorLayouts = TNavigatorLayoutPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTNavigatorLayoutsCriteria = criteria;

        return collTNavigatorLayouts;
    }





    /**
     * Collection to store aggregation of collTMailTextBlocks
     */
    protected List<TMailTextBlock> collTMailTextBlocks;

    /**
     * Temporary storage of collTMailTextBlocks to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTMailTextBlocks()
    {
        if (collTMailTextBlocks == null)
        {
            collTMailTextBlocks = new ArrayList<TMailTextBlock>();
        }
    }


    /**
     * Method called to associate a TMailTextBlock object to this object
     * through the TMailTextBlock foreign key attribute
     *
     * @param l TMailTextBlock
     * @throws TorqueException
     */
    public void addTMailTextBlock(TMailTextBlock l) throws TorqueException
    {
        getTMailTextBlocks().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TMailTextBlock object to this object
     * through the TMailTextBlock foreign key attribute using connection.
     *
     * @param l TMailTextBlock
     * @throws TorqueException
     */
    public void addTMailTextBlock(TMailTextBlock l, Connection con) throws TorqueException
    {
        getTMailTextBlocks(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTMailTextBlocks
     */
    private Criteria lastTMailTextBlocksCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMailTextBlocks(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TMailTextBlock> getTMailTextBlocks()
        throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            collTMailTextBlocks = getTMailTextBlocks(new Criteria(10));
        }
        return collTMailTextBlocks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMailTextBlocks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TMailTextBlock> getTMailTextBlocks(Criteria criteria) throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            if (isNew())
            {
               collTMailTextBlocks = new ArrayList<TMailTextBlock>();
            }
            else
            {
                criteria.add(TMailTextBlockPeer.PERSON, getObjectID() );
                collTMailTextBlocks = TMailTextBlockPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
                if (!lastTMailTextBlocksCriteria.equals(criteria))
                {
                    collTMailTextBlocks = TMailTextBlockPeer.doSelect(criteria);
                }
            }
        }
        lastTMailTextBlocksCriteria = criteria;

        return collTMailTextBlocks;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTMailTextBlocks(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMailTextBlock> getTMailTextBlocks(Connection con) throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            collTMailTextBlocks = getTMailTextBlocks(new Criteria(10), con);
        }
        return collTMailTextBlocks;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TMailTextBlocks from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TMailTextBlock> getTMailTextBlocks(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            if (isNew())
            {
               collTMailTextBlocks = new ArrayList<TMailTextBlock>();
            }
            else
            {
                 criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
                 collTMailTextBlocks = TMailTextBlockPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
                 if (!lastTMailTextBlocksCriteria.equals(criteria))
                 {
                     collTMailTextBlocks = TMailTextBlockPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTMailTextBlocksCriteria = criteria;

         return collTMailTextBlocks;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TMailTextBlocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TMailTextBlock> getTMailTextBlocksJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            if (isNew())
            {
               collTMailTextBlocks = new ArrayList<TMailTextBlock>();
            }
            else
            {
                criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
                collTMailTextBlocks = TMailTextBlockPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
            if (!lastTMailTextBlocksCriteria.equals(criteria))
            {
                collTMailTextBlocks = TMailTextBlockPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTMailTextBlocksCriteria = criteria;

        return collTMailTextBlocks;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TMailTextBlocks from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TMailTextBlock> getTMailTextBlocksJoinTProject(Criteria criteria)
        throws TorqueException
    {
        if (collTMailTextBlocks == null)
        {
            if (isNew())
            {
               collTMailTextBlocks = new ArrayList<TMailTextBlock>();
            }
            else
            {
                criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
                collTMailTextBlocks = TMailTextBlockPeer.doSelectJoinTProject(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TMailTextBlockPeer.PERSON, getObjectID());
            if (!lastTMailTextBlocksCriteria.equals(criteria))
            {
                collTMailTextBlocks = TMailTextBlockPeer.doSelectJoinTProject(criteria);
            }
        }
        lastTMailTextBlocksCriteria = criteria;

        return collTMailTextBlocks;
    }





    /**
     * Collection to store aggregation of collTPersonInDomains
     */
    protected List<TPersonInDomain> collTPersonInDomains;

    /**
     * Temporary storage of collTPersonInDomains to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTPersonInDomains()
    {
        if (collTPersonInDomains == null)
        {
            collTPersonInDomains = new ArrayList<TPersonInDomain>();
        }
    }


    /**
     * Method called to associate a TPersonInDomain object to this object
     * through the TPersonInDomain foreign key attribute
     *
     * @param l TPersonInDomain
     * @throws TorqueException
     */
    public void addTPersonInDomain(TPersonInDomain l) throws TorqueException
    {
        getTPersonInDomains().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TPersonInDomain object to this object
     * through the TPersonInDomain foreign key attribute using connection.
     *
     * @param l TPersonInDomain
     * @throws TorqueException
     */
    public void addTPersonInDomain(TPersonInDomain l, Connection con) throws TorqueException
    {
        getTPersonInDomains(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTPersonInDomains
     */
    private Criteria lastTPersonInDomainsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPersonInDomains(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TPersonInDomain> getTPersonInDomains()
        throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            collTPersonInDomains = getTPersonInDomains(new Criteria(10));
        }
        return collTPersonInDomains;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPersonInDomains from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TPersonInDomain> getTPersonInDomains(Criteria criteria) throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            if (isNew())
            {
               collTPersonInDomains = new ArrayList<TPersonInDomain>();
            }
            else
            {
                criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID() );
                collTPersonInDomains = TPersonInDomainPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
                if (!lastTPersonInDomainsCriteria.equals(criteria))
                {
                    collTPersonInDomains = TPersonInDomainPeer.doSelect(criteria);
                }
            }
        }
        lastTPersonInDomainsCriteria = criteria;

        return collTPersonInDomains;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTPersonInDomains(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPersonInDomain> getTPersonInDomains(Connection con) throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            collTPersonInDomains = getTPersonInDomains(new Criteria(10), con);
        }
        return collTPersonInDomains;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TPersonInDomains from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TPersonInDomain> getTPersonInDomains(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            if (isNew())
            {
               collTPersonInDomains = new ArrayList<TPersonInDomain>();
            }
            else
            {
                 criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
                 collTPersonInDomains = TPersonInDomainPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
                 if (!lastTPersonInDomainsCriteria.equals(criteria))
                 {
                     collTPersonInDomains = TPersonInDomainPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTPersonInDomainsCriteria = criteria;

         return collTPersonInDomains;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPersonInDomains from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPersonInDomain> getTPersonInDomainsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            if (isNew())
            {
               collTPersonInDomains = new ArrayList<TPersonInDomain>();
            }
            else
            {
                criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
                collTPersonInDomains = TPersonInDomainPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
            if (!lastTPersonInDomainsCriteria.equals(criteria))
            {
                collTPersonInDomains = TPersonInDomainPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTPersonInDomainsCriteria = criteria;

        return collTPersonInDomains;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TPersonInDomains from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TPersonInDomain> getTPersonInDomainsJoinTDomain(Criteria criteria)
        throws TorqueException
    {
        if (collTPersonInDomains == null)
        {
            if (isNew())
            {
               collTPersonInDomains = new ArrayList<TPersonInDomain>();
            }
            else
            {
                criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
                collTPersonInDomains = TPersonInDomainPeer.doSelectJoinTDomain(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TPersonInDomainPeer.PERSONKEY, getObjectID());
            if (!lastTPersonInDomainsCriteria.equals(criteria))
            {
                collTPersonInDomains = TPersonInDomainPeer.doSelectJoinTDomain(criteria);
            }
        }
        lastTPersonInDomainsCriteria = criteria;

        return collTPersonInDomains;
    }





    /**
     * Collection to store aggregation of collTAttachmentVersions
     */
    protected List<TAttachmentVersion> collTAttachmentVersions;

    /**
     * Temporary storage of collTAttachmentVersions to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTAttachmentVersions()
    {
        if (collTAttachmentVersions == null)
        {
            collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
        }
    }


    /**
     * Method called to associate a TAttachmentVersion object to this object
     * through the TAttachmentVersion foreign key attribute
     *
     * @param l TAttachmentVersion
     * @throws TorqueException
     */
    public void addTAttachmentVersion(TAttachmentVersion l) throws TorqueException
    {
        getTAttachmentVersions().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TAttachmentVersion object to this object
     * through the TAttachmentVersion foreign key attribute using connection.
     *
     * @param l TAttachmentVersion
     * @throws TorqueException
     */
    public void addTAttachmentVersion(TAttachmentVersion l, Connection con) throws TorqueException
    {
        getTAttachmentVersions(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTAttachmentVersions
     */
    private Criteria lastTAttachmentVersionsCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAttachmentVersions(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TAttachmentVersion> getTAttachmentVersions()
        throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            collTAttachmentVersions = getTAttachmentVersions(new Criteria(10));
        }
        return collTAttachmentVersions;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAttachmentVersions from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TAttachmentVersion> getTAttachmentVersions(Criteria criteria) throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            if (isNew())
            {
               collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
            }
            else
            {
                criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID() );
                collTAttachmentVersions = TAttachmentVersionPeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                if (!lastTAttachmentVersionsCriteria.equals(criteria))
                {
                    collTAttachmentVersions = TAttachmentVersionPeer.doSelect(criteria);
                }
            }
        }
        lastTAttachmentVersionsCriteria = criteria;

        return collTAttachmentVersions;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTAttachmentVersions(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAttachmentVersion> getTAttachmentVersions(Connection con) throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            collTAttachmentVersions = getTAttachmentVersions(new Criteria(10), con);
        }
        return collTAttachmentVersions;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TAttachmentVersions from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TAttachmentVersion> getTAttachmentVersions(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            if (isNew())
            {
               collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
            }
            else
            {
                 criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                 collTAttachmentVersions = TAttachmentVersionPeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                 if (!lastTAttachmentVersionsCriteria.equals(criteria))
                 {
                     collTAttachmentVersions = TAttachmentVersionPeer.doSelect(criteria, con);
                 }
             }
         }
         lastTAttachmentVersionsCriteria = criteria;

         return collTAttachmentVersions;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachmentVersions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachmentVersion> getTAttachmentVersionsJoinTWorkItem(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            if (isNew())
            {
               collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
            }
            else
            {
                criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentVersionsCriteria.equals(criteria))
            {
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTWorkItem(criteria);
            }
        }
        lastTAttachmentVersionsCriteria = criteria;

        return collTAttachmentVersions;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachmentVersions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachmentVersion> getTAttachmentVersionsJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            if (isNew())
            {
               collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
            }
            else
            {
                criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentVersionsCriteria.equals(criteria))
            {
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTAttachmentVersionsCriteria = criteria;

        return collTAttachmentVersions;
    }









    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TAttachmentVersions from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TAttachmentVersion> getTAttachmentVersionsJoinTDocState(Criteria criteria)
        throws TorqueException
    {
        if (collTAttachmentVersions == null)
        {
            if (isNew())
            {
               collTAttachmentVersions = new ArrayList<TAttachmentVersion>();
            }
            else
            {
                criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTDocState(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TAttachmentVersionPeer.CHANGEDBY, getObjectID());
            if (!lastTAttachmentVersionsCriteria.equals(criteria))
            {
                collTAttachmentVersions = TAttachmentVersionPeer.doSelectJoinTDocState(criteria);
            }
        }
        lastTAttachmentVersionsCriteria = criteria;

        return collTAttachmentVersions;
    }





    /**
     * Collection to store aggregation of collTUserFeatures
     */
    protected List<TUserFeature> collTUserFeatures;

    /**
     * Temporary storage of collTUserFeatures to save a possible db hit in
     * the event objects are add to the collection, but the
     * complete collection is never requested.
     */
    protected void initTUserFeatures()
    {
        if (collTUserFeatures == null)
        {
            collTUserFeatures = new ArrayList<TUserFeature>();
        }
    }


    /**
     * Method called to associate a TUserFeature object to this object
     * through the TUserFeature foreign key attribute
     *
     * @param l TUserFeature
     * @throws TorqueException
     */
    public void addTUserFeature(TUserFeature l) throws TorqueException
    {
        getTUserFeatures().add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * Method called to associate a TUserFeature object to this object
     * through the TUserFeature foreign key attribute using connection.
     *
     * @param l TUserFeature
     * @throws TorqueException
     */
    public void addTUserFeature(TUserFeature l, Connection con) throws TorqueException
    {
        getTUserFeatures(con).add(l);
        l.setTPerson((TPerson) this);
    }

    /**
     * The criteria used to select the current contents of collTUserFeatures
     */
    private Criteria lastTUserFeaturesCriteria = null;

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTUserFeatures(new Criteria())
     *
     * @return the collection of associated objects
     * @throws TorqueException
     */
    public List<TUserFeature> getTUserFeatures()
        throws TorqueException
    {
        if (collTUserFeatures == null)
        {
            collTUserFeatures = getTUserFeatures(new Criteria(10));
        }
        return collTUserFeatures;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TUserFeatures from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     *
     * @throws TorqueException
     */
    public List<TUserFeature> getTUserFeatures(Criteria criteria) throws TorqueException
    {
        if (collTUserFeatures == null)
        {
            if (isNew())
            {
               collTUserFeatures = new ArrayList<TUserFeature>();
            }
            else
            {
                criteria.add(TUserFeaturePeer.PERSON, getObjectID() );
                collTUserFeatures = TUserFeaturePeer.doSelect(criteria);
            }
        }
        else
        {
            // criteria has no effect for a new object
            if (!isNew())
            {
                // the following code is to determine if a new query is
                // called for.  If the criteria is the same as the last
                // one, just return the collection.
                criteria.add(TUserFeaturePeer.PERSON, getObjectID());
                if (!lastTUserFeaturesCriteria.equals(criteria))
                {
                    collTUserFeatures = TUserFeaturePeer.doSelect(criteria);
                }
            }
        }
        lastTUserFeaturesCriteria = criteria;

        return collTUserFeatures;
    }

    /**
     * If this collection has already been initialized, returns
     * the collection. Otherwise returns the results of
     * getTUserFeatures(new Criteria(),Connection)
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TUserFeature> getTUserFeatures(Connection con) throws TorqueException
    {
        if (collTUserFeatures == null)
        {
            collTUserFeatures = getTUserFeatures(new Criteria(10), con);
        }
        return collTUserFeatures;
    }

    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson has previously
     * been saved, it will retrieve related TUserFeatures from storage.
     * If this TPerson is new, it will return
     * an empty collection or the current collection, the criteria
     * is ignored on a new object.
     * This method takes in the Connection also as input so that
     * referenced objects can also be obtained using a Connection
     * that is taken as input
     */
    public List<TUserFeature> getTUserFeatures(Criteria criteria, Connection con)
            throws TorqueException
    {
        if (collTUserFeatures == null)
        {
            if (isNew())
            {
               collTUserFeatures = new ArrayList<TUserFeature>();
            }
            else
            {
                 criteria.add(TUserFeaturePeer.PERSON, getObjectID());
                 collTUserFeatures = TUserFeaturePeer.doSelect(criteria, con);
             }
         }
         else
         {
             // criteria has no effect for a new object
             if (!isNew())
             {
                 // the following code is to determine if a new query is
                 // called for.  If the criteria is the same as the last
                 // one, just return the collection.
                 criteria.add(TUserFeaturePeer.PERSON, getObjectID());
                 if (!lastTUserFeaturesCriteria.equals(criteria))
                 {
                     collTUserFeatures = TUserFeaturePeer.doSelect(criteria, con);
                 }
             }
         }
         lastTUserFeaturesCriteria = criteria;

         return collTUserFeatures;
     }











    /**
     * If this collection has already been initialized with
     * an identical criteria, it returns the collection.
     * Otherwise if this TPerson is new, it will return
     * an empty collection; or if this TPerson has previously
     * been saved, it will retrieve related TUserFeatures from storage.
     *
     * This method is protected by default in order to keep the public
     * api reasonable.  You can provide public methods for those you
     * actually need in TPerson.
     */
    protected List<TUserFeature> getTUserFeaturesJoinTPerson(Criteria criteria)
        throws TorqueException
    {
        if (collTUserFeatures == null)
        {
            if (isNew())
            {
               collTUserFeatures = new ArrayList<TUserFeature>();
            }
            else
            {
                criteria.add(TUserFeaturePeer.PERSON, getObjectID());
                collTUserFeatures = TUserFeaturePeer.doSelectJoinTPerson(criteria);
            }
        }
        else
        {
            // the following code is to determine if a new query is
            // called for.  If the criteria is the same as the last
            // one, just return the collection.
            criteria.add(TUserFeaturePeer.PERSON, getObjectID());
            if (!lastTUserFeaturesCriteria.equals(criteria))
            {
                collTUserFeatures = TUserFeaturePeer.doSelectJoinTPerson(criteria);
            }
        }
        lastTUserFeaturesCriteria = criteria;

        return collTUserFeatures;
    }



        
    private static List<String> fieldNames = null;

    /**
     * Generate a list of field names.
     *
     * @return a list of field names
     */
    public static synchronized List<String> getFieldNames()
    {
        if (fieldNames == null)
        {
            fieldNames = new ArrayList<String>();
            fieldNames.add("ObjectID");
            fieldNames.add("FirstName");
            fieldNames.add("LastName");
            fieldNames.add("LoginName");
            fieldNames.add("Email");
            fieldNames.add("Passwd");
            fieldNames.add("Salt");
            fieldNames.add("ForgotPasswordKey");
            fieldNames.add("Phone");
            fieldNames.add("DepartmentID");
            fieldNames.add("ValidUntil");
            fieldNames.add("Preferences");
            fieldNames.add("LastEdit");
            fieldNames.add("Created");
            fieldNames.add("Deleted");
            fieldNames.add("TokenPasswd");
            fieldNames.add("TokenExpDate");
            fieldNames.add("EmailFrequency");
            fieldNames.add("EmailLead");
            fieldNames.add("EmailLastReminded");
            fieldNames.add("EmailRemindMe");
            fieldNames.add("PrefEmailType");
            fieldNames.add("PrefLocale");
            fieldNames.add("MyDefaultReport");
            fieldNames.add("NoEmailPlease");
            fieldNames.add("RemindMeAsOriginator");
            fieldNames.add("RemindMeAsManager");
            fieldNames.add("RemindMeAsResponsible");
            fieldNames.add("EmailRemindPriorityLevel");
            fieldNames.add("EmailRemindSeverityLevel");
            fieldNames.add("HoursPerWorkDay");
            fieldNames.add("HourlyWage");
            fieldNames.add("ExtraHourWage");
            fieldNames.add("EmployeeID");
            fieldNames.add("Isgroup");
            fieldNames.add("UserLevel");
            fieldNames.add("MaxAssignedItems");
            fieldNames.add("MessengerURL");
            fieldNames.add("CALLURL");
            fieldNames.add("Symbol");
            fieldNames.add("IconKey");
            fieldNames.add("SubstituteID");
            fieldNames.add("SubstituteActive");
            fieldNames.add("Uuid");
            fieldNames = Collections.unmodifiableList(fieldNames);
        }
        return fieldNames;
    }

    /**
     * Retrieves a field from the object by field (Java) name passed in as a String.
     *
     * @param name field name
     * @return value
     */
    public Object getByName(String name)
    {
        if (name.equals("ObjectID"))
        {
            return getObjectID();
        }
        if (name.equals("FirstName"))
        {
            return getFirstName();
        }
        if (name.equals("LastName"))
        {
            return getLastName();
        }
        if (name.equals("LoginName"))
        {
            return getLoginName();
        }
        if (name.equals("Email"))
        {
            return getEmail();
        }
        if (name.equals("Passwd"))
        {
            return getPasswd();
        }
        if (name.equals("Salt"))
        {
            return getSalt();
        }
        if (name.equals("ForgotPasswordKey"))
        {
            return getForgotPasswordKey();
        }
        if (name.equals("Phone"))
        {
            return getPhone();
        }
        if (name.equals("DepartmentID"))
        {
            return getDepartmentID();
        }
        if (name.equals("ValidUntil"))
        {
            return getValidUntil();
        }
        if (name.equals("Preferences"))
        {
            return getPreferences();
        }
        if (name.equals("LastEdit"))
        {
            return getLastEdit();
        }
        if (name.equals("Created"))
        {
            return getCreated();
        }
        if (name.equals("Deleted"))
        {
            return getDeleted();
        }
        if (name.equals("TokenPasswd"))
        {
            return getTokenPasswd();
        }
        if (name.equals("TokenExpDate"))
        {
            return getTokenExpDate();
        }
        if (name.equals("EmailFrequency"))
        {
            return getEmailFrequency();
        }
        if (name.equals("EmailLead"))
        {
            return getEmailLead();
        }
        if (name.equals("EmailLastReminded"))
        {
            return getEmailLastReminded();
        }
        if (name.equals("EmailRemindMe"))
        {
            return getEmailRemindMe();
        }
        if (name.equals("PrefEmailType"))
        {
            return getPrefEmailType();
        }
        if (name.equals("PrefLocale"))
        {
            return getPrefLocale();
        }
        if (name.equals("MyDefaultReport"))
        {
            return getMyDefaultReport();
        }
        if (name.equals("NoEmailPlease"))
        {
            return getNoEmailPlease();
        }
        if (name.equals("RemindMeAsOriginator"))
        {
            return getRemindMeAsOriginator();
        }
        if (name.equals("RemindMeAsManager"))
        {
            return getRemindMeAsManager();
        }
        if (name.equals("RemindMeAsResponsible"))
        {
            return getRemindMeAsResponsible();
        }
        if (name.equals("EmailRemindPriorityLevel"))
        {
            return getEmailRemindPriorityLevel();
        }
        if (name.equals("EmailRemindSeverityLevel"))
        {
            return getEmailRemindSeverityLevel();
        }
        if (name.equals("HoursPerWorkDay"))
        {
            return getHoursPerWorkDay();
        }
        if (name.equals("HourlyWage"))
        {
            return getHourlyWage();
        }
        if (name.equals("ExtraHourWage"))
        {
            return getExtraHourWage();
        }
        if (name.equals("EmployeeID"))
        {
            return getEmployeeID();
        }
        if (name.equals("Isgroup"))
        {
            return getIsgroup();
        }
        if (name.equals("UserLevel"))
        {
            return getUserLevel();
        }
        if (name.equals("MaxAssignedItems"))
        {
            return getMaxAssignedItems();
        }
        if (name.equals("MessengerURL"))
        {
            return getMessengerURL();
        }
        if (name.equals("CALLURL"))
        {
            return getCALLURL();
        }
        if (name.equals("Symbol"))
        {
            return getSymbol();
        }
        if (name.equals("IconKey"))
        {
            return getIconKey();
        }
        if (name.equals("SubstituteID"))
        {
            return getSubstituteID();
        }
        if (name.equals("SubstituteActive"))
        {
            return getSubstituteActive();
        }
        if (name.equals("Uuid"))
        {
            return getUuid();
        }
        return null;
    }

    /**
     * Set a field in the object by field (Java) name.
     *
     * @param name field name
     * @param value field value
     * @return True if value was set, false if not (invalid name / protected field).
     * @throws IllegalArgumentException if object type of value does not match field object type.
     * @throws TorqueException If a problem occurs with the set[Field] method.
     */
    public boolean setByName(String name, Object value )
        throws TorqueException, IllegalArgumentException
    {
        if (name.equals("ObjectID"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setObjectID((Integer) value);
            return true;
        }
        if (name.equals("FirstName"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setFirstName((String) value);
            return true;
        }
        if (name.equals("LastName"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setLastName((String) value);
            return true;
        }
        if (name.equals("LoginName"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setLoginName((String) value);
            return true;
        }
        if (name.equals("Email"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmail((String) value);
            return true;
        }
        if (name.equals("Passwd"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setPasswd((String) value);
            return true;
        }
        if (name.equals("Salt"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setSalt((String) value);
            return true;
        }
        if (name.equals("ForgotPasswordKey"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setForgotPasswordKey((String) value);
            return true;
        }
        if (name.equals("Phone"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setPhone((String) value);
            return true;
        }
        if (name.equals("DepartmentID"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setDepartmentID((Integer) value);
            return true;
        }
        if (name.equals("ValidUntil"))
        {
            // Object fields can be null
            if (value != null && ! Date.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setValidUntil((Date) value);
            return true;
        }
        if (name.equals("Preferences"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setPreferences((String) value);
            return true;
        }
        if (name.equals("LastEdit"))
        {
            // Object fields can be null
            if (value != null && ! Date.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setLastEdit((Date) value);
            return true;
        }
        if (name.equals("Created"))
        {
            // Object fields can be null
            if (value != null && ! Date.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setCreated((Date) value);
            return true;
        }
        if (name.equals("Deleted"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setDeleted((String) value);
            return true;
        }
        if (name.equals("TokenPasswd"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setTokenPasswd((String) value);
            return true;
        }
        if (name.equals("TokenExpDate"))
        {
            // Object fields can be null
            if (value != null && ! Date.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setTokenExpDate((Date) value);
            return true;
        }
        if (name.equals("EmailFrequency"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailFrequency((Integer) value);
            return true;
        }
        if (name.equals("EmailLead"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailLead((Integer) value);
            return true;
        }
        if (name.equals("EmailLastReminded"))
        {
            // Object fields can be null
            if (value != null && ! Date.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailLastReminded((Date) value);
            return true;
        }
        if (name.equals("EmailRemindMe"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailRemindMe((String) value);
            return true;
        }
        if (name.equals("PrefEmailType"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setPrefEmailType((String) value);
            return true;
        }
        if (name.equals("PrefLocale"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setPrefLocale((String) value);
            return true;
        }
        if (name.equals("MyDefaultReport"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setMyDefaultReport((Integer) value);
            return true;
        }
        if (name.equals("NoEmailPlease"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setNoEmailPlease((Integer) value);
            return true;
        }
        if (name.equals("RemindMeAsOriginator"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setRemindMeAsOriginator((String) value);
            return true;
        }
        if (name.equals("RemindMeAsManager"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setRemindMeAsManager((String) value);
            return true;
        }
        if (name.equals("RemindMeAsResponsible"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setRemindMeAsResponsible((String) value);
            return true;
        }
        if (name.equals("EmailRemindPriorityLevel"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailRemindPriorityLevel((Integer) value);
            return true;
        }
        if (name.equals("EmailRemindSeverityLevel"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmailRemindSeverityLevel((Integer) value);
            return true;
        }
        if (name.equals("HoursPerWorkDay"))
        {
            // Object fields can be null
            if (value != null && ! Double.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setHoursPerWorkDay((Double) value);
            return true;
        }
        if (name.equals("HourlyWage"))
        {
            // Object fields can be null
            if (value != null && ! Double.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setHourlyWage((Double) value);
            return true;
        }
        if (name.equals("ExtraHourWage"))
        {
            // Object fields can be null
            if (value != null && ! Double.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setExtraHourWage((Double) value);
            return true;
        }
        if (name.equals("EmployeeID"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setEmployeeID((String) value);
            return true;
        }
        if (name.equals("Isgroup"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setIsgroup((String) value);
            return true;
        }
        if (name.equals("UserLevel"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setUserLevel((Integer) value);
            return true;
        }
        if (name.equals("MaxAssignedItems"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setMaxAssignedItems((Integer) value);
            return true;
        }
        if (name.equals("MessengerURL"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setMessengerURL((String) value);
            return true;
        }
        if (name.equals("CALLURL"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setCALLURL((String) value);
            return true;
        }
        if (name.equals("Symbol"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setSymbol((String) value);
            return true;
        }
        if (name.equals("IconKey"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setIconKey((Integer) value);
            return true;
        }
        if (name.equals("SubstituteID"))
        {
            // Object fields can be null
            if (value != null && ! Integer.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setSubstituteID((Integer) value);
            return true;
        }
        if (name.equals("SubstituteActive"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setSubstituteActive((String) value);
            return true;
        }
        if (name.equals("Uuid"))
        {
            // Object fields can be null
            if (value != null && ! String.class.isInstance(value))
            {
                throw new IllegalArgumentException("Invalid type of object specified for value in setByName");
            }
            setUuid((String) value);
            return true;
        }
        return false;
    }

    /**
     * Retrieves a field from the object by name passed in
     * as a String.  The String must be one of the static
     * Strings defined in this Class' Peer.
     *
     * @param name peer name
     * @return value
     */
    public Object getByPeerName(String name)
    {
        if (name.equals(TPersonPeer.PKEY))
        {
            return getObjectID();
        }
        if (name.equals(TPersonPeer.FIRSTNAME))
        {
            return getFirstName();
        }
        if (name.equals(TPersonPeer.LASTNAME))
        {
            return getLastName();
        }
        if (name.equals(TPersonPeer.LOGINNAME))
        {
            return getLoginName();
        }
        if (name.equals(TPersonPeer.EMAIL))
        {
            return getEmail();
        }
        if (name.equals(TPersonPeer.PASSWD))
        {
            return getPasswd();
        }
        if (name.equals(TPersonPeer.SALT))
        {
            return getSalt();
        }
        if (name.equals(TPersonPeer.FORGOTPASSWORDKEY))
        {
            return getForgotPasswordKey();
        }
        if (name.equals(TPersonPeer.PHONE))
        {
            return getPhone();
        }
        if (name.equals(TPersonPeer.DEPKEY))
        {
            return getDepartmentID();
        }
        if (name.equals(TPersonPeer.VALIDUNTIL))
        {
            return getValidUntil();
        }
        if (name.equals(TPersonPeer.PREFERENCES))
        {
            return getPreferences();
        }
        if (name.equals(TPersonPeer.LASTEDIT))
        {
            return getLastEdit();
        }
        if (name.equals(TPersonPeer.CREATED))
        {
            return getCreated();
        }
        if (name.equals(TPersonPeer.DELETED))
        {
            return getDeleted();
        }
        if (name.equals(TPersonPeer.TOKENPASSWD))
        {
            return getTokenPasswd();
        }
        if (name.equals(TPersonPeer.TOKENEXPDATE))
        {
            return getTokenExpDate();
        }
        if (name.equals(TPersonPeer.EMAILFREQUENCY))
        {
            return getEmailFrequency();
        }
        if (name.equals(TPersonPeer.EMAILLEAD))
        {
            return getEmailLead();
        }
        if (name.equals(TPersonPeer.EMAILLASTREMINDED))
        {
            return getEmailLastReminded();
        }
        if (name.equals(TPersonPeer.EMAILREMINDME))
        {
            return getEmailRemindMe();
        }
        if (name.equals(TPersonPeer.PREFEMAILTYPE))
        {
            return getPrefEmailType();
        }
        if (name.equals(TPersonPeer.PREFLOCALE))
        {
            return getPrefLocale();
        }
        if (name.equals(TPersonPeer.MYDEFAULTREPORT))
        {
            return getMyDefaultReport();
        }
        if (name.equals(TPersonPeer.NOEMAILSPLEASE))
        {
            return getNoEmailPlease();
        }
        if (name.equals(TPersonPeer.REMINDMEASORIGINATOR))
        {
            return getRemindMeAsOriginator();
        }
        if (name.equals(TPersonPeer.REMINDMEASMANAGER))
        {
            return getRemindMeAsManager();
        }
        if (name.equals(TPersonPeer.REMINDMEASRESPONSIBLE))
        {
            return getRemindMeAsResponsible();
        }
        if (name.equals(TPersonPeer.EMAILREMINDPLEVEL))
        {
            return getEmailRemindPriorityLevel();
        }
        if (name.equals(TPersonPeer.EMAILREMINDSLEVEL))
        {
            return getEmailRemindSeverityLevel();
        }
        if (name.equals(TPersonPeer.HOURSPERWORKDAY))
        {
            return getHoursPerWorkDay();
        }
        if (name.equals(TPersonPeer.HOURLYWAGE))
        {
            return getHourlyWage();
        }
        if (name.equals(TPersonPeer.EXTRAHOURWAGE))
        {
            return getExtraHourWage();
        }
        if (name.equals(TPersonPeer.EMPLOYEEID))
        {
            return getEmployeeID();
        }
        if (name.equals(TPersonPeer.ISGROUP))
        {
            return getIsgroup();
        }
        if (name.equals(TPersonPeer.USERLEVEL))
        {
            return getUserLevel();
        }
        if (name.equals(TPersonPeer.MAXASSIGNEDITEMS))
        {
            return getMaxAssignedItems();
        }
        if (name.equals(TPersonPeer.MESSENGERURL))
        {
            return getMessengerURL();
        }
        if (name.equals(TPersonPeer.CALLURL))
        {
            return getCALLURL();
        }
        if (name.equals(TPersonPeer.SYMBOL))
        {
            return getSymbol();
        }
        if (name.equals(TPersonPeer.ICONKEY))
        {
            return getIconKey();
        }
        if (name.equals(TPersonPeer.SUBSTITUTEKEY))
        {
            return getSubstituteID();
        }
        if (name.equals(TPersonPeer.SUBSTITUTEACTIVE))
        {
            return getSubstituteActive();
        }
        if (name.equals(TPersonPeer.TPUUID))
        {
            return getUuid();
        }
        return null;
    }

    /**
     * Set field values by Peer Field Name
     *
     * @param name field name
     * @param value field value
     * @return True if value was set, false if not (invalid name / protected field).
     * @throws IllegalArgumentException if object type of value does not match field object type.
     * @throws TorqueException If a problem occurs with the set[Field] method.
     */
    public boolean setByPeerName(String name, Object value)
        throws TorqueException, IllegalArgumentException
    {
      if (TPersonPeer.PKEY.equals(name))
        {
            return setByName("ObjectID", value);
        }
      if (TPersonPeer.FIRSTNAME.equals(name))
        {
            return setByName("FirstName", value);
        }
      if (TPersonPeer.LASTNAME.equals(name))
        {
            return setByName("LastName", value);
        }
      if (TPersonPeer.LOGINNAME.equals(name))
        {
            return setByName("LoginName", value);
        }
      if (TPersonPeer.EMAIL.equals(name))
        {
            return setByName("Email", value);
        }
      if (TPersonPeer.PASSWD.equals(name))
        {
            return setByName("Passwd", value);
        }
      if (TPersonPeer.SALT.equals(name))
        {
            return setByName("Salt", value);
        }
      if (TPersonPeer.FORGOTPASSWORDKEY.equals(name))
        {
            return setByName("ForgotPasswordKey", value);
        }
      if (TPersonPeer.PHONE.equals(name))
        {
            return setByName("Phone", value);
        }
      if (TPersonPeer.DEPKEY.equals(name))
        {
            return setByName("DepartmentID", value);
        }
      if (TPersonPeer.VALIDUNTIL.equals(name))
        {
            return setByName("ValidUntil", value);
        }
      if (TPersonPeer.PREFERENCES.equals(name))
        {
            return setByName("Preferences", value);
        }
      if (TPersonPeer.LASTEDIT.equals(name))
        {
            return setByName("LastEdit", value);
        }
      if (TPersonPeer.CREATED.equals(name))
        {
            return setByName("Created", value);
        }
      if (TPersonPeer.DELETED.equals(name))
        {
            return setByName("Deleted", value);
        }
      if (TPersonPeer.TOKENPASSWD.equals(name))
        {
            return setByName("TokenPasswd", value);
        }
      if (TPersonPeer.TOKENEXPDATE.equals(name))
        {
            return setByName("TokenExpDate", value);
        }
      if (TPersonPeer.EMAILFREQUENCY.equals(name))
        {
            return setByName("EmailFrequency", value);
        }
      if (TPersonPeer.EMAILLEAD.equals(name))
        {
            return setByName("EmailLead", value);
        }
      if (TPersonPeer.EMAILLASTREMINDED.equals(name))
        {
            return setByName("EmailLastReminded", value);
        }
      if (TPersonPeer.EMAILREMINDME.equals(name))
        {
            return setByName("EmailRemindMe", value);
        }
      if (TPersonPeer.PREFEMAILTYPE.equals(name))
        {
            return setByName("PrefEmailType", value);
        }
      if (TPersonPeer.PREFLOCALE.equals(name))
        {
            return setByName("PrefLocale", value);
        }
      if (TPersonPeer.MYDEFAULTREPORT.equals(name))
        {
            return setByName("MyDefaultReport", value);
        }
      if (TPersonPeer.NOEMAILSPLEASE.equals(name))
        {
            return setByName("NoEmailPlease", value);
        }
      if (TPersonPeer.REMINDMEASORIGINATOR.equals(name))
        {
            return setByName("RemindMeAsOriginator", value);
        }
      if (TPersonPeer.REMINDMEASMANAGER.equals(name))
        {
            return setByName("RemindMeAsManager", value);
        }
      if (TPersonPeer.REMINDMEASRESPONSIBLE.equals(name))
        {
            return setByName("RemindMeAsResponsible", value);
        }
      if (TPersonPeer.EMAILREMINDPLEVEL.equals(name))
        {
            return setByName("EmailRemindPriorityLevel", value);
        }
      if (TPersonPeer.EMAILREMINDSLEVEL.equals(name))
        {
            return setByName("EmailRemindSeverityLevel", value);
        }
      if (TPersonPeer.HOURSPERWORKDAY.equals(name))
        {
            return setByName("HoursPerWorkDay", value);
        }
      if (TPersonPeer.HOURLYWAGE.equals(name))
        {
            return setByName("HourlyWage", value);
        }
      if (TPersonPeer.EXTRAHOURWAGE.equals(name))
        {
            return setByName("ExtraHourWage", value);
        }
      if (TPersonPeer.EMPLOYEEID.equals(name))
        {
            return setByName("EmployeeID", value);
        }
      if (TPersonPeer.ISGROUP.equals(name))
        {
            return setByName("Isgroup", value);
        }
      if (TPersonPeer.USERLEVEL.equals(name))
        {
            return setByName("UserLevel", value);
        }
      if (TPersonPeer.MAXASSIGNEDITEMS.equals(name))
        {
            return setByName("MaxAssignedItems", value);
        }
      if (TPersonPeer.MESSENGERURL.equals(name))
        {
            return setByName("MessengerURL", value);
        }
      if (TPersonPeer.CALLURL.equals(name))
        {
            return setByName("CALLURL", value);
        }
      if (TPersonPeer.SYMBOL.equals(name))
        {
            return setByName("Symbol", value);
        }
      if (TPersonPeer.ICONKEY.equals(name))
        {
            return setByName("IconKey", value);
        }
      if (TPersonPeer.SUBSTITUTEKEY.equals(name))
        {
            return setByName("SubstituteID", value);
        }
      if (TPersonPeer.SUBSTITUTEACTIVE.equals(name))
        {
            return setByName("SubstituteActive", value);
        }
      if (TPersonPeer.TPUUID.equals(name))
        {
            return setByName("Uuid", value);
        }
        return false;
    }

    /**
     * Retrieves a field from the object by Position as specified
     * in the xml schema.  Zero-based.
     *
     * @param pos position in xml schema
     * @return value
     */
    public Object getByPosition(int pos)
    {
        if (pos == 0)
        {
            return getObjectID();
        }
        if (pos == 1)
        {
            return getFirstName();
        }
        if (pos == 2)
        {
            return getLastName();
        }
        if (pos == 3)
        {
            return getLoginName();
        }
        if (pos == 4)
        {
            return getEmail();
        }
        if (pos == 5)
        {
            return getPasswd();
        }
        if (pos == 6)
        {
            return getSalt();
        }
        if (pos == 7)
        {
            return getForgotPasswordKey();
        }
        if (pos == 8)
        {
            return getPhone();
        }
        if (pos == 9)
        {
            return getDepartmentID();
        }
        if (pos == 10)
        {
            return getValidUntil();
        }
        if (pos == 11)
        {
            return getPreferences();
        }
        if (pos == 12)
        {
            return getLastEdit();
        }
        if (pos == 13)
        {
            return getCreated();
        }
        if (pos == 14)
        {
            return getDeleted();
        }
        if (pos == 15)
        {
            return getTokenPasswd();
        }
        if (pos == 16)
        {
            return getTokenExpDate();
        }
        if (pos == 17)
        {
            return getEmailFrequency();
        }
        if (pos == 18)
        {
            return getEmailLead();
        }
        if (pos == 19)
        {
            return getEmailLastReminded();
        }
        if (pos == 20)
        {
            return getEmailRemindMe();
        }
        if (pos == 21)
        {
            return getPrefEmailType();
        }
        if (pos == 22)
        {
            return getPrefLocale();
        }
        if (pos == 23)
        {
            return getMyDefaultReport();
        }
        if (pos == 24)
        {
            return getNoEmailPlease();
        }
        if (pos == 25)
        {
            return getRemindMeAsOriginator();
        }
        if (pos == 26)
        {
            return getRemindMeAsManager();
        }
        if (pos == 27)
        {
            return getRemindMeAsResponsible();
        }
        if (pos == 28)
        {
            return getEmailRemindPriorityLevel();
        }
        if (pos == 29)
        {
            return getEmailRemindSeverityLevel();
        }
        if (pos == 30)
        {
            return getHoursPerWorkDay();
        }
        if (pos == 31)
        {
            return getHourlyWage();
        }
        if (pos == 32)
        {
            return getExtraHourWage();
        }
        if (pos == 33)
        {
            return getEmployeeID();
        }
        if (pos == 34)
        {
            return getIsgroup();
        }
        if (pos == 35)
        {
            return getUserLevel();
        }
        if (pos == 36)
        {
            return getMaxAssignedItems();
        }
        if (pos == 37)
        {
            return getMessengerURL();
        }
        if (pos == 38)
        {
            return getCALLURL();
        }
        if (pos == 39)
        {
            return getSymbol();
        }
        if (pos == 40)
        {
            return getIconKey();
        }
        if (pos == 41)
        {
            return getSubstituteID();
        }
        if (pos == 42)
        {
            return getSubstituteActive();
        }
        if (pos == 43)
        {
            return getUuid();
        }
        return null;
    }

    /**
     * Set field values by its position (zero based) in the XML schema.
     *
     * @param position The field position
     * @param value field value
     * @return True if value was set, false if not (invalid position / protected field).
     * @throws IllegalArgumentException if object type of value does not match field object type.
     * @throws TorqueException If a problem occurs with the set[Field] method.
     */
    public boolean setByPosition(int position, Object value)
        throws TorqueException, IllegalArgumentException
    {
    if (position == 0)
        {
            return setByName("ObjectID", value);
        }
    if (position == 1)
        {
            return setByName("FirstName", value);
        }
    if (position == 2)
        {
            return setByName("LastName", value);
        }
    if (position == 3)
        {
            return setByName("LoginName", value);
        }
    if (position == 4)
        {
            return setByName("Email", value);
        }
    if (position == 5)
        {
            return setByName("Passwd", value);
        }
    if (position == 6)
        {
            return setByName("Salt", value);
        }
    if (position == 7)
        {
            return setByName("ForgotPasswordKey", value);
        }
    if (position == 8)
        {
            return setByName("Phone", value);
        }
    if (position == 9)
        {
            return setByName("DepartmentID", value);
        }
    if (position == 10)
        {
            return setByName("ValidUntil", value);
        }
    if (position == 11)
        {
            return setByName("Preferences", value);
        }
    if (position == 12)
        {
            return setByName("LastEdit", value);
        }
    if (position == 13)
        {
            return setByName("Created", value);
        }
    if (position == 14)
        {
            return setByName("Deleted", value);
        }
    if (position == 15)
        {
            return setByName("TokenPasswd", value);
        }
    if (position == 16)
        {
            return setByName("TokenExpDate", value);
        }
    if (position == 17)
        {
            return setByName("EmailFrequency", value);
        }
    if (position == 18)
        {
            return setByName("EmailLead", value);
        }
    if (position == 19)
        {
            return setByName("EmailLastReminded", value);
        }
    if (position == 20)
        {
            return setByName("EmailRemindMe", value);
        }
    if (position == 21)
        {
            return setByName("PrefEmailType", value);
        }
    if (position == 22)
        {
            return setByName("PrefLocale", value);
        }
    if (position == 23)
        {
            return setByName("MyDefaultReport", value);
        }
    if (position == 24)
        {
            return setByName("NoEmailPlease", value);
        }
    if (position == 25)
        {
            return setByName("RemindMeAsOriginator", value);
        }
    if (position == 26)
        {
            return setByName("RemindMeAsManager", value);
        }
    if (position == 27)
        {
            return setByName("RemindMeAsResponsible", value);
        }
    if (position == 28)
        {
            return setByName("EmailRemindPriorityLevel", value);
        }
    if (position == 29)
        {
            return setByName("EmailRemindSeverityLevel", value);
        }
    if (position == 30)
        {
            return setByName("HoursPerWorkDay", value);
        }
    if (position == 31)
        {
            return setByName("HourlyWage", value);
        }
    if (position == 32)
        {
            return setByName("ExtraHourWage", value);
        }
    if (position == 33)
        {
            return setByName("EmployeeID", value);
        }
    if (position == 34)
        {
            return setByName("Isgroup", value);
        }
    if (position == 35)
        {
            return setByName("UserLevel", value);
        }
    if (position == 36)
        {
            return setByName("MaxAssignedItems", value);
        }
    if (position == 37)
        {
            return setByName("MessengerURL", value);
        }
    if (position == 38)
        {
            return setByName("CALLURL", value);
        }
    if (position == 39)
        {
            return setByName("Symbol", value);
        }
    if (position == 40)
        {
            return setByName("IconKey", value);
        }
    if (position == 41)
        {
            return setByName("SubstituteID", value);
        }
    if (position == 42)
        {
            return setByName("SubstituteActive", value);
        }
    if (position == 43)
        {
            return setByName("Uuid", value);
        }
        return false;
    }
     
    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.
     *
     * @throws Exception
     */
    public void save() throws Exception
    {
        save(TPersonPeer.DATABASE_NAME);
    }

    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.
     * Note: this code is here because the method body is
     * auto-generated conditionally and therefore needs to be
     * in this file instead of in the super class, BaseObject.
     *
     * @param dbName
     * @throws TorqueException
     */
    public void save(String dbName) throws TorqueException
    {
        Connection con = null;
        try
        {
            con = Transaction.begin(dbName);
            save(con);
            Transaction.commit(con);
        }
        catch(TorqueException e)
        {
            Transaction.safeRollback(con);
            throw e;
        }
    }

    /** flag to prevent endless save loop, if this object is referenced
        by another object which falls in this transaction. */
    private boolean alreadyInSave = false;
    /**
     * Stores the object in the database.  If the object is new,
     * it inserts it; otherwise an update is performed.  This method
     * is meant to be used as part of a transaction, otherwise use
     * the save() method and the connection details will be handled
     * internally
     *
     * @param con
     * @throws TorqueException
     */
    public void save(Connection con) throws TorqueException
    {
        if (!alreadyInSave)
        {
            alreadyInSave = true;



            // If this object has been modified, then save it to the database.
            if (isModified())
            {
                if (isNew())
                {
                    TPersonPeer.doInsert((TPerson) this, con);
                    setNew(false);
                }
                else
                {
                    TPersonPeer.doUpdate((TPerson) this, con);
                }
            }


            if (collTAccessControlLists != null)
            {
                for (int i = 0; i < collTAccessControlLists.size(); i++)
                {
                    ((TAccessControlList) collTAccessControlLists.get(i)).save(con);
                }
            }

            if (collTBaseLines != null)
            {
                for (int i = 0; i < collTBaseLines.size(); i++)
                {
                    ((TBaseLine) collTBaseLines.get(i)).save(con);
                }
            }

            if (collTNotifys != null)
            {
                for (int i = 0; i < collTNotifys.size(); i++)
                {
                    ((TNotify) collTNotifys.get(i)).save(con);
                }
            }

            if (collTProjectsRelatedByDefaultOwnerID != null)
            {
                for (int i = 0; i < collTProjectsRelatedByDefaultOwnerID.size(); i++)
                {
                    ((TProject) collTProjectsRelatedByDefaultOwnerID.get(i)).save(con);
                }
            }

            if (collTProjectsRelatedByDefaultManagerID != null)
            {
                for (int i = 0; i < collTProjectsRelatedByDefaultManagerID.size(); i++)
                {
                    ((TProject) collTProjectsRelatedByDefaultManagerID.get(i)).save(con);
                }
            }

            if (collTStateChanges != null)
            {
                for (int i = 0; i < collTStateChanges.size(); i++)
                {
                    ((TStateChange) collTStateChanges.get(i)).save(con);
                }
            }

            if (collTTrails != null)
            {
                for (int i = 0; i < collTTrails.size(); i++)
                {
                    ((TTrail) collTTrails.get(i)).save(con);
                }
            }

            if (collTWorkItemsRelatedByOwnerID != null)
            {
                for (int i = 0; i < collTWorkItemsRelatedByOwnerID.size(); i++)
                {
                    ((TWorkItem) collTWorkItemsRelatedByOwnerID.get(i)).save(con);
                }
            }

            if (collTWorkItemsRelatedByChangedByID != null)
            {
                for (int i = 0; i < collTWorkItemsRelatedByChangedByID.size(); i++)
                {
                    ((TWorkItem) collTWorkItemsRelatedByChangedByID.get(i)).save(con);
                }
            }

            if (collTWorkItemsRelatedByOriginatorID != null)
            {
                for (int i = 0; i < collTWorkItemsRelatedByOriginatorID.size(); i++)
                {
                    ((TWorkItem) collTWorkItemsRelatedByOriginatorID.get(i)).save(con);
                }
            }

            if (collTWorkItemsRelatedByResponsibleID != null)
            {
                for (int i = 0; i < collTWorkItemsRelatedByResponsibleID.size(); i++)
                {
                    ((TWorkItem) collTWorkItemsRelatedByResponsibleID.get(i)).save(con);
                }
            }

            if (collTComputedValuess != null)
            {
                for (int i = 0; i < collTComputedValuess.size(); i++)
                {
                    ((TComputedValues) collTComputedValuess.get(i)).save(con);
                }
            }

            if (collTPrivateReportRepositorys != null)
            {
                for (int i = 0; i < collTPrivateReportRepositorys.size(); i++)
                {
                    ((TPrivateReportRepository) collTPrivateReportRepositorys.get(i)).save(con);
                }
            }

            if (collTPublicReportRepositorys != null)
            {
                for (int i = 0; i < collTPublicReportRepositorys.size(); i++)
                {
                    ((TPublicReportRepository) collTPublicReportRepositorys.get(i)).save(con);
                }
            }

            if (collTAttachments != null)
            {
                for (int i = 0; i < collTAttachments.size(); i++)
                {
                    ((TAttachment) collTAttachments.get(i)).save(con);
                }
            }

            if (collTCosts != null)
            {
                for (int i = 0; i < collTCosts.size(); i++)
                {
                    ((TCost) collTCosts.get(i)).save(con);
                }
            }

            if (collTWorkFlows != null)
            {
                for (int i = 0; i < collTWorkFlows.size(); i++)
                {
                    ((TWorkFlow) collTWorkFlows.get(i)).save(con);
                }
            }

            if (collTIssueAttributeValues != null)
            {
                for (int i = 0; i < collTIssueAttributeValues.size(); i++)
                {
                    ((TIssueAttributeValue) collTIssueAttributeValues.get(i)).save(con);
                }
            }

            if (collTReportLayouts != null)
            {
                for (int i = 0; i < collTReportLayouts.size(); i++)
                {
                    ((TReportLayout) collTReportLayouts.get(i)).save(con);
                }
            }

            if (collTSchedulers != null)
            {
                for (int i = 0; i < collTSchedulers.size(); i++)
                {
                    ((TScheduler) collTSchedulers.get(i)).save(con);
                }
            }

            if (collTGroupMembersRelatedByTheGroup != null)
            {
                for (int i = 0; i < collTGroupMembersRelatedByTheGroup.size(); i++)
                {
                    ((TGroupMember) collTGroupMembersRelatedByTheGroup.get(i)).save(con);
                }
            }

            if (collTGroupMembersRelatedByPerson != null)
            {
                for (int i = 0; i < collTGroupMembersRelatedByPerson.size(); i++)
                {
                    ((TGroupMember) collTGroupMembersRelatedByPerson.get(i)).save(con);
                }
            }

            if (collTBudgets != null)
            {
                for (int i = 0; i < collTBudgets.size(); i++)
                {
                    ((TBudget) collTBudgets.get(i)).save(con);
                }
            }

            if (collTActualEstimatedBudgets != null)
            {
                for (int i = 0; i < collTActualEstimatedBudgets.size(); i++)
                {
                    ((TActualEstimatedBudget) collTActualEstimatedBudgets.get(i)).save(con);
                }
            }

            if (collTDashboardScreensRelatedByPerson != null)
            {
                for (int i = 0; i < collTDashboardScreensRelatedByPerson.size(); i++)
                {
                    ((TDashboardScreen) collTDashboardScreensRelatedByPerson.get(i)).save(con);
                }
            }

            if (collTDashboardScreensRelatedByOwner != null)
            {
                for (int i = 0; i < collTDashboardScreensRelatedByOwner.size(); i++)
                {
                    ((TDashboardScreen) collTDashboardScreensRelatedByOwner.get(i)).save(con);
                }
            }

            if (collTFields != null)
            {
                for (int i = 0; i < collTFields.size(); i++)
                {
                    ((TField) collTFields.get(i)).save(con);
                }
            }

            if (collTLists != null)
            {
                for (int i = 0; i < collTLists.size(); i++)
                {
                    ((TList) collTLists.get(i)).save(con);
                }
            }

            if (collTScreens != null)
            {
                for (int i = 0; i < collTScreens.size(); i++)
                {
                    ((TScreen) collTScreens.get(i)).save(con);
                }
            }

            if (collTNotifyTriggers != null)
            {
                for (int i = 0; i < collTNotifyTriggers.size(); i++)
                {
                    ((TNotifyTrigger) collTNotifyTriggers.get(i)).save(con);
                }
            }

            if (collTNotifySettingss != null)
            {
                for (int i = 0; i < collTNotifySettingss.size(); i++)
                {
                    ((TNotifySettings) collTNotifySettingss.get(i)).save(con);
                }
            }

            if (collTQueryRepositorys != null)
            {
                for (int i = 0; i < collTQueryRepositorys.size(); i++)
                {
                    ((TQueryRepository) collTQueryRepositorys.get(i)).save(con);
                }
            }

            if (collTWorkItemLinks != null)
            {
                for (int i = 0; i < collTWorkItemLinks.size(); i++)
                {
                    ((TWorkItemLink) collTWorkItemLinks.get(i)).save(con);
                }
            }

            if (collTWorkItemLocks != null)
            {
                for (int i = 0; i < collTWorkItemLocks.size(); i++)
                {
                    ((TWorkItemLock) collTWorkItemLocks.get(i)).save(con);
                }
            }

            if (collTExportTemplates != null)
            {
                for (int i = 0; i < collTExportTemplates.size(); i++)
                {
                    ((TExportTemplate) collTExportTemplates.get(i)).save(con);
                }
            }

            if (collTLoggedInUserss != null)
            {
                for (int i = 0; i < collTLoggedInUserss.size(); i++)
                {
                    ((TLoggedInUsers) collTLoggedInUserss.get(i)).save(con);
                }
            }

            if (collTSummaryMailsRelatedByPERSONFROM != null)
            {
                for (int i = 0; i < collTSummaryMailsRelatedByPERSONFROM.size(); i++)
                {
                    ((TSummaryMail) collTSummaryMailsRelatedByPERSONFROM.get(i)).save(con);
                }
            }

            if (collTSummaryMailsRelatedByPERSONTO != null)
            {
                for (int i = 0; i < collTSummaryMailsRelatedByPERSONTO.size(); i++)
                {
                    ((TSummaryMail) collTSummaryMailsRelatedByPERSONTO.get(i)).save(con);
                }
            }

            if (collTHistoryTransactions != null)
            {
                for (int i = 0; i < collTHistoryTransactions.size(); i++)
                {
                    ((THistoryTransaction) collTHistoryTransactions.get(i)).save(con);
                }
            }

            if (collTScriptss != null)
            {
                for (int i = 0; i < collTScriptss.size(); i++)
                {
                    ((TScripts) collTScriptss.get(i)).save(con);
                }
            }

            if (collTTemplatePersons != null)
            {
                for (int i = 0; i < collTTemplatePersons.size(); i++)
                {
                    ((TTemplatePerson) collTTemplatePersons.get(i)).save(con);
                }
            }

            if (collTReportPersonSettingss != null)
            {
                for (int i = 0; i < collTReportPersonSettingss.size(); i++)
                {
                    ((TReportPersonSettings) collTReportPersonSettingss.get(i)).save(con);
                }
            }

            if (collTMSProjectExchanges != null)
            {
                for (int i = 0; i < collTMSProjectExchanges.size(); i++)
                {
                    ((TMSProjectExchange) collTMSProjectExchanges.get(i)).save(con);
                }
            }

            if (collTFilterCategorys != null)
            {
                for (int i = 0; i < collTFilterCategorys.size(); i++)
                {
                    ((TFilterCategory) collTFilterCategorys.get(i)).save(con);
                }
            }

            if (collTReportCategorys != null)
            {
                for (int i = 0; i < collTReportCategorys.size(); i++)
                {
                    ((TReportCategory) collTReportCategorys.get(i)).save(con);
                }
            }

            if (collTMenuitemQuerys != null)
            {
                for (int i = 0; i < collTMenuitemQuerys.size(); i++)
                {
                    ((TMenuitemQuery) collTMenuitemQuerys.get(i)).save(con);
                }
            }

            if (collTPersonBaskets != null)
            {
                for (int i = 0; i < collTPersonBaskets.size(); i++)
                {
                    ((TPersonBasket) collTPersonBaskets.get(i)).save(con);
                }
            }

            if (collTBaskets != null)
            {
                for (int i = 0; i < collTBaskets.size(); i++)
                {
                    ((TBasket) collTBaskets.get(i)).save(con);
                }
            }

            if (collTLastVisitedItems != null)
            {
                for (int i = 0; i < collTLastVisitedItems.size(); i++)
                {
                    ((TLastVisitedItem) collTLastVisitedItems.get(i)).save(con);
                }
            }

            if (collTWorkflowDefs != null)
            {
                for (int i = 0; i < collTWorkflowDefs.size(); i++)
                {
                    ((TWorkflowDef) collTWorkflowDefs.get(i)).save(con);
                }
            }

            if (collTWorkflowActivitysRelatedByNewMan != null)
            {
                for (int i = 0; i < collTWorkflowActivitysRelatedByNewMan.size(); i++)
                {
                    ((TWorkflowActivity) collTWorkflowActivitysRelatedByNewMan.get(i)).save(con);
                }
            }

            if (collTWorkflowActivitysRelatedByNewResp != null)
            {
                for (int i = 0; i < collTWorkflowActivitysRelatedByNewResp.size(); i++)
                {
                    ((TWorkflowActivity) collTWorkflowActivitysRelatedByNewResp.get(i)).save(con);
                }
            }

            if (collTWorkflowGuards != null)
            {
                for (int i = 0; i < collTWorkflowGuards.size(); i++)
                {
                    ((TWorkflowGuard) collTWorkflowGuards.get(i)).save(con);
                }
            }

            if (collTEscalationEntrys != null)
            {
                for (int i = 0; i < collTEscalationEntrys.size(); i++)
                {
                    ((TEscalationEntry) collTEscalationEntrys.get(i)).save(con);
                }
            }

            if (collTReadIssues != null)
            {
                for (int i = 0; i < collTReadIssues.size(); i++)
                {
                    ((TReadIssue) collTReadIssues.get(i)).save(con);
                }
            }

            if (collTLastExecutedQuerys != null)
            {
                for (int i = 0; i < collTLastExecutedQuerys.size(); i++)
                {
                    ((TLastExecutedQuery) collTLastExecutedQuerys.get(i)).save(con);
                }
            }

            if (collTReportSubscribes != null)
            {
                for (int i = 0; i < collTReportSubscribes.size(); i++)
                {
                    ((TReportSubscribe) collTReportSubscribes.get(i)).save(con);
                }
            }

            if (collTGridLayouts != null)
            {
                for (int i = 0; i < collTGridLayouts.size(); i++)
                {
                    ((TGridLayout) collTGridLayouts.get(i)).save(con);
                }
            }

            if (collTNavigatorLayouts != null)
            {
                for (int i = 0; i < collTNavigatorLayouts.size(); i++)
                {
                    ((TNavigatorLayout) collTNavigatorLayouts.get(i)).save(con);
                }
            }

            if (collTMailTextBlocks != null)
            {
                for (int i = 0; i < collTMailTextBlocks.size(); i++)
                {
                    ((TMailTextBlock) collTMailTextBlocks.get(i)).save(con);
                }
            }

            if (collTPersonInDomains != null)
            {
                for (int i = 0; i < collTPersonInDomains.size(); i++)
                {
                    ((TPersonInDomain) collTPersonInDomains.get(i)).save(con);
                }
            }

            if (collTAttachmentVersions != null)
            {
                for (int i = 0; i < collTAttachmentVersions.size(); i++)
                {
                    ((TAttachmentVersion) collTAttachmentVersions.get(i)).save(con);
                }
            }

            if (collTUserFeatures != null)
            {
                for (int i = 0; i < collTUserFeatures.size(); i++)
                {
                    ((TUserFeature) collTUserFeatures.get(i)).save(con);
                }
            }
            alreadyInSave = false;
        }
    }


    /**
     * Set the PrimaryKey using ObjectKey.
     *
     * @param key objectID ObjectKey
     */
    public void setPrimaryKey(ObjectKey key)
        throws TorqueException
    {
        setObjectID(new Integer(((NumberKey) key).intValue()));
    }

    /**
     * Set the PrimaryKey using a String.
     *
     * @param key
     */
    public void setPrimaryKey(String key) throws TorqueException
    {
        setObjectID(new Integer(key));
    }


    /**
     * returns an id that differentiates this object from others
     * of its class.
     */
    public ObjectKey getPrimaryKey()
    {
        return SimpleKey.keyFor(getObjectID());
    }
 

    /**
     * Makes a copy of this object.
     * It creates a new object filling in the simple attributes.
     * It then fills all the association collections and sets the
     * related objects to isNew=true.
     */
    public TPerson copy() throws TorqueException
    {
        return copy(true);
    }

    /**
     * Makes a copy of this object using connection.
     * It creates a new object filling in the simple attributes.
     * It then fills all the association collections and sets the
     * related objects to isNew=true.
     *
     * @param con the database connection to read associated objects.
     */
    public TPerson copy(Connection con) throws TorqueException
    {
        return copy(true, con);
    }

    /**
     * Makes a copy of this object.
     * It creates a new object filling in the simple attributes.
     * If the parameter deepcopy is true, it then fills all the
     * association collections and sets the related objects to
     * isNew=true.
     *
     * @param deepcopy whether to copy the associated objects.
     */
    public TPerson copy(boolean deepcopy) throws TorqueException
    {
        return copyInto(new TPerson(), deepcopy);
    }

    /**
     * Makes a copy of this object using connection.
     * It creates a new object filling in the simple attributes.
     * If the parameter deepcopy is true, it then fills all the
     * association collections and sets the related objects to
     * isNew=true.
     *
     * @param deepcopy whether to copy the associated objects.
     * @param con the database connection to read associated objects.
     */
    public TPerson copy(boolean deepcopy, Connection con) throws TorqueException
    {
        return copyInto(new TPerson(), deepcopy, con);
    }
  
    /**
     * Fills the copyObj with the contents of this object.
     * The associated objects are also copied and treated as new objects.
     *
     * @param copyObj the object to fill.
     */
    protected TPerson copyInto(TPerson copyObj) throws TorqueException
    {
        return copyInto(copyObj, true);
    }

  
    /**
     * Fills the copyObj with the contents of this object using connection.
     * The associated objects are also copied and treated as new objects.
     *
     * @param copyObj the object to fill.
     * @param con the database connection to read associated objects.
     */
    protected TPerson copyInto(TPerson copyObj, Connection con) throws TorqueException
    {
        return copyInto(copyObj, true, con);
    }
  
    /**
     * Fills the copyObj with the contents of this object.
     * If deepcopy is true, The associated objects are also copied
     * and treated as new objects.
     *
     * @param copyObj the object to fill.
     * @param deepcopy whether the associated objects should be copied.
     */
    protected TPerson copyInto(TPerson copyObj, boolean deepcopy) throws TorqueException
    {
        copyObj.setObjectID(objectID);
        copyObj.setFirstName(firstName);
        copyObj.setLastName(lastName);
        copyObj.setLoginName(loginName);
        copyObj.setEmail(email);
        copyObj.setPasswd(passwd);
        copyObj.setSalt(salt);
        copyObj.setForgotPasswordKey(forgotPasswordKey);
        copyObj.setPhone(phone);
        copyObj.setDepartmentID(departmentID);
        copyObj.setValidUntil(validUntil);
        copyObj.setPreferences(preferences);
        copyObj.setLastEdit(lastEdit);
        copyObj.setCreated(created);
        copyObj.setDeleted(deleted);
        copyObj.setTokenPasswd(tokenPasswd);
        copyObj.setTokenExpDate(tokenExpDate);
        copyObj.setEmailFrequency(emailFrequency);
        copyObj.setEmailLead(emailLead);
        copyObj.setEmailLastReminded(emailLastReminded);
        copyObj.setEmailRemindMe(emailRemindMe);
        copyObj.setPrefEmailType(prefEmailType);
        copyObj.setPrefLocale(prefLocale);
        copyObj.setMyDefaultReport(myDefaultReport);
        copyObj.setNoEmailPlease(noEmailPlease);
        copyObj.setRemindMeAsOriginator(remindMeAsOriginator);
        copyObj.setRemindMeAsManager(remindMeAsManager);
        copyObj.setRemindMeAsResponsible(remindMeAsResponsible);
        copyObj.setEmailRemindPriorityLevel(emailRemindPriorityLevel);
        copyObj.setEmailRemindSeverityLevel(emailRemindSeverityLevel);
        copyObj.setHoursPerWorkDay(hoursPerWorkDay);
        copyObj.setHourlyWage(hourlyWage);
        copyObj.setExtraHourWage(extraHourWage);
        copyObj.setEmployeeID(employeeID);
        copyObj.setIsgroup(isgroup);
        copyObj.setUserLevel(userLevel);
        copyObj.setMaxAssignedItems(maxAssignedItems);
        copyObj.setMessengerURL(messengerURL);
        copyObj.setCALLURL(cALLURL);
        copyObj.setSymbol(symbol);
        copyObj.setIconKey(iconKey);
        copyObj.setSubstituteID(substituteID);
        copyObj.setSubstituteActive(substituteActive);
        copyObj.setUuid(uuid);

        copyObj.setObjectID((Integer)null);

        if (deepcopy)
        {


        List<TAccessControlList> vTAccessControlLists = getTAccessControlLists();
        if (vTAccessControlLists != null)
        {
            for (int i = 0; i < vTAccessControlLists.size(); i++)
            {
                TAccessControlList obj =  vTAccessControlLists.get(i);
                copyObj.addTAccessControlList(obj.copy());
            }
        }
        else
        {
            copyObj.collTAccessControlLists = null;
        }


        List<TBaseLine> vTBaseLines = getTBaseLines();
        if (vTBaseLines != null)
        {
            for (int i = 0; i < vTBaseLines.size(); i++)
            {
                TBaseLine obj =  vTBaseLines.get(i);
                copyObj.addTBaseLine(obj.copy());
            }
        }
        else
        {
            copyObj.collTBaseLines = null;
        }


        List<TNotify> vTNotifys = getTNotifys();
        if (vTNotifys != null)
        {
            for (int i = 0; i < vTNotifys.size(); i++)
            {
                TNotify obj =  vTNotifys.get(i);
                copyObj.addTNotify(obj.copy());
            }
        }
        else
        {
            copyObj.collTNotifys = null;
        }


        List<TProject> vTProjectsRelatedByDefaultOwnerID = getTProjectsRelatedByDefaultOwnerID();
        if (vTProjectsRelatedByDefaultOwnerID != null)
        {
            for (int i = 0; i < vTProjectsRelatedByDefaultOwnerID.size(); i++)
            {
                TProject obj =  vTProjectsRelatedByDefaultOwnerID.get(i);
                copyObj.addTProjectRelatedByDefaultOwnerID(obj.copy());
            }
        }
        else
        {
            copyObj.collTProjectsRelatedByDefaultOwnerID = null;
        }


        List<TProject> vTProjectsRelatedByDefaultManagerID = getTProjectsRelatedByDefaultManagerID();
        if (vTProjectsRelatedByDefaultManagerID != null)
        {
            for (int i = 0; i < vTProjectsRelatedByDefaultManagerID.size(); i++)
            {
                TProject obj =  vTProjectsRelatedByDefaultManagerID.get(i);
                copyObj.addTProjectRelatedByDefaultManagerID(obj.copy());
            }
        }
        else
        {
            copyObj.collTProjectsRelatedByDefaultManagerID = null;
        }


        List<TStateChange> vTStateChanges = getTStateChanges();
        if (vTStateChanges != null)
        {
            for (int i = 0; i < vTStateChanges.size(); i++)
            {
                TStateChange obj =  vTStateChanges.get(i);
                copyObj.addTStateChange(obj.copy());
            }
        }
        else
        {
            copyObj.collTStateChanges = null;
        }


        List<TTrail> vTTrails = getTTrails();
        if (vTTrails != null)
        {
            for (int i = 0; i < vTTrails.size(); i++)
            {
                TTrail obj =  vTTrails.get(i);
                copyObj.addTTrail(obj.copy());
            }
        }
        else
        {
            copyObj.collTTrails = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByOwnerID = getTWorkItemsRelatedByOwnerID();
        if (vTWorkItemsRelatedByOwnerID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByOwnerID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByOwnerID.get(i);
                copyObj.addTWorkItemRelatedByOwnerID(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByOwnerID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByChangedByID = getTWorkItemsRelatedByChangedByID();
        if (vTWorkItemsRelatedByChangedByID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByChangedByID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByChangedByID.get(i);
                copyObj.addTWorkItemRelatedByChangedByID(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByChangedByID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByOriginatorID = getTWorkItemsRelatedByOriginatorID();
        if (vTWorkItemsRelatedByOriginatorID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByOriginatorID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByOriginatorID.get(i);
                copyObj.addTWorkItemRelatedByOriginatorID(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByOriginatorID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByResponsibleID = getTWorkItemsRelatedByResponsibleID();
        if (vTWorkItemsRelatedByResponsibleID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByResponsibleID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByResponsibleID.get(i);
                copyObj.addTWorkItemRelatedByResponsibleID(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByResponsibleID = null;
        }


        List<TComputedValues> vTComputedValuess = getTComputedValuess();
        if (vTComputedValuess != null)
        {
            for (int i = 0; i < vTComputedValuess.size(); i++)
            {
                TComputedValues obj =  vTComputedValuess.get(i);
                copyObj.addTComputedValues(obj.copy());
            }
        }
        else
        {
            copyObj.collTComputedValuess = null;
        }


        List<TPrivateReportRepository> vTPrivateReportRepositorys = getTPrivateReportRepositorys();
        if (vTPrivateReportRepositorys != null)
        {
            for (int i = 0; i < vTPrivateReportRepositorys.size(); i++)
            {
                TPrivateReportRepository obj =  vTPrivateReportRepositorys.get(i);
                copyObj.addTPrivateReportRepository(obj.copy());
            }
        }
        else
        {
            copyObj.collTPrivateReportRepositorys = null;
        }


        List<TPublicReportRepository> vTPublicReportRepositorys = getTPublicReportRepositorys();
        if (vTPublicReportRepositorys != null)
        {
            for (int i = 0; i < vTPublicReportRepositorys.size(); i++)
            {
                TPublicReportRepository obj =  vTPublicReportRepositorys.get(i);
                copyObj.addTPublicReportRepository(obj.copy());
            }
        }
        else
        {
            copyObj.collTPublicReportRepositorys = null;
        }


        List<TAttachment> vTAttachments = getTAttachments();
        if (vTAttachments != null)
        {
            for (int i = 0; i < vTAttachments.size(); i++)
            {
                TAttachment obj =  vTAttachments.get(i);
                copyObj.addTAttachment(obj.copy());
            }
        }
        else
        {
            copyObj.collTAttachments = null;
        }


        List<TCost> vTCosts = getTCosts();
        if (vTCosts != null)
        {
            for (int i = 0; i < vTCosts.size(); i++)
            {
                TCost obj =  vTCosts.get(i);
                copyObj.addTCost(obj.copy());
            }
        }
        else
        {
            copyObj.collTCosts = null;
        }


        List<TWorkFlow> vTWorkFlows = getTWorkFlows();
        if (vTWorkFlows != null)
        {
            for (int i = 0; i < vTWorkFlows.size(); i++)
            {
                TWorkFlow obj =  vTWorkFlows.get(i);
                copyObj.addTWorkFlow(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkFlows = null;
        }


        List<TIssueAttributeValue> vTIssueAttributeValues = getTIssueAttributeValues();
        if (vTIssueAttributeValues != null)
        {
            for (int i = 0; i < vTIssueAttributeValues.size(); i++)
            {
                TIssueAttributeValue obj =  vTIssueAttributeValues.get(i);
                copyObj.addTIssueAttributeValue(obj.copy());
            }
        }
        else
        {
            copyObj.collTIssueAttributeValues = null;
        }


        List<TReportLayout> vTReportLayouts = getTReportLayouts();
        if (vTReportLayouts != null)
        {
            for (int i = 0; i < vTReportLayouts.size(); i++)
            {
                TReportLayout obj =  vTReportLayouts.get(i);
                copyObj.addTReportLayout(obj.copy());
            }
        }
        else
        {
            copyObj.collTReportLayouts = null;
        }


        List<TScheduler> vTSchedulers = getTSchedulers();
        if (vTSchedulers != null)
        {
            for (int i = 0; i < vTSchedulers.size(); i++)
            {
                TScheduler obj =  vTSchedulers.get(i);
                copyObj.addTScheduler(obj.copy());
            }
        }
        else
        {
            copyObj.collTSchedulers = null;
        }


        List<TGroupMember> vTGroupMembersRelatedByTheGroup = getTGroupMembersRelatedByTheGroup();
        if (vTGroupMembersRelatedByTheGroup != null)
        {
            for (int i = 0; i < vTGroupMembersRelatedByTheGroup.size(); i++)
            {
                TGroupMember obj =  vTGroupMembersRelatedByTheGroup.get(i);
                copyObj.addTGroupMemberRelatedByTheGroup(obj.copy());
            }
        }
        else
        {
            copyObj.collTGroupMembersRelatedByTheGroup = null;
        }


        List<TGroupMember> vTGroupMembersRelatedByPerson = getTGroupMembersRelatedByPerson();
        if (vTGroupMembersRelatedByPerson != null)
        {
            for (int i = 0; i < vTGroupMembersRelatedByPerson.size(); i++)
            {
                TGroupMember obj =  vTGroupMembersRelatedByPerson.get(i);
                copyObj.addTGroupMemberRelatedByPerson(obj.copy());
            }
        }
        else
        {
            copyObj.collTGroupMembersRelatedByPerson = null;
        }


        List<TBudget> vTBudgets = getTBudgets();
        if (vTBudgets != null)
        {
            for (int i = 0; i < vTBudgets.size(); i++)
            {
                TBudget obj =  vTBudgets.get(i);
                copyObj.addTBudget(obj.copy());
            }
        }
        else
        {
            copyObj.collTBudgets = null;
        }


        List<TActualEstimatedBudget> vTActualEstimatedBudgets = getTActualEstimatedBudgets();
        if (vTActualEstimatedBudgets != null)
        {
            for (int i = 0; i < vTActualEstimatedBudgets.size(); i++)
            {
                TActualEstimatedBudget obj =  vTActualEstimatedBudgets.get(i);
                copyObj.addTActualEstimatedBudget(obj.copy());
            }
        }
        else
        {
            copyObj.collTActualEstimatedBudgets = null;
        }


        List<TDashboardScreen> vTDashboardScreensRelatedByPerson = getTDashboardScreensRelatedByPerson();
        if (vTDashboardScreensRelatedByPerson != null)
        {
            for (int i = 0; i < vTDashboardScreensRelatedByPerson.size(); i++)
            {
                TDashboardScreen obj =  vTDashboardScreensRelatedByPerson.get(i);
                copyObj.addTDashboardScreenRelatedByPerson(obj.copy());
            }
        }
        else
        {
            copyObj.collTDashboardScreensRelatedByPerson = null;
        }


        List<TDashboardScreen> vTDashboardScreensRelatedByOwner = getTDashboardScreensRelatedByOwner();
        if (vTDashboardScreensRelatedByOwner != null)
        {
            for (int i = 0; i < vTDashboardScreensRelatedByOwner.size(); i++)
            {
                TDashboardScreen obj =  vTDashboardScreensRelatedByOwner.get(i);
                copyObj.addTDashboardScreenRelatedByOwner(obj.copy());
            }
        }
        else
        {
            copyObj.collTDashboardScreensRelatedByOwner = null;
        }


        List<TField> vTFields = getTFields();
        if (vTFields != null)
        {
            for (int i = 0; i < vTFields.size(); i++)
            {
                TField obj =  vTFields.get(i);
                copyObj.addTField(obj.copy());
            }
        }
        else
        {
            copyObj.collTFields = null;
        }


        List<TList> vTLists = getTLists();
        if (vTLists != null)
        {
            for (int i = 0; i < vTLists.size(); i++)
            {
                TList obj =  vTLists.get(i);
                copyObj.addTList(obj.copy());
            }
        }
        else
        {
            copyObj.collTLists = null;
        }


        List<TScreen> vTScreens = getTScreens();
        if (vTScreens != null)
        {
            for (int i = 0; i < vTScreens.size(); i++)
            {
                TScreen obj =  vTScreens.get(i);
                copyObj.addTScreen(obj.copy());
            }
        }
        else
        {
            copyObj.collTScreens = null;
        }


        List<TNotifyTrigger> vTNotifyTriggers = getTNotifyTriggers();
        if (vTNotifyTriggers != null)
        {
            for (int i = 0; i < vTNotifyTriggers.size(); i++)
            {
                TNotifyTrigger obj =  vTNotifyTriggers.get(i);
                copyObj.addTNotifyTrigger(obj.copy());
            }
        }
        else
        {
            copyObj.collTNotifyTriggers = null;
        }


        List<TNotifySettings> vTNotifySettingss = getTNotifySettingss();
        if (vTNotifySettingss != null)
        {
            for (int i = 0; i < vTNotifySettingss.size(); i++)
            {
                TNotifySettings obj =  vTNotifySettingss.get(i);
                copyObj.addTNotifySettings(obj.copy());
            }
        }
        else
        {
            copyObj.collTNotifySettingss = null;
        }


        List<TQueryRepository> vTQueryRepositorys = getTQueryRepositorys();
        if (vTQueryRepositorys != null)
        {
            for (int i = 0; i < vTQueryRepositorys.size(); i++)
            {
                TQueryRepository obj =  vTQueryRepositorys.get(i);
                copyObj.addTQueryRepository(obj.copy());
            }
        }
        else
        {
            copyObj.collTQueryRepositorys = null;
        }


        List<TWorkItemLink> vTWorkItemLinks = getTWorkItemLinks();
        if (vTWorkItemLinks != null)
        {
            for (int i = 0; i < vTWorkItemLinks.size(); i++)
            {
                TWorkItemLink obj =  vTWorkItemLinks.get(i);
                copyObj.addTWorkItemLink(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemLinks = null;
        }


        List<TWorkItemLock> vTWorkItemLocks = getTWorkItemLocks();
        if (vTWorkItemLocks != null)
        {
            for (int i = 0; i < vTWorkItemLocks.size(); i++)
            {
                TWorkItemLock obj =  vTWorkItemLocks.get(i);
                copyObj.addTWorkItemLock(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkItemLocks = null;
        }


        List<TExportTemplate> vTExportTemplates = getTExportTemplates();
        if (vTExportTemplates != null)
        {
            for (int i = 0; i < vTExportTemplates.size(); i++)
            {
                TExportTemplate obj =  vTExportTemplates.get(i);
                copyObj.addTExportTemplate(obj.copy());
            }
        }
        else
        {
            copyObj.collTExportTemplates = null;
        }


        List<TLoggedInUsers> vTLoggedInUserss = getTLoggedInUserss();
        if (vTLoggedInUserss != null)
        {
            for (int i = 0; i < vTLoggedInUserss.size(); i++)
            {
                TLoggedInUsers obj =  vTLoggedInUserss.get(i);
                copyObj.addTLoggedInUsers(obj.copy());
            }
        }
        else
        {
            copyObj.collTLoggedInUserss = null;
        }


        List<TSummaryMail> vTSummaryMailsRelatedByPERSONFROM = getTSummaryMailsRelatedByPERSONFROM();
        if (vTSummaryMailsRelatedByPERSONFROM != null)
        {
            for (int i = 0; i < vTSummaryMailsRelatedByPERSONFROM.size(); i++)
            {
                TSummaryMail obj =  vTSummaryMailsRelatedByPERSONFROM.get(i);
                copyObj.addTSummaryMailRelatedByPERSONFROM(obj.copy());
            }
        }
        else
        {
            copyObj.collTSummaryMailsRelatedByPERSONFROM = null;
        }


        List<TSummaryMail> vTSummaryMailsRelatedByPERSONTO = getTSummaryMailsRelatedByPERSONTO();
        if (vTSummaryMailsRelatedByPERSONTO != null)
        {
            for (int i = 0; i < vTSummaryMailsRelatedByPERSONTO.size(); i++)
            {
                TSummaryMail obj =  vTSummaryMailsRelatedByPERSONTO.get(i);
                copyObj.addTSummaryMailRelatedByPERSONTO(obj.copy());
            }
        }
        else
        {
            copyObj.collTSummaryMailsRelatedByPERSONTO = null;
        }


        List<THistoryTransaction> vTHistoryTransactions = getTHistoryTransactions();
        if (vTHistoryTransactions != null)
        {
            for (int i = 0; i < vTHistoryTransactions.size(); i++)
            {
                THistoryTransaction obj =  vTHistoryTransactions.get(i);
                copyObj.addTHistoryTransaction(obj.copy());
            }
        }
        else
        {
            copyObj.collTHistoryTransactions = null;
        }


        List<TScripts> vTScriptss = getTScriptss();
        if (vTScriptss != null)
        {
            for (int i = 0; i < vTScriptss.size(); i++)
            {
                TScripts obj =  vTScriptss.get(i);
                copyObj.addTScripts(obj.copy());
            }
        }
        else
        {
            copyObj.collTScriptss = null;
        }


        List<TTemplatePerson> vTTemplatePersons = getTTemplatePersons();
        if (vTTemplatePersons != null)
        {
            for (int i = 0; i < vTTemplatePersons.size(); i++)
            {
                TTemplatePerson obj =  vTTemplatePersons.get(i);
                copyObj.addTTemplatePerson(obj.copy());
            }
        }
        else
        {
            copyObj.collTTemplatePersons = null;
        }


        List<TReportPersonSettings> vTReportPersonSettingss = getTReportPersonSettingss();
        if (vTReportPersonSettingss != null)
        {
            for (int i = 0; i < vTReportPersonSettingss.size(); i++)
            {
                TReportPersonSettings obj =  vTReportPersonSettingss.get(i);
                copyObj.addTReportPersonSettings(obj.copy());
            }
        }
        else
        {
            copyObj.collTReportPersonSettingss = null;
        }


        List<TMSProjectExchange> vTMSProjectExchanges = getTMSProjectExchanges();
        if (vTMSProjectExchanges != null)
        {
            for (int i = 0; i < vTMSProjectExchanges.size(); i++)
            {
                TMSProjectExchange obj =  vTMSProjectExchanges.get(i);
                copyObj.addTMSProjectExchange(obj.copy());
            }
        }
        else
        {
            copyObj.collTMSProjectExchanges = null;
        }


        List<TFilterCategory> vTFilterCategorys = getTFilterCategorys();
        if (vTFilterCategorys != null)
        {
            for (int i = 0; i < vTFilterCategorys.size(); i++)
            {
                TFilterCategory obj =  vTFilterCategorys.get(i);
                copyObj.addTFilterCategory(obj.copy());
            }
        }
        else
        {
            copyObj.collTFilterCategorys = null;
        }


        List<TReportCategory> vTReportCategorys = getTReportCategorys();
        if (vTReportCategorys != null)
        {
            for (int i = 0; i < vTReportCategorys.size(); i++)
            {
                TReportCategory obj =  vTReportCategorys.get(i);
                copyObj.addTReportCategory(obj.copy());
            }
        }
        else
        {
            copyObj.collTReportCategorys = null;
        }


        List<TMenuitemQuery> vTMenuitemQuerys = getTMenuitemQuerys();
        if (vTMenuitemQuerys != null)
        {
            for (int i = 0; i < vTMenuitemQuerys.size(); i++)
            {
                TMenuitemQuery obj =  vTMenuitemQuerys.get(i);
                copyObj.addTMenuitemQuery(obj.copy());
            }
        }
        else
        {
            copyObj.collTMenuitemQuerys = null;
        }


        List<TPersonBasket> vTPersonBaskets = getTPersonBaskets();
        if (vTPersonBaskets != null)
        {
            for (int i = 0; i < vTPersonBaskets.size(); i++)
            {
                TPersonBasket obj =  vTPersonBaskets.get(i);
                copyObj.addTPersonBasket(obj.copy());
            }
        }
        else
        {
            copyObj.collTPersonBaskets = null;
        }


        List<TBasket> vTBaskets = getTBaskets();
        if (vTBaskets != null)
        {
            for (int i = 0; i < vTBaskets.size(); i++)
            {
                TBasket obj =  vTBaskets.get(i);
                copyObj.addTBasket(obj.copy());
            }
        }
        else
        {
            copyObj.collTBaskets = null;
        }


        List<TLastVisitedItem> vTLastVisitedItems = getTLastVisitedItems();
        if (vTLastVisitedItems != null)
        {
            for (int i = 0; i < vTLastVisitedItems.size(); i++)
            {
                TLastVisitedItem obj =  vTLastVisitedItems.get(i);
                copyObj.addTLastVisitedItem(obj.copy());
            }
        }
        else
        {
            copyObj.collTLastVisitedItems = null;
        }


        List<TWorkflowDef> vTWorkflowDefs = getTWorkflowDefs();
        if (vTWorkflowDefs != null)
        {
            for (int i = 0; i < vTWorkflowDefs.size(); i++)
            {
                TWorkflowDef obj =  vTWorkflowDefs.get(i);
                copyObj.addTWorkflowDef(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkflowDefs = null;
        }


        List<TWorkflowActivity> vTWorkflowActivitysRelatedByNewMan = getTWorkflowActivitysRelatedByNewMan();
        if (vTWorkflowActivitysRelatedByNewMan != null)
        {
            for (int i = 0; i < vTWorkflowActivitysRelatedByNewMan.size(); i++)
            {
                TWorkflowActivity obj =  vTWorkflowActivitysRelatedByNewMan.get(i);
                copyObj.addTWorkflowActivityRelatedByNewMan(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkflowActivitysRelatedByNewMan = null;
        }


        List<TWorkflowActivity> vTWorkflowActivitysRelatedByNewResp = getTWorkflowActivitysRelatedByNewResp();
        if (vTWorkflowActivitysRelatedByNewResp != null)
        {
            for (int i = 0; i < vTWorkflowActivitysRelatedByNewResp.size(); i++)
            {
                TWorkflowActivity obj =  vTWorkflowActivitysRelatedByNewResp.get(i);
                copyObj.addTWorkflowActivityRelatedByNewResp(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkflowActivitysRelatedByNewResp = null;
        }


        List<TWorkflowGuard> vTWorkflowGuards = getTWorkflowGuards();
        if (vTWorkflowGuards != null)
        {
            for (int i = 0; i < vTWorkflowGuards.size(); i++)
            {
                TWorkflowGuard obj =  vTWorkflowGuards.get(i);
                copyObj.addTWorkflowGuard(obj.copy());
            }
        }
        else
        {
            copyObj.collTWorkflowGuards = null;
        }


        List<TEscalationEntry> vTEscalationEntrys = getTEscalationEntrys();
        if (vTEscalationEntrys != null)
        {
            for (int i = 0; i < vTEscalationEntrys.size(); i++)
            {
                TEscalationEntry obj =  vTEscalationEntrys.get(i);
                copyObj.addTEscalationEntry(obj.copy());
            }
        }
        else
        {
            copyObj.collTEscalationEntrys = null;
        }


        List<TReadIssue> vTReadIssues = getTReadIssues();
        if (vTReadIssues != null)
        {
            for (int i = 0; i < vTReadIssues.size(); i++)
            {
                TReadIssue obj =  vTReadIssues.get(i);
                copyObj.addTReadIssue(obj.copy());
            }
        }
        else
        {
            copyObj.collTReadIssues = null;
        }


        List<TLastExecutedQuery> vTLastExecutedQuerys = getTLastExecutedQuerys();
        if (vTLastExecutedQuerys != null)
        {
            for (int i = 0; i < vTLastExecutedQuerys.size(); i++)
            {
                TLastExecutedQuery obj =  vTLastExecutedQuerys.get(i);
                copyObj.addTLastExecutedQuery(obj.copy());
            }
        }
        else
        {
            copyObj.collTLastExecutedQuerys = null;
        }


        List<TReportSubscribe> vTReportSubscribes = getTReportSubscribes();
        if (vTReportSubscribes != null)
        {
            for (int i = 0; i < vTReportSubscribes.size(); i++)
            {
                TReportSubscribe obj =  vTReportSubscribes.get(i);
                copyObj.addTReportSubscribe(obj.copy());
            }
        }
        else
        {
            copyObj.collTReportSubscribes = null;
        }


        List<TGridLayout> vTGridLayouts = getTGridLayouts();
        if (vTGridLayouts != null)
        {
            for (int i = 0; i < vTGridLayouts.size(); i++)
            {
                TGridLayout obj =  vTGridLayouts.get(i);
                copyObj.addTGridLayout(obj.copy());
            }
        }
        else
        {
            copyObj.collTGridLayouts = null;
        }


        List<TNavigatorLayout> vTNavigatorLayouts = getTNavigatorLayouts();
        if (vTNavigatorLayouts != null)
        {
            for (int i = 0; i < vTNavigatorLayouts.size(); i++)
            {
                TNavigatorLayout obj =  vTNavigatorLayouts.get(i);
                copyObj.addTNavigatorLayout(obj.copy());
            }
        }
        else
        {
            copyObj.collTNavigatorLayouts = null;
        }


        List<TMailTextBlock> vTMailTextBlocks = getTMailTextBlocks();
        if (vTMailTextBlocks != null)
        {
            for (int i = 0; i < vTMailTextBlocks.size(); i++)
            {
                TMailTextBlock obj =  vTMailTextBlocks.get(i);
                copyObj.addTMailTextBlock(obj.copy());
            }
        }
        else
        {
            copyObj.collTMailTextBlocks = null;
        }


        List<TPersonInDomain> vTPersonInDomains = getTPersonInDomains();
        if (vTPersonInDomains != null)
        {
            for (int i = 0; i < vTPersonInDomains.size(); i++)
            {
                TPersonInDomain obj =  vTPersonInDomains.get(i);
                copyObj.addTPersonInDomain(obj.copy());
            }
        }
        else
        {
            copyObj.collTPersonInDomains = null;
        }


        List<TAttachmentVersion> vTAttachmentVersions = getTAttachmentVersions();
        if (vTAttachmentVersions != null)
        {
            for (int i = 0; i < vTAttachmentVersions.size(); i++)
            {
                TAttachmentVersion obj =  vTAttachmentVersions.get(i);
                copyObj.addTAttachmentVersion(obj.copy());
            }
        }
        else
        {
            copyObj.collTAttachmentVersions = null;
        }


        List<TUserFeature> vTUserFeatures = getTUserFeatures();
        if (vTUserFeatures != null)
        {
            for (int i = 0; i < vTUserFeatures.size(); i++)
            {
                TUserFeature obj =  vTUserFeatures.get(i);
                copyObj.addTUserFeature(obj.copy());
            }
        }
        else
        {
            copyObj.collTUserFeatures = null;
        }
        }
        return copyObj;
    }
        
    
    /**
     * Fills the copyObj with the contents of this object using connection.
     * If deepcopy is true, The associated objects are also copied
     * and treated as new objects.
     *
     * @param copyObj the object to fill.
     * @param deepcopy whether the associated objects should be copied.
     * @param con the database connection to read associated objects.
     */
    protected TPerson copyInto(TPerson copyObj, boolean deepcopy, Connection con) throws TorqueException
    {
        copyObj.setObjectID(objectID);
        copyObj.setFirstName(firstName);
        copyObj.setLastName(lastName);
        copyObj.setLoginName(loginName);
        copyObj.setEmail(email);
        copyObj.setPasswd(passwd);
        copyObj.setSalt(salt);
        copyObj.setForgotPasswordKey(forgotPasswordKey);
        copyObj.setPhone(phone);
        copyObj.setDepartmentID(departmentID);
        copyObj.setValidUntil(validUntil);
        copyObj.setPreferences(preferences);
        copyObj.setLastEdit(lastEdit);
        copyObj.setCreated(created);
        copyObj.setDeleted(deleted);
        copyObj.setTokenPasswd(tokenPasswd);
        copyObj.setTokenExpDate(tokenExpDate);
        copyObj.setEmailFrequency(emailFrequency);
        copyObj.setEmailLead(emailLead);
        copyObj.setEmailLastReminded(emailLastReminded);
        copyObj.setEmailRemindMe(emailRemindMe);
        copyObj.setPrefEmailType(prefEmailType);
        copyObj.setPrefLocale(prefLocale);
        copyObj.setMyDefaultReport(myDefaultReport);
        copyObj.setNoEmailPlease(noEmailPlease);
        copyObj.setRemindMeAsOriginator(remindMeAsOriginator);
        copyObj.setRemindMeAsManager(remindMeAsManager);
        copyObj.setRemindMeAsResponsible(remindMeAsResponsible);
        copyObj.setEmailRemindPriorityLevel(emailRemindPriorityLevel);
        copyObj.setEmailRemindSeverityLevel(emailRemindSeverityLevel);
        copyObj.setHoursPerWorkDay(hoursPerWorkDay);
        copyObj.setHourlyWage(hourlyWage);
        copyObj.setExtraHourWage(extraHourWage);
        copyObj.setEmployeeID(employeeID);
        copyObj.setIsgroup(isgroup);
        copyObj.setUserLevel(userLevel);
        copyObj.setMaxAssignedItems(maxAssignedItems);
        copyObj.setMessengerURL(messengerURL);
        copyObj.setCALLURL(cALLURL);
        copyObj.setSymbol(symbol);
        copyObj.setIconKey(iconKey);
        copyObj.setSubstituteID(substituteID);
        copyObj.setSubstituteActive(substituteActive);
        copyObj.setUuid(uuid);

        copyObj.setObjectID((Integer)null);

        if (deepcopy)
        {


        List<TAccessControlList> vTAccessControlLists = getTAccessControlLists(con);
        if (vTAccessControlLists != null)
        {
            for (int i = 0; i < vTAccessControlLists.size(); i++)
            {
                TAccessControlList obj =  vTAccessControlLists.get(i);
                copyObj.addTAccessControlList(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTAccessControlLists = null;
        }


        List<TBaseLine> vTBaseLines = getTBaseLines(con);
        if (vTBaseLines != null)
        {
            for (int i = 0; i < vTBaseLines.size(); i++)
            {
                TBaseLine obj =  vTBaseLines.get(i);
                copyObj.addTBaseLine(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTBaseLines = null;
        }


        List<TNotify> vTNotifys = getTNotifys(con);
        if (vTNotifys != null)
        {
            for (int i = 0; i < vTNotifys.size(); i++)
            {
                TNotify obj =  vTNotifys.get(i);
                copyObj.addTNotify(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTNotifys = null;
        }


        List<TProject> vTProjectsRelatedByDefaultOwnerID = getTProjectsRelatedByDefaultOwnerID(con);
        if (vTProjectsRelatedByDefaultOwnerID != null)
        {
            for (int i = 0; i < vTProjectsRelatedByDefaultOwnerID.size(); i++)
            {
                TProject obj =  vTProjectsRelatedByDefaultOwnerID.get(i);
                copyObj.addTProjectRelatedByDefaultOwnerID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTProjectsRelatedByDefaultOwnerID = null;
        }


        List<TProject> vTProjectsRelatedByDefaultManagerID = getTProjectsRelatedByDefaultManagerID(con);
        if (vTProjectsRelatedByDefaultManagerID != null)
        {
            for (int i = 0; i < vTProjectsRelatedByDefaultManagerID.size(); i++)
            {
                TProject obj =  vTProjectsRelatedByDefaultManagerID.get(i);
                copyObj.addTProjectRelatedByDefaultManagerID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTProjectsRelatedByDefaultManagerID = null;
        }


        List<TStateChange> vTStateChanges = getTStateChanges(con);
        if (vTStateChanges != null)
        {
            for (int i = 0; i < vTStateChanges.size(); i++)
            {
                TStateChange obj =  vTStateChanges.get(i);
                copyObj.addTStateChange(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTStateChanges = null;
        }


        List<TTrail> vTTrails = getTTrails(con);
        if (vTTrails != null)
        {
            for (int i = 0; i < vTTrails.size(); i++)
            {
                TTrail obj =  vTTrails.get(i);
                copyObj.addTTrail(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTTrails = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByOwnerID = getTWorkItemsRelatedByOwnerID(con);
        if (vTWorkItemsRelatedByOwnerID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByOwnerID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByOwnerID.get(i);
                copyObj.addTWorkItemRelatedByOwnerID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByOwnerID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByChangedByID = getTWorkItemsRelatedByChangedByID(con);
        if (vTWorkItemsRelatedByChangedByID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByChangedByID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByChangedByID.get(i);
                copyObj.addTWorkItemRelatedByChangedByID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByChangedByID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByOriginatorID = getTWorkItemsRelatedByOriginatorID(con);
        if (vTWorkItemsRelatedByOriginatorID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByOriginatorID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByOriginatorID.get(i);
                copyObj.addTWorkItemRelatedByOriginatorID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByOriginatorID = null;
        }


        List<TWorkItem> vTWorkItemsRelatedByResponsibleID = getTWorkItemsRelatedByResponsibleID(con);
        if (vTWorkItemsRelatedByResponsibleID != null)
        {
            for (int i = 0; i < vTWorkItemsRelatedByResponsibleID.size(); i++)
            {
                TWorkItem obj =  vTWorkItemsRelatedByResponsibleID.get(i);
                copyObj.addTWorkItemRelatedByResponsibleID(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemsRelatedByResponsibleID = null;
        }


        List<TComputedValues> vTComputedValuess = getTComputedValuess(con);
        if (vTComputedValuess != null)
        {
            for (int i = 0; i < vTComputedValuess.size(); i++)
            {
                TComputedValues obj =  vTComputedValuess.get(i);
                copyObj.addTComputedValues(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTComputedValuess = null;
        }


        List<TPrivateReportRepository> vTPrivateReportRepositorys = getTPrivateReportRepositorys(con);
        if (vTPrivateReportRepositorys != null)
        {
            for (int i = 0; i < vTPrivateReportRepositorys.size(); i++)
            {
                TPrivateReportRepository obj =  vTPrivateReportRepositorys.get(i);
                copyObj.addTPrivateReportRepository(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTPrivateReportRepositorys = null;
        }


        List<TPublicReportRepository> vTPublicReportRepositorys = getTPublicReportRepositorys(con);
        if (vTPublicReportRepositorys != null)
        {
            for (int i = 0; i < vTPublicReportRepositorys.size(); i++)
            {
                TPublicReportRepository obj =  vTPublicReportRepositorys.get(i);
                copyObj.addTPublicReportRepository(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTPublicReportRepositorys = null;
        }


        List<TAttachment> vTAttachments = getTAttachments(con);
        if (vTAttachments != null)
        {
            for (int i = 0; i < vTAttachments.size(); i++)
            {
                TAttachment obj =  vTAttachments.get(i);
                copyObj.addTAttachment(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTAttachments = null;
        }


        List<TCost> vTCosts = getTCosts(con);
        if (vTCosts != null)
        {
            for (int i = 0; i < vTCosts.size(); i++)
            {
                TCost obj =  vTCosts.get(i);
                copyObj.addTCost(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTCosts = null;
        }


        List<TWorkFlow> vTWorkFlows = getTWorkFlows(con);
        if (vTWorkFlows != null)
        {
            for (int i = 0; i < vTWorkFlows.size(); i++)
            {
                TWorkFlow obj =  vTWorkFlows.get(i);
                copyObj.addTWorkFlow(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkFlows = null;
        }


        List<TIssueAttributeValue> vTIssueAttributeValues = getTIssueAttributeValues(con);
        if (vTIssueAttributeValues != null)
        {
            for (int i = 0; i < vTIssueAttributeValues.size(); i++)
            {
                TIssueAttributeValue obj =  vTIssueAttributeValues.get(i);
                copyObj.addTIssueAttributeValue(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTIssueAttributeValues = null;
        }


        List<TReportLayout> vTReportLayouts = getTReportLayouts(con);
        if (vTReportLayouts != null)
        {
            for (int i = 0; i < vTReportLayouts.size(); i++)
            {
                TReportLayout obj =  vTReportLayouts.get(i);
                copyObj.addTReportLayout(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTReportLayouts = null;
        }


        List<TScheduler> vTSchedulers = getTSchedulers(con);
        if (vTSchedulers != null)
        {
            for (int i = 0; i < vTSchedulers.size(); i++)
            {
                TScheduler obj =  vTSchedulers.get(i);
                copyObj.addTScheduler(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTSchedulers = null;
        }


        List<TGroupMember> vTGroupMembersRelatedByTheGroup = getTGroupMembersRelatedByTheGroup(con);
        if (vTGroupMembersRelatedByTheGroup != null)
        {
            for (int i = 0; i < vTGroupMembersRelatedByTheGroup.size(); i++)
            {
                TGroupMember obj =  vTGroupMembersRelatedByTheGroup.get(i);
                copyObj.addTGroupMemberRelatedByTheGroup(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTGroupMembersRelatedByTheGroup = null;
        }


        List<TGroupMember> vTGroupMembersRelatedByPerson = getTGroupMembersRelatedByPerson(con);
        if (vTGroupMembersRelatedByPerson != null)
        {
            for (int i = 0; i < vTGroupMembersRelatedByPerson.size(); i++)
            {
                TGroupMember obj =  vTGroupMembersRelatedByPerson.get(i);
                copyObj.addTGroupMemberRelatedByPerson(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTGroupMembersRelatedByPerson = null;
        }


        List<TBudget> vTBudgets = getTBudgets(con);
        if (vTBudgets != null)
        {
            for (int i = 0; i < vTBudgets.size(); i++)
            {
                TBudget obj =  vTBudgets.get(i);
                copyObj.addTBudget(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTBudgets = null;
        }


        List<TActualEstimatedBudget> vTActualEstimatedBudgets = getTActualEstimatedBudgets(con);
        if (vTActualEstimatedBudgets != null)
        {
            for (int i = 0; i < vTActualEstimatedBudgets.size(); i++)
            {
                TActualEstimatedBudget obj =  vTActualEstimatedBudgets.get(i);
                copyObj.addTActualEstimatedBudget(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTActualEstimatedBudgets = null;
        }


        List<TDashboardScreen> vTDashboardScreensRelatedByPerson = getTDashboardScreensRelatedByPerson(con);
        if (vTDashboardScreensRelatedByPerson != null)
        {
            for (int i = 0; i < vTDashboardScreensRelatedByPerson.size(); i++)
            {
                TDashboardScreen obj =  vTDashboardScreensRelatedByPerson.get(i);
                copyObj.addTDashboardScreenRelatedByPerson(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTDashboardScreensRelatedByPerson = null;
        }


        List<TDashboardScreen> vTDashboardScreensRelatedByOwner = getTDashboardScreensRelatedByOwner(con);
        if (vTDashboardScreensRelatedByOwner != null)
        {
            for (int i = 0; i < vTDashboardScreensRelatedByOwner.size(); i++)
            {
                TDashboardScreen obj =  vTDashboardScreensRelatedByOwner.get(i);
                copyObj.addTDashboardScreenRelatedByOwner(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTDashboardScreensRelatedByOwner = null;
        }


        List<TField> vTFields = getTFields(con);
        if (vTFields != null)
        {
            for (int i = 0; i < vTFields.size(); i++)
            {
                TField obj =  vTFields.get(i);
                copyObj.addTField(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTFields = null;
        }


        List<TList> vTLists = getTLists(con);
        if (vTLists != null)
        {
            for (int i = 0; i < vTLists.size(); i++)
            {
                TList obj =  vTLists.get(i);
                copyObj.addTList(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTLists = null;
        }


        List<TScreen> vTScreens = getTScreens(con);
        if (vTScreens != null)
        {
            for (int i = 0; i < vTScreens.size(); i++)
            {
                TScreen obj =  vTScreens.get(i);
                copyObj.addTScreen(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTScreens = null;
        }


        List<TNotifyTrigger> vTNotifyTriggers = getTNotifyTriggers(con);
        if (vTNotifyTriggers != null)
        {
            for (int i = 0; i < vTNotifyTriggers.size(); i++)
            {
                TNotifyTrigger obj =  vTNotifyTriggers.get(i);
                copyObj.addTNotifyTrigger(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTNotifyTriggers = null;
        }


        List<TNotifySettings> vTNotifySettingss = getTNotifySettingss(con);
        if (vTNotifySettingss != null)
        {
            for (int i = 0; i < vTNotifySettingss.size(); i++)
            {
                TNotifySettings obj =  vTNotifySettingss.get(i);
                copyObj.addTNotifySettings(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTNotifySettingss = null;
        }


        List<TQueryRepository> vTQueryRepositorys = getTQueryRepositorys(con);
        if (vTQueryRepositorys != null)
        {
            for (int i = 0; i < vTQueryRepositorys.size(); i++)
            {
                TQueryRepository obj =  vTQueryRepositorys.get(i);
                copyObj.addTQueryRepository(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTQueryRepositorys = null;
        }


        List<TWorkItemLink> vTWorkItemLinks = getTWorkItemLinks(con);
        if (vTWorkItemLinks != null)
        {
            for (int i = 0; i < vTWorkItemLinks.size(); i++)
            {
                TWorkItemLink obj =  vTWorkItemLinks.get(i);
                copyObj.addTWorkItemLink(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemLinks = null;
        }


        List<TWorkItemLock> vTWorkItemLocks = getTWorkItemLocks(con);
        if (vTWorkItemLocks != null)
        {
            for (int i = 0; i < vTWorkItemLocks.size(); i++)
            {
                TWorkItemLock obj =  vTWorkItemLocks.get(i);
                copyObj.addTWorkItemLock(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkItemLocks = null;
        }


        List<TExportTemplate> vTExportTemplates = getTExportTemplates(con);
        if (vTExportTemplates != null)
        {
            for (int i = 0; i < vTExportTemplates.size(); i++)
            {
                TExportTemplate obj =  vTExportTemplates.get(i);
                copyObj.addTExportTemplate(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTExportTemplates = null;
        }


        List<TLoggedInUsers> vTLoggedInUserss = getTLoggedInUserss(con);
        if (vTLoggedInUserss != null)
        {
            for (int i = 0; i < vTLoggedInUserss.size(); i++)
            {
                TLoggedInUsers obj =  vTLoggedInUserss.get(i);
                copyObj.addTLoggedInUsers(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTLoggedInUserss = null;
        }


        List<TSummaryMail> vTSummaryMailsRelatedByPERSONFROM = getTSummaryMailsRelatedByPERSONFROM(con);
        if (vTSummaryMailsRelatedByPERSONFROM != null)
        {
            for (int i = 0; i < vTSummaryMailsRelatedByPERSONFROM.size(); i++)
            {
                TSummaryMail obj =  vTSummaryMailsRelatedByPERSONFROM.get(i);
                copyObj.addTSummaryMailRelatedByPERSONFROM(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTSummaryMailsRelatedByPERSONFROM = null;
        }


        List<TSummaryMail> vTSummaryMailsRelatedByPERSONTO = getTSummaryMailsRelatedByPERSONTO(con);
        if (vTSummaryMailsRelatedByPERSONTO != null)
        {
            for (int i = 0; i < vTSummaryMailsRelatedByPERSONTO.size(); i++)
            {
                TSummaryMail obj =  vTSummaryMailsRelatedByPERSONTO.get(i);
                copyObj.addTSummaryMailRelatedByPERSONTO(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTSummaryMailsRelatedByPERSONTO = null;
        }


        List<THistoryTransaction> vTHistoryTransactions = getTHistoryTransactions(con);
        if (vTHistoryTransactions != null)
        {
            for (int i = 0; i < vTHistoryTransactions.size(); i++)
            {
                THistoryTransaction obj =  vTHistoryTransactions.get(i);
                copyObj.addTHistoryTransaction(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTHistoryTransactions = null;
        }


        List<TScripts> vTScriptss = getTScriptss(con);
        if (vTScriptss != null)
        {
            for (int i = 0; i < vTScriptss.size(); i++)
            {
                TScripts obj =  vTScriptss.get(i);
                copyObj.addTScripts(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTScriptss = null;
        }


        List<TTemplatePerson> vTTemplatePersons = getTTemplatePersons(con);
        if (vTTemplatePersons != null)
        {
            for (int i = 0; i < vTTemplatePersons.size(); i++)
            {
                TTemplatePerson obj =  vTTemplatePersons.get(i);
                copyObj.addTTemplatePerson(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTTemplatePersons = null;
        }


        List<TReportPersonSettings> vTReportPersonSettingss = getTReportPersonSettingss(con);
        if (vTReportPersonSettingss != null)
        {
            for (int i = 0; i < vTReportPersonSettingss.size(); i++)
            {
                TReportPersonSettings obj =  vTReportPersonSettingss.get(i);
                copyObj.addTReportPersonSettings(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTReportPersonSettingss = null;
        }


        List<TMSProjectExchange> vTMSProjectExchanges = getTMSProjectExchanges(con);
        if (vTMSProjectExchanges != null)
        {
            for (int i = 0; i < vTMSProjectExchanges.size(); i++)
            {
                TMSProjectExchange obj =  vTMSProjectExchanges.get(i);
                copyObj.addTMSProjectExchange(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTMSProjectExchanges = null;
        }


        List<TFilterCategory> vTFilterCategorys = getTFilterCategorys(con);
        if (vTFilterCategorys != null)
        {
            for (int i = 0; i < vTFilterCategorys.size(); i++)
            {
                TFilterCategory obj =  vTFilterCategorys.get(i);
                copyObj.addTFilterCategory(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTFilterCategorys = null;
        }


        List<TReportCategory> vTReportCategorys = getTReportCategorys(con);
        if (vTReportCategorys != null)
        {
            for (int i = 0; i < vTReportCategorys.size(); i++)
            {
                TReportCategory obj =  vTReportCategorys.get(i);
                copyObj.addTReportCategory(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTReportCategorys = null;
        }


        List<TMenuitemQuery> vTMenuitemQuerys = getTMenuitemQuerys(con);
        if (vTMenuitemQuerys != null)
        {
            for (int i = 0; i < vTMenuitemQuerys.size(); i++)
            {
                TMenuitemQuery obj =  vTMenuitemQuerys.get(i);
                copyObj.addTMenuitemQuery(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTMenuitemQuerys = null;
        }


        List<TPersonBasket> vTPersonBaskets = getTPersonBaskets(con);
        if (vTPersonBaskets != null)
        {
            for (int i = 0; i < vTPersonBaskets.size(); i++)
            {
                TPersonBasket obj =  vTPersonBaskets.get(i);
                copyObj.addTPersonBasket(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTPersonBaskets = null;
        }


        List<TBasket> vTBaskets = getTBaskets(con);
        if (vTBaskets != null)
        {
            for (int i = 0; i < vTBaskets.size(); i++)
            {
                TBasket obj =  vTBaskets.get(i);
                copyObj.addTBasket(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTBaskets = null;
        }


        List<TLastVisitedItem> vTLastVisitedItems = getTLastVisitedItems(con);
        if (vTLastVisitedItems != null)
        {
            for (int i = 0; i < vTLastVisitedItems.size(); i++)
            {
                TLastVisitedItem obj =  vTLastVisitedItems.get(i);
                copyObj.addTLastVisitedItem(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTLastVisitedItems = null;
        }


        List<TWorkflowDef> vTWorkflowDefs = getTWorkflowDefs(con);
        if (vTWorkflowDefs != null)
        {
            for (int i = 0; i < vTWorkflowDefs.size(); i++)
            {
                TWorkflowDef obj =  vTWorkflowDefs.get(i);
                copyObj.addTWorkflowDef(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkflowDefs = null;
        }


        List<TWorkflowActivity> vTWorkflowActivitysRelatedByNewMan = getTWorkflowActivitysRelatedByNewMan(con);
        if (vTWorkflowActivitysRelatedByNewMan != null)
        {
            for (int i = 0; i < vTWorkflowActivitysRelatedByNewMan.size(); i++)
            {
                TWorkflowActivity obj =  vTWorkflowActivitysRelatedByNewMan.get(i);
                copyObj.addTWorkflowActivityRelatedByNewMan(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkflowActivitysRelatedByNewMan = null;
        }


        List<TWorkflowActivity> vTWorkflowActivitysRelatedByNewResp = getTWorkflowActivitysRelatedByNewResp(con);
        if (vTWorkflowActivitysRelatedByNewResp != null)
        {
            for (int i = 0; i < vTWorkflowActivitysRelatedByNewResp.size(); i++)
            {
                TWorkflowActivity obj =  vTWorkflowActivitysRelatedByNewResp.get(i);
                copyObj.addTWorkflowActivityRelatedByNewResp(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkflowActivitysRelatedByNewResp = null;
        }


        List<TWorkflowGuard> vTWorkflowGuards = getTWorkflowGuards(con);
        if (vTWorkflowGuards != null)
        {
            for (int i = 0; i < vTWorkflowGuards.size(); i++)
            {
                TWorkflowGuard obj =  vTWorkflowGuards.get(i);
                copyObj.addTWorkflowGuard(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTWorkflowGuards = null;
        }


        List<TEscalationEntry> vTEscalationEntrys = getTEscalationEntrys(con);
        if (vTEscalationEntrys != null)
        {
            for (int i = 0; i < vTEscalationEntrys.size(); i++)
            {
                TEscalationEntry obj =  vTEscalationEntrys.get(i);
                copyObj.addTEscalationEntry(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTEscalationEntrys = null;
        }


        List<TReadIssue> vTReadIssues = getTReadIssues(con);
        if (vTReadIssues != null)
        {
            for (int i = 0; i < vTReadIssues.size(); i++)
            {
                TReadIssue obj =  vTReadIssues.get(i);
                copyObj.addTReadIssue(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTReadIssues = null;
        }


        List<TLastExecutedQuery> vTLastExecutedQuerys = getTLastExecutedQuerys(con);
        if (vTLastExecutedQuerys != null)
        {
            for (int i = 0; i < vTLastExecutedQuerys.size(); i++)
            {
                TLastExecutedQuery obj =  vTLastExecutedQuerys.get(i);
                copyObj.addTLastExecutedQuery(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTLastExecutedQuerys = null;
        }


        List<TReportSubscribe> vTReportSubscribes = getTReportSubscribes(con);
        if (vTReportSubscribes != null)
        {
            for (int i = 0; i < vTReportSubscribes.size(); i++)
            {
                TReportSubscribe obj =  vTReportSubscribes.get(i);
                copyObj.addTReportSubscribe(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTReportSubscribes = null;
        }


        List<TGridLayout> vTGridLayouts = getTGridLayouts(con);
        if (vTGridLayouts != null)
        {
            for (int i = 0; i < vTGridLayouts.size(); i++)
            {
                TGridLayout obj =  vTGridLayouts.get(i);
                copyObj.addTGridLayout(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTGridLayouts = null;
        }


        List<TNavigatorLayout> vTNavigatorLayouts = getTNavigatorLayouts(con);
        if (vTNavigatorLayouts != null)
        {
            for (int i = 0; i < vTNavigatorLayouts.size(); i++)
            {
                TNavigatorLayout obj =  vTNavigatorLayouts.get(i);
                copyObj.addTNavigatorLayout(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTNavigatorLayouts = null;
        }


        List<TMailTextBlock> vTMailTextBlocks = getTMailTextBlocks(con);
        if (vTMailTextBlocks != null)
        {
            for (int i = 0; i < vTMailTextBlocks.size(); i++)
            {
                TMailTextBlock obj =  vTMailTextBlocks.get(i);
                copyObj.addTMailTextBlock(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTMailTextBlocks = null;
        }


        List<TPersonInDomain> vTPersonInDomains = getTPersonInDomains(con);
        if (vTPersonInDomains != null)
        {
            for (int i = 0; i < vTPersonInDomains.size(); i++)
            {
                TPersonInDomain obj =  vTPersonInDomains.get(i);
                copyObj.addTPersonInDomain(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTPersonInDomains = null;
        }


        List<TAttachmentVersion> vTAttachmentVersions = getTAttachmentVersions(con);
        if (vTAttachmentVersions != null)
        {
            for (int i = 0; i < vTAttachmentVersions.size(); i++)
            {
                TAttachmentVersion obj =  vTAttachmentVersions.get(i);
                copyObj.addTAttachmentVersion(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTAttachmentVersions = null;
        }


        List<TUserFeature> vTUserFeatures = getTUserFeatures(con);
        if (vTUserFeatures != null)
        {
            for (int i = 0; i < vTUserFeatures.size(); i++)
            {
                TUserFeature obj =  vTUserFeatures.get(i);
                copyObj.addTUserFeature(obj.copy(con), con);
            }
        }
        else
        {
            copyObj.collTUserFeatures = null;
        }
        }
        return copyObj;
    }
    
    

    /**
     * returns a peer instance associated with this om.  Since Peer classes
     * are not to have any instance attributes, this method returns the
     * same instance for all member of this class. The method could therefore
     * be static, but this would prevent one from overriding the behavior.
     */
    public TPersonPeer getPeer()
    {
        return peer;
    }

    /**
     * Retrieves the TableMap object related to this Table data without
     * compiler warnings of using getPeer().getTableMap().
     *
     * @return The associated TableMap object.
     */
    public TableMap getTableMap() throws TorqueException
    {
        return TPersonPeer.getTableMap();
    }

  
    /**
     * Creates a TPersonBean with the contents of this object
     * This also creates beans for cached related objects, if they exist
     * @return a TPersonBean with the contents of this object
     */
    public TPersonBean getBean()
    {
        return getBean(new IdentityMap());
    }

    /**
     * Creates a TPersonBean with the contents of this object
     * intended for internal use only
     * @param createdBeans a IdentityMap which maps objects
     *        to already created beans
     * @return a TPersonBean with the contents of this object
     */
    public TPersonBean getBean(IdentityMap createdBeans)
    {
        TPersonBean result = (TPersonBean) createdBeans.get(this);
        if (result != null ) {
            // we have already created a bean for this object, return it
            return result;
        }
        // no bean exists for this object; create a new one
        result = new TPersonBean();
        createdBeans.put(this, result);

        result.setObjectID(getObjectID());
        result.setFirstName(getFirstName());
        result.setLastName(getLastName());
        result.setLoginName(getLoginName());
        result.setEmail(getEmail());
        result.setPasswd(getPasswd());
        result.setSalt(getSalt());
        result.setForgotPasswordKey(getForgotPasswordKey());
        result.setPhone(getPhone());
        result.setDepartmentID(getDepartmentID());
        result.setValidUntil(getValidUntil());
        result.setPreferences(getPreferences());
        result.setLastEdit(getLastEdit());
        result.setCreated(getCreated());
        result.setDeleted(getDeleted());
        result.setTokenPasswd(getTokenPasswd());
        result.setTokenExpDate(getTokenExpDate());
        result.setEmailFrequency(getEmailFrequency());
        result.setEmailLead(getEmailLead());
        result.setEmailLastReminded(getEmailLastReminded());
        result.setEmailRemindMe(getEmailRemindMe());
        result.setPrefEmailType(getPrefEmailType());
        result.setPrefLocale(getPrefLocale());
        result.setMyDefaultReport(getMyDefaultReport());
        result.setNoEmailPlease(getNoEmailPlease());
        result.setRemindMeAsOriginator(getRemindMeAsOriginator());
        result.setRemindMeAsManager(getRemindMeAsManager());
        result.setRemindMeAsResponsible(getRemindMeAsResponsible());
        result.setEmailRemindPriorityLevel(getEmailRemindPriorityLevel());
        result.setEmailRemindSeverityLevel(getEmailRemindSeverityLevel());
        result.setHoursPerWorkDay(getHoursPerWorkDay());
        result.setHourlyWage(getHourlyWage());
        result.setExtraHourWage(getExtraHourWage());
        result.setEmployeeID(getEmployeeID());
        result.setIsgroup(getIsgroup());
        result.setUserLevel(getUserLevel());
        result.setMaxAssignedItems(getMaxAssignedItems());
        result.setMessengerURL(getMessengerURL());
        result.setCALLURL(getCALLURL());
        result.setSymbol(getSymbol());
        result.setIconKey(getIconKey());
        result.setSubstituteID(getSubstituteID());
        result.setSubstituteActive(getSubstituteActive());
        result.setUuid(getUuid());



        if (collTAccessControlLists != null)
        {
            List<TAccessControlListBean> relatedBeans = new ArrayList<TAccessControlListBean>(collTAccessControlLists.size());
            for (Iterator<TAccessControlList> collTAccessControlListsIt = collTAccessControlLists.iterator(); collTAccessControlListsIt.hasNext(); )
            {
                TAccessControlList related = (TAccessControlList) collTAccessControlListsIt.next();
                TAccessControlListBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTAccessControlListBeans(relatedBeans);
        }


        if (collTBaseLines != null)
        {
            List<TBaseLineBean> relatedBeans = new ArrayList<TBaseLineBean>(collTBaseLines.size());
            for (Iterator<TBaseLine> collTBaseLinesIt = collTBaseLines.iterator(); collTBaseLinesIt.hasNext(); )
            {
                TBaseLine related = (TBaseLine) collTBaseLinesIt.next();
                TBaseLineBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTBaseLineBeans(relatedBeans);
        }


        if (collTNotifys != null)
        {
            List<TNotifyBean> relatedBeans = new ArrayList<TNotifyBean>(collTNotifys.size());
            for (Iterator<TNotify> collTNotifysIt = collTNotifys.iterator(); collTNotifysIt.hasNext(); )
            {
                TNotify related = (TNotify) collTNotifysIt.next();
                TNotifyBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTNotifyBeans(relatedBeans);
        }


        if (collTProjectsRelatedByDefaultOwnerID != null)
        {
            List<TProjectBean> relatedBeans = new ArrayList<TProjectBean>(collTProjectsRelatedByDefaultOwnerID.size());
            for (Iterator<TProject> collTProjectsRelatedByDefaultOwnerIDIt = collTProjectsRelatedByDefaultOwnerID.iterator(); collTProjectsRelatedByDefaultOwnerIDIt.hasNext(); )
            {
                TProject related = (TProject) collTProjectsRelatedByDefaultOwnerIDIt.next();
                TProjectBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTProjectBeansRelatedByDefaultOwnerID(relatedBeans);
        }


        if (collTProjectsRelatedByDefaultManagerID != null)
        {
            List<TProjectBean> relatedBeans = new ArrayList<TProjectBean>(collTProjectsRelatedByDefaultManagerID.size());
            for (Iterator<TProject> collTProjectsRelatedByDefaultManagerIDIt = collTProjectsRelatedByDefaultManagerID.iterator(); collTProjectsRelatedByDefaultManagerIDIt.hasNext(); )
            {
                TProject related = (TProject) collTProjectsRelatedByDefaultManagerIDIt.next();
                TProjectBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTProjectBeansRelatedByDefaultManagerID(relatedBeans);
        }


        if (collTStateChanges != null)
        {
            List<TStateChangeBean> relatedBeans = new ArrayList<TStateChangeBean>(collTStateChanges.size());
            for (Iterator<TStateChange> collTStateChangesIt = collTStateChanges.iterator(); collTStateChangesIt.hasNext(); )
            {
                TStateChange related = (TStateChange) collTStateChangesIt.next();
                TStateChangeBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTStateChangeBeans(relatedBeans);
        }


        if (collTTrails != null)
        {
            List<TTrailBean> relatedBeans = new ArrayList<TTrailBean>(collTTrails.size());
            for (Iterator<TTrail> collTTrailsIt = collTTrails.iterator(); collTTrailsIt.hasNext(); )
            {
                TTrail related = (TTrail) collTTrailsIt.next();
                TTrailBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTTrailBeans(relatedBeans);
        }


        if (collTWorkItemsRelatedByOwnerID != null)
        {
            List<TWorkItemBean> relatedBeans = new ArrayList<TWorkItemBean>(collTWorkItemsRelatedByOwnerID.size());
            for (Iterator<TWorkItem> collTWorkItemsRelatedByOwnerIDIt = collTWorkItemsRelatedByOwnerID.iterator(); collTWorkItemsRelatedByOwnerIDIt.hasNext(); )
            {
                TWorkItem related = (TWorkItem) collTWorkItemsRelatedByOwnerIDIt.next();
                TWorkItemBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemBeansRelatedByOwnerID(relatedBeans);
        }


        if (collTWorkItemsRelatedByChangedByID != null)
        {
            List<TWorkItemBean> relatedBeans = new ArrayList<TWorkItemBean>(collTWorkItemsRelatedByChangedByID.size());
            for (Iterator<TWorkItem> collTWorkItemsRelatedByChangedByIDIt = collTWorkItemsRelatedByChangedByID.iterator(); collTWorkItemsRelatedByChangedByIDIt.hasNext(); )
            {
                TWorkItem related = (TWorkItem) collTWorkItemsRelatedByChangedByIDIt.next();
                TWorkItemBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemBeansRelatedByChangedByID(relatedBeans);
        }


        if (collTWorkItemsRelatedByOriginatorID != null)
        {
            List<TWorkItemBean> relatedBeans = new ArrayList<TWorkItemBean>(collTWorkItemsRelatedByOriginatorID.size());
            for (Iterator<TWorkItem> collTWorkItemsRelatedByOriginatorIDIt = collTWorkItemsRelatedByOriginatorID.iterator(); collTWorkItemsRelatedByOriginatorIDIt.hasNext(); )
            {
                TWorkItem related = (TWorkItem) collTWorkItemsRelatedByOriginatorIDIt.next();
                TWorkItemBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemBeansRelatedByOriginatorID(relatedBeans);
        }


        if (collTWorkItemsRelatedByResponsibleID != null)
        {
            List<TWorkItemBean> relatedBeans = new ArrayList<TWorkItemBean>(collTWorkItemsRelatedByResponsibleID.size());
            for (Iterator<TWorkItem> collTWorkItemsRelatedByResponsibleIDIt = collTWorkItemsRelatedByResponsibleID.iterator(); collTWorkItemsRelatedByResponsibleIDIt.hasNext(); )
            {
                TWorkItem related = (TWorkItem) collTWorkItemsRelatedByResponsibleIDIt.next();
                TWorkItemBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemBeansRelatedByResponsibleID(relatedBeans);
        }


        if (collTComputedValuess != null)
        {
            List<TComputedValuesBean> relatedBeans = new ArrayList<TComputedValuesBean>(collTComputedValuess.size());
            for (Iterator<TComputedValues> collTComputedValuessIt = collTComputedValuess.iterator(); collTComputedValuessIt.hasNext(); )
            {
                TComputedValues related = (TComputedValues) collTComputedValuessIt.next();
                TComputedValuesBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTComputedValuesBeans(relatedBeans);
        }


        if (collTPrivateReportRepositorys != null)
        {
            List<TPrivateReportRepositoryBean> relatedBeans = new ArrayList<TPrivateReportRepositoryBean>(collTPrivateReportRepositorys.size());
            for (Iterator<TPrivateReportRepository> collTPrivateReportRepositorysIt = collTPrivateReportRepositorys.iterator(); collTPrivateReportRepositorysIt.hasNext(); )
            {
                TPrivateReportRepository related = (TPrivateReportRepository) collTPrivateReportRepositorysIt.next();
                TPrivateReportRepositoryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTPrivateReportRepositoryBeans(relatedBeans);
        }


        if (collTPublicReportRepositorys != null)
        {
            List<TPublicReportRepositoryBean> relatedBeans = new ArrayList<TPublicReportRepositoryBean>(collTPublicReportRepositorys.size());
            for (Iterator<TPublicReportRepository> collTPublicReportRepositorysIt = collTPublicReportRepositorys.iterator(); collTPublicReportRepositorysIt.hasNext(); )
            {
                TPublicReportRepository related = (TPublicReportRepository) collTPublicReportRepositorysIt.next();
                TPublicReportRepositoryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTPublicReportRepositoryBeans(relatedBeans);
        }


        if (collTAttachments != null)
        {
            List<TAttachmentBean> relatedBeans = new ArrayList<TAttachmentBean>(collTAttachments.size());
            for (Iterator<TAttachment> collTAttachmentsIt = collTAttachments.iterator(); collTAttachmentsIt.hasNext(); )
            {
                TAttachment related = (TAttachment) collTAttachmentsIt.next();
                TAttachmentBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTAttachmentBeans(relatedBeans);
        }


        if (collTCosts != null)
        {
            List<TCostBean> relatedBeans = new ArrayList<TCostBean>(collTCosts.size());
            for (Iterator<TCost> collTCostsIt = collTCosts.iterator(); collTCostsIt.hasNext(); )
            {
                TCost related = (TCost) collTCostsIt.next();
                TCostBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTCostBeans(relatedBeans);
        }


        if (collTWorkFlows != null)
        {
            List<TWorkFlowBean> relatedBeans = new ArrayList<TWorkFlowBean>(collTWorkFlows.size());
            for (Iterator<TWorkFlow> collTWorkFlowsIt = collTWorkFlows.iterator(); collTWorkFlowsIt.hasNext(); )
            {
                TWorkFlow related = (TWorkFlow) collTWorkFlowsIt.next();
                TWorkFlowBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkFlowBeans(relatedBeans);
        }


        if (collTIssueAttributeValues != null)
        {
            List<TIssueAttributeValueBean> relatedBeans = new ArrayList<TIssueAttributeValueBean>(collTIssueAttributeValues.size());
            for (Iterator<TIssueAttributeValue> collTIssueAttributeValuesIt = collTIssueAttributeValues.iterator(); collTIssueAttributeValuesIt.hasNext(); )
            {
                TIssueAttributeValue related = (TIssueAttributeValue) collTIssueAttributeValuesIt.next();
                TIssueAttributeValueBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTIssueAttributeValueBeans(relatedBeans);
        }


        if (collTReportLayouts != null)
        {
            List<TReportLayoutBean> relatedBeans = new ArrayList<TReportLayoutBean>(collTReportLayouts.size());
            for (Iterator<TReportLayout> collTReportLayoutsIt = collTReportLayouts.iterator(); collTReportLayoutsIt.hasNext(); )
            {
                TReportLayout related = (TReportLayout) collTReportLayoutsIt.next();
                TReportLayoutBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTReportLayoutBeans(relatedBeans);
        }


        if (collTSchedulers != null)
        {
            List<TSchedulerBean> relatedBeans = new ArrayList<TSchedulerBean>(collTSchedulers.size());
            for (Iterator<TScheduler> collTSchedulersIt = collTSchedulers.iterator(); collTSchedulersIt.hasNext(); )
            {
                TScheduler related = (TScheduler) collTSchedulersIt.next();
                TSchedulerBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTSchedulerBeans(relatedBeans);
        }


        if (collTGroupMembersRelatedByTheGroup != null)
        {
            List<TGroupMemberBean> relatedBeans = new ArrayList<TGroupMemberBean>(collTGroupMembersRelatedByTheGroup.size());
            for (Iterator<TGroupMember> collTGroupMembersRelatedByTheGroupIt = collTGroupMembersRelatedByTheGroup.iterator(); collTGroupMembersRelatedByTheGroupIt.hasNext(); )
            {
                TGroupMember related = (TGroupMember) collTGroupMembersRelatedByTheGroupIt.next();
                TGroupMemberBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTGroupMemberBeansRelatedByTheGroup(relatedBeans);
        }


        if (collTGroupMembersRelatedByPerson != null)
        {
            List<TGroupMemberBean> relatedBeans = new ArrayList<TGroupMemberBean>(collTGroupMembersRelatedByPerson.size());
            for (Iterator<TGroupMember> collTGroupMembersRelatedByPersonIt = collTGroupMembersRelatedByPerson.iterator(); collTGroupMembersRelatedByPersonIt.hasNext(); )
            {
                TGroupMember related = (TGroupMember) collTGroupMembersRelatedByPersonIt.next();
                TGroupMemberBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTGroupMemberBeansRelatedByPerson(relatedBeans);
        }


        if (collTBudgets != null)
        {
            List<TBudgetBean> relatedBeans = new ArrayList<TBudgetBean>(collTBudgets.size());
            for (Iterator<TBudget> collTBudgetsIt = collTBudgets.iterator(); collTBudgetsIt.hasNext(); )
            {
                TBudget related = (TBudget) collTBudgetsIt.next();
                TBudgetBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTBudgetBeans(relatedBeans);
        }


        if (collTActualEstimatedBudgets != null)
        {
            List<TActualEstimatedBudgetBean> relatedBeans = new ArrayList<TActualEstimatedBudgetBean>(collTActualEstimatedBudgets.size());
            for (Iterator<TActualEstimatedBudget> collTActualEstimatedBudgetsIt = collTActualEstimatedBudgets.iterator(); collTActualEstimatedBudgetsIt.hasNext(); )
            {
                TActualEstimatedBudget related = (TActualEstimatedBudget) collTActualEstimatedBudgetsIt.next();
                TActualEstimatedBudgetBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTActualEstimatedBudgetBeans(relatedBeans);
        }


        if (collTDashboardScreensRelatedByPerson != null)
        {
            List<TDashboardScreenBean> relatedBeans = new ArrayList<TDashboardScreenBean>(collTDashboardScreensRelatedByPerson.size());
            for (Iterator<TDashboardScreen> collTDashboardScreensRelatedByPersonIt = collTDashboardScreensRelatedByPerson.iterator(); collTDashboardScreensRelatedByPersonIt.hasNext(); )
            {
                TDashboardScreen related = (TDashboardScreen) collTDashboardScreensRelatedByPersonIt.next();
                TDashboardScreenBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTDashboardScreenBeansRelatedByPerson(relatedBeans);
        }


        if (collTDashboardScreensRelatedByOwner != null)
        {
            List<TDashboardScreenBean> relatedBeans = new ArrayList<TDashboardScreenBean>(collTDashboardScreensRelatedByOwner.size());
            for (Iterator<TDashboardScreen> collTDashboardScreensRelatedByOwnerIt = collTDashboardScreensRelatedByOwner.iterator(); collTDashboardScreensRelatedByOwnerIt.hasNext(); )
            {
                TDashboardScreen related = (TDashboardScreen) collTDashboardScreensRelatedByOwnerIt.next();
                TDashboardScreenBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTDashboardScreenBeansRelatedByOwner(relatedBeans);
        }


        if (collTFields != null)
        {
            List<TFieldBean> relatedBeans = new ArrayList<TFieldBean>(collTFields.size());
            for (Iterator<TField> collTFieldsIt = collTFields.iterator(); collTFieldsIt.hasNext(); )
            {
                TField related = (TField) collTFieldsIt.next();
                TFieldBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTFieldBeans(relatedBeans);
        }


        if (collTLists != null)
        {
            List<TListBean> relatedBeans = new ArrayList<TListBean>(collTLists.size());
            for (Iterator<TList> collTListsIt = collTLists.iterator(); collTListsIt.hasNext(); )
            {
                TList related = (TList) collTListsIt.next();
                TListBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTListBeans(relatedBeans);
        }


        if (collTScreens != null)
        {
            List<TScreenBean> relatedBeans = new ArrayList<TScreenBean>(collTScreens.size());
            for (Iterator<TScreen> collTScreensIt = collTScreens.iterator(); collTScreensIt.hasNext(); )
            {
                TScreen related = (TScreen) collTScreensIt.next();
                TScreenBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTScreenBeans(relatedBeans);
        }


        if (collTNotifyTriggers != null)
        {
            List<TNotifyTriggerBean> relatedBeans = new ArrayList<TNotifyTriggerBean>(collTNotifyTriggers.size());
            for (Iterator<TNotifyTrigger> collTNotifyTriggersIt = collTNotifyTriggers.iterator(); collTNotifyTriggersIt.hasNext(); )
            {
                TNotifyTrigger related = (TNotifyTrigger) collTNotifyTriggersIt.next();
                TNotifyTriggerBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTNotifyTriggerBeans(relatedBeans);
        }


        if (collTNotifySettingss != null)
        {
            List<TNotifySettingsBean> relatedBeans = new ArrayList<TNotifySettingsBean>(collTNotifySettingss.size());
            for (Iterator<TNotifySettings> collTNotifySettingssIt = collTNotifySettingss.iterator(); collTNotifySettingssIt.hasNext(); )
            {
                TNotifySettings related = (TNotifySettings) collTNotifySettingssIt.next();
                TNotifySettingsBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTNotifySettingsBeans(relatedBeans);
        }


        if (collTQueryRepositorys != null)
        {
            List<TQueryRepositoryBean> relatedBeans = new ArrayList<TQueryRepositoryBean>(collTQueryRepositorys.size());
            for (Iterator<TQueryRepository> collTQueryRepositorysIt = collTQueryRepositorys.iterator(); collTQueryRepositorysIt.hasNext(); )
            {
                TQueryRepository related = (TQueryRepository) collTQueryRepositorysIt.next();
                TQueryRepositoryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTQueryRepositoryBeans(relatedBeans);
        }


        if (collTWorkItemLinks != null)
        {
            List<TWorkItemLinkBean> relatedBeans = new ArrayList<TWorkItemLinkBean>(collTWorkItemLinks.size());
            for (Iterator<TWorkItemLink> collTWorkItemLinksIt = collTWorkItemLinks.iterator(); collTWorkItemLinksIt.hasNext(); )
            {
                TWorkItemLink related = (TWorkItemLink) collTWorkItemLinksIt.next();
                TWorkItemLinkBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemLinkBeans(relatedBeans);
        }


        if (collTWorkItemLocks != null)
        {
            List<TWorkItemLockBean> relatedBeans = new ArrayList<TWorkItemLockBean>(collTWorkItemLocks.size());
            for (Iterator<TWorkItemLock> collTWorkItemLocksIt = collTWorkItemLocks.iterator(); collTWorkItemLocksIt.hasNext(); )
            {
                TWorkItemLock related = (TWorkItemLock) collTWorkItemLocksIt.next();
                TWorkItemLockBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkItemLockBeans(relatedBeans);
        }


        if (collTExportTemplates != null)
        {
            List<TExportTemplateBean> relatedBeans = new ArrayList<TExportTemplateBean>(collTExportTemplates.size());
            for (Iterator<TExportTemplate> collTExportTemplatesIt = collTExportTemplates.iterator(); collTExportTemplatesIt.hasNext(); )
            {
                TExportTemplate related = (TExportTemplate) collTExportTemplatesIt.next();
                TExportTemplateBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTExportTemplateBeans(relatedBeans);
        }


        if (collTLoggedInUserss != null)
        {
            List<TLoggedInUsersBean> relatedBeans = new ArrayList<TLoggedInUsersBean>(collTLoggedInUserss.size());
            for (Iterator<TLoggedInUsers> collTLoggedInUserssIt = collTLoggedInUserss.iterator(); collTLoggedInUserssIt.hasNext(); )
            {
                TLoggedInUsers related = (TLoggedInUsers) collTLoggedInUserssIt.next();
                TLoggedInUsersBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTLoggedInUsersBeans(relatedBeans);
        }


        if (collTSummaryMailsRelatedByPERSONFROM != null)
        {
            List<TSummaryMailBean> relatedBeans = new ArrayList<TSummaryMailBean>(collTSummaryMailsRelatedByPERSONFROM.size());
            for (Iterator<TSummaryMail> collTSummaryMailsRelatedByPERSONFROMIt = collTSummaryMailsRelatedByPERSONFROM.iterator(); collTSummaryMailsRelatedByPERSONFROMIt.hasNext(); )
            {
                TSummaryMail related = (TSummaryMail) collTSummaryMailsRelatedByPERSONFROMIt.next();
                TSummaryMailBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTSummaryMailBeansRelatedByPERSONFROM(relatedBeans);
        }


        if (collTSummaryMailsRelatedByPERSONTO != null)
        {
            List<TSummaryMailBean> relatedBeans = new ArrayList<TSummaryMailBean>(collTSummaryMailsRelatedByPERSONTO.size());
            for (Iterator<TSummaryMail> collTSummaryMailsRelatedByPERSONTOIt = collTSummaryMailsRelatedByPERSONTO.iterator(); collTSummaryMailsRelatedByPERSONTOIt.hasNext(); )
            {
                TSummaryMail related = (TSummaryMail) collTSummaryMailsRelatedByPERSONTOIt.next();
                TSummaryMailBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTSummaryMailBeansRelatedByPERSONTO(relatedBeans);
        }


        if (collTHistoryTransactions != null)
        {
            List<THistoryTransactionBean> relatedBeans = new ArrayList<THistoryTransactionBean>(collTHistoryTransactions.size());
            for (Iterator<THistoryTransaction> collTHistoryTransactionsIt = collTHistoryTransactions.iterator(); collTHistoryTransactionsIt.hasNext(); )
            {
                THistoryTransaction related = (THistoryTransaction) collTHistoryTransactionsIt.next();
                THistoryTransactionBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTHistoryTransactionBeans(relatedBeans);
        }


        if (collTScriptss != null)
        {
            List<TScriptsBean> relatedBeans = new ArrayList<TScriptsBean>(collTScriptss.size());
            for (Iterator<TScripts> collTScriptssIt = collTScriptss.iterator(); collTScriptssIt.hasNext(); )
            {
                TScripts related = (TScripts) collTScriptssIt.next();
                TScriptsBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTScriptsBeans(relatedBeans);
        }


        if (collTTemplatePersons != null)
        {
            List<TTemplatePersonBean> relatedBeans = new ArrayList<TTemplatePersonBean>(collTTemplatePersons.size());
            for (Iterator<TTemplatePerson> collTTemplatePersonsIt = collTTemplatePersons.iterator(); collTTemplatePersonsIt.hasNext(); )
            {
                TTemplatePerson related = (TTemplatePerson) collTTemplatePersonsIt.next();
                TTemplatePersonBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTTemplatePersonBeans(relatedBeans);
        }


        if (collTReportPersonSettingss != null)
        {
            List<TReportPersonSettingsBean> relatedBeans = new ArrayList<TReportPersonSettingsBean>(collTReportPersonSettingss.size());
            for (Iterator<TReportPersonSettings> collTReportPersonSettingssIt = collTReportPersonSettingss.iterator(); collTReportPersonSettingssIt.hasNext(); )
            {
                TReportPersonSettings related = (TReportPersonSettings) collTReportPersonSettingssIt.next();
                TReportPersonSettingsBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTReportPersonSettingsBeans(relatedBeans);
        }


        if (collTMSProjectExchanges != null)
        {
            List<TMSProjectExchangeBean> relatedBeans = new ArrayList<TMSProjectExchangeBean>(collTMSProjectExchanges.size());
            for (Iterator<TMSProjectExchange> collTMSProjectExchangesIt = collTMSProjectExchanges.iterator(); collTMSProjectExchangesIt.hasNext(); )
            {
                TMSProjectExchange related = (TMSProjectExchange) collTMSProjectExchangesIt.next();
                TMSProjectExchangeBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTMSProjectExchangeBeans(relatedBeans);
        }


        if (collTFilterCategorys != null)
        {
            List<TFilterCategoryBean> relatedBeans = new ArrayList<TFilterCategoryBean>(collTFilterCategorys.size());
            for (Iterator<TFilterCategory> collTFilterCategorysIt = collTFilterCategorys.iterator(); collTFilterCategorysIt.hasNext(); )
            {
                TFilterCategory related = (TFilterCategory) collTFilterCategorysIt.next();
                TFilterCategoryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTFilterCategoryBeans(relatedBeans);
        }


        if (collTReportCategorys != null)
        {
            List<TReportCategoryBean> relatedBeans = new ArrayList<TReportCategoryBean>(collTReportCategorys.size());
            for (Iterator<TReportCategory> collTReportCategorysIt = collTReportCategorys.iterator(); collTReportCategorysIt.hasNext(); )
            {
                TReportCategory related = (TReportCategory) collTReportCategorysIt.next();
                TReportCategoryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTReportCategoryBeans(relatedBeans);
        }


        if (collTMenuitemQuerys != null)
        {
            List<TMenuitemQueryBean> relatedBeans = new ArrayList<TMenuitemQueryBean>(collTMenuitemQuerys.size());
            for (Iterator<TMenuitemQuery> collTMenuitemQuerysIt = collTMenuitemQuerys.iterator(); collTMenuitemQuerysIt.hasNext(); )
            {
                TMenuitemQuery related = (TMenuitemQuery) collTMenuitemQuerysIt.next();
                TMenuitemQueryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTMenuitemQueryBeans(relatedBeans);
        }


        if (collTPersonBaskets != null)
        {
            List<TPersonBasketBean> relatedBeans = new ArrayList<TPersonBasketBean>(collTPersonBaskets.size());
            for (Iterator<TPersonBasket> collTPersonBasketsIt = collTPersonBaskets.iterator(); collTPersonBasketsIt.hasNext(); )
            {
                TPersonBasket related = (TPersonBasket) collTPersonBasketsIt.next();
                TPersonBasketBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTPersonBasketBeans(relatedBeans);
        }


        if (collTBaskets != null)
        {
            List<TBasketBean> relatedBeans = new ArrayList<TBasketBean>(collTBaskets.size());
            for (Iterator<TBasket> collTBasketsIt = collTBaskets.iterator(); collTBasketsIt.hasNext(); )
            {
                TBasket related = (TBasket) collTBasketsIt.next();
                TBasketBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTBasketBeans(relatedBeans);
        }


        if (collTLastVisitedItems != null)
        {
            List<TLastVisitedItemBean> relatedBeans = new ArrayList<TLastVisitedItemBean>(collTLastVisitedItems.size());
            for (Iterator<TLastVisitedItem> collTLastVisitedItemsIt = collTLastVisitedItems.iterator(); collTLastVisitedItemsIt.hasNext(); )
            {
                TLastVisitedItem related = (TLastVisitedItem) collTLastVisitedItemsIt.next();
                TLastVisitedItemBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTLastVisitedItemBeans(relatedBeans);
        }


        if (collTWorkflowDefs != null)
        {
            List<TWorkflowDefBean> relatedBeans = new ArrayList<TWorkflowDefBean>(collTWorkflowDefs.size());
            for (Iterator<TWorkflowDef> collTWorkflowDefsIt = collTWorkflowDefs.iterator(); collTWorkflowDefsIt.hasNext(); )
            {
                TWorkflowDef related = (TWorkflowDef) collTWorkflowDefsIt.next();
                TWorkflowDefBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkflowDefBeans(relatedBeans);
        }


        if (collTWorkflowActivitysRelatedByNewMan != null)
        {
            List<TWorkflowActivityBean> relatedBeans = new ArrayList<TWorkflowActivityBean>(collTWorkflowActivitysRelatedByNewMan.size());
            for (Iterator<TWorkflowActivity> collTWorkflowActivitysRelatedByNewManIt = collTWorkflowActivitysRelatedByNewMan.iterator(); collTWorkflowActivitysRelatedByNewManIt.hasNext(); )
            {
                TWorkflowActivity related = (TWorkflowActivity) collTWorkflowActivitysRelatedByNewManIt.next();
                TWorkflowActivityBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkflowActivityBeansRelatedByNewMan(relatedBeans);
        }


        if (collTWorkflowActivitysRelatedByNewResp != null)
        {
            List<TWorkflowActivityBean> relatedBeans = new ArrayList<TWorkflowActivityBean>(collTWorkflowActivitysRelatedByNewResp.size());
            for (Iterator<TWorkflowActivity> collTWorkflowActivitysRelatedByNewRespIt = collTWorkflowActivitysRelatedByNewResp.iterator(); collTWorkflowActivitysRelatedByNewRespIt.hasNext(); )
            {
                TWorkflowActivity related = (TWorkflowActivity) collTWorkflowActivitysRelatedByNewRespIt.next();
                TWorkflowActivityBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkflowActivityBeansRelatedByNewResp(relatedBeans);
        }


        if (collTWorkflowGuards != null)
        {
            List<TWorkflowGuardBean> relatedBeans = new ArrayList<TWorkflowGuardBean>(collTWorkflowGuards.size());
            for (Iterator<TWorkflowGuard> collTWorkflowGuardsIt = collTWorkflowGuards.iterator(); collTWorkflowGuardsIt.hasNext(); )
            {
                TWorkflowGuard related = (TWorkflowGuard) collTWorkflowGuardsIt.next();
                TWorkflowGuardBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTWorkflowGuardBeans(relatedBeans);
        }


        if (collTEscalationEntrys != null)
        {
            List<TEscalationEntryBean> relatedBeans = new ArrayList<TEscalationEntryBean>(collTEscalationEntrys.size());
            for (Iterator<TEscalationEntry> collTEscalationEntrysIt = collTEscalationEntrys.iterator(); collTEscalationEntrysIt.hasNext(); )
            {
                TEscalationEntry related = (TEscalationEntry) collTEscalationEntrysIt.next();
                TEscalationEntryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTEscalationEntryBeans(relatedBeans);
        }


        if (collTReadIssues != null)
        {
            List<TReadIssueBean> relatedBeans = new ArrayList<TReadIssueBean>(collTReadIssues.size());
            for (Iterator<TReadIssue> collTReadIssuesIt = collTReadIssues.iterator(); collTReadIssuesIt.hasNext(); )
            {
                TReadIssue related = (TReadIssue) collTReadIssuesIt.next();
                TReadIssueBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTReadIssueBeans(relatedBeans);
        }


        if (collTLastExecutedQuerys != null)
        {
            List<TLastExecutedQueryBean> relatedBeans = new ArrayList<TLastExecutedQueryBean>(collTLastExecutedQuerys.size());
            for (Iterator<TLastExecutedQuery> collTLastExecutedQuerysIt = collTLastExecutedQuerys.iterator(); collTLastExecutedQuerysIt.hasNext(); )
            {
                TLastExecutedQuery related = (TLastExecutedQuery) collTLastExecutedQuerysIt.next();
                TLastExecutedQueryBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTLastExecutedQueryBeans(relatedBeans);
        }


        if (collTReportSubscribes != null)
        {
            List<TReportSubscribeBean> relatedBeans = new ArrayList<TReportSubscribeBean>(collTReportSubscribes.size());
            for (Iterator<TReportSubscribe> collTReportSubscribesIt = collTReportSubscribes.iterator(); collTReportSubscribesIt.hasNext(); )
            {
                TReportSubscribe related = (TReportSubscribe) collTReportSubscribesIt.next();
                TReportSubscribeBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTReportSubscribeBeans(relatedBeans);
        }


        if (collTGridLayouts != null)
        {
            List<TGridLayoutBean> relatedBeans = new ArrayList<TGridLayoutBean>(collTGridLayouts.size());
            for (Iterator<TGridLayout> collTGridLayoutsIt = collTGridLayouts.iterator(); collTGridLayoutsIt.hasNext(); )
            {
                TGridLayout related = (TGridLayout) collTGridLayoutsIt.next();
                TGridLayoutBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTGridLayoutBeans(relatedBeans);
        }


        if (collTNavigatorLayouts != null)
        {
            List<TNavigatorLayoutBean> relatedBeans = new ArrayList<TNavigatorLayoutBean>(collTNavigatorLayouts.size());
            for (Iterator<TNavigatorLayout> collTNavigatorLayoutsIt = collTNavigatorLayouts.iterator(); collTNavigatorLayoutsIt.hasNext(); )
            {
                TNavigatorLayout related = (TNavigatorLayout) collTNavigatorLayoutsIt.next();
                TNavigatorLayoutBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTNavigatorLayoutBeans(relatedBeans);
        }


        if (collTMailTextBlocks != null)
        {
            List<TMailTextBlockBean> relatedBeans = new ArrayList<TMailTextBlockBean>(collTMailTextBlocks.size());
            for (Iterator<TMailTextBlock> collTMailTextBlocksIt = collTMailTextBlocks.iterator(); collTMailTextBlocksIt.hasNext(); )
            {
                TMailTextBlock related = (TMailTextBlock) collTMailTextBlocksIt.next();
                TMailTextBlockBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTMailTextBlockBeans(relatedBeans);
        }


        if (collTPersonInDomains != null)
        {
            List<TPersonInDomainBean> relatedBeans = new ArrayList<TPersonInDomainBean>(collTPersonInDomains.size());
            for (Iterator<TPersonInDomain> collTPersonInDomainsIt = collTPersonInDomains.iterator(); collTPersonInDomainsIt.hasNext(); )
            {
                TPersonInDomain related = (TPersonInDomain) collTPersonInDomainsIt.next();
                TPersonInDomainBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTPersonInDomainBeans(relatedBeans);
        }


        if (collTAttachmentVersions != null)
        {
            List<TAttachmentVersionBean> relatedBeans = new ArrayList<TAttachmentVersionBean>(collTAttachmentVersions.size());
            for (Iterator<TAttachmentVersion> collTAttachmentVersionsIt = collTAttachmentVersions.iterator(); collTAttachmentVersionsIt.hasNext(); )
            {
                TAttachmentVersion related = (TAttachmentVersion) collTAttachmentVersionsIt.next();
                TAttachmentVersionBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTAttachmentVersionBeans(relatedBeans);
        }


        if (collTUserFeatures != null)
        {
            List<TUserFeatureBean> relatedBeans = new ArrayList<TUserFeatureBean>(collTUserFeatures.size());
            for (Iterator<TUserFeature> collTUserFeaturesIt = collTUserFeatures.iterator(); collTUserFeaturesIt.hasNext(); )
            {
                TUserFeature related = (TUserFeature) collTUserFeaturesIt.next();
                TUserFeatureBean relatedBean = related.getBean(createdBeans);
                relatedBeans.add(relatedBean);
            }
            result.setTUserFeatureBeans(relatedBeans);
        }




        if (aTDepartment != null)
        {
            TDepartmentBean relatedBean = aTDepartment.getBean(createdBeans);
            result.setTDepartmentBean(relatedBean);
        }



        if (aTPrivateReportRepository != null)
        {
            TPrivateReportRepositoryBean relatedBean = aTPrivateReportRepository.getBean(createdBeans);
            result.setTPrivateReportRepositoryBean(relatedBean);
        }



        if (aTBLOB != null)
        {
            TBLOBBean relatedBean = aTBLOB.getBean(createdBeans);
            result.setTBLOBBean(relatedBean);
        }



        if (aTPersonRelatedBySubstituteID != null)
        {
            TPersonBean relatedBean = aTPersonRelatedBySubstituteID.getBean(createdBeans);
            result.setTPersonBeanRelatedBySubstituteID(relatedBean);
        }
        result.setModified(isModified());
        result.setNew(isNew());
        return result;
    }

    /**
     * Creates an instance of TPerson with the contents
     * of a TPersonBean.
     * This behaviour could have also been achieved using a constructor,
     * however as this class is abstract no constructors are allowed
     * @param bean the TPersonBean which contents are used to create
     *        the resulting class
     * @return an instance of TPerson with the contents of bean
     */
    public static TPerson createTPerson(TPersonBean bean)
        throws TorqueException
    {
        return createTPerson(bean, new IdentityMap());
    }

    /**
     * Creates an instance of TPerson with the contents
     * of a TPersonBean.
     * This behaviour could have also been achieved using a constructor,
     * however as this class is abstract no constructors are allowed.
     *
     * This method is intended for internal use only.
     * @param bean the TPersonBean which contents are used to create
     *        the resulting class
     * @param createdObjects a IdentityMap which maps beans
     *        to already created objects
     * @return an instance of TPerson with the contents of bean
     */

    public static TPerson createTPerson(TPersonBean bean, IdentityMap createdObjects)
        throws TorqueException
    {
        TPerson result = (TPerson) createdObjects.get(bean);
        if (result != null)
        {
            // we already have an object for the bean, return it
            return result;
        }
        result = new TPerson();
        createdObjects.put(bean, result);

        result.setObjectID(bean.getObjectID());
        result.setFirstName(bean.getFirstName());
        result.setLastName(bean.getLastName());
        result.setLoginName(bean.getLoginName());
        result.setEmail(bean.getEmail());
        result.setPasswd(bean.getPasswd());
        result.setSalt(bean.getSalt());
        result.setForgotPasswordKey(bean.getForgotPasswordKey());
        result.setPhone(bean.getPhone());
        result.setDepartmentID(bean.getDepartmentID());
        result.setValidUntil(bean.getValidUntil());
        result.setPreferences(bean.getPreferences());
        result.setLastEdit(bean.getLastEdit());
        result.setCreated(bean.getCreated());
        result.setDeleted(bean.getDeleted());
        result.setTokenPasswd(bean.getTokenPasswd());
        result.setTokenExpDate(bean.getTokenExpDate());
        result.setEmailFrequency(bean.getEmailFrequency());
        result.setEmailLead(bean.getEmailLead());
        result.setEmailLastReminded(bean.getEmailLastReminded());
        result.setEmailRemindMe(bean.getEmailRemindMe());
        result.setPrefEmailType(bean.getPrefEmailType());
        result.setPrefLocale(bean.getPrefLocale());
        result.setMyDefaultReport(bean.getMyDefaultReport());
        result.setNoEmailPlease(bean.getNoEmailPlease());
        result.setRemindMeAsOriginator(bean.getRemindMeAsOriginator());
        result.setRemindMeAsManager(bean.getRemindMeAsManager());
        result.setRemindMeAsResponsible(bean.getRemindMeAsResponsible());
        result.setEmailRemindPriorityLevel(bean.getEmailRemindPriorityLevel());
        result.setEmailRemindSeverityLevel(bean.getEmailRemindSeverityLevel());
        result.setHoursPerWorkDay(bean.getHoursPerWorkDay());
        result.setHourlyWage(bean.getHourlyWage());
        result.setExtraHourWage(bean.getExtraHourWage());
        result.setEmployeeID(bean.getEmployeeID());
        result.setIsgroup(bean.getIsgroup());
        result.setUserLevel(bean.getUserLevel());
        result.setMaxAssignedItems(bean.getMaxAssignedItems());
        result.setMessengerURL(bean.getMessengerURL());
        result.setCALLURL(bean.getCALLURL());
        result.setSymbol(bean.getSymbol());
        result.setIconKey(bean.getIconKey());
        result.setSubstituteID(bean.getSubstituteID());
        result.setSubstituteActive(bean.getSubstituteActive());
        result.setUuid(bean.getUuid());



        {
            List<TAccessControlListBean> relatedBeans = bean.getTAccessControlListBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TAccessControlListBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TAccessControlListBean relatedBean =  relatedBeansIt.next();
                    TAccessControlList related = TAccessControlList.createTAccessControlList(relatedBean, createdObjects);
                    result.addTAccessControlListFromBean(related);
                }
            }
        }


        {
            List<TBaseLineBean> relatedBeans = bean.getTBaseLineBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TBaseLineBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TBaseLineBean relatedBean =  relatedBeansIt.next();
                    TBaseLine related = TBaseLine.createTBaseLine(relatedBean, createdObjects);
                    result.addTBaseLineFromBean(related);
                }
            }
        }


        {
            List<TNotifyBean> relatedBeans = bean.getTNotifyBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TNotifyBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TNotifyBean relatedBean =  relatedBeansIt.next();
                    TNotify related = TNotify.createTNotify(relatedBean, createdObjects);
                    result.addTNotifyFromBean(related);
                }
            }
        }


        {
            List<TProjectBean> relatedBeans = bean.getTProjectBeansRelatedByDefaultOwnerID();
            if (relatedBeans != null)
            {
                for (Iterator<TProjectBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TProjectBean relatedBean =  relatedBeansIt.next();
                    TProject related = TProject.createTProject(relatedBean, createdObjects);
                    result.addTProjectRelatedByDefaultOwnerIDFromBean(related);
                }
            }
        }


        {
            List<TProjectBean> relatedBeans = bean.getTProjectBeansRelatedByDefaultManagerID();
            if (relatedBeans != null)
            {
                for (Iterator<TProjectBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TProjectBean relatedBean =  relatedBeansIt.next();
                    TProject related = TProject.createTProject(relatedBean, createdObjects);
                    result.addTProjectRelatedByDefaultManagerIDFromBean(related);
                }
            }
        }


        {
            List<TStateChangeBean> relatedBeans = bean.getTStateChangeBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TStateChangeBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TStateChangeBean relatedBean =  relatedBeansIt.next();
                    TStateChange related = TStateChange.createTStateChange(relatedBean, createdObjects);
                    result.addTStateChangeFromBean(related);
                }
            }
        }


        {
            List<TTrailBean> relatedBeans = bean.getTTrailBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TTrailBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TTrailBean relatedBean =  relatedBeansIt.next();
                    TTrail related = TTrail.createTTrail(relatedBean, createdObjects);
                    result.addTTrailFromBean(related);
                }
            }
        }


        {
            List<TWorkItemBean> relatedBeans = bean.getTWorkItemBeansRelatedByOwnerID();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemBean relatedBean =  relatedBeansIt.next();
                    TWorkItem related = TWorkItem.createTWorkItem(relatedBean, createdObjects);
                    result.addTWorkItemRelatedByOwnerIDFromBean(related);
                }
            }
        }


        {
            List<TWorkItemBean> relatedBeans = bean.getTWorkItemBeansRelatedByChangedByID();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemBean relatedBean =  relatedBeansIt.next();
                    TWorkItem related = TWorkItem.createTWorkItem(relatedBean, createdObjects);
                    result.addTWorkItemRelatedByChangedByIDFromBean(related);
                }
            }
        }


        {
            List<TWorkItemBean> relatedBeans = bean.getTWorkItemBeansRelatedByOriginatorID();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemBean relatedBean =  relatedBeansIt.next();
                    TWorkItem related = TWorkItem.createTWorkItem(relatedBean, createdObjects);
                    result.addTWorkItemRelatedByOriginatorIDFromBean(related);
                }
            }
        }


        {
            List<TWorkItemBean> relatedBeans = bean.getTWorkItemBeansRelatedByResponsibleID();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemBean relatedBean =  relatedBeansIt.next();
                    TWorkItem related = TWorkItem.createTWorkItem(relatedBean, createdObjects);
                    result.addTWorkItemRelatedByResponsibleIDFromBean(related);
                }
            }
        }


        {
            List<TComputedValuesBean> relatedBeans = bean.getTComputedValuesBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TComputedValuesBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TComputedValuesBean relatedBean =  relatedBeansIt.next();
                    TComputedValues related = TComputedValues.createTComputedValues(relatedBean, createdObjects);
                    result.addTComputedValuesFromBean(related);
                }
            }
        }


        {
            List<TPrivateReportRepositoryBean> relatedBeans = bean.getTPrivateReportRepositoryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TPrivateReportRepositoryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TPrivateReportRepositoryBean relatedBean =  relatedBeansIt.next();
                    TPrivateReportRepository related = TPrivateReportRepository.createTPrivateReportRepository(relatedBean, createdObjects);
                    result.addTPrivateReportRepositoryFromBean(related);
                }
            }
        }


        {
            List<TPublicReportRepositoryBean> relatedBeans = bean.getTPublicReportRepositoryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TPublicReportRepositoryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TPublicReportRepositoryBean relatedBean =  relatedBeansIt.next();
                    TPublicReportRepository related = TPublicReportRepository.createTPublicReportRepository(relatedBean, createdObjects);
                    result.addTPublicReportRepositoryFromBean(related);
                }
            }
        }


        {
            List<TAttachmentBean> relatedBeans = bean.getTAttachmentBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TAttachmentBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TAttachmentBean relatedBean =  relatedBeansIt.next();
                    TAttachment related = TAttachment.createTAttachment(relatedBean, createdObjects);
                    result.addTAttachmentFromBean(related);
                }
            }
        }


        {
            List<TCostBean> relatedBeans = bean.getTCostBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TCostBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TCostBean relatedBean =  relatedBeansIt.next();
                    TCost related = TCost.createTCost(relatedBean, createdObjects);
                    result.addTCostFromBean(related);
                }
            }
        }


        {
            List<TWorkFlowBean> relatedBeans = bean.getTWorkFlowBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkFlowBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkFlowBean relatedBean =  relatedBeansIt.next();
                    TWorkFlow related = TWorkFlow.createTWorkFlow(relatedBean, createdObjects);
                    result.addTWorkFlowFromBean(related);
                }
            }
        }


        {
            List<TIssueAttributeValueBean> relatedBeans = bean.getTIssueAttributeValueBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TIssueAttributeValueBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TIssueAttributeValueBean relatedBean =  relatedBeansIt.next();
                    TIssueAttributeValue related = TIssueAttributeValue.createTIssueAttributeValue(relatedBean, createdObjects);
                    result.addTIssueAttributeValueFromBean(related);
                }
            }
        }


        {
            List<TReportLayoutBean> relatedBeans = bean.getTReportLayoutBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TReportLayoutBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TReportLayoutBean relatedBean =  relatedBeansIt.next();
                    TReportLayout related = TReportLayout.createTReportLayout(relatedBean, createdObjects);
                    result.addTReportLayoutFromBean(related);
                }
            }
        }


        {
            List<TSchedulerBean> relatedBeans = bean.getTSchedulerBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TSchedulerBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TSchedulerBean relatedBean =  relatedBeansIt.next();
                    TScheduler related = TScheduler.createTScheduler(relatedBean, createdObjects);
                    result.addTSchedulerFromBean(related);
                }
            }
        }


        {
            List<TGroupMemberBean> relatedBeans = bean.getTGroupMemberBeansRelatedByTheGroup();
            if (relatedBeans != null)
            {
                for (Iterator<TGroupMemberBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TGroupMemberBean relatedBean =  relatedBeansIt.next();
                    TGroupMember related = TGroupMember.createTGroupMember(relatedBean, createdObjects);
                    result.addTGroupMemberRelatedByTheGroupFromBean(related);
                }
            }
        }


        {
            List<TGroupMemberBean> relatedBeans = bean.getTGroupMemberBeansRelatedByPerson();
            if (relatedBeans != null)
            {
                for (Iterator<TGroupMemberBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TGroupMemberBean relatedBean =  relatedBeansIt.next();
                    TGroupMember related = TGroupMember.createTGroupMember(relatedBean, createdObjects);
                    result.addTGroupMemberRelatedByPersonFromBean(related);
                }
            }
        }


        {
            List<TBudgetBean> relatedBeans = bean.getTBudgetBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TBudgetBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TBudgetBean relatedBean =  relatedBeansIt.next();
                    TBudget related = TBudget.createTBudget(relatedBean, createdObjects);
                    result.addTBudgetFromBean(related);
                }
            }
        }


        {
            List<TActualEstimatedBudgetBean> relatedBeans = bean.getTActualEstimatedBudgetBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TActualEstimatedBudgetBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TActualEstimatedBudgetBean relatedBean =  relatedBeansIt.next();
                    TActualEstimatedBudget related = TActualEstimatedBudget.createTActualEstimatedBudget(relatedBean, createdObjects);
                    result.addTActualEstimatedBudgetFromBean(related);
                }
            }
        }


        {
            List<TDashboardScreenBean> relatedBeans = bean.getTDashboardScreenBeansRelatedByPerson();
            if (relatedBeans != null)
            {
                for (Iterator<TDashboardScreenBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TDashboardScreenBean relatedBean =  relatedBeansIt.next();
                    TDashboardScreen related = TDashboardScreen.createTDashboardScreen(relatedBean, createdObjects);
                    result.addTDashboardScreenRelatedByPersonFromBean(related);
                }
            }
        }


        {
            List<TDashboardScreenBean> relatedBeans = bean.getTDashboardScreenBeansRelatedByOwner();
            if (relatedBeans != null)
            {
                for (Iterator<TDashboardScreenBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TDashboardScreenBean relatedBean =  relatedBeansIt.next();
                    TDashboardScreen related = TDashboardScreen.createTDashboardScreen(relatedBean, createdObjects);
                    result.addTDashboardScreenRelatedByOwnerFromBean(related);
                }
            }
        }


        {
            List<TFieldBean> relatedBeans = bean.getTFieldBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TFieldBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TFieldBean relatedBean =  relatedBeansIt.next();
                    TField related = TField.createTField(relatedBean, createdObjects);
                    result.addTFieldFromBean(related);
                }
            }
        }


        {
            List<TListBean> relatedBeans = bean.getTListBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TListBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TListBean relatedBean =  relatedBeansIt.next();
                    TList related = TList.createTList(relatedBean, createdObjects);
                    result.addTListFromBean(related);
                }
            }
        }


        {
            List<TScreenBean> relatedBeans = bean.getTScreenBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TScreenBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TScreenBean relatedBean =  relatedBeansIt.next();
                    TScreen related = TScreen.createTScreen(relatedBean, createdObjects);
                    result.addTScreenFromBean(related);
                }
            }
        }


        {
            List<TNotifyTriggerBean> relatedBeans = bean.getTNotifyTriggerBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TNotifyTriggerBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TNotifyTriggerBean relatedBean =  relatedBeansIt.next();
                    TNotifyTrigger related = TNotifyTrigger.createTNotifyTrigger(relatedBean, createdObjects);
                    result.addTNotifyTriggerFromBean(related);
                }
            }
        }


        {
            List<TNotifySettingsBean> relatedBeans = bean.getTNotifySettingsBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TNotifySettingsBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TNotifySettingsBean relatedBean =  relatedBeansIt.next();
                    TNotifySettings related = TNotifySettings.createTNotifySettings(relatedBean, createdObjects);
                    result.addTNotifySettingsFromBean(related);
                }
            }
        }


        {
            List<TQueryRepositoryBean> relatedBeans = bean.getTQueryRepositoryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TQueryRepositoryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TQueryRepositoryBean relatedBean =  relatedBeansIt.next();
                    TQueryRepository related = TQueryRepository.createTQueryRepository(relatedBean, createdObjects);
                    result.addTQueryRepositoryFromBean(related);
                }
            }
        }


        {
            List<TWorkItemLinkBean> relatedBeans = bean.getTWorkItemLinkBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemLinkBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemLinkBean relatedBean =  relatedBeansIt.next();
                    TWorkItemLink related = TWorkItemLink.createTWorkItemLink(relatedBean, createdObjects);
                    result.addTWorkItemLinkFromBean(related);
                }
            }
        }


        {
            List<TWorkItemLockBean> relatedBeans = bean.getTWorkItemLockBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkItemLockBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkItemLockBean relatedBean =  relatedBeansIt.next();
                    TWorkItemLock related = TWorkItemLock.createTWorkItemLock(relatedBean, createdObjects);
                    result.addTWorkItemLockFromBean(related);
                }
            }
        }


        {
            List<TExportTemplateBean> relatedBeans = bean.getTExportTemplateBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TExportTemplateBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TExportTemplateBean relatedBean =  relatedBeansIt.next();
                    TExportTemplate related = TExportTemplate.createTExportTemplate(relatedBean, createdObjects);
                    result.addTExportTemplateFromBean(related);
                }
            }
        }


        {
            List<TLoggedInUsersBean> relatedBeans = bean.getTLoggedInUsersBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TLoggedInUsersBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TLoggedInUsersBean relatedBean =  relatedBeansIt.next();
                    TLoggedInUsers related = TLoggedInUsers.createTLoggedInUsers(relatedBean, createdObjects);
                    result.addTLoggedInUsersFromBean(related);
                }
            }
        }


        {
            List<TSummaryMailBean> relatedBeans = bean.getTSummaryMailBeansRelatedByPERSONFROM();
            if (relatedBeans != null)
            {
                for (Iterator<TSummaryMailBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TSummaryMailBean relatedBean =  relatedBeansIt.next();
                    TSummaryMail related = TSummaryMail.createTSummaryMail(relatedBean, createdObjects);
                    result.addTSummaryMailRelatedByPERSONFROMFromBean(related);
                }
            }
        }


        {
            List<TSummaryMailBean> relatedBeans = bean.getTSummaryMailBeansRelatedByPERSONTO();
            if (relatedBeans != null)
            {
                for (Iterator<TSummaryMailBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TSummaryMailBean relatedBean =  relatedBeansIt.next();
                    TSummaryMail related = TSummaryMail.createTSummaryMail(relatedBean, createdObjects);
                    result.addTSummaryMailRelatedByPERSONTOFromBean(related);
                }
            }
        }


        {
            List<THistoryTransactionBean> relatedBeans = bean.getTHistoryTransactionBeans();
            if (relatedBeans != null)
            {
                for (Iterator<THistoryTransactionBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    THistoryTransactionBean relatedBean =  relatedBeansIt.next();
                    THistoryTransaction related = THistoryTransaction.createTHistoryTransaction(relatedBean, createdObjects);
                    result.addTHistoryTransactionFromBean(related);
                }
            }
        }


        {
            List<TScriptsBean> relatedBeans = bean.getTScriptsBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TScriptsBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TScriptsBean relatedBean =  relatedBeansIt.next();
                    TScripts related = TScripts.createTScripts(relatedBean, createdObjects);
                    result.addTScriptsFromBean(related);
                }
            }
        }


        {
            List<TTemplatePersonBean> relatedBeans = bean.getTTemplatePersonBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TTemplatePersonBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TTemplatePersonBean relatedBean =  relatedBeansIt.next();
                    TTemplatePerson related = TTemplatePerson.createTTemplatePerson(relatedBean, createdObjects);
                    result.addTTemplatePersonFromBean(related);
                }
            }
        }


        {
            List<TReportPersonSettingsBean> relatedBeans = bean.getTReportPersonSettingsBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TReportPersonSettingsBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TReportPersonSettingsBean relatedBean =  relatedBeansIt.next();
                    TReportPersonSettings related = TReportPersonSettings.createTReportPersonSettings(relatedBean, createdObjects);
                    result.addTReportPersonSettingsFromBean(related);
                }
            }
        }


        {
            List<TMSProjectExchangeBean> relatedBeans = bean.getTMSProjectExchangeBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TMSProjectExchangeBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TMSProjectExchangeBean relatedBean =  relatedBeansIt.next();
                    TMSProjectExchange related = TMSProjectExchange.createTMSProjectExchange(relatedBean, createdObjects);
                    result.addTMSProjectExchangeFromBean(related);
                }
            }
        }


        {
            List<TFilterCategoryBean> relatedBeans = bean.getTFilterCategoryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TFilterCategoryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TFilterCategoryBean relatedBean =  relatedBeansIt.next();
                    TFilterCategory related = TFilterCategory.createTFilterCategory(relatedBean, createdObjects);
                    result.addTFilterCategoryFromBean(related);
                }
            }
        }


        {
            List<TReportCategoryBean> relatedBeans = bean.getTReportCategoryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TReportCategoryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TReportCategoryBean relatedBean =  relatedBeansIt.next();
                    TReportCategory related = TReportCategory.createTReportCategory(relatedBean, createdObjects);
                    result.addTReportCategoryFromBean(related);
                }
            }
        }


        {
            List<TMenuitemQueryBean> relatedBeans = bean.getTMenuitemQueryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TMenuitemQueryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TMenuitemQueryBean relatedBean =  relatedBeansIt.next();
                    TMenuitemQuery related = TMenuitemQuery.createTMenuitemQuery(relatedBean, createdObjects);
                    result.addTMenuitemQueryFromBean(related);
                }
            }
        }


        {
            List<TPersonBasketBean> relatedBeans = bean.getTPersonBasketBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TPersonBasketBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TPersonBasketBean relatedBean =  relatedBeansIt.next();
                    TPersonBasket related = TPersonBasket.createTPersonBasket(relatedBean, createdObjects);
                    result.addTPersonBasketFromBean(related);
                }
            }
        }


        {
            List<TBasketBean> relatedBeans = bean.getTBasketBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TBasketBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TBasketBean relatedBean =  relatedBeansIt.next();
                    TBasket related = TBasket.createTBasket(relatedBean, createdObjects);
                    result.addTBasketFromBean(related);
                }
            }
        }


        {
            List<TLastVisitedItemBean> relatedBeans = bean.getTLastVisitedItemBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TLastVisitedItemBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TLastVisitedItemBean relatedBean =  relatedBeansIt.next();
                    TLastVisitedItem related = TLastVisitedItem.createTLastVisitedItem(relatedBean, createdObjects);
                    result.addTLastVisitedItemFromBean(related);
                }
            }
        }


        {
            List<TWorkflowDefBean> relatedBeans = bean.getTWorkflowDefBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkflowDefBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkflowDefBean relatedBean =  relatedBeansIt.next();
                    TWorkflowDef related = TWorkflowDef.createTWorkflowDef(relatedBean, createdObjects);
                    result.addTWorkflowDefFromBean(related);
                }
            }
        }


        {
            List<TWorkflowActivityBean> relatedBeans = bean.getTWorkflowActivityBeansRelatedByNewMan();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkflowActivityBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkflowActivityBean relatedBean =  relatedBeansIt.next();
                    TWorkflowActivity related = TWorkflowActivity.createTWorkflowActivity(relatedBean, createdObjects);
                    result.addTWorkflowActivityRelatedByNewManFromBean(related);
                }
            }
        }


        {
            List<TWorkflowActivityBean> relatedBeans = bean.getTWorkflowActivityBeansRelatedByNewResp();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkflowActivityBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkflowActivityBean relatedBean =  relatedBeansIt.next();
                    TWorkflowActivity related = TWorkflowActivity.createTWorkflowActivity(relatedBean, createdObjects);
                    result.addTWorkflowActivityRelatedByNewRespFromBean(related);
                }
            }
        }


        {
            List<TWorkflowGuardBean> relatedBeans = bean.getTWorkflowGuardBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TWorkflowGuardBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TWorkflowGuardBean relatedBean =  relatedBeansIt.next();
                    TWorkflowGuard related = TWorkflowGuard.createTWorkflowGuard(relatedBean, createdObjects);
                    result.addTWorkflowGuardFromBean(related);
                }
            }
        }


        {
            List<TEscalationEntryBean> relatedBeans = bean.getTEscalationEntryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TEscalationEntryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TEscalationEntryBean relatedBean =  relatedBeansIt.next();
                    TEscalationEntry related = TEscalationEntry.createTEscalationEntry(relatedBean, createdObjects);
                    result.addTEscalationEntryFromBean(related);
                }
            }
        }


        {
            List<TReadIssueBean> relatedBeans = bean.getTReadIssueBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TReadIssueBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TReadIssueBean relatedBean =  relatedBeansIt.next();
                    TReadIssue related = TReadIssue.createTReadIssue(relatedBean, createdObjects);
                    result.addTReadIssueFromBean(related);
                }
            }
        }


        {
            List<TLastExecutedQueryBean> relatedBeans = bean.getTLastExecutedQueryBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TLastExecutedQueryBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TLastExecutedQueryBean relatedBean =  relatedBeansIt.next();
                    TLastExecutedQuery related = TLastExecutedQuery.createTLastExecutedQuery(relatedBean, createdObjects);
                    result.addTLastExecutedQueryFromBean(related);
                }
            }
        }


        {
            List<TReportSubscribeBean> relatedBeans = bean.getTReportSubscribeBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TReportSubscribeBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TReportSubscribeBean relatedBean =  relatedBeansIt.next();
                    TReportSubscribe related = TReportSubscribe.createTReportSubscribe(relatedBean, createdObjects);
                    result.addTReportSubscribeFromBean(related);
                }
            }
        }


        {
            List<TGridLayoutBean> relatedBeans = bean.getTGridLayoutBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TGridLayoutBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TGridLayoutBean relatedBean =  relatedBeansIt.next();
                    TGridLayout related = TGridLayout.createTGridLayout(relatedBean, createdObjects);
                    result.addTGridLayoutFromBean(related);
                }
            }
        }


        {
            List<TNavigatorLayoutBean> relatedBeans = bean.getTNavigatorLayoutBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TNavigatorLayoutBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TNavigatorLayoutBean relatedBean =  relatedBeansIt.next();
                    TNavigatorLayout related = TNavigatorLayout.createTNavigatorLayout(relatedBean, createdObjects);
                    result.addTNavigatorLayoutFromBean(related);
                }
            }
        }


        {
            List<TMailTextBlockBean> relatedBeans = bean.getTMailTextBlockBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TMailTextBlockBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TMailTextBlockBean relatedBean =  relatedBeansIt.next();
                    TMailTextBlock related = TMailTextBlock.createTMailTextBlock(relatedBean, createdObjects);
                    result.addTMailTextBlockFromBean(related);
                }
            }
        }


        {
            List<TPersonInDomainBean> relatedBeans = bean.getTPersonInDomainBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TPersonInDomainBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TPersonInDomainBean relatedBean =  relatedBeansIt.next();
                    TPersonInDomain related = TPersonInDomain.createTPersonInDomain(relatedBean, createdObjects);
                    result.addTPersonInDomainFromBean(related);
                }
            }
        }


        {
            List<TAttachmentVersionBean> relatedBeans = bean.getTAttachmentVersionBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TAttachmentVersionBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TAttachmentVersionBean relatedBean =  relatedBeansIt.next();
                    TAttachmentVersion related = TAttachmentVersion.createTAttachmentVersion(relatedBean, createdObjects);
                    result.addTAttachmentVersionFromBean(related);
                }
            }
        }


        {
            List<TUserFeatureBean> relatedBeans = bean.getTUserFeatureBeans();
            if (relatedBeans != null)
            {
                for (Iterator<TUserFeatureBean> relatedBeansIt = relatedBeans.iterator(); relatedBeansIt.hasNext(); )
                {
                    TUserFeatureBean relatedBean =  relatedBeansIt.next();
                    TUserFeature related = TUserFeature.createTUserFeature(relatedBean, createdObjects);
                    result.addTUserFeatureFromBean(related);
                }
            }
        }




        {
            TDepartmentBean relatedBean = bean.getTDepartmentBean();
            if (relatedBean != null)
            {
                TDepartment relatedObject = TDepartment.createTDepartment(relatedBean, createdObjects);
                result.setTDepartment(relatedObject);
            }
        }



        {
            TPrivateReportRepositoryBean relatedBean = bean.getTPrivateReportRepositoryBean();
            if (relatedBean != null)
            {
                TPrivateReportRepository relatedObject = TPrivateReportRepository.createTPrivateReportRepository(relatedBean, createdObjects);
                result.setTPrivateReportRepository(relatedObject);
            }
        }



        {
            TBLOBBean relatedBean = bean.getTBLOBBean();
            if (relatedBean != null)
            {
                TBLOB relatedObject = TBLOB.createTBLOB(relatedBean, createdObjects);
                result.setTBLOB(relatedObject);
            }
        }



        {
            TPersonBean relatedBean = bean.getTPersonBeanRelatedBySubstituteID();
            if (relatedBean != null)
            {
                TPerson relatedObject = TPerson.createTPerson(relatedBean, createdObjects);
                result.setTPersonRelatedBySubstituteID(relatedObject);
            }
        }
    result.setModified(bean.isModified());
    result.setNew(bean.isNew());
      return result;
    }



    /**
     * Method called to associate a TAccessControlList object to this object.
     * through the TAccessControlList foreign key attribute
     *
     * @param toAdd TAccessControlList
     */
    protected void addTAccessControlListFromBean(TAccessControlList toAdd)
    {
        initTAccessControlLists();
        collTAccessControlLists.add(toAdd);
    }


    /**
     * Method called to associate a TBaseLine object to this object.
     * through the TBaseLine foreign key attribute
     *
     * @param toAdd TBaseLine
     */
    protected void addTBaseLineFromBean(TBaseLine toAdd)
    {
        initTBaseLines();
        collTBaseLines.add(toAdd);
    }


    /**
     * Method called to associate a TNotify object to this object.
     * through the TNotify foreign key attribute
     *
     * @param toAdd TNotify
     */
    protected void addTNotifyFromBean(TNotify toAdd)
    {
        initTNotifys();
        collTNotifys.add(toAdd);
    }


    /**
     * Method called to associate a TProject object to this object.
     * through the TProject foreign key attribute
     *
     * @param toAdd TProject
     */
    protected void addTProjectRelatedByDefaultOwnerIDFromBean(TProject toAdd)
    {
        initTProjectsRelatedByDefaultOwnerID();
        collTProjectsRelatedByDefaultOwnerID.add(toAdd);
    }


    /**
     * Method called to associate a TProject object to this object.
     * through the TProject foreign key attribute
     *
     * @param toAdd TProject
     */
    protected void addTProjectRelatedByDefaultManagerIDFromBean(TProject toAdd)
    {
        initTProjectsRelatedByDefaultManagerID();
        collTProjectsRelatedByDefaultManagerID.add(toAdd);
    }


    /**
     * Method called to associate a TStateChange object to this object.
     * through the TStateChange foreign key attribute
     *
     * @param toAdd TStateChange
     */
    protected void addTStateChangeFromBean(TStateChange toAdd)
    {
        initTStateChanges();
        collTStateChanges.add(toAdd);
    }


    /**
     * Method called to associate a TTrail object to this object.
     * through the TTrail foreign key attribute
     *
     * @param toAdd TTrail
     */
    protected void addTTrailFromBean(TTrail toAdd)
    {
        initTTrails();
        collTTrails.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItem object to this object.
     * through the TWorkItem foreign key attribute
     *
     * @param toAdd TWorkItem
     */
    protected void addTWorkItemRelatedByOwnerIDFromBean(TWorkItem toAdd)
    {
        initTWorkItemsRelatedByOwnerID();
        collTWorkItemsRelatedByOwnerID.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItem object to this object.
     * through the TWorkItem foreign key attribute
     *
     * @param toAdd TWorkItem
     */
    protected void addTWorkItemRelatedByChangedByIDFromBean(TWorkItem toAdd)
    {
        initTWorkItemsRelatedByChangedByID();
        collTWorkItemsRelatedByChangedByID.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItem object to this object.
     * through the TWorkItem foreign key attribute
     *
     * @param toAdd TWorkItem
     */
    protected void addTWorkItemRelatedByOriginatorIDFromBean(TWorkItem toAdd)
    {
        initTWorkItemsRelatedByOriginatorID();
        collTWorkItemsRelatedByOriginatorID.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItem object to this object.
     * through the TWorkItem foreign key attribute
     *
     * @param toAdd TWorkItem
     */
    protected void addTWorkItemRelatedByResponsibleIDFromBean(TWorkItem toAdd)
    {
        initTWorkItemsRelatedByResponsibleID();
        collTWorkItemsRelatedByResponsibleID.add(toAdd);
    }


    /**
     * Method called to associate a TComputedValues object to this object.
     * through the TComputedValues foreign key attribute
     *
     * @param toAdd TComputedValues
     */
    protected void addTComputedValuesFromBean(TComputedValues toAdd)
    {
        initTComputedValuess();
        collTComputedValuess.add(toAdd);
    }


    /**
     * Method called to associate a TPrivateReportRepository object to this object.
     * through the TPrivateReportRepository foreign key attribute
     *
     * @param toAdd TPrivateReportRepository
     */
    protected void addTPrivateReportRepositoryFromBean(TPrivateReportRepository toAdd)
    {
        initTPrivateReportRepositorys();
        collTPrivateReportRepositorys.add(toAdd);
    }


    /**
     * Method called to associate a TPublicReportRepository object to this object.
     * through the TPublicReportRepository foreign key attribute
     *
     * @param toAdd TPublicReportRepository
     */
    protected void addTPublicReportRepositoryFromBean(TPublicReportRepository toAdd)
    {
        initTPublicReportRepositorys();
        collTPublicReportRepositorys.add(toAdd);
    }


    /**
     * Method called to associate a TAttachment object to this object.
     * through the TAttachment foreign key attribute
     *
     * @param toAdd TAttachment
     */
    protected void addTAttachmentFromBean(TAttachment toAdd)
    {
        initTAttachments();
        collTAttachments.add(toAdd);
    }


    /**
     * Method called to associate a TCost object to this object.
     * through the TCost foreign key attribute
     *
     * @param toAdd TCost
     */
    protected void addTCostFromBean(TCost toAdd)
    {
        initTCosts();
        collTCosts.add(toAdd);
    }


    /**
     * Method called to associate a TWorkFlow object to this object.
     * through the TWorkFlow foreign key attribute
     *
     * @param toAdd TWorkFlow
     */
    protected void addTWorkFlowFromBean(TWorkFlow toAdd)
    {
        initTWorkFlows();
        collTWorkFlows.add(toAdd);
    }


    /**
     * Method called to associate a TIssueAttributeValue object to this object.
     * through the TIssueAttributeValue foreign key attribute
     *
     * @param toAdd TIssueAttributeValue
     */
    protected void addTIssueAttributeValueFromBean(TIssueAttributeValue toAdd)
    {
        initTIssueAttributeValues();
        collTIssueAttributeValues.add(toAdd);
    }


    /**
     * Method called to associate a TReportLayout object to this object.
     * through the TReportLayout foreign key attribute
     *
     * @param toAdd TReportLayout
     */
    protected void addTReportLayoutFromBean(TReportLayout toAdd)
    {
        initTReportLayouts();
        collTReportLayouts.add(toAdd);
    }


    /**
     * Method called to associate a TScheduler object to this object.
     * through the TScheduler foreign key attribute
     *
     * @param toAdd TScheduler
     */
    protected void addTSchedulerFromBean(TScheduler toAdd)
    {
        initTSchedulers();
        collTSchedulers.add(toAdd);
    }


    /**
     * Method called to associate a TGroupMember object to this object.
     * through the TGroupMember foreign key attribute
     *
     * @param toAdd TGroupMember
     */
    protected void addTGroupMemberRelatedByTheGroupFromBean(TGroupMember toAdd)
    {
        initTGroupMembersRelatedByTheGroup();
        collTGroupMembersRelatedByTheGroup.add(toAdd);
    }


    /**
     * Method called to associate a TGroupMember object to this object.
     * through the TGroupMember foreign key attribute
     *
     * @param toAdd TGroupMember
     */
    protected void addTGroupMemberRelatedByPersonFromBean(TGroupMember toAdd)
    {
        initTGroupMembersRelatedByPerson();
        collTGroupMembersRelatedByPerson.add(toAdd);
    }


    /**
     * Method called to associate a TBudget object to this object.
     * through the TBudget foreign key attribute
     *
     * @param toAdd TBudget
     */
    protected void addTBudgetFromBean(TBudget toAdd)
    {
        initTBudgets();
        collTBudgets.add(toAdd);
    }


    /**
     * Method called to associate a TActualEstimatedBudget object to this object.
     * through the TActualEstimatedBudget foreign key attribute
     *
     * @param toAdd TActualEstimatedBudget
     */
    protected void addTActualEstimatedBudgetFromBean(TActualEstimatedBudget toAdd)
    {
        initTActualEstimatedBudgets();
        collTActualEstimatedBudgets.add(toAdd);
    }


    /**
     * Method called to associate a TDashboardScreen object to this object.
     * through the TDashboardScreen foreign key attribute
     *
     * @param toAdd TDashboardScreen
     */
    protected void addTDashboardScreenRelatedByPersonFromBean(TDashboardScreen toAdd)
    {
        initTDashboardScreensRelatedByPerson();
        collTDashboardScreensRelatedByPerson.add(toAdd);
    }


    /**
     * Method called to associate a TDashboardScreen object to this object.
     * through the TDashboardScreen foreign key attribute
     *
     * @param toAdd TDashboardScreen
     */
    protected void addTDashboardScreenRelatedByOwnerFromBean(TDashboardScreen toAdd)
    {
        initTDashboardScreensRelatedByOwner();
        collTDashboardScreensRelatedByOwner.add(toAdd);
    }


    /**
     * Method called to associate a TField object to this object.
     * through the TField foreign key attribute
     *
     * @param toAdd TField
     */
    protected void addTFieldFromBean(TField toAdd)
    {
        initTFields();
        collTFields.add(toAdd);
    }


    /**
     * Method called to associate a TList object to this object.
     * through the TList foreign key attribute
     *
     * @param toAdd TList
     */
    protected void addTListFromBean(TList toAdd)
    {
        initTLists();
        collTLists.add(toAdd);
    }


    /**
     * Method called to associate a TScreen object to this object.
     * through the TScreen foreign key attribute
     *
     * @param toAdd TScreen
     */
    protected void addTScreenFromBean(TScreen toAdd)
    {
        initTScreens();
        collTScreens.add(toAdd);
    }


    /**
     * Method called to associate a TNotifyTrigger object to this object.
     * through the TNotifyTrigger foreign key attribute
     *
     * @param toAdd TNotifyTrigger
     */
    protected void addTNotifyTriggerFromBean(TNotifyTrigger toAdd)
    {
        initTNotifyTriggers();
        collTNotifyTriggers.add(toAdd);
    }


    /**
     * Method called to associate a TNotifySettings object to this object.
     * through the TNotifySettings foreign key attribute
     *
     * @param toAdd TNotifySettings
     */
    protected void addTNotifySettingsFromBean(TNotifySettings toAdd)
    {
        initTNotifySettingss();
        collTNotifySettingss.add(toAdd);
    }


    /**
     * Method called to associate a TQueryRepository object to this object.
     * through the TQueryRepository foreign key attribute
     *
     * @param toAdd TQueryRepository
     */
    protected void addTQueryRepositoryFromBean(TQueryRepository toAdd)
    {
        initTQueryRepositorys();
        collTQueryRepositorys.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItemLink object to this object.
     * through the TWorkItemLink foreign key attribute
     *
     * @param toAdd TWorkItemLink
     */
    protected void addTWorkItemLinkFromBean(TWorkItemLink toAdd)
    {
        initTWorkItemLinks();
        collTWorkItemLinks.add(toAdd);
    }


    /**
     * Method called to associate a TWorkItemLock object to this object.
     * through the TWorkItemLock foreign key attribute
     *
     * @param toAdd TWorkItemLock
     */
    protected void addTWorkItemLockFromBean(TWorkItemLock toAdd)
    {
        initTWorkItemLocks();
        collTWorkItemLocks.add(toAdd);
    }


    /**
     * Method called to associate a TExportTemplate object to this object.
     * through the TExportTemplate foreign key attribute
     *
     * @param toAdd TExportTemplate
     */
    protected void addTExportTemplateFromBean(TExportTemplate toAdd)
    {
        initTExportTemplates();
        collTExportTemplates.add(toAdd);
    }


    /**
     * Method called to associate a TLoggedInUsers object to this object.
     * through the TLoggedInUsers foreign key attribute
     *
     * @param toAdd TLoggedInUsers
     */
    protected void addTLoggedInUsersFromBean(TLoggedInUsers toAdd)
    {
        initTLoggedInUserss();
        collTLoggedInUserss.add(toAdd);
    }


    /**
     * Method called to associate a TSummaryMail object to this object.
     * through the TSummaryMail foreign key attribute
     *
     * @param toAdd TSummaryMail
     */
    protected void addTSummaryMailRelatedByPERSONFROMFromBean(TSummaryMail toAdd)
    {
        initTSummaryMailsRelatedByPERSONFROM();
        collTSummaryMailsRelatedByPERSONFROM.add(toAdd);
    }


    /**
     * Method called to associate a TSummaryMail object to this object.
     * through the TSummaryMail foreign key attribute
     *
     * @param toAdd TSummaryMail
     */
    protected void addTSummaryMailRelatedByPERSONTOFromBean(TSummaryMail toAdd)
    {
        initTSummaryMailsRelatedByPERSONTO();
        collTSummaryMailsRelatedByPERSONTO.add(toAdd);
    }


    /**
     * Method called to associate a THistoryTransaction object to this object.
     * through the THistoryTransaction foreign key attribute
     *
     * @param toAdd THistoryTransaction
     */
    protected void addTHistoryTransactionFromBean(THistoryTransaction toAdd)
    {
        initTHistoryTransactions();
        collTHistoryTransactions.add(toAdd);
    }


    /**
     * Method called to associate a TScripts object to this object.
     * through the TScripts foreign key attribute
     *
     * @param toAdd TScripts
     */
    protected void addTScriptsFromBean(TScripts toAdd)
    {
        initTScriptss();
        collTScriptss.add(toAdd);
    }


    /**
     * Method called to associate a TTemplatePerson object to this object.
     * through the TTemplatePerson foreign key attribute
     *
     * @param toAdd TTemplatePerson
     */
    protected void addTTemplatePersonFromBean(TTemplatePerson toAdd)
    {
        initTTemplatePersons();
        collTTemplatePersons.add(toAdd);
    }


    /**
     * Method called to associate a TReportPersonSettings object to this object.
     * through the TReportPersonSettings foreign key attribute
     *
     * @param toAdd TReportPersonSettings
     */
    protected void addTReportPersonSettingsFromBean(TReportPersonSettings toAdd)
    {
        initTReportPersonSettingss();
        collTReportPersonSettingss.add(toAdd);
    }


    /**
     * Method called to associate a TMSProjectExchange object to this object.
     * through the TMSProjectExchange foreign key attribute
     *
     * @param toAdd TMSProjectExchange
     */
    protected void addTMSProjectExchangeFromBean(TMSProjectExchange toAdd)
    {
        initTMSProjectExchanges();
        collTMSProjectExchanges.add(toAdd);
    }


    /**
     * Method called to associate a TFilterCategory object to this object.
     * through the TFilterCategory foreign key attribute
     *
     * @param toAdd TFilterCategory
     */
    protected void addTFilterCategoryFromBean(TFilterCategory toAdd)
    {
        initTFilterCategorys();
        collTFilterCategorys.add(toAdd);
    }


    /**
     * Method called to associate a TReportCategory object to this object.
     * through the TReportCategory foreign key attribute
     *
     * @param toAdd TReportCategory
     */
    protected void addTReportCategoryFromBean(TReportCategory toAdd)
    {
        initTReportCategorys();
        collTReportCategorys.add(toAdd);
    }


    /**
     * Method called to associate a TMenuitemQuery object to this object.
     * through the TMenuitemQuery foreign key attribute
     *
     * @param toAdd TMenuitemQuery
     */
    protected void addTMenuitemQueryFromBean(TMenuitemQuery toAdd)
    {
        initTMenuitemQuerys();
        collTMenuitemQuerys.add(toAdd);
    }


    /**
     * Method called to associate a TPersonBasket object to this object.
     * through the TPersonBasket foreign key attribute
     *
     * @param toAdd TPersonBasket
     */
    protected void addTPersonBasketFromBean(TPersonBasket toAdd)
    {
        initTPersonBaskets();
        collTPersonBaskets.add(toAdd);
    }


    /**
     * Method called to associate a TBasket object to this object.
     * through the TBasket foreign key attribute
     *
     * @param toAdd TBasket
     */
    protected void addTBasketFromBean(TBasket toAdd)
    {
        initTBaskets();
        collTBaskets.add(toAdd);
    }


    /**
     * Method called to associate a TLastVisitedItem object to this object.
     * through the TLastVisitedItem foreign key attribute
     *
     * @param toAdd TLastVisitedItem
     */
    protected void addTLastVisitedItemFromBean(TLastVisitedItem toAdd)
    {
        initTLastVisitedItems();
        collTLastVisitedItems.add(toAdd);
    }


    /**
     * Method called to associate a TWorkflowDef object to this object.
     * through the TWorkflowDef foreign key attribute
     *
     * @param toAdd TWorkflowDef
     */
    protected void addTWorkflowDefFromBean(TWorkflowDef toAdd)
    {
        initTWorkflowDefs();
        collTWorkflowDefs.add(toAdd);
    }


    /**
     * Method called to associate a TWorkflowActivity object to this object.
     * through the TWorkflowActivity foreign key attribute
     *
     * @param toAdd TWorkflowActivity
     */
    protected void addTWorkflowActivityRelatedByNewManFromBean(TWorkflowActivity toAdd)
    {
        initTWorkflowActivitysRelatedByNewMan();
        collTWorkflowActivitysRelatedByNewMan.add(toAdd);
    }


    /**
     * Method called to associate a TWorkflowActivity object to this object.
     * through the TWorkflowActivity foreign key attribute
     *
     * @param toAdd TWorkflowActivity
     */
    protected void addTWorkflowActivityRelatedByNewRespFromBean(TWorkflowActivity toAdd)
    {
        initTWorkflowActivitysRelatedByNewResp();
        collTWorkflowActivitysRelatedByNewResp.add(toAdd);
    }


    /**
     * Method called to associate a TWorkflowGuard object to this object.
     * through the TWorkflowGuard foreign key attribute
     *
     * @param toAdd TWorkflowGuard
     */
    protected void addTWorkflowGuardFromBean(TWorkflowGuard toAdd)
    {
        initTWorkflowGuards();
        collTWorkflowGuards.add(toAdd);
    }


    /**
     * Method called to associate a TEscalationEntry object to this object.
     * through the TEscalationEntry foreign key attribute
     *
     * @param toAdd TEscalationEntry
     */
    protected void addTEscalationEntryFromBean(TEscalationEntry toAdd)
    {
        initTEscalationEntrys();
        collTEscalationEntrys.add(toAdd);
    }


    /**
     * Method called to associate a TReadIssue object to this object.
     * through the TReadIssue foreign key attribute
     *
     * @param toAdd TReadIssue
     */
    protected void addTReadIssueFromBean(TReadIssue toAdd)
    {
        initTReadIssues();
        collTReadIssues.add(toAdd);
    }


    /**
     * Method called to associate a TLastExecutedQuery object to this object.
     * through the TLastExecutedQuery foreign key attribute
     *
     * @param toAdd TLastExecutedQuery
     */
    protected void addTLastExecutedQueryFromBean(TLastExecutedQuery toAdd)
    {
        initTLastExecutedQuerys();
        collTLastExecutedQuerys.add(toAdd);
    }


    /**
     * Method called to associate a TReportSubscribe object to this object.
     * through the TReportSubscribe foreign key attribute
     *
     * @param toAdd TReportSubscribe
     */
    protected void addTReportSubscribeFromBean(TReportSubscribe toAdd)
    {
        initTReportSubscribes();
        collTReportSubscribes.add(toAdd);
    }


    /**
     * Method called to associate a TGridLayout object to this object.
     * through the TGridLayout foreign key attribute
     *
     * @param toAdd TGridLayout
     */
    protected void addTGridLayoutFromBean(TGridLayout toAdd)
    {
        initTGridLayouts();
        collTGridLayouts.add(toAdd);
    }


    /**
     * Method called to associate a TNavigatorLayout object to this object.
     * through the TNavigatorLayout foreign key attribute
     *
     * @param toAdd TNavigatorLayout
     */
    protected void addTNavigatorLayoutFromBean(TNavigatorLayout toAdd)
    {
        initTNavigatorLayouts();
        collTNavigatorLayouts.add(toAdd);
    }


    /**
     * Method called to associate a TMailTextBlock object to this object.
     * through the TMailTextBlock foreign key attribute
     *
     * @param toAdd TMailTextBlock
     */
    protected void addTMailTextBlockFromBean(TMailTextBlock toAdd)
    {
        initTMailTextBlocks();
        collTMailTextBlocks.add(toAdd);
    }


    /**
     * Method called to associate a TPersonInDomain object to this object.
     * through the TPersonInDomain foreign key attribute
     *
     * @param toAdd TPersonInDomain
     */
    protected void addTPersonInDomainFromBean(TPersonInDomain toAdd)
    {
        initTPersonInDomains();
        collTPersonInDomains.add(toAdd);
    }


    /**
     * Method called to associate a TAttachmentVersion object to this object.
     * through the TAttachmentVersion foreign key attribute
     *
     * @param toAdd TAttachmentVersion
     */
    protected void addTAttachmentVersionFromBean(TAttachmentVersion toAdd)
    {
        initTAttachmentVersions();
        collTAttachmentVersions.add(toAdd);
    }


    /**
     * Method called to associate a TUserFeature object to this object.
     * through the TUserFeature foreign key attribute
     *
     * @param toAdd TUserFeature
     */
    protected void addTUserFeatureFromBean(TUserFeature toAdd)
    {
        initTUserFeatures();
        collTUserFeatures.add(toAdd);
    }


    public String toString()
    {
        StringBuffer str = new StringBuffer();
        str.append("TPerson:\n");
        str.append("ObjectID = ")
           .append(getObjectID())
           .append("\n");
        str.append("FirstName = ")
           .append(getFirstName())
           .append("\n");
        str.append("LastName = ")
           .append(getLastName())
           .append("\n");
        str.append("LoginName = ")
           .append(getLoginName())
           .append("\n");
        str.append("Email = ")
           .append(getEmail())
           .append("\n");
        str.append("Passwd = ")
           .append(getPasswd())
           .append("\n");
        str.append("Salt = ")
           .append(getSalt())
           .append("\n");
        str.append("ForgotPasswordKey = ")
           .append(getForgotPasswordKey())
           .append("\n");
        str.append("Phone = ")
           .append(getPhone())
           .append("\n");
        str.append("DepartmentID = ")
           .append(getDepartmentID())
           .append("\n");
        str.append("ValidUntil = ")
           .append(getValidUntil())
           .append("\n");
        str.append("Preferences = ")
           .append(getPreferences())
           .append("\n");
        str.append("LastEdit = ")
           .append(getLastEdit())
           .append("\n");
        str.append("Created = ")
           .append(getCreated())
           .append("\n");
        str.append("Deleted = ")
           .append(getDeleted())
           .append("\n");
        str.append("TokenPasswd = ")
           .append(getTokenPasswd())
           .append("\n");
        str.append("TokenExpDate = ")
           .append(getTokenExpDate())
           .append("\n");
        str.append("EmailFrequency = ")
           .append(getEmailFrequency())
           .append("\n");
        str.append("EmailLead = ")
           .append(getEmailLead())
           .append("\n");
        str.append("EmailLastReminded = ")
           .append(getEmailLastReminded())
           .append("\n");
        str.append("EmailRemindMe = ")
           .append(getEmailRemindMe())
           .append("\n");
        str.append("PrefEmailType = ")
           .append(getPrefEmailType())
           .append("\n");
        str.append("PrefLocale = ")
           .append(getPrefLocale())
           .append("\n");
        str.append("MyDefaultReport = ")
           .append(getMyDefaultReport())
           .append("\n");
        str.append("NoEmailPlease = ")
           .append(getNoEmailPlease())
           .append("\n");
        str.append("RemindMeAsOriginator = ")
           .append(getRemindMeAsOriginator())
           .append("\n");
        str.append("RemindMeAsManager = ")
           .append(getRemindMeAsManager())
           .append("\n");
        str.append("RemindMeAsResponsible = ")
           .append(getRemindMeAsResponsible())
           .append("\n");
        str.append("EmailRemindPriorityLevel = ")
           .append(getEmailRemindPriorityLevel())
           .append("\n");
        str.append("EmailRemindSeverityLevel = ")
           .append(getEmailRemindSeverityLevel())
           .append("\n");
        str.append("HoursPerWorkDay = ")
           .append(getHoursPerWorkDay())
           .append("\n");
        str.append("HourlyWage = ")
           .append(getHourlyWage())
           .append("\n");
        str.append("ExtraHourWage = ")
           .append(getExtraHourWage())
           .append("\n");
        str.append("EmployeeID = ")
           .append(getEmployeeID())
           .append("\n");
        str.append("Isgroup = ")
           .append(getIsgroup())
           .append("\n");
        str.append("UserLevel = ")
           .append(getUserLevel())
           .append("\n");
        str.append("MaxAssignedItems = ")
           .append(getMaxAssignedItems())
           .append("\n");
        str.append("MessengerURL = ")
           .append(getMessengerURL())
           .append("\n");
        str.append("CALLURL = ")
           .append(getCALLURL())
           .append("\n");
        str.append("Symbol = ")
           .append(getSymbol())
           .append("\n");
        str.append("IconKey = ")
           .append(getIconKey())
           .append("\n");
        str.append("SubstituteID = ")
           .append(getSubstituteID())
           .append("\n");
        str.append("SubstituteActive = ")
           .append(getSubstituteActive())
           .append("\n");
        str.append("Uuid = ")
           .append(getUuid())
           .append("\n");
        return(str.toString());
    }
}
