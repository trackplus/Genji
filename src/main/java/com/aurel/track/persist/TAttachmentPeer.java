/**
 * Genji Scrum Tool and Issue Tracker
 * Copyright (C) 2015 Steinbeis GmbH & Co. KG Task Management Solutions

 * <a href="http://www.trackplus.com">Genji Scrum Tool</a>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/* $Id:$ */

package com.aurel.track.persist;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.torque.TorqueException;
import org.apache.torque.om.SimpleKey;
import org.apache.torque.util.Criteria;

import com.aurel.track.admin.customize.category.filter.execute.loadItems.criteria.TreeFilterCriteria;
import com.aurel.track.admin.customize.category.filter.tree.design.FilterUpperTO;
import com.aurel.track.admin.customize.category.filter.tree.design.RACIBean;
import com.aurel.track.attachment.AttachBL;
import com.aurel.track.beans.TAttachmentBean;
import com.aurel.track.beans.TPersonBean;
import com.aurel.track.dao.AttachmentDAO;
import com.aurel.track.errors.ErrorData;
import com.aurel.track.tql.TqlBL;
import com.aurel.track.util.GeneralUtils;
import com.workingdogs.village.Record;

/**
 * The skeleton for this class was autogenerated by Torque on:
 *
 * [Tue Jun 15 21:31:34 CEST 2004]
 *
 *  You should add additional methods to this class to meet the
 *  application requirements.  This class will only be generated as
 *  long as it does not already exist in the output directory.
 */
public class TAttachmentPeer extends com.aurel.track.persist.BaseTAttachmentPeer implements AttachmentDAO{
	private static final long serialVersionUID = 6645799500993932870L;
	private static final Logger LOGGER = LogManager.getLogger(TAttachmentPeer.class);
	

	/**
	 *  Gets all attachments
	 * @return
	 */
	@Override
	public List<TAttachmentBean> loadAll() {
		List<TAttachment> torqueList = null;
		Criteria crit = new Criteria();
		try {
			torqueList = doSelect(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading all attachements failed with " + e.getMessage());
		}
		return convertTorqueListToBeanList(torqueList);
	}
	
	/**
	 * Load the attachment with given Id
	 */
	@Override
	public TAttachmentBean loadByID(Integer objectID) {
		TAttachment tobject = null;
		try{
			tobject = retrieveByPK(objectID);
		}
		catch(Exception e){
			LOGGER.error("Loading of a attachment by primary key " + objectID + " failed with " + e.getMessage());
		} 
		if (tobject!=null){
			return tobject.getBean();
		}
		return null;   
	}
	
	/**
	 * Load the attachment with given Id
	 */
	@Override
	public TAttachmentBean loadByIDWithDimensions(Integer objectID) {
		TAttachment tobject = null;
		TAttachmentBean image = null;
		try{
			tobject = retrieveByPK(objectID);
			image = tobject.getBean();
			Integer itemID = tobject.getTWorkItem().getObjectID();
			String diskFileName=AttachBL.getFullFileName(null,objectID, itemID);
			File imageFile = new File(diskFileName);
			try {
				ImageInputStream in = ImageIO.createImageInputStream(imageFile);
			    final Iterator<ImageReader> readers = ImageIO.getImageReaders(in);
			    if (readers.hasNext()) {
			        ImageReader reader = readers.next();
			        try {
			            reader.setInput(in);
			            image.setHeight(reader.getHeight(0));
						image.setWidth(reader.getWidth(0));;
			        } finally {
			            reader.dispose();
			        }
			    }
			} catch (IOException e) {
				LOGGER.error("Could not read attached image file " + imageFile.getAbsolutePath());
			}
		}
		catch(Exception e){
			LOGGER.error("Loading of a attachment by primary key " + objectID + " failed with " + e.getMessage());
		} 
		return image;   
	}
	
	/**
	 * Obtain the attachments for an item
	 */
	@Override
	public List<TAttachmentBean> loadByWorkItemKey(Integer itemID) {
		List<TAttachment> torqueList = null;
		Criteria crit = new Criteria();
		crit.add(WORKITEM,itemID);
		try {
			torqueList = doSelect(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading attachements for:"+itemID+" failed with " + e.getMessage());
		}
		return convertTorqueListToBeanList(torqueList);
	}
	@Override
	public int countByWorkItemID(Integer workItemID){
		String COUNT = "count(" + OBJECTID + ")";
		Criteria crit = new Criteria();
		crit.add(WORKITEM,workItemID);
		crit.addSelectColumn(COUNT);
		try {
			return ((Record) doSelectVillageRecords(crit).get(0)).getValue(1).asInt();
		} catch (Exception e) {
			LOGGER.error("Counting attachements by workItemID " + workItemID +  " failed with " + e.getMessage());
			return 0;
		}
	}
	
	/**
	 * Obtain the attachments for given attachment ids
	 * @param attachmentIDs
	 * @return
	 */
	@Override
	public List<TAttachmentBean> loadByAttachmentIDs(List<Integer> attachmentIDs) {
		List<TAttachmentBean> attachmentsList = new ArrayList<TAttachmentBean>();
		if (attachmentIDs==null || attachmentIDs.isEmpty()) {
			return new ArrayList<TAttachmentBean>();
		}
		List<int[]> attachmentIDChunksList = GeneralUtils.getListOfChunks(attachmentIDs);
		if (attachmentIDChunksList==null) {
			return new ArrayList<TAttachmentBean>();
		}
		Iterator<int[]> iterator = attachmentIDChunksList.iterator();
		int i = 0;
		Criteria criteria;
		while (iterator.hasNext()) {
			i++;
			int[] attachmentIDChunk = iterator.next();
			criteria = new Criteria();	
			criteria.addIn(OBJECTID, attachmentIDChunk);
			try {
				attachmentsList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
			} catch (TorqueException e) {
				LOGGER.error("Loading attachments for by objectIDs and the chunk number " + 
						i + " of length  "  + attachmentIDChunk.length + " failed with " + e.getMessage(), e);
			}
		}
		return attachmentsList;
	}
	
	@Override
	public List<TAttachmentBean> loadByWorkItemKeys(int[] workItemIDs){
		List<TAttachmentBean> attachmentsList = new ArrayList<TAttachmentBean>();
		if (workItemIDs==null || workItemIDs.length==0) {
			return new ArrayList<TAttachmentBean>();
		}
		List<int[]> workItemIDChunksList = GeneralUtils.getListOfChunks(workItemIDs);
		if (workItemIDChunksList==null) {
			return new ArrayList<TAttachmentBean>();
		}
		Iterator<int[]> iterator = workItemIDChunksList.iterator();
		int i = 0;
		Criteria criteria;
		while (iterator.hasNext()) {
			i++;
			int[] workItemIDChunk = iterator.next();
			criteria = new Criteria();	
			criteria.addIn(WORKITEM, workItemIDChunk);
			try {
				attachmentsList.addAll(convertTorqueListToBeanList(doSelect(criteria)));
			} catch (TorqueException e) {
				LOGGER.error("Loading attachments for multiple items and the chunk number " + 
						i + " of length  "  + workItemIDChunk.length + " failed with " + e.getMessage(), e);
			}
		}
		return attachmentsList;
	}
	
	/**
	 * Gets the classBeans for a prepared criteria
	 * @param preparedCriteria
	 * @return
	 * @throws TorqueException
	 */
	private static List<TAttachmentBean> getFilterAttachments(Criteria preparedCriteria) throws TorqueException {
		preparedCriteria.addJoin(TWorkItemPeer.WORKITEMKEY,  WORKITEM);
		return convertTorqueListToBeanList(doSelect(preparedCriteria));
	}
	/**
	 * Gets the attachments filtered by filterSelectsTO and raciBean
	 * @param filterUpperTO
	 * @param raciBean
	 * @param personID
	 * @return
	 */
	@Override
	public List<TAttachmentBean> loadTreeFilterAttachments(FilterUpperTO filterUpperTO, RACIBean raciBean, Integer personID) {
		Integer[] selectedProjects = filterUpperTO.getSelectedProjects();
		if (selectedProjects==null  || selectedProjects.length==0) {
			//at least one selected project needed
			return new ArrayList<TAttachmentBean>();
		}		
		Criteria crit = TreeFilterCriteria.prepareTreeFilterCriteria(filterUpperTO, raciBean, personID);
		try {
			return getFilterAttachments(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the attachments for tree filter failed with " + e.getMessage());
			return new ArrayList<TAttachmentBean>();
		}
	}
	
	/**
	 * Get the attachments for a TQL expression
	 * @param tqlExpression
	 * @param personBean
	 * @param locale
	 * @param errors
	 * @return
	 */
	@Override
	public List<TAttachmentBean> loadTQLFilterAttachments(String tqlExpression, TPersonBean personBean, Locale locale, List<ErrorData> errors) {
		Criteria crit = TqlBL.createCriteria(tqlExpression, personBean, locale, errors);
		try {
			return getFilterAttachments(crit);
		} catch (TorqueException e) {
			LOGGER.error("Loading the attachments for TQL filter " + tqlExpression + " failed with " + e.getMessage());
			return new ArrayList<TAttachmentBean>();
		}
	}
	
	@Override
	public Integer save(TAttachmentBean attach) {
		try {
			TAttachment tobject = BaseTAttachment.createTAttachment(attach);
			//There is a DB problem if mymeType length >15 characters
			//anyway we obtain this on load time from file on disk 
			tobject.setMimeType(null);
			tobject.save();
			return tobject.getObjectID();
		} catch (Exception e) {
			LOGGER.error("Saving of a attachment failed with " + e.getMessage());
			return null;
		}	
	}
	@Override
	public void delete(Integer objectID) {
		try {
			doDelete(SimpleKey.keyFor(objectID));
		} catch (TorqueException e) {
			LOGGER.error("Deleting an attachment for key " + objectID + " failed with: " + e);
		}
	}

	private static List<TAttachmentBean> convertTorqueListToBeanList(List<TAttachment> torqueList) {
		List<TAttachmentBean> beanList = new ArrayList<TAttachmentBean>();
		TAttachment tattach;
		if (torqueList!=null){
			Iterator<TAttachment> itrTorqueList = torqueList.iterator();
			while (itrTorqueList.hasNext()){
				tattach = itrTorqueList.next();
				beanList.add(tattach.getBean());
			}
		}
		return beanList;
	}

	

}
